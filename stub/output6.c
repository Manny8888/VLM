/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunfcal.as
 ************************************************************************/

/* Function calling. */
/* Start call. */
/* Finish call. */
/* start DoFinishCallTos */

/* Halfword 10 bit immediate instruction - DoFinishCallTos */

dofinishcalltos : if (_trace) printf("dofinishcalltos:\n");
/* Actually only one entry point, but simulate others for dispatch */

DoFinishCallTosIM : if (_trace) printf("DoFinishCallTosIM:\n");

DoFinishCallTosSP : if (_trace) printf("DoFinishCallTosSP:\n");

DoFinishCallTosLP : if (_trace) printf("DoFinishCallTosLP:\n");

DoFinishCallTosFP : if (_trace) printf("DoFinishCallTosFP:\n");
/* arg1 has operand preloaded. */
arg1 = (uint8_t) (arg3 >> ((5 & 7) * 8)); // arg1 contains the disposition (two bits)
arg2 = *(int32_t *)iSP; // Get the number of args
iSP = iSP - 8; // Pop stack
arg2 = (arg2 * 8) + 8; // Add 1 and convert to stacked word address
goto finishcallmerge;

/* end DoFinishCallTos */
/* End of Halfword operand from stack instruction - DoFinishCallTos */
/* Function entry. */
/* start DoEntryRestAccepted */

/* Field Extraction instruction - DoEntryRestAccepted */

doentryrestaccepted : if (_trace) printf("doentryrestaccepted:\n");
/* Actually only one entry point, but simulate others for dispatch */

DoEntryRestAcceptedIM : if (_trace) printf("DoEntryRestAcceptedIM:\n");

DoEntryRestAcceptedSP : if (_trace) printf("DoEntryRestAcceptedSP:\n");

DoEntryRestAcceptedLP : if (_trace) printf("DoEntryRestAcceptedLP:\n");

DoEntryRestAcceptedFP : if (_trace) printf("DoEntryRestAcceptedFP:\n");
arg5 = *(int32_t *)&processor->control; // The control register
arg4 = arg3 >> 18; // Pull down the number of optionals
arg1 = (uint8_t) (arg3 >> ((5 & 7) * 8)); // Extract the 'ptr' field while we are waiting
arg4 = arg4 & 255;
/* arg1=ptr field, arg2=required, arg3=instn, arg4=optionals arg5=control-register */
t2 = arg5 >> 27; // Get the cr.trace-pending bit
t1 = arg5 & 255; // The supplied args
if (t2 & 1)
    goto tracetrap;
t3 = arg5 >> 17;
t4 = *(int32_t *)(iSP + 4); // Get the tag of the stack top.

force_alignment44549 : if (_trace) printf("force_alignment44549:\n");
if (t3 & 1) // J. if apply args
    goto b_apply_argument_supplied44547;

b_apply_argument_supplied44548 : t2 = t1 - arg2; // t2=supplied-minimum
if ((int64_t) t2 < 0) // B. if too few args.
    goto retryeratoofew;
arg1 = arg4 - t1; // maximum-supplied
if ((int64_t) arg1 < 0) // B. rest args.
    goto retryerarest;
/* Compute entry position and advance PC/CP accordingly. */
iPC = *(uint64_t *)&(((CACHELINEP)iCP)->nextpcdata); // get the next PC
t3 = t2 << 1; // Adjust index to halfword
iCP = *(uint64_t *)&(((CACHELINEP)iCP)->nextcp);
if (t2 == 0) // J. if index zero, no adjustment.
    goto INTERPRETINSTRUCTION;
iPC = iPC + t3; // Compute the new address
iPC = iPC & ~1L; // Make it an DTP-EVEN-PC
goto interpretinstructionforjump;

applysuppra : if (_trace) printf("applysuppra:\n");
arg1 = arg4 - t1; // maximum-supplied
if ((int64_t) arg1 < 0) // B. rest args.
    goto retryerarest;
if ((int64_t) arg1 > 0) // try pulling from applied args.
    goto pullapplyargs;
t6 = *(int32_t *)(iSP + 4); // get tag
t6 = t6 & 63;
t6 = t6 | 64;
*(uint32_t *)(iSP + 4) = t6; // set tag
t2 = t1 - arg2; // t2=supplied-minimum
t2 = t2 + 1;
/* Compute entry position and advance PC/CP accordingly. */
iPC = *(uint64_t *)&(((CACHELINEP)iCP)->nextpcdata); // get the next PC
t3 = t2 << 1; // Adjust index to halfword
iCP = *(uint64_t *)&(((CACHELINEP)iCP)->nextcp);
if (t2 == 0) // J. if index zero, no adjustment.
    goto INTERPRETINSTRUCTION;
iPC = iPC + t3; // Compute the new address
iPC = iPC & ~1L; // Make it an DTP-EVEN-PC
goto interpretinstructionforjump;

retryeratoofew : if (_trace) printf("retryeratoofew:\n");
arg5 = 0;
arg2 = 77;
goto illegaloperand;

retryerarest : if (_trace) printf("retryerarest:\n");
t1 = *(int32_t *)(iSP + 4); // get tag
t1 = t1 & 63;
t1 = t1 | 64;
*(uint32_t *)(iSP + 4) = t1; // set tag
t2 = arg5 >> 17;
t3 = *(int32_t *)(iSP + 4); // Get the tag of the stack top.

force_alignment44554 : if (_trace) printf("force_alignment44554:\n");
if (t2 & 1) // J. if apply args
    goto b_apply_argument_supplied44552;

b_apply_argument_supplied44553 : t1 = (arg4 * 8) + iFP;
/* Convert stack cache address to VMA */
t3 = *(uint64_t *)&(processor->stackcachedata);
t2 = *(uint64_t *)&(processor->stackcachebasevma);
t3 = t1 - t3; // stack cache base relative offset
t3 = t3 >> 3; // convert byte address to word address
t2 = t3 + t2; // reconstruct VMA
t1 = Type_List;
*(uint32_t *)(iSP + 8) = t2;
*(uint32_t *)(iSP + 12) = t1; // write the stack cache
iSP = iSP + 8;
goto push_apply_args44551;

push_apply_args44550 : if (_trace) printf("push_apply_args44550:\n");
t1 = iSP - 8;
t3 = *(int32_t *)(t1 + 4); // get tag
t3 = t3 & 63;
t3 = t3 | 128;
*(uint32_t *)(t1 + 4) = t3; // set tag
t1 = (arg4 * 8) + iFP;
/* Convert stack cache address to VMA */
t3 = *(uint64_t *)&(processor->stackcachedata);
t2 = *(uint64_t *)&(processor->stackcachebasevma);
t3 = t1 - t3; // stack cache base relative offset
t3 = t3 >> 3; // convert byte address to word address
t2 = t3 + t2; // reconstruct VMA
t1 = Type_List;
*(uint32_t *)(iSP + 8) = t2;
*(uint32_t *)(iSP + 12) = t1; // write the stack cache
iSP = iSP + 8;
iLP = iLP + 8;
arg5 = arg5 + 1;
*(uint32_t *)&processor->control = arg5;

push_apply_args44551 : if (_trace) printf("push_apply_args44551:\n");
t1 = arg4 - arg2;
t1 = t1 + 1;
/* Compute entry position and advance PC/CP accordingly. */
iPC = *(uint64_t *)&(((CACHELINEP)iCP)->nextpcdata); // get the next PC
t2 = t1 << 1; // Adjust index to halfword
iCP = *(uint64_t *)&(((CACHELINEP)iCP)->nextcp);
if (t1 == 0) // J. if index zero, no adjustment.
    goto INTERPRETINSTRUCTION;
iPC = iPC + t2; // Compute the new address
iPC = iPC & ~1L; // Make it an DTP-EVEN-PC
goto interpretinstructionforjump;

b_apply_argument_supplied44552 : if (_trace) printf("b_apply_argument_supplied44552:\n");
t3 = t3 & 63;
t3 = t3 - Type_NIL;
if (t3 != 0) // J. if apply args supplied not nil.
    goto push_apply_args44550;
t2 = t2 & 1; // keep just the apply bit!
t2 = t2 << 17; // reposition the apply bit
iSP = iSP - 8; // Pop off the null applied arg.
arg5 = arg5 & ~t2; // Blast the apply arg bit away
*(uint32_t *)&processor->control = arg5; // Reset the stored cr bit
goto b_apply_argument_supplied44553;

b_apply_argument_supplied44547 : if (_trace) printf("b_apply_argument_supplied44547:\n");
t4 = t4 & 63;
t4 = t4 - Type_NIL;
if (t4 != 0) // J. if apply args supplied not nil.
    goto applysuppra;
t3 = t3 & 1; // keep just the apply bit!
t3 = t3 << 17; // reposition the apply bit
iSP = iSP - 8; // Pop off the null applied arg.
arg5 = arg5 & ~t3; // Blast the apply arg bit away
*(uint32_t *)&processor->control = arg5; // Reset the stored cr bit
goto b_apply_argument_supplied44548;

/* end DoEntryRestAccepted */
/* End of Halfword operand from stack instruction - DoEntryRestAccepted */
/* start CarCdrInternal */

carcdrinternal : if (_trace) printf("carcdrinternal:\n");
sp = sp + -8;
arg2 = (uint32_t) (t2 >> ((zero & 7) * 8));
t5 = t1 & 63; // Strip off any CDR code bits.
t6 = (t5 == Type_List) ? 1 : 0;

force_alignment44602 : if (_trace) printf("force_alignment44602:\n");
if (t6 == 0)
    goto basic_dispatch44559;
/* Here if argument TypeList */
/* Memory Read Internal */

vma_memory_read44560 : t7 = arg2 + ivory;
arg6 = (t7 * 4);
arg5 = LDQ_U(t7);
t5 = arg2 - t11; // Stack cache offset
t8 = *(uint64_t *)&(processor->dataread_mask);
t6 = ((uint64_t) t5 < (uint64_t) t12) ? 1 : 0; // In range?
arg6 = *(int32_t *)arg6;
arg5 = (uint8_t) (arg5 >> ((t7 & 7) * 8));
if (t6 != 0)
    goto vma_memory_read44562;

vma_memory_read44561 : t7 = zero + 240;
t8 = t8 >> (arg5 & 63);
t7 = t7 >> (arg5 & 63);
arg6 = (uint32_t) arg6;
if (t8 & 1)
    goto vma_memory_read44564;

vma_memory_read44571 : t5 = (int32_t) arg2 - (int32_t) t2;
if (t5 != 0) // CAR forwarded, must CDR the hard way
    goto carcdr_internal44555;
t1 = arg5;
t2 = arg6;

carcdr_internal44557 : if (_trace) printf("carcdr_internal44557:\n");
t5 = arg5 & 192; // Extract CDR code.
if (t5 != 0)
    goto basic_dispatch44573;
/* Here if argument 0 */
arg6 = arg2 + 1; // Address of next position is CDR
arg5 = Type_List;

basic_dispatch44572 : if (_trace) printf("basic_dispatch44572:\n");

basic_dispatch44558 : if (_trace) printf("basic_dispatch44558:\n");

carcdr_internal44556 : if (_trace) printf("carcdr_internal44556:\n");
sp = sp + 8;
goto *r0; /* ret */

basic_dispatch44559 : if (_trace) printf("basic_dispatch44559:\n");
t6 = (t5 == Type_NIL) ? 1 : 0;

force_alignment44603 : if (_trace) printf("force_alignment44603:\n");
if (t6 == 0)
    goto basic_dispatch44589;
/* Here if argument TypeNIL */
arg6 = *(int32_t *)&processor->niladdress;
arg5 = *((int32_t *)(&processor->niladdress) + 1);
arg6 = (uint32_t) arg6;
goto basic_dispatch44558;

basic_dispatch44589 : if (_trace) printf("basic_dispatch44589:\n");
/* Here for all other cases */
arg6 = t1; // arg6 = tag to dispatch on
arg3 = 0; // arg3 = stackp
arg1 = 1; // arg1 = instruction arity
arg4 = 0; // arg4 = arithmeticp
goto listexception;

carcdr_internal44555 : if (_trace) printf("carcdr_internal44555:\n");
arg2 = (uint32_t) (t2 >> ((zero & 7) * 8));
t1 = arg5;
t2 = arg6;
/* Memory Read Internal */

vma_memory_read44591 : t7 = arg2 + ivory;
arg6 = (t7 * 4);
arg5 = LDQ_U(t7);
t5 = arg2 - t11; // Stack cache offset
t8 = *(uint64_t *)&(processor->cdr_mask);
t6 = ((uint64_t) t5 < (uint64_t) t12) ? 1 : 0; // In range?
arg6 = *(int32_t *)arg6;
arg5 = (uint8_t) (arg5 >> ((t7 & 7) * 8));
if (t6 != 0)
    goto vma_memory_read44593;

vma_memory_read44592 : t7 = zero + 192;
t8 = t8 >> (arg5 & 63);
t7 = t7 >> (arg5 & 63);
if (t8 & 1)
    goto vma_memory_read44595;

vma_memory_read44600 : goto carcdr_internal44557;

vma_memory_read44595 : if (_trace) printf("vma_memory_read44595:\n");
if ((t7 & 1) == 0)
    goto vma_memory_read44594;
arg2 = (uint32_t) arg6; // Do the indirect thing
goto vma_memory_read44591;

vma_memory_read44594 : if (_trace) printf("vma_memory_read44594:\n");

vma_memory_read44593 : if (_trace) printf("vma_memory_read44593:\n");
*(uint64_t *)sp = r0;
r0 = (uint64_t)  && return0036;
goto memoryreadcdrdecode;
return0036 : r0 = *(uint64_t *)sp;
goto vma_memory_read44600;

basic_dispatch44573 : if (_trace) printf("basic_dispatch44573:\n");
t6 = (t5 == 128) ? 1 : 0;

force_alignment44604 : if (_trace) printf("force_alignment44604:\n");
if (t6 == 0)
    goto basic_dispatch44574;
/* Here if argument 128 */
arg2 = arg2 + 1;
/* Memory Read Internal */

vma_memory_read44575 : t7 = arg2 + ivory;
arg6 = (t7 * 4);
arg5 = LDQ_U(t7);
t5 = arg2 - t11; // Stack cache offset
t8 = *(uint64_t *)&(processor->dataread_mask);
t6 = ((uint64_t) t5 < (uint64_t) t12) ? 1 : 0; // In range?
arg6 = *(int32_t *)arg6;
arg5 = (uint8_t) (arg5 >> ((t7 & 7) * 8));
if (t6 != 0)
    goto vma_memory_read44577;

vma_memory_read44576 : t7 = zero + 240;
t8 = t8 >> (arg5 & 63);
t7 = t7 >> (arg5 & 63);
arg6 = (uint32_t) arg6;
if (t8 & 1)
    goto vma_memory_read44579;
goto carcdr_internal44556;

basic_dispatch44574 : if (_trace) printf("basic_dispatch44574:\n");
t6 = (t5 == 64) ? 1 : 0;

force_alignment44605 : if (_trace) printf("force_alignment44605:\n");
if (t6 == 0)
    goto basic_dispatch44586;
/* Here if argument 64 */
arg6 = *(int32_t *)&processor->niladdress;
arg5 = *((int32_t *)(&processor->niladdress) + 1);
arg6 = (uint32_t) arg6;
goto carcdr_internal44556;

basic_dispatch44586 : if (_trace) printf("basic_dispatch44586:\n");
/* Here for all other cases */
arg5 = arg2;
arg2 = 15;
goto illegaloperand;

vma_memory_read44579 : if (_trace) printf("vma_memory_read44579:\n");
if ((t7 & 1) == 0)
    goto vma_memory_read44578;
arg2 = (uint32_t) arg6; // Do the indirect thing
goto vma_memory_read44575;

vma_memory_read44578 : if (_trace) printf("vma_memory_read44578:\n");

vma_memory_read44577 : if (_trace) printf("vma_memory_read44577:\n");
*(uint64_t *)sp = r0;
r0 = (uint64_t)  && return0037;
goto memoryreaddatadecode;
return0037 : r0 = *(uint64_t *)sp;
goto carcdr_internal44556;

vma_memory_read44564 : if (_trace) printf("vma_memory_read44564:\n");
if ((t7 & 1) == 0)
    goto vma_memory_read44563;
arg2 = (uint32_t) arg6; // Do the indirect thing
goto vma_memory_read44560;

vma_memory_read44563 : if (_trace) printf("vma_memory_read44563:\n");

vma_memory_read44562 : if (_trace) printf("vma_memory_read44562:\n");
*(uint64_t *)sp = r0;
r0 = (uint64_t)  && return0038;
goto memoryreaddatadecode;
return0038 : r0 = *(uint64_t *)sp;
goto vma_memory_read44571;

/* end CarCdrInternal */
/* start PullApplyArgsSlowly */

pullapplyargsslowly : if (_trace) printf("pullapplyargsslowly:\n");
t11 = *(uint64_t *)&(processor->stackcachebasevma);
t12 = *(int32_t *)&processor->scovlimit; // Size of the stack cache (words)
arg4 = *(int32_t *)iSP; // Get the rest arg
arg3 = *(int32_t *)(iSP + 4);
arg4 = (uint32_t) arg4;
t2 = (uint32_t) (arg4 >> ((zero & 7) * 8));
t3 = arg3 & 63; // Strip off any CDR code bits.
t4 = (t3 == Type_List) ? 1 : 0;

force_alignment44653 : if (_trace) printf("force_alignment44653:\n");
if (t4 == 0)
    goto basic_dispatch44610;
/* Here if argument TypeList */
/* Memory Read Internal */

vma_memory_read44611 : t5 = t2 + ivory;
arg6 = (t5 * 4);
arg5 = LDQ_U(t5);
t3 = t2 - t11; // Stack cache offset
t6 = *(uint64_t *)&(processor->dataread_mask);
t4 = ((uint64_t) t3 < (uint64_t) t12) ? 1 : 0; // In range?
arg6 = *(int32_t *)arg6;
arg5 = (uint8_t) (arg5 >> ((t5 & 7) * 8));
if (t4 != 0)
    goto vma_memory_read44613;

vma_memory_read44612 : t5 = zero + 240;
t6 = t6 >> (arg5 & 63);
t5 = t5 >> (arg5 & 63);
arg6 = (uint32_t) arg6;
if (t6 & 1)
    goto vma_memory_read44615;

vma_memory_read44622 : t3 = (int32_t) t2 - (int32_t) arg4;
if (t3 != 0) // CAR forwarded, must CDR the hard way
    goto carcdr_internal44606;
arg3 = arg5;
arg4 = arg6;

carcdr_internal44608 : if (_trace) printf("carcdr_internal44608:\n");
t3 = arg5 & 192; // Extract CDR code.
if (t3 != 0)
    goto basic_dispatch44624;
/* Here if argument 0 */
arg6 = t2 + 1; // Address of next position is CDR
arg5 = Type_List;

basic_dispatch44623 : if (_trace) printf("basic_dispatch44623:\n");

basic_dispatch44609 : if (_trace) printf("basic_dispatch44609:\n");

carcdr_internal44607 : if (_trace) printf("carcdr_internal44607:\n");
*(uint32_t *)iSP = arg4; // Push the pulled argument
*(uint32_t *)(iSP + 4) = arg3; // write the stack cache
t1 = arg5 & 63; // set CDR-NEXT
*(uint32_t *)(iSP + 8) = arg6; // Push the new rest arg
*(uint32_t *)(iSP + 12) = t1; // write the stack cache
iSP = iSP + 8;
arg2 = *(int32_t *)&processor->control;
t2 = arg2 & 255; // Get current arg size.
arg2 = arg2 & ~255L;
t2 = t2 + 1;
arg2 = t2 + arg2; // Update the arg size
*(uint32_t *)&processor->control = arg2;
iLP = iLP + 8;
goto INTERPRETINSTRUCTION;

basic_dispatch44610 : if (_trace) printf("basic_dispatch44610:\n");
t4 = (t3 == Type_NIL) ? 1 : 0;

force_alignment44654 : if (_trace) printf("force_alignment44654:\n");
if (t4 == 0)
    goto basic_dispatch44640;
/* Here if argument TypeNIL */
arg6 = *(int32_t *)&processor->niladdress;
arg5 = *((int32_t *)(&processor->niladdress) + 1);
arg6 = (uint32_t) arg6;
goto basic_dispatch44609;

basic_dispatch44640 : if (_trace) printf("basic_dispatch44640:\n");
/* Here for all other cases */
arg1 = arg1;
goto pullapplyargstrap;

carcdr_internal44606 : if (_trace) printf("carcdr_internal44606:\n");
t2 = (uint32_t) (arg4 >> ((zero & 7) * 8));
arg3 = arg5;
arg4 = arg6;
/* Memory Read Internal */

vma_memory_read44642 : t5 = t2 + ivory;
arg6 = (t5 * 4);
arg5 = LDQ_U(t5);
t3 = t2 - t11; // Stack cache offset
t6 = *(uint64_t *)&(processor->cdr_mask);
t4 = ((uint64_t) t3 < (uint64_t) t12) ? 1 : 0; // In range?
arg6 = *(int32_t *)arg6;
arg5 = (uint8_t) (arg5 >> ((t5 & 7) * 8));
if (t4 != 0)
    goto vma_memory_read44644;

vma_memory_read44643 : t5 = zero + 192;
t6 = t6 >> (arg5 & 63);
t5 = t5 >> (arg5 & 63);
if (t6 & 1)
    goto vma_memory_read44646;

vma_memory_read44651 : goto carcdr_internal44608;

vma_memory_read44644 : if (_trace) printf("vma_memory_read44644:\n");
t4 = *(uint64_t *)&(processor->stackcachedata);
t3 = (t3 * 8) + t4; // reconstruct SCA
arg6 = *(int32_t *)t3;
arg5 = *(int32_t *)(t3 + 4); // Read from stack cache
goto vma_memory_read44643;

vma_memory_read44646 : if (_trace) printf("vma_memory_read44646:\n");
if ((t5 & 1) == 0)
    goto vma_memory_read44645;
t2 = (uint32_t) arg6; // Do the indirect thing
goto vma_memory_read44642;

vma_memory_read44645 : if (_trace) printf("vma_memory_read44645:\n");
t6 = *(uint64_t *)&(processor->cdr); // Load the memory action table for cycle
/* TagType. */
t5 = arg5 & 63; // Discard the CDR code
*(uint64_t *)&processor->vma = t2; // stash the VMA for the (likely) trap
t5 = (t5 * 4) + t6; // Adjust for a longword load
t6 = *(int32_t *)t5; // Get the memory action

vma_memory_read44648 :
    /* Perform memory action */
    arg1
    = t6;
arg2 = 9;
goto performmemoryaction;

basic_dispatch44624 : if (_trace) printf("basic_dispatch44624:\n");
t4 = (t3 == 128) ? 1 : 0;

force_alignment44655 : if (_trace) printf("force_alignment44655:\n");
if (t4 == 0)
    goto basic_dispatch44625;
/* Here if argument 128 */
t2 = t2 + 1;
/* Memory Read Internal */

vma_memory_read44626 : t5 = t2 + ivory;
arg6 = (t5 * 4);
arg5 = LDQ_U(t5);
t3 = t2 - t11; // Stack cache offset
t6 = *(uint64_t *)&(processor->dataread_mask);
t4 = ((uint64_t) t3 < (uint64_t) t12) ? 1 : 0; // In range?
arg6 = *(int32_t *)arg6;
arg5 = (uint8_t) (arg5 >> ((t5 & 7) * 8));
if (t4 != 0)
    goto vma_memory_read44628;

vma_memory_read44627 : t5 = zero + 240;
t6 = t6 >> (arg5 & 63);
t5 = t5 >> (arg5 & 63);
arg6 = (uint32_t) arg6;
if (t6 & 1)
    goto vma_memory_read44630;
goto carcdr_internal44607;

basic_dispatch44625 : if (_trace) printf("basic_dispatch44625:\n");
t4 = (t3 == 64) ? 1 : 0;

force_alignment44656 : if (_trace) printf("force_alignment44656:\n");
if (t4 == 0)
    goto basic_dispatch44637;
/* Here if argument 64 */
arg6 = *(int32_t *)&processor->niladdress;
arg5 = *((int32_t *)(&processor->niladdress) + 1);
arg6 = (uint32_t) arg6;
goto carcdr_internal44607;

basic_dispatch44637 : if (_trace) printf("basic_dispatch44637:\n");
/* Here for all other cases */
arg5 = t2;
arg2 = 15;
goto illegaloperand;

vma_memory_read44628 : if (_trace) printf("vma_memory_read44628:\n");
t4 = *(uint64_t *)&(processor->stackcachedata);
t3 = (t3 * 8) + t4; // reconstruct SCA
arg6 = *(int32_t *)t3;
arg5 = *(int32_t *)(t3 + 4); // Read from stack cache
goto vma_memory_read44627;

vma_memory_read44630 : if (_trace) printf("vma_memory_read44630:\n");
if ((t5 & 1) == 0)
    goto vma_memory_read44629;
t2 = (uint32_t) arg6; // Do the indirect thing
goto vma_memory_read44626;

vma_memory_read44629 : if (_trace) printf("vma_memory_read44629:\n");
t6 = *(uint64_t *)&(processor->dataread); // Load the memory action table for cycle
/* TagType. */
t5 = arg5 & 63; // Discard the CDR code
*(uint64_t *)&processor->vma = t2; // stash the VMA for the (likely) trap
t5 = (t5 * 4) + t6; // Adjust for a longword load
t6 = *(int32_t *)t5; // Get the memory action

vma_memory_read44634 : if (_trace) printf("vma_memory_read44634:\n");
t5 = t6 & MemoryActionTransform;
if (t5 == 0)
    goto vma_memory_read44633;
arg5 = arg5 & ~63L;
arg5 = arg5 | Type_ExternalValueCellPointer;
goto carcdr_internal44607;

vma_memory_read44633 :

    vma_memory_read44632 :
    /* Perform memory action */
    arg1
    = t6;
arg2 = 0;
goto performmemoryaction;

vma_memory_read44613 : if (_trace) printf("vma_memory_read44613:\n");
t4 = *(uint64_t *)&(processor->stackcachedata);
t3 = (t3 * 8) + t4; // reconstruct SCA
arg6 = *(int32_t *)t3;
arg5 = *(int32_t *)(t3 + 4); // Read from stack cache
goto vma_memory_read44612;

vma_memory_read44615 : if (_trace) printf("vma_memory_read44615:\n");
if ((t5 & 1) == 0)
    goto vma_memory_read44614;
t2 = (uint32_t) arg6; // Do the indirect thing
goto vma_memory_read44611;

vma_memory_read44614 : if (_trace) printf("vma_memory_read44614:\n");
t6 = *(uint64_t *)&(processor->dataread); // Load the memory action table for cycle
/* TagType. */
t5 = arg5 & 63; // Discard the CDR code
*(uint64_t *)&processor->vma = t2; // stash the VMA for the (likely) trap
t5 = (t5 * 4) + t6; // Adjust for a longword load
t6 = *(int32_t *)t5; // Get the memory action

vma_memory_read44619 : if (_trace) printf("vma_memory_read44619:\n");
t5 = t6 & MemoryActionTransform;
if (t5 == 0)
    goto vma_memory_read44618;
arg5 = arg5 & ~63L;
arg5 = arg5 | Type_ExternalValueCellPointer;
goto vma_memory_read44622;

vma_memory_read44618 :

    vma_memory_read44617 :
    /* Perform memory action */
    arg1
    = t6;
arg2 = 0;
goto performmemoryaction;

/* end PullApplyArgsSlowly */
/* start DoLocateLocals */

/* Halfword operand from stack instruction - DoLocateLocals */
/* arg2 has the preloaded 8 bit operand. */

dolocatelocals : if (_trace) printf("dolocatelocals:\n");

DoLocateLocalsSP : if (_trace) printf("DoLocateLocalsSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoLocateLocalsLP : if (_trace) printf("DoLocateLocalsLP:\n");

DoLocateLocalsFP : if (_trace) printf("DoLocateLocalsFP:\n");

begindolocatelocals : if (_trace) printf("begindolocatelocals:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
t1 = *(int32_t *)&processor->control; // The control register
iLP = iSP;
t3 = iLP - iFP; // arg size including the fudge 2
t3 = t3 >> 3; // adjust arg size to words
t2 = t1 & 255; // argument size
t2 = t2 - 2; // corrected arg size
t1 = t1 & ~255L;
t1 = t1 | t3; // replace the arg size
t4 = Type_Fixnum;
*(uint32_t *)(iSP + 8) = t2;
*(uint32_t *)(iSP + 12) = t4; // write the stack cache
iSP = iSP + 8;
*(uint32_t *)&processor->control = t1;
goto NEXTINSTRUCTION;

DoLocateLocalsIM : goto doistageerror;

/* end DoLocateLocals */
/* End of Halfword operand from stack instruction - DoLocateLocals */
/* Returning. */
/* start DoReturnMultiple */

/* Halfword operand from stack instruction - DoReturnMultiple */
/* arg2 has the preloaded 8 bit operand. */

doreturnmultiple : if (_trace) printf("doreturnmultiple:\n");

DoReturnMultipleSP : if (_trace) printf("DoReturnMultipleSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoReturnMultipleLP : if (_trace) printf("DoReturnMultipleLP:\n");

DoReturnMultipleFP : if (_trace) printf("DoReturnMultipleFP:\n");

begindoreturnmultiple : if (_trace) printf("begindoreturnmultiple:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
t1 = *(int32_t *)(arg1 + 4); // Fetch the tag for type-check
arg1 = *(int32_t *)arg1; // Fetch the data
t2 = t1 - Type_Fixnum;
t2 = t2 & 63; // Strip CDR code
if (t2 != 0)
    goto returnmultipleio;
arg1 = (uint32_t) arg1; // Discard dtp-fixnum tag word

returnmultipletop : if (_trace) printf("returnmultipletop:\n");
arg5 = *(int32_t *)&processor->control;
t3 = (12) << 16;
t2 = iSP + 8;
t1 = arg1 << 3; // Value bytes
t3 = t3 & arg5; // Mask
t3 = t3 >> 18; // Shift disposition bits into place.
arg3 = t2 - t1; // Compute position of value(s)
arg6 = *(uint64_t *)&(processor->stackcachedata);
arg4 = t3 - 2; // arg4 -2=effect -1=value 0=return 1=multiple
if ((int64_t) arg4 < 0)
    goto returnmultiplesingle;
/* Restore machine state from frame header. */
t3 = *(int32_t *)iFP;
t1 = (1792) << 16;
t5 = *(int32_t *)&processor->continuation;
t1 = arg5 & t1; // Mask
t2 = *(int32_t *)(iFP + 4);
t7 = iCP;
if (t1 != 0) // Need to cleanup frame first
    goto handleframecleanup;
t3 = (uint32_t) t3;
t4 = *((int32_t *)(&processor->continuation) + 1);
t5 = (uint32_t) t5;
t6 = *(int32_t *)(iFP + 8); // Get saved control register
/* TagType. */
t2 = t2 & 63;
/* Restore the PC. */
if (arg4 == 0)
    goto abandon_frame_simple44658;
iPC = t5 << 1; // Assume even PC
t1 = t4 & 1;
t7 = *(uint64_t *)&(processor->continuationcp);
iPC = iPC + t1;

abandon_frame_simple44658 : if (_trace) printf("abandon_frame_simple44658:\n");
/* Restore the saved continuation */
*((uint32_t *)(&processor->continuation) + 1) = t2;
t1 = arg5 >> 9; // Get the caller frame size into place
*(uint32_t *)&processor->continuation = t3;
iSP = iFP - 8; // Restore the stack pointer.
*(uint64_t *)&processor->continuationcp = zero;
t1 = t1 & 255; // Mask just the caller frame size.
t1 = (t1 * 8) + 0; // *8
t2 = (2048) << 16;
t2 = t2 & arg5;
t3 = *(int32_t *)&processor->interruptreg; // Get the preempt-pending bit
t6 = t2 | t6; // Sticky trace pending bit.
t4 = *(uint64_t *)&(processor->please_stop); // Get the trap/suspend bits
iFP = iFP - t1; // Restore the frame pointer.
*(uint32_t *)&processor->control = t6; // Restore the control register
t1 = t6 & 255; // extract the argument size
t3 = t3 & 1;
t3 = t4 | t3;
*(uint64_t *)&processor->stop_interpreter = t3;
iLP = (t1 * 8) + iFP; // Restore the local pointer.
arg6 = ((uint64_t) iFP < (uint64_t) arg6) ? 1 : 0; // ARG6 = stack-cache underflow
t4 = iSP + 8; // Compute destination of copy
t3 = arg1; // Values
t1 = *(uint64_t *)&(processor->cdrcodemask); // mask for CDR codes
goto stack_block_copy44659;

stack_block_copy44660 : if (_trace) printf("stack_block_copy44660:\n");
t3 = t3 - 1;
t2 = *(uint64_t *)arg3; // Get a word from source
arg3 = arg3 + 8; // advance from position
t2 = t2 & ~t1; // Strip off CDR code
*(uint64_t *)t4 = t2; // Put word in destination
t4 = t4 + 8; // advance to position

stack_block_copy44659 : if ((int64_t) t3 > 0) goto stack_block_copy44660;
iSP = (arg1 * 8) + iSP; // Adjust iSP over returned values
/* arg4 -2=effect -1=value 0=return 1=multiple */
if (arg4 == 0)
    goto returnmultiplereturn;

returnmultiplemultiple : if (_trace) printf("returnmultiplemultiple:\n");
t1 = Type_Fixnum;
*(uint32_t *)(iSP + 8) = arg1; // push the MV return count
*(uint32_t *)(iSP + 12) = t1; // write the stack cache
iSP = iSP + 8;

returnmultipledone : if (_trace) printf("returnmultipledone:\n");
if (arg6 != 0)
    goto returnmultipleunderflow;
arg2 = t7;
if (t7 != 0)
    goto interpretinstructionpredicted;
if (arg4 != 0)
    goto interpretinstructionforbranch;
goto INTERPRETINSTRUCTION; // Return-multiple done

returnmultipleunderflow : if (_trace) printf("returnmultipleunderflow:\n");
goto stackcacheunderflowcheck;

returnmultiplesingle : if (_trace) printf("returnmultiplesingle:\n");
arg3 = *(uint64_t *)arg3;
t1 = *(uint64_t *)&(processor->niladdress);
arg3 = arg3 << 26; // Clear cdr
arg3 = arg3 >> 26; // Clear cdr
if (arg1 == 0)
    arg3 = t1;
goto returncommontail;

returnmultiplereturn : if (_trace) printf("returnmultiplereturn:\n");
if (arg2 != 0)
    goto returnmultipledone;
t1 = Type_Fixnum;
*(uint32_t *)(iSP + 8) = arg1;
*(uint32_t *)(iSP + 12) = t1; // write the stack cache
iSP = iSP + 8;
goto returnmultipledone;

DoReturnMultipleIM : if (_trace) printf("DoReturnMultipleIM:\n");
arg1 = arg2;
arg2 = zero + 1;
goto returnmultipletop;

returnmultipleio : if (_trace) printf("returnmultipleio:\n");
arg5 = 0;
arg2 = 63;
goto illegaloperand;

/* end DoReturnMultiple */
/* End of Halfword operand from stack instruction - DoReturnMultiple */
/* start HANDLEFRAMECLEANUP */

handleframecleanup : if (_trace) printf("handleframecleanup:\n");
iSP = *(uint64_t *)&(processor->restartsp); // Restore SP to instruction start
arg5 = *(int32_t *)&processor->control; // Get control register

cleanup_frame44663 : if (_trace) printf("cleanup_frame44663:\n");
t1 = (1024) << 16;
t4 = *(int32_t *)&processor->catchblock;
t4 = (uint32_t) t4;
t2 = t1 & arg5;
if (t2 == 0) // J. if cr.cleanup-catch is 0
    goto cleanup_frame44662;
/* Convert VMA to stack cache address */
t2 = *(uint64_t *)&(processor->stackcachebasevma);
t3 = *(uint64_t *)&(processor->stackcachedata);
t2 = t4 - t2; // stack cache base relative offset
t3 = (t2 * 8) + t3; // reconstruct SCA
t6 = *(int32_t *)(t3 + 16);
t5 = *(int32_t *)(t3 + 20);
t6 = (uint32_t) t6;
t2 = *(int32_t *)(t3 + 8);
t1 = *(int32_t *)(t3 + 12);
t2 = (uint32_t) t2;
t12 = t1 & 64;
if (t12 != 0) // J. if catch block is UWP variety.
    goto handleunwindprotect;
t3 = (1024) << 16;
t2 = t5 & 64; // Extract the catchcleanup bit
t2 = t2 << 20; // Shift into place for CR
t3 = arg5 & ~t3;
arg5 = t3 | t2;
*(uint32_t *)&processor->control = arg5;
/* TagType. */
t5 = t5 & 63;
t5 = t5 << 32;
t6 = t6 | t5;
*(uint64_t *)&processor->catchblock = t6;
goto cleanup_frame44663;

cleanup_frame44662 : if (_trace) printf("cleanup_frame44662:\n");
t1 = (512) << 16;
t2 = t1 & arg5;
t1 = *(uint64_t *)&(processor->bindingstackpointer);
if (t2 == 0) // J. if cr.cleanup-bindings is 0.
    goto cleanup_frame44661;

cleanup_frame44664 : if (_trace) printf("cleanup_frame44664:\n");
t1 = *(uint64_t *)&(processor->bindingstackpointer);
t4 = *(int32_t *)&processor->control;
t1 = (uint32_t) t1; // vma only
t2 = (512) << 16;
t5 = t1 - 1;
t3 = t4 & t2;
t4 = t4 & ~t2; // Turn off the bit
if (t3 != 0)
    goto g44665;
t4 = *(uint64_t *)&(processor->restartsp); // Get the SP, ->op2
arg5 = 0;
arg2 = 20;
goto illegaloperand;

g44665 : if (_trace) printf("g44665:\n");
/* Memory Read Internal */

vma_memory_read44666 : t8 = *(uint64_t *)&(processor->stackcachebasevma); // Base of stack cache
t10 = t1 + ivory;
t9 = *(int32_t *)&processor->scovlimit;
t6 = (t10 * 4);
t7 = LDQ_U(t10);
t8 = t1 - t8; // Stack cache offset
t11 = *(uint64_t *)&(processor->bindread_mask);
t9 = ((uint64_t) t8 < (uint64_t) t9) ? 1 : 0; // In range?
t6 = *(int32_t *)t6;
t7 = (uint8_t) (t7 >> ((t10 & 7) * 8));
if (t9 != 0)
    goto vma_memory_read44668;

vma_memory_read44667 : t10 = zero + 224;
t11 = t11 >> (t7 & 63);
t10 = t10 >> (t7 & 63);
if (t11 & 1)
    goto vma_memory_read44670;

vma_memory_read44675 :
    /* Memory Read Internal */

    vma_memory_read44676 : t8
                           = *(uint64_t *)&(processor->stackcachebasevma); // Base of stack cache
t10 = t5 + ivory;
t9 = *(int32_t *)&processor->scovlimit;
t2 = (t10 * 4);
t3 = LDQ_U(t10);
t8 = t5 - t8; // Stack cache offset
t11 = *(uint64_t *)&(processor->bindread_mask);
t9 = ((uint64_t) t8 < (uint64_t) t9) ? 1 : 0; // In range?
t2 = *(int32_t *)t2;
t3 = (uint8_t) (t3 >> ((t10 & 7) * 8));
if (t9 != 0)
    goto vma_memory_read44678;

vma_memory_read44677 : t10 = zero + 224;
t11 = t11 >> (t3 & 63);
t10 = t10 >> (t3 & 63);
t2 = (uint32_t) t2;
if (t11 & 1)
    goto vma_memory_read44680;

vma_memory_read44685 :
    /* Memory Read Internal */

    vma_memory_read44686 : t10
                           = *(uint64_t *)&(processor->stackcachebasevma); // Base of stack cache
t12 = t2 + ivory;
t11 = *(int32_t *)&processor->scovlimit;
t9 = (t12 * 4);
t8 = LDQ_U(t12);
t10 = t2 - t10; // Stack cache offset
t11 = ((uint64_t) t10 < (uint64_t) t11) ? 1 : 0; // In range?
t9 = *(int32_t *)t9;
t8 = (uint8_t) (t8 >> ((t12 & 7) * 8));
if (t11 != 0)
    goto vma_memory_read44688;

vma_memory_read44687 : t10 = *(uint64_t *)&(processor->bindwrite_mask);
t12 = zero + 224;
t10 = t10 >> (t8 & 63);
t12 = t12 >> (t8 & 63);
if (t10 & 1)
    goto vma_memory_read44690;

vma_memory_read44695 :
    /* Merge cdr-code */
    t9
    = t7 & 63;
t8 = t8 & 192;
t8 = t8 | t9;
t10 = t2 + ivory;
t9 = (t10 * 4);
t12 = LDQ_U(t10);
t11 = (t8 & 0xff) << ((t10 & 7) * 8);
t12 = t12 & ~(0xffL << (t10 & 7) * 8);

force_alignment44698 : if (_trace) printf("force_alignment44698:\n");
t12 = t12 | t11;
t11 = *(uint64_t *)&(processor->stackcachebasevma);
STQ_U(t10, t12);
t10 = *(int32_t *)&processor->scovlimit;
t11 = t2 - t11; // Stack cache offset
t10 = ((uint64_t) t11 < (uint64_t) t10) ? 1 : 0; // In range?
*(uint32_t *)t9 = t6;
if (t10 != 0) // J. if in cache
    goto vma_memory_write44697;

vma_memory_write44696 : t3 = t3 & 64; // Get the old cleanup-bindings bit
t3 = t3 << 19;
t1 = t1 - 2;
*(uint32_t *)&processor->bindingstackpointer = t1; // vma only
t4 = t4 | t3;
*(uint32_t *)&processor->control = t4;
arg5 = *(int32_t *)&processor->control;
t1 = (512) << 16;
t2 = t1 & arg5;
if (t2 != 0) // J. if cr.cleanup-bindings is 0.
    goto cleanup_frame44664;
t2 = *(int32_t *)&processor->interruptreg;
t3 = t2 & 2;
t3 = (t3 == 2) ? 1 : 0;
t2 = t2 | t3;
*(uint32_t *)&processor->interruptreg = t2;
if (t2 == 0)
    goto check_preempt_request44699;
*(uint64_t *)&processor->stop_interpreter = t2;

check_preempt_request44699 : if (_trace) printf("check_preempt_request44699:\n");

cleanup_frame44661 : if (_trace) printf("cleanup_frame44661:\n");
t3 = (256) << 16;
t2 = t3 & arg5;
if (t2 == 0)
    goto INTERPRETINSTRUCTION;
arg5 = zero;
arg2 = 79;
goto illegaloperand;
goto INTERPRETINSTRUCTION; // Retry the instruction

vma_memory_write44697 : if (_trace) printf("vma_memory_write44697:\n");
t10 = *(uint64_t *)&(processor->stackcachedata);
t10 = (t11 * 8) + t10; // reconstruct SCA
*(uint32_t *)t10 = t6; // Store in stack
*(uint32_t *)(t10 + 4) = t8; // write the stack cache
goto vma_memory_write44696;

vma_memory_read44688 : if (_trace) printf("vma_memory_read44688:\n");
t11 = *(uint64_t *)&(processor->stackcachedata);
t10 = (t10 * 8) + t11; // reconstruct SCA
t9 = *(int32_t *)t10;
t8 = *(int32_t *)(t10 + 4); // Read from stack cache
goto vma_memory_read44687;

vma_memory_read44690 : if (_trace) printf("vma_memory_read44690:\n");
if ((t12 & 1) == 0)
    goto vma_memory_read44689;
t2 = (uint32_t) t9; // Do the indirect thing
goto vma_memory_read44686;

vma_memory_read44689 : if (_trace) printf("vma_memory_read44689:\n");
t10 = *(uint64_t *)&(processor->bindwrite); // Load the memory action table for cycle
/* TagType. */
t12 = t8 & 63; // Discard the CDR code
*(uint64_t *)&processor->vma = t2; // stash the VMA for the (likely) trap
t12 = (t12 * 4) + t10; // Adjust for a longword load
t10 = *(int32_t *)t12; // Get the memory action

vma_memory_read44692 :
    /* Perform memory action */
    arg1
    = t10;
arg2 = 3;
goto performmemoryaction;

vma_memory_read44678 : if (_trace) printf("vma_memory_read44678:\n");
t9 = *(uint64_t *)&(processor->stackcachedata);
t8 = (t8 * 8) + t9; // reconstruct SCA
t2 = *(int32_t *)t8;
t3 = *(int32_t *)(t8 + 4); // Read from stack cache
goto vma_memory_read44677;

vma_memory_read44680 : if (_trace) printf("vma_memory_read44680:\n");
if ((t10 & 1) == 0)
    goto vma_memory_read44679;
t5 = (uint32_t) t2; // Do the indirect thing
goto vma_memory_read44676;

vma_memory_read44679 : if (_trace) printf("vma_memory_read44679:\n");
t11 = *(uint64_t *)&(processor->bindread); // Load the memory action table for cycle
/* TagType. */
t10 = t3 & 63; // Discard the CDR code
*(uint64_t *)&processor->vma = t5; // stash the VMA for the (likely) trap
t10 = (t10 * 4) + t11; // Adjust for a longword load
t11 = *(int32_t *)t10; // Get the memory action

vma_memory_read44682 :
    /* Perform memory action */
    arg1
    = t11;
arg2 = 2;
goto performmemoryaction;

vma_memory_read44668 : if (_trace) printf("vma_memory_read44668:\n");
t9 = *(uint64_t *)&(processor->stackcachedata);
t8 = (t8 * 8) + t9; // reconstruct SCA
t6 = *(int32_t *)t8;
t7 = *(int32_t *)(t8 + 4); // Read from stack cache
goto vma_memory_read44667;

vma_memory_read44670 : if (_trace) printf("vma_memory_read44670:\n");
if ((t10 & 1) == 0)
    goto vma_memory_read44669;
t1 = (uint32_t) t6; // Do the indirect thing
goto vma_memory_read44666;

vma_memory_read44669 : if (_trace) printf("vma_memory_read44669:\n");
t11 = *(uint64_t *)&(processor->bindread); // Load the memory action table for cycle
/* TagType. */
t10 = t7 & 63; // Discard the CDR code
*(uint64_t *)&processor->vma = t1; // stash the VMA for the (likely) trap
t10 = (t10 * 4) + t11; // Adjust for a longword load
t11 = *(int32_t *)t10; // Get the memory action

vma_memory_read44672 :
    /* Perform memory action */
    arg1
    = t11;
arg2 = 2;
goto performmemoryaction;

/* end HANDLEFRAMECLEANUP */
/* start StackCacheUnderflowCheck */

stackcacheunderflowcheck : if (_trace) printf("stackcacheunderflowcheck:\n");
t1 = *(uint64_t *)&(processor->stackcachedata);
t4 = *(uint64_t *)&(processor->restartsp); // Preserve through instruction's original SP
t3 = t1 - iFP; // Number of words*8 to fill iff positive
if ((int64_t) t3 <= 0)
    goto interpretinstructionforbranch;
t3 = (int64_t) t3 >> 3; // Convert to a word count
t4 = t4 + 8; // Account for the inclusive limit
if ((int64_t) t3 <= 0) // in case only low three bits nonzero
    goto interpretinstructionforbranch;
r0 = (uint64_t)  && return0039;
goto stackcacheunderflow;
return0039 : goto interpretinstructionforbranch;

/* end StackCacheUnderflowCheck */
/* start StackCacheUnderflow */

stackcacheunderflow : if (_trace) printf("stackcacheunderflow:\n");
t2 = (t3 * 8) + t1; // Compute target address for shift
t5 = t4 - t1; // Compute number of elements to preserve
t5 = (int64_t) t5 >> 3; // Convert to word count
/* Shove everything up */
t1 = (t5 * 8) + t1; // Adjust to end of source block
t2 = (t5 * 8) + t2; // Adjust to end of target block
goto stack_block_copy44700;

stack_block_copy44701 : if (_trace) printf("stack_block_copy44701:\n");
t1 = t1 - 8; // advance from position
t5 = t5 - 1;
t7 = *(uint64_t *)t1; // Get a word from source
t2 = t2 - 8; // advance to position
*(uint64_t *)t2 = t7; // Put word in destination

stack_block_copy44700 : if ((int64_t) t5 > 0) goto stack_block_copy44701;
/* Adjust stack cache relative registers */
iFP = (t3 * 8) + iFP;
t4 = *(uint64_t *)&(processor->restartsp);
iSP = (t3 * 8) + iSP;
iLP = (t3 * 8) + iLP;
t4 = (t3 * 8) + t4;
/* Fill freshly opened slots of stack cache from memory */
t1 = *(uint64_t *)&(processor->stackcachebasevma);
t2 = *(uint64_t *)&(processor->stackcachedata);
*(uint64_t *)&processor->restartsp = t4;
t1 = t1 - t3; // Compute new base address of stack cache
t4 = *(uint64_t *)&(processor->stackcachetopvma); // Top of cache
*(uint64_t *)&processor->stackcachebasevma = t1;
t4 = t4 - t3; // Adjust top of cache
*(uint64_t *)&processor->stackcachetopvma = t4;
t7 = t1 + ivory;
t5 = (t7 * 4);
t4 = LDQ_U(t7);
t5 = *(int32_t *)t5;
t4 = (uint8_t) (t4 >> ((t7 & 7) * 8));
goto stack_fill44702;

stack_fill44703 : if (_trace) printf("stack_fill44703:\n");
t7 = t1 + ivory;
t5 = (t7 * 4);
t4 = LDQ_U(t7);
t5 = *(int32_t *)t5;
t4 = (uint8_t) (t4 >> ((t7 & 7) * 8));
t3 = t3 - 1;
t1 = t1 + 1; // advance vma position
*(uint32_t *)t2 = t5;
*(uint32_t *)(t2 + 4) = t4; // write the stack cache
t2 = t2 + 8; // advance sca position

stack_fill44702 : if ((int64_t) t3 > 0) goto stack_fill44703;
goto *r0; /* ret */

/* end StackCacheUnderflow */
/* start StackCacheOverflowHandler */

stackcacheoverflowhandler : if (_trace) printf("stackcacheoverflowhandler:\n");
/* Stack cache overflow detected */
t1 = zero + 256;
t1 = t1 + arg2; // Account for what we're about to push
t1 = (t1 * 8) + iSP; // SCA of desired end of cache
iSP = *(uint64_t *)&(processor->restartsp);
t4 = *(uint64_t *)&(processor->stackcachedata); // Alpha base of stack cache
t4 = t1 - t4; // New limit*8
t4 = t4 >> 3;
*(uint32_t *)&processor->scovlimit = t4; // Update stack cache limit
/* Check that the page underlying the end of the stack cache is accessible */
/* Convert stack cache address to VMA */
t4 = *(uint64_t *)&(processor->stackcachedata);
t3 = *(uint64_t *)&(processor->stackcachebasevma);
t4 = t1 - t4; // stack cache base relative offset
t4 = t4 >> 3; // convert byte address to word address
t3 = t4 + t3; // reconstruct VMA
t5 = *(uint64_t *)&(processor->vmattributetable); // Per-page attributes table
t4 = t3 >> (MemoryPage_AddressShift & 63); // Index into the attributes table
t5 = t4 + t5; // Address of the page's attributes
t4 = LDQ_U(t5); // Get the quadword with the page's attributes
*(uint64_t *)&processor->vma = t3; // Stash the VMA
t4 = (uint8_t) (t4 >> ((t5 & 7) * 8)); // Extract the page's attributes
if (t4 == 0) // Non-existent page
    goto pagenotresident;
t5 = t4 & VMAttribute_AccessFault;
if (t5 != 0) // Access fault
    goto pagefaultrequesthandler;
t5 = t4 & VMAttribute_WriteFault;
if (t5 != 0) // Write fault
    goto pagewritefault;
/* Check if we must dump the cache */
t4 = *(int32_t *)&processor->scovlimit; // New stack cache limit (words)
t5 = *(uint64_t *)&(processor->stackcachesize); // Absolute size of the cache (words)
t5 = ((int64_t) t4 <= (int64_t) t5) ? 1 : 0;
if (t5 != 0) // We're done if new limit is less than absolute limit
    goto INTERPRETINSTRUCTION;
/* Dump the stack cache to make room */
t1 = zero + 896;
t2 = *(uint64_t *)&(processor->stackcachebasevma); // Stack cache base VMA
t3 = *(uint64_t *)&(processor->stackcachedata); // Alpha base of stack cache
*(uint32_t *)&processor->scovdumpcount = t1; // Will be destructively modified
t5 = t2 + ivory; // Starting address of tags
t2 = (t5 * 4); // Starting address of data
/* Dump the data */
goto stack_dump44704;

stack_dump44705 : if (_trace) printf("stack_dump44705:\n");
t4 = *(int32_t *)t3; // Get data word
t1 = t1 - 1;
t3 = t3 + 8; // Advance SCA position
*(uint32_t *)t2 = t4; // Save data word
t2 = t2 + 4; // Advance VMA position

stack_dump44704 : if ((int64_t) t1 > 0) goto stack_dump44705;
/* Dump the tags */
t1 = *(int32_t *)&processor->scovdumpcount; // Restore the count
t2 = t5; // Restore tag VMA
t4 = t1 << 3;
t3 = t3 - t4; // Restore orginal SCA
goto stack_dump44706;

stack_dump44707 : if (_trace) printf("stack_dump44707:\n");
t1 = t1 - 1;
t4 = *(int32_t *)(t3 + 4); // Get tag word
t3 = t3 + 8; // Advance SCA position
t5 = LDQ_U(t2); // Get packed tags word
t4 = (t4 & 0xff) << ((t2 & 7) * 8); // Position the new tag
t5 = t5 & ~(0xffL << (t2 & 7) * 8); // Remove old tag
t5 = t4 | t5; // Put in new byte
STQ_U(t2, t5); // Save packed tags word
t2 = t2 + 1; // Advance VMA position

stack_dump44706 : if ((int64_t) t1 > 0) goto stack_dump44707;
t1 = zero + 896;
t2 = *(uint64_t *)&(processor->stackcachebasevma); // Stack cache base VMA
t4 = *(uint64_t *)&(processor->stackcachetopvma); // Top of cache
t5 = *(int32_t *)&processor->scovlimit; // Cache limit in words
t2 = t2 + t1; // Adjust cache base VMA
t4 = t4 + t1; // Adjust top of cache
t5 = t5 - t1; // Adjust limit
*(uint64_t *)&processor->stackcachebasevma = t2; // Save update
*(uint64_t *)&processor->stackcachetopvma = t4;
*(uint32_t *)&processor->scovlimit = t5;
/* Move the cache down */
t3 = *(uint64_t *)&(processor->stackcachedata); // Alpha base of stack cache
t2 = (t1 * 8) + t3; // SCA of first word of new base
goto stack_block_copy44708;

stack_block_copy44709 : if (_trace) printf("stack_block_copy44709:\n");
t1 = t1 - 1;
t5 = *(uint64_t *)t2; // Get a word from source
t2 = t2 + 8; // advance from position
*(uint64_t *)t3 = t5; // Put word in destination
t3 = t3 + 8; // advance to position

stack_block_copy44708 : if ((int64_t) t1 > 0) goto stack_block_copy44709;
/* Adjust stack cache relative registers */
t1 = zero + 896;
t1 = t1 << 3; // Convert to SCA adjustment
iSP = iSP - t1;
iFP = iFP - t1;
iLP = iLP - t1;
*(uint64_t *)&processor->restartsp = iSP;
goto INTERPRETINSTRUCTION;

/* end StackCacheOverflowHandler */
/* start DoReturnKludge */

/* Halfword operand from stack instruction - DoReturnKludge */
/* arg2 has the preloaded 8 bit operand. */

doreturnkludge : if (_trace) printf("doreturnkludge:\n");

DoReturnKludgeSP : if (_trace) printf("DoReturnKludgeSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoReturnKludgeLP : if (_trace) printf("DoReturnKludgeLP:\n");

DoReturnKludgeFP : if (_trace) printf("DoReturnKludgeFP:\n");

begindoreturnkludge : if (_trace) printf("begindoreturnkludge:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
t1 = *(int32_t *)(arg1 + 4);
arg2 = *(int32_t *)arg1;
t2 = t1 - Type_Fixnum;
t2 = t2 & 63; // Strip CDR code
if (t2 != 0)
    goto returnkludgeio;
arg2 = (uint32_t) arg2;

DoReturnKludgeIM : if (_trace) printf("DoReturnKludgeIM:\n");
arg6 = *(uint64_t *)&(processor->stackcachedata);
t1 = (arg2 * 8) - 8;
t2 = *(int32_t *)&processor->control;
t1 = iSP - t1; // t1 is the values block
/* Restore machine state from frame header. */
t5 = *(int32_t *)iFP;
t3 = (1792) << 16;
t7 = *(int32_t *)&processor->continuation;
t3 = t2 & t3; // Mask
t4 = *(int32_t *)(iFP + 4);
t9 = iCP;
if (t3 != 0) // Need to cleanup frame first
    goto returnkludgecleanup;
t5 = (uint32_t) t5;
t6 = *((int32_t *)(&processor->continuation) + 1);
t7 = (uint32_t) t7;
t8 = *(int32_t *)(iFP + 8); // Get saved control register
/* TagType. */
t4 = t4 & 63;
/* Restore the PC. */
iPC = t7 << 1; // Assume even PC
t3 = t6 & 1;
t9 = *(uint64_t *)&(processor->continuationcp);
iPC = iPC + t3;

abandon_frame_simple44711 : if (_trace) printf("abandon_frame_simple44711:\n");
/* Restore the saved continuation */
*((uint32_t *)(&processor->continuation) + 1) = t4;
t3 = t2 >> 9; // Get the caller frame size into place
*(uint32_t *)&processor->continuation = t5;
iSP = iFP - 8; // Restore the stack pointer.
*(uint64_t *)&processor->continuationcp = zero;
t3 = t3 & 255; // Mask just the caller frame size.
t3 = (t3 * 8) + 0; // *8
t4 = (2048) << 16;
t4 = t4 & t2;
t5 = *(int32_t *)&processor->interruptreg; // Get the preempt-pending bit
t8 = t4 | t8; // Sticky trace pending bit.
t6 = *(uint64_t *)&(processor->please_stop); // Get the trap/suspend bits
iFP = iFP - t3; // Restore the frame pointer.
*(uint32_t *)&processor->control = t8; // Restore the control register
t3 = t8 & 255; // extract the argument size
t5 = t5 & 1;
t5 = t6 | t5;
*(uint64_t *)&processor->stop_interpreter = t5;
iLP = (t3 * 8) + iFP; // Restore the local pointer.
arg6 = ((uint64_t) iFP < (uint64_t) arg6) ? 1 : 0; // ARG6 = stack-cache underflow
if (arg2 == 0)
    goto rkloopdone;

rklooptop : if (_trace) printf("rklooptop:\n");
t4 = *(uint64_t *)t1; // Read a 40 bit word from the values block
arg2 = arg2 - 1;
*(uint64_t *)(iSP + 8) = t4; // Push value onto stack cdr codes and all
t1 = t1 + 8;
iSP = iSP + 8;
if ((int64_t) arg2 > 0)
    goto rklooptop;

rkloopdone : if (_trace) printf("rkloopdone:\n");
if (arg6 != 0)
    goto returnkludgeunderflow;
if (t9 == 0) // No prediction, validate cache
    goto interpretinstructionforbranch;
iCP = t9;
goto INTERPRETINSTRUCTION;

returnkludgeio : if (_trace) printf("returnkludgeio:\n");
arg5 = 0;
arg2 = 63;
goto illegaloperand;

returnkludgecleanup : if (_trace) printf("returnkludgecleanup:\n");
goto handleframecleanup;

returnkludgeunderflow : if (_trace) printf("returnkludgeunderflow:\n");
goto stackcacheunderflowcheck;

/* end DoReturnKludge */
/* End of Halfword operand from stack instruction - DoReturnKludge */
/* start DoTakeValues */

/* Halfword operand from stack instruction - DoTakeValues */
/* arg2 has the preloaded 8 bit operand. */

dotakevalues : if (_trace) printf("dotakevalues:\n");

DoTakeValuesIM : if (_trace) printf("DoTakeValuesIM:\n");
/* This sequence is lukewarm */
*(uint32_t *)&processor->immediate_arg = arg2;
arg1 = *(uint64_t *)&(processor->immediate_arg);
goto begindotakevalues;

DoTakeValuesSP : if (_trace) printf("DoTakeValuesSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoTakeValuesLP : if (_trace) printf("DoTakeValuesLP:\n");

DoTakeValuesFP : if (_trace) printf("DoTakeValuesFP:\n");

headdotakevalues : if (_trace) printf("headdotakevalues:\n");
arg1 = (arg2 * 8) + arg1; // Compute operand address
arg1 = *(uint64_t *)arg1; // Get the operand

begindotakevalues : if (_trace) printf("begindotakevalues:\n");
/* arg1 has the operand, not sign extended if immediate. */
arg6 = *(uint64_t *)&(processor->niladdress);
arg1 = (uint32_t) arg1; // Number of values expected
arg4 = *(int32_t *)iSP; // Number of values provided
arg3 = *(int32_t *)(iSP + 4); // Number of values provided
iSP = iSP - 8; // Pop Stack.
arg4 = (uint32_t) arg4;
arg2 = arg1 - arg4;
if ((int64_t) arg2 < 0) // J. if too many args supplied
    goto takevalueslose;
if ((int64_t) arg2 > 0) // J. if too few values supplied
    goto takevaluespad;
goto NEXTINSTRUCTION;

takevalueslose : if (_trace) printf("takevalueslose:\n");
iSP = (arg2 * 8) + iSP; // Remove the unwanted values
goto NEXTINSTRUCTION;

takevaluespad : if (_trace) printf("takevaluespad:\n");
t4 = *(int32_t *)&processor->scovlimit; // Current stack cache limit (words)
t1 = zero + 128;
t2 = *(uint64_t *)&(processor->stackcachedata); // Alpha base of stack cache
t1 = t1 + arg2; // Account for what we're about to push
t1 = (t1 * 8) + iSP; // SCA of desired end of cache
t2 = (t4 * 8) + t2; // SCA of current end of cache
t4 = ((int64_t) t1 <= (int64_t) t2) ? 1 : 0;
if (t4 == 0) // We're done if new SCA is within bounds
    goto stackcacheoverflowhandler;

takevaluespadloop : if (_trace) printf("takevaluespadloop:\n");
*(uint64_t *)(iSP + 8) = arg6; // Push NIL
iSP = iSP + 8;
arg2 = arg2 - 1;
if ((int64_t) arg2 > 0)
    goto takevaluespadloop;
goto NEXTINSTRUCTION;

/* end DoTakeValues */
/* End of Halfword operand from stack instruction - DoTakeValues */
/* Catch Instructions */
/* start DoCatchOpen */

/* Halfword 10 bit immediate instruction - DoCatchOpen */

docatchopen : if (_trace) printf("docatchopen:\n");
/* Actually only one entry point, but simulate others for dispatch */

DoCatchOpenIM : if (_trace) printf("DoCatchOpenIM:\n");

DoCatchOpenSP : if (_trace) printf("DoCatchOpenSP:\n");

DoCatchOpenLP : if (_trace) printf("DoCatchOpenLP:\n");

DoCatchOpenFP : if (_trace) printf("DoCatchOpenFP:\n");
arg1 = (uint16_t) (arg3 >> ((4 & 7) * 8));
/* arg1 has operand preloaded. */
t10 = arg1 & 1; // t10=1 if unwind-protect, t10=0 if catch
t3 = *((int32_t *)(&processor->catchblock) + 1); // tag
t10 = t10 << 38;
t4 = *(int32_t *)&processor->catchblock; // data
t2 = *(uint64_t *)&(processor->bindingstackpointer);
/* Convert stack cache address to VMA */
t1 = *(uint64_t *)&(processor->stackcachedata);
t9 = *(uint64_t *)&(processor->stackcachebasevma);
t1 = iSP - t1; // stack cache base relative offset
t1 = t1 >> 3; // convert byte address to word address
t9 = t1 + t9; // reconstruct VMA
t1 = t10 | t2;
*(uint64_t *)(iSP + 8) = t1;
iSP = iSP + 8;
t11 = *(int32_t *)&processor->control;
t2 = t11 >> 20; // Get old cleanup catch bit
t2 = t2 & 64;
t1 = t11 >> 1; // Get old extra arg bit
t1 = t1 & 128;
t1 = t1 | t2;
/* TagType. */
t2 = t3 & 63;
t1 = t1 | t2; // T1 now has new tag
*(uint32_t *)(iSP + 8) = t4;
*(uint32_t *)(iSP + 12) = t1; // write the stack cache
iSP = iSP + 8;
if (t10 != 0)
    goto catchopen2;
t2 = *(int32_t *)&processor->continuation;
t1 = *((int32_t *)(&processor->continuation) + 1);
t2 = (uint32_t) t2;
/* TagType. */
t1 = t1 & 63;
t3 = arg1 & 192; // T3 has the disposition bits in place
t1 = t1 | t3;
*(uint32_t *)(iSP + 8) = t2;
*(uint32_t *)(iSP + 12) = t1; // write the stack cache
iSP = iSP + 8;

catchopen2 : if (_trace) printf("catchopen2:\n");
t1 = Type_Locative;
*((uint32_t *)(&processor->catchblock) + 1) = t1; // tag
*(uint32_t *)&processor->catchblock = t9; // data
t1 = (1024) << 16;
t1 = t1 | t11; // set it
*(uint32_t *)&processor->control = t1;
goto NEXTINSTRUCTION;

/* end DoCatchOpen */
/* End of Halfword operand from stack instruction - DoCatchOpen */
/* start DoCatchClose */

/* Halfword operand from stack instruction - DoCatchClose */
/* arg2 has the preloaded 8 bit operand. */

docatchclose : if (_trace) printf("docatchclose:\n");

DoCatchCloseSP : if (_trace) printf("DoCatchCloseSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoCatchCloseLP : if (_trace) printf("DoCatchCloseLP:\n");

DoCatchCloseFP : if (_trace) printf("DoCatchCloseFP:\n");

begindocatchclose : if (_trace) printf("begindocatchclose:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
t1 = *(int32_t *)&processor->catchblock; // data
t1 = (uint32_t) t1;
/* Convert VMA to stack cache address */
t3 = *(uint64_t *)&(processor->stackcachebasevma);
t10 = *(uint64_t *)&(processor->stackcachedata);
t3 = t1 - t3; // stack cache base relative offset
t10 = (t3 * 8) + t10; // reconstruct SCA
arg4 = *(int32_t *)(t10 + 8); // bstag bsdata
arg3 = *(int32_t *)(t10 + 12);
arg4 = (uint32_t) arg4;
t4 = *(uint64_t *)&(processor->bindingstackpointer);
arg6 = *(int32_t *)(t10 + 16); // prtag prdata
arg5 = *(int32_t *)(t10 + 20);
arg6 = (uint32_t) arg6;
t3 = t4 >> 32;
t5 = (int32_t) arg4 - (int32_t) t4;
if (t5 == 0)
    goto catchcloseld;
t1 = t3 - Type_Locative;
t1 = t1 & 63; // Strip CDR code
if (t1 != 0)
    goto catchclosedbt;

catchcloselt : if (_trace) printf("catchcloselt:\n");
t1 = *(uint64_t *)&(processor->bindingstackpointer);
t4 = *(int32_t *)&processor->control;
t1 = (uint32_t) t1; // vma only
t2 = (512) << 16;
t5 = t1 - 1;
t3 = t4 & t2;
t4 = t4 & ~t2; // Turn off the bit
if (t3 != 0)
    goto g44713;
t4 = *(uint64_t *)&(processor->restartsp); // Get the SP, ->op2
arg5 = 0;
arg2 = 20;
goto illegaloperand;

g44713 : if (_trace) printf("g44713:\n");
/* Memory Read Internal */

vma_memory_read44714 : t8 = *(uint64_t *)&(processor->stackcachebasevma); // Base of stack cache
arg1 = t1 + ivory;
t9 = *(int32_t *)&processor->scovlimit;
t6 = (arg1 * 4);
t7 = LDQ_U(arg1);
t8 = t1 - t8; // Stack cache offset
arg2 = *(uint64_t *)&(processor->bindread_mask);
t9 = ((uint64_t) t8 < (uint64_t) t9) ? 1 : 0; // In range?
t6 = *(int32_t *)t6;
t7 = (uint8_t) (t7 >> ((arg1 & 7) * 8));
if (t9 != 0)
    goto vma_memory_read44716;

vma_memory_read44715 : arg1 = zero + 224;
arg2 = arg2 >> (t7 & 63);
arg1 = arg1 >> (t7 & 63);
if (arg2 & 1)
    goto vma_memory_read44718;

vma_memory_read44723 :
    /* Memory Read Internal */

    vma_memory_read44724 : t8
                           = *(uint64_t *)&(processor->stackcachebasevma); // Base of stack cache
arg1 = t5 + ivory;
t9 = *(int32_t *)&processor->scovlimit;
t2 = (arg1 * 4);
t3 = LDQ_U(arg1);
t8 = t5 - t8; // Stack cache offset
arg2 = *(uint64_t *)&(processor->bindread_mask);
t9 = ((uint64_t) t8 < (uint64_t) t9) ? 1 : 0; // In range?
t2 = *(int32_t *)t2;
t3 = (uint8_t) (t3 >> ((arg1 & 7) * 8));
if (t9 != 0)
    goto vma_memory_read44726;

vma_memory_read44725 : arg1 = zero + 224;
arg2 = arg2 >> (t3 & 63);
arg1 = arg1 >> (t3 & 63);
t2 = (uint32_t) t2;
if (arg2 & 1)
    goto vma_memory_read44728;

vma_memory_read44733 :
    /* Memory Read Internal */

    vma_memory_read44734 : arg1
                           = *(uint64_t *)&(processor->stackcachebasevma); // Base of stack cache
t11 = t2 + ivory;
arg2 = *(int32_t *)&processor->scovlimit;
t9 = (t11 * 4);
t8 = LDQ_U(t11);
arg1 = t2 - arg1; // Stack cache offset
arg2 = ((uint64_t) arg1 < (uint64_t) arg2) ? 1 : 0; // In range?
t9 = *(int32_t *)t9;
t8 = (uint8_t) (t8 >> ((t11 & 7) * 8));
if (arg2 != 0)
    goto vma_memory_read44736;

vma_memory_read44735 : arg1 = *(uint64_t *)&(processor->bindwrite_mask);
t11 = zero + 224;
arg1 = arg1 >> (t8 & 63);
t11 = t11 >> (t8 & 63);
if (arg1 & 1)
    goto vma_memory_read44738;

vma_memory_read44743 :
    /* Merge cdr-code */
    t9
    = t7 & 63;
t8 = t8 & 192;
t8 = t8 | t9;
arg1 = t2 + ivory;
t9 = (arg1 * 4);
t11 = LDQ_U(arg1);
arg2 = (t8 & 0xff) << ((arg1 & 7) * 8);
t11 = t11 & ~(0xffL << (arg1 & 7) * 8);

force_alignment44746 : if (_trace) printf("force_alignment44746:\n");
t11 = t11 | arg2;
arg2 = *(uint64_t *)&(processor->stackcachebasevma);
STQ_U(arg1, t11);
arg1 = *(int32_t *)&processor->scovlimit;
arg2 = t2 - arg2; // Stack cache offset
arg1 = ((uint64_t) arg2 < (uint64_t) arg1) ? 1 : 0; // In range?
*(uint32_t *)t9 = t6;
if (arg1 != 0) // J. if in cache
    goto vma_memory_write44745;

vma_memory_write44744 : t3 = t3 & 64; // Get the old cleanup-bindings bit
t3 = t3 << 19;
t1 = t1 - 2;
*(uint32_t *)&processor->bindingstackpointer = t1; // vma only
t4 = t4 | t3;
*(uint32_t *)&processor->control = t4;
t5 = (int32_t) arg4 - (int32_t) t1;
if (t5 != 0)
    goto catchcloselt;
t3 = *(int32_t *)&processor->interruptreg;
t4 = t3 & 2;
t4 = (t4 == 2) ? 1 : 0;
t3 = t3 | t4;
*(uint32_t *)&processor->interruptreg = t3;
if (t3 == 0)
    goto check_preempt_request44747;
*(uint64_t *)&processor->stop_interpreter = t3;

check_preempt_request44747 : if (_trace) printf("check_preempt_request44747:\n");

catchcloseld : if (_trace) printf("catchcloseld:\n");
/* TagType. */
t1 = arg5 & 63;
*((uint32_t *)(&processor->catchblock) + 1) = t1; // tag
t2 = arg5 & 128; // extra argument bit
t6 = *(uint64_t *)&(processor->extraandcatch); // mask for two bits
t2 = t2 << 1; // position in place for control register.
*(uint32_t *)&processor->catchblock = arg6; // data
t3 = arg5 & 64; // cleanup catch bit
t3 = t3 << 20; // position in place for cr
t4 = *(int32_t *)&processor->control;
t5 = t2 | t3; // coalesce the two bits
t4 = t4 & ~t6; // Turn off extra-arg and cleanup-catch
t4 = t4 | t5; // Maybe turn them back on
*(uint32_t *)&processor->control = t4;
t6 = arg3 & 64; // uwp bit
if (t6 == 0)
    goto NEXTINSTRUCTION;
/* Handle unwind-protect cleanup here */
arg2 = *(int32_t *)t10; // pctag pcdata
arg1 = *(int32_t *)(t10 + 4);
arg2 = (uint32_t) arg2;
t8 = t4 >> 17; // Cleanup in progress bit into cdr code pos
t7 = iPC + 1; // Next PC
/* Convert PC to a real continuation. */
t8 = t7 & 1;
t10 = t7 >> 1; // convert PC to a real word address.
t8 = t8 + Type_EvenPC;
/* TagType. */
t7 = t8 & 63;
t8 = t8 & 64;
t9 = (128) << 16;
t8 = t8 | 128;
t7 = t7 | t8;
*(uint32_t *)(iSP + 8) = t10;
*(uint32_t *)(iSP + 12) = t7; // write the stack cache
iSP = iSP + 8;
t4 = t4 | t9; // set cr.cleanup-in-progress
*(uint32_t *)&processor->control = t4;
/* Convert real continuation to PC. */
iPC = arg1 & 1;
iPC = arg2 + iPC;
iPC = arg2 + iPC;
goto interpretinstructionforjump;

catchclosedbt : if (_trace) printf("catchclosedbt:\n");
goto dbunwindcatchtrap;

vma_memory_write44745 : if (_trace) printf("vma_memory_write44745:\n");
arg1 = *(uint64_t *)&(processor->stackcachedata);
arg1 = (arg2 * 8) + arg1; // reconstruct SCA
*(uint32_t *)arg1 = t6; // Store in stack
*(uint32_t *)(arg1 + 4) = t8; // write the stack cache
goto vma_memory_write44744;

vma_memory_read44736 : if (_trace) printf("vma_memory_read44736:\n");
arg2 = *(uint64_t *)&(processor->stackcachedata);
arg1 = (arg1 * 8) + arg2; // reconstruct SCA
t9 = *(int32_t *)arg1;
t8 = *(int32_t *)(arg1 + 4); // Read from stack cache
goto vma_memory_read44735;

vma_memory_read44738 : if (_trace) printf("vma_memory_read44738:\n");
if ((t11 & 1) == 0)
    goto vma_memory_read44737;
t2 = (uint32_t) t9; // Do the indirect thing
goto vma_memory_read44734;

vma_memory_read44737 : if (_trace) printf("vma_memory_read44737:\n");
arg1 = *(uint64_t *)&(processor->bindwrite); // Load the memory action table for cycle
/* TagType. */
t11 = t8 & 63; // Discard the CDR code
*(uint64_t *)&processor->vma = t2; // stash the VMA for the (likely) trap
t11 = (t11 * 4) + arg1; // Adjust for a longword load
arg1 = *(int32_t *)t11; // Get the memory action

vma_memory_read44740 :
    /* Perform memory action */
    arg1
    = arg1;
arg2 = 3;
goto performmemoryaction;

vma_memory_read44726 : if (_trace) printf("vma_memory_read44726:\n");
t9 = *(uint64_t *)&(processor->stackcachedata);
t8 = (t8 * 8) + t9; // reconstruct SCA
t2 = *(int32_t *)t8;
t3 = *(int32_t *)(t8 + 4); // Read from stack cache
goto vma_memory_read44725;

vma_memory_read44728 : if (_trace) printf("vma_memory_read44728:\n");
if ((arg1 & 1) == 0)
    goto vma_memory_read44727;
t5 = (uint32_t) t2; // Do the indirect thing
goto vma_memory_read44724;

vma_memory_read44727 : if (_trace) printf("vma_memory_read44727:\n");
arg2 = *(uint64_t *)&(processor->bindread); // Load the memory action table for cycle
/* TagType. */
arg1 = t3 & 63; // Discard the CDR code
*(uint64_t *)&processor->vma = t5; // stash the VMA for the (likely) trap
arg1 = (arg1 * 4) + arg2; // Adjust for a longword load
arg2 = *(int32_t *)arg1; // Get the memory action

vma_memory_read44730 :
    /* Perform memory action */
    arg1
    = arg2;
arg2 = 2;
goto performmemoryaction;

vma_memory_read44716 : if (_trace) printf("vma_memory_read44716:\n");
t9 = *(uint64_t *)&(processor->stackcachedata);
t8 = (t8 * 8) + t9; // reconstruct SCA
t6 = *(int32_t *)t8;
t7 = *(int32_t *)(t8 + 4); // Read from stack cache
goto vma_memory_read44715;

vma_memory_read44718 : if (_trace) printf("vma_memory_read44718:\n");
if ((arg1 & 1) == 0)
    goto vma_memory_read44717;
t1 = (uint32_t) t6; // Do the indirect thing
goto vma_memory_read44714;

vma_memory_read44717 : if (_trace) printf("vma_memory_read44717:\n");
arg2 = *(uint64_t *)&(processor->bindread); // Load the memory action table for cycle
/* TagType. */
arg1 = t7 & 63; // Discard the CDR code
*(uint64_t *)&processor->vma = t1; // stash the VMA for the (likely) trap
arg1 = (arg1 * 4) + arg2; // Adjust for a longword load
arg2 = *(int32_t *)arg1; // Get the memory action

vma_memory_read44720 :
    /* Perform memory action */
    arg1
    = arg2;
arg2 = 2;
goto performmemoryaction;

DoCatchCloseIM : goto doistageerror;

/* end DoCatchClose */
/* End of Halfword operand from stack instruction - DoCatchClose */
/* Fin. */

/* End of file automatically generated from ../alpha-emulator/ifunfcal.as */
