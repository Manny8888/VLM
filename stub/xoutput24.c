/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/idouble.as
 ************************************************************************/

  /* Support for double precision floating point. */
/* start FetchDoubleFloat */


fetchdoublefloat:
  if (_trace) printf("fetchdoublefloat:\n");
  sp = sp + -8;
  /* Memory Read Internal */

g6314:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6316;

g6315:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)
    goto g6318;

g6325:
  t5 = arg5 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto g6313;
  *((u32 *)(&processor->fp0)+1) = arg6;
  arg2 = arg2 + 1;
  /* Memory Read Internal */

g6326:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6328;

g6327:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)
    goto g6330;

g6337:
  t5 = arg5 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto g6313;
  *(u32 *)&processor->fp0 = arg6;
  sp = sp + 8;
  goto *r0; /* ret */

g6330:
  if (_trace) printf("g6330:\n");
  if ((t7 & 1) == 0)
    goto g6329;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6326;

g6329:
  if (_trace) printf("g6329:\n");

g6328:
  if (_trace) printf("g6328:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0204;
  goto memoryreaddatadecode;
return0204:
  r0 = *(u64 *)sp;
  goto g6337;

g6318:
  if (_trace) printf("g6318:\n");
  if ((t7 & 1) == 0)
    goto g6317;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6314;

g6317:
  if (_trace) printf("g6317:\n");

g6316:
  if (_trace) printf("g6316:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0205;
  goto memoryreaddatadecode;
return0205:
  r0 = *(u64 *)sp;
  goto g6325;

g6313:
  if (_trace) printf("g6313:\n");
  /* arg6 = tag to dispatch on */
  arg6 = Type_DoubleFloat;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;

/* end FetchDoubleFloat */
/* start ConsDoubleFloat */


consdoublefloat:
  if (_trace) printf("consdoublefloat:\n");
  sp = sp + -8;
  arg6 = *(s32 *)&processor->fp0;
  arg5 = *((s32 *)(&processor->fp0)+1);
  t5 = *(u64 *)&(processor->lcarea);
  t8 = *(u64 *)&(processor->niladdress);
  t6 = *(s32 *)&processor->lclength;
  /* Fetch address */
  arg2 = *(u64 *)&(processor->lcaddress);
  t7 = (t5 == t8) ? 1 : 0;
  /* Decached area */
  if (t7 != 0)
    goto g6338;
  /* Effectively an unsigned 32-bit compare */
  t7 = t6 - 2;
  /* Insufficient cache */
  if ((s64)t7 < 0)
    goto g6338;
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  /* Store remaining length */
  *(u32 *)&processor->lclength = t7;
  t8 = (u32)arg2;
  /* Increment address */
  t8 = t8 + 2;
  /* Store updated address */
  *(u32 *)&processor->lcaddress = t8;
  arg2 = (u32)arg2;
  t9 = Type_Fixnum;
  t9 = t9 | 128;
  t5 = arg2 + ivory;
  t8 = (t5 * 4);
  t7 = LDQ_U(t5);
  t6 = (t9 & 0xff) << ((t5&7)*8);
  t7 = t7 & ~(0xffL << (t5&7)*8);

g6339:
  if (_trace) printf("g6339:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);
  *(u32 *)t8 = arg5;
  t10 = arg2 + 1;
  t9 = Type_Fixnum;
  t9 = t9 | 64;
  t5 = t10 + ivory;
  t8 = (t5 * 4);
  t7 = LDQ_U(t5);
  t6 = (t9 & 0xff) << ((t5&7)*8);
  t7 = t7 & ~(0xffL << (t5&7)*8);

g6340:
  if (_trace) printf("g6340:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);
  *(u32 *)t8 = arg6;
  sp = sp + 8;
  goto *r0; /* ret */

g6338:
  if (_trace) printf("g6338:\n");
  /* arg6 = tag to dispatch on */
  arg6 = Type_DoubleFloat;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;

/* end ConsDoubleFloat */
/* start DoDoubleFloatOp */

  /* Halfword operand from stack instruction - DoDoubleFloatOp */
  /* arg2 has the preloaded 8 bit operand. */

dodoublefloatop:
  if (_trace) printf("dodoublefloatop:\n");
#ifdef TRACING
#endif

DoDoubleFloatOpIM:
  if (_trace) printf("DoDoubleFloatOpIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindodoublefloatop;
#ifdef TRACING
#endif

DoDoubleFloatOpSP:
  if (_trace) printf("DoDoubleFloatOpSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdodoublefloatop;
#endif

DoDoubleFloatOpLP:
  if (_trace) printf("DoDoubleFloatOpLP:\n");
#ifdef TRACING
  goto headdodoublefloatop;
#endif

DoDoubleFloatOpFP:
  if (_trace) printf("DoDoubleFloatOpFP:\n");

headdodoublefloatop:
  if (_trace) printf("headdodoublefloatop:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindodoublefloatop:
  if (_trace) printf("begindodoublefloatop:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  /* X high */
  arg3 = *(s32 *)(iSP + -24);
  /* X low */
  arg4 = *(s32 *)(iSP + -16);
  /* Y high */
  arg5 = *(s32 *)(iSP + -8);
  /* Y low */
  arg6 = *(s32 *)iSP;
  /* Get high part up top */
  arg3 = arg3 << 32;
  arg4 = (u32)arg4;
  /* Get high part up top */
  arg5 = arg5 << 32;
  arg6 = (u32)arg6;
  /* ARG3 is now X */
  arg3 = arg3 | arg4;
  /* ARG5 is now Y */
  arg5 = arg5 | arg6;
  *(u64 *)&processor->fp0 = arg3;
  *(u64 *)&processor->fp1 = arg5;
  /* Immediate tag */
  t2 = arg1 >> 32;
  /* Immediate data */
  t1 = (u32)arg1;
  t3 = t2 - Type_Fixnum;
  /* Strip CDR code */
  t3 = t3 & 63;
  if (t3 != 0)
    goto doublefloatiop;
  LDT(1, f1, processor->fp0);
  LDT(2, f2, processor->fp1);
  /* NIL */
  t3 = zero + DoubleFloatOp_Add;
  t3 = t1 - t3;
  if (t3 != 0)
    goto g6342;
  /* Here if argument DoubleFloatOpAdd */
  ADDT(1, f1, 1, f1, 2, f2); /* addt */
  goto g6341;

g6342:
  if (_trace) printf("g6342:\n");
  t3 = zero + DoubleFloatOp_Sub;
  t3 = t1 - t3;
  if (t3 != 0)
    goto g6343;
  /* Here if argument DoubleFloatOpSub */
  SUBT(1, f1, 1, f1, 2, f2);
  goto g6341;

g6343:
  if (_trace) printf("g6343:\n");
  t3 = zero + DoubleFloatOp_Multiply;
  t3 = t1 - t3;
  if (t3 != 0)
    goto g6344;
  /* Here if argument DoubleFloatOpMultiply */
  MULT(1, f1, 1, f1, 2, f2);
  goto g6341;

g6344:
  if (_trace) printf("g6344:\n");
  t3 = zero + DoubleFloatOp_Divide;
  t3 = t1 - t3;
  if (t3 != 0)
    goto g6345;
  /* Here if argument DoubleFloatOpDivide */
  DIVT(1, f1, 1, f1, 2, f2);
  goto g6341;

g6345:
  if (_trace) printf("g6345:\n");

g6341:
  if (_trace) printf("g6341:\n");
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  /* There was no FP exception */
  t3 = *(u64 *)&(processor->niladdress);

doublefloatmerge:
  STT( (u64 *)&processor->fp0, 1, f1 );
  t1 = *(s32 *)&processor->fp0;
  t2 = *((s32 *)(&processor->fp0)+1);
  /* Pop all the operands */
  iSP = iSP - 32;
  t4 = Type_Fixnum;
  /* Push high result */
  *(u32 *)(iSP + 8) = t2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  t4 = Type_Fixnum;
  /* Push low result */
  *(u32 *)(iSP + 8) = t1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  iSP = iSP + 8;
  t4 = t3 << 26;
  t4 = t4 >> 26;
  /* Push the exception predicate */
  *(u64 *)iSP = t4;
  goto NEXTINSTRUCTION;

doublefloatexc:
  if (_trace) printf("doublefloatexc:\n");
  /* Indicate an FP exception occurred */
  t3 = *(u64 *)&(processor->taddress);
  goto doublefloatmerge;

doublefloatiop:
  if (_trace) printf("doublefloatiop:\n");
  arg5 = 0;
  arg2 = 85;
  goto illegaloperand;

/* end DoDoubleFloatOp */
  /* End of Halfword operand from stack instruction - DoDoubleFloatOp */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/idouble.as */
