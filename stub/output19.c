/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunbind.as
 ************************************************************************/

  /* Binding Instructions. */
/* start DoBindLocativeToValue */

  /* Halfword operand from stack instruction - DoBindLocativeToValue */

dobindlocativetovalue:
  if (_trace) printf("dobindlocativetovalue:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoBindLocativeToValueIM:
  if (_trace) printf("DoBindLocativeToValueIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment11186:
  if (_trace) printf("force-alignment11186:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindobindlocativetovalue;   
#ifdef TRACING
#endif

DoBindLocativeToValueSP:
  if (_trace) printf("DoBindLocativeToValueSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdobindlocativetovalue;   
#endif

DoBindLocativeToValueLP:
  if (_trace) printf("DoBindLocativeToValueLP:\n");
#ifdef TRACING
  goto headdobindlocativetovalue;   
#endif

DoBindLocativeToValueFP:
  if (_trace) printf("DoBindLocativeToValueFP:\n");

headdobindlocativetovalue:
  if (_trace) printf("headdobindlocativetovalue:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindobindlocativetovalue:
  if (_trace) printf("begindobindlocativetovalue:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg6 = *(s32 *)iSP;   		// ltag/ldata 
  arg5 = *(s32 *)(iSP + 4);   		// ltag/ldata 
  iSP = iSP - 8;   		// Pop Stack. 
  arg6 = (u32)arg6;   
  arg3 = *(u64 *)&(processor->bindingstackpointer);   
  arg2 = arg1 >> 32;   		// new tag 
  arg4 = *(u64 *)&(processor->bindingstacklimit);   
  arg1 = (u32)arg1;   		// new data 
  t1 = arg5 - Type_Locative;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto bindloctovaliop;
#ifdef MINIMA
  t2 = arg3 >> 32;   
#endif
  arg3 = (u32)arg3;   
  arg4 = (u32)arg4;   
  t1 = arg3 - arg4;   
  if ((s64)t1 >= 0)   		// J. if binding stack overflow 
    goto bindloctovalov;
  t3 = arg3 + 1;
#ifdef MINIMA
  /* BSP not a locative -> Deep-bound */
  t1 = t2 - Type_Locative;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto bindloctovaldeep;
#endif
  t9 = *(s32 *)&processor->control;   
  t8 = arg6;
  /* Memory Read Internal */

vma-memory-read11154:
  t4 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t6 = t8 + ivory;
  t5 = *(s32 *)&processor->scovlimit;   
  t1 = (t6 * 4);   
  t2 = LDQ_U(t6);   
  t4 = t8 - t4;   		// Stack cache offset 
  t7 = *(u64 *)&(processor->bindread_mask);   
  t5 = ((u64)t4 < (u64)t5) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;   
  t2 = (u8)(t2 >> ((t6&7)*8));   
  if (t5 != 0)   
    goto vma-memory-read11156;

vma-memory-read11155:
  t6 = zero + 224;   
  t7 = t7 >> (t2 & 63);   
  t6 = t6 >> (t2 & 63);   
  if (t7 & 1)   
    goto vma-memory-read11158;

vma-memory-read11163:
  t10 = t9 >> 19;   
  /* TagType. */
  t8 = arg5 & 63;
  t10 = t10 & 64;		// Extract the CR.cleanup-bindings bit 
  t11 = t10 | t8;
  t5 = *(u64 *)&(processor->stackcachebasevma);   
  t4 = t3 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t7 = (t4 * 4);   
  t6 = LDQ_U(t4);   
  t5 = t3 - t5;   		// Stack cache offset 
  t8 = ((u64)t5 < (u64)t8) ? 1 : 0;   		// In range? 
  t5 = (t11 & 0xff) << ((t4&7)*8);   
  t6 = t6 & ~(0xffL << (t4&7)*8);   

force-alignment11166:
  if (_trace) printf("force-alignment11166:\n");
  t6 = t6 | t5;
  STQ_U(t4, t6);   
  *(u32 *)t7 = arg6;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write11165;

vma-memory-write11164:
  t3 = arg3 + 2;
  t5 = *(u64 *)&(processor->stackcachebasevma);   
  t4 = t3 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t7 = (t4 * 4);   
  t6 = LDQ_U(t4);   
  t5 = t3 - t5;   		// Stack cache offset 
  t8 = ((u64)t5 < (u64)t8) ? 1 : 0;   		// In range? 
  t5 = (t2 & 0xff) << ((t4&7)*8);   
  t6 = t6 & ~(0xffL << (t4&7)*8);   

force-alignment11169:
  if (_trace) printf("force-alignment11169:\n");
  t6 = t6 | t5;
  STQ_U(t4, t6);   
  *(u32 *)t7 = t1;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write11168;

vma-memory-write11167:
  t1 = (512) << 16;   
  /* Memory Read Internal */

vma-memory-read11170:
  t6 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t8 = arg6 + ivory;
  t7 = *(s32 *)&processor->scovlimit;   
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = arg6 - t6;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->bindwrite_mask);   
  t7 = ((u64)t6 < (u64)t7) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read11172;

vma-memory-read11171:
  t8 = zero + 224;   
  t10 = t10 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t10 & 1)   
    goto vma-memory-read11174;

vma-memory-read11179:
  /* Merge cdr-code */
  t5 = arg2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t7 = *(u64 *)&(processor->stackcachebasevma);   
  t6 = arg6 + ivory;
  t10 = *(s32 *)&processor->scovlimit;   
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = arg6 - t7;   		// Stack cache offset 
  t10 = ((u64)t7 < (u64)t10) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment11182:
  if (_trace) printf("force-alignment11182:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = arg1;
  if (t10 != 0)   		// J. if in cache 
    goto vma-memory-write11181;

vma-memory-write11180:
  t9 = t1 | t9;		// Set cr.cleanup-bindings bit 
  *(u32 *)&processor->control = t9;
		/* vma only */
  *(u32 *)&processor->bindingstackpointer = t3;
  goto NEXTINSTRUCTION;   

bindloctovalov:
  if (_trace) printf("bindloctovalov:\n");
  arg5 = 0;
  arg2 = 19;
  goto illegaloperand;

bindloctovaliop:
  if (_trace) printf("bindloctovaliop:\n");
  arg5 = 0;
  arg2 = 18;
  goto illegaloperand;

bindloctovaldeep:
  if (_trace) printf("bindloctovaldeep:\n");
  t1 = *(u64 *)&(processor->restartsp);   		// Get the SP, ->op2 
  /* Convert stack cache address to VMA */
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = t1 - t3;   		// stack cache base relative offset 
  t3 = t3 >> 3;   		// convert byte address to word address 
  t2 = t3 + t2;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 72;
  goto illegaloperand;

vma-memory-write11181:
  if (_trace) printf("vma-memory-write11181:\n");
  t7 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment11183:
  if (_trace) printf("force-alignment11183:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = arg6 - t7;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = arg1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto vma-memory-write11180;   

vma-memory-read11172:
  if (_trace) printf("vma-memory-read11172:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read11171;   

vma-memory-read11174:
  if (_trace) printf("vma-memory-read11174:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read11173;
  arg6 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read11170;   

vma-memory-read11173:
  if (_trace) printf("vma-memory-read11173:\n");
  t10 = *(u64 *)&(processor->bindwrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg6;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read11176:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 3;
  goto performmemoryaction;

vma-memory-write11168:
  if (_trace) printf("vma-memory-write11168:\n");
  t5 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment11184:
  if (_trace) printf("force-alignment11184:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t5 = t3 - t5;   		// Stack cache offset 
  t4 = (t5 * 8) + t4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t4 = t1;
		/* write the stack cache */
  *(u32 *)(t4 + 4) = t2;
  goto vma-memory-write11167;   

vma-memory-write11165:
  if (_trace) printf("vma-memory-write11165:\n");
  t5 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment11185:
  if (_trace) printf("force-alignment11185:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t5 = t3 - t5;   		// Stack cache offset 
  t4 = (t5 * 8) + t4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t4 = arg6;
		/* write the stack cache */
  *(u32 *)(t4 + 4) = t11;
  goto vma-memory-write11164;   

vma-memory-read11156:
  if (_trace) printf("vma-memory-read11156:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t4 = (t4 * 8) + t5;  		// reconstruct SCA 
  t1 = *(s32 *)t4;   
  t2 = *(s32 *)(t4 + 4);   		// Read from stack cache 
  goto vma-memory-read11155;   

vma-memory-read11158:
  if (_trace) printf("vma-memory-read11158:\n");
  if ((t6 & 1) == 0)   
    goto vma-memory-read11157;
  t8 = (u32)t1;   		// Do the indirect thing 
  goto vma-memory-read11154;   

vma-memory-read11157:
  if (_trace) printf("vma-memory-read11157:\n");
  t7 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  t6 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t8;   		// stash the VMA for the (likely) trap 
  t6 = (t6 * 4) + t7;   		// Adjust for a longword load 
  t7 = *(s32 *)t6;   		// Get the memory action 

vma-memory-read11160:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 2;
  goto performmemoryaction;

/* end DoBindLocativeToValue */
  /* End of Halfword operand from stack instruction - DoBindLocativeToValue */
/* start DoBindLocative */

  /* Halfword operand from stack instruction - DoBindLocative */
  /* arg2 has the preloaded 8 bit operand. */

dobindlocative:
  if (_trace) printf("dobindlocative:\n");
#ifdef TRACING
#endif

DoBindLocativeSP:
  if (_trace) printf("DoBindLocativeSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindobindlocative;   
#endif

DoBindLocativeLP:
  if (_trace) printf("DoBindLocativeLP:\n");
#ifdef TRACING
  goto begindobindlocative;   
#endif

DoBindLocativeFP:
  if (_trace) printf("DoBindLocativeFP:\n");

begindobindlocative:
  if (_trace) printf("begindobindlocative:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 
  arg3 = *(u64 *)&(processor->bindingstackpointer);   
  arg5 = arg1 >> 32;   		// tag 
  arg4 = *(u64 *)&(processor->bindingstacklimit);   
  arg6 = (u32)arg1;   		// data 
  t1 = arg5 - Type_Locative;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto bindlociop;
#ifdef MINIMA
  t2 = arg3 >> 32;   
#endif
  arg3 = (u32)arg3;   
  arg4 = (u32)arg4;   
  t1 = arg3 - arg4;   
  if ((s64)t1 >= 0)   		// J. if binding stack overflow 
    goto bindlocov;
  t3 = arg3 + 1;
#ifdef MINIMA
  /* BSP not a locative -> Deep-bound */
  t1 = t2 - Type_Locative;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto bindlocdeep;
#endif
  t9 = *(s32 *)&processor->control;   
  t8 = arg6;
  /* Memory Read Internal */

vma-memory-read11187:
  t4 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t6 = t8 + ivory;
  t5 = *(s32 *)&processor->scovlimit;   
  t1 = (t6 * 4);   
  t2 = LDQ_U(t6);   
  t4 = t8 - t4;   		// Stack cache offset 
  t7 = *(u64 *)&(processor->bindread_mask);   
  t5 = ((u64)t4 < (u64)t5) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;   
  t2 = (u8)(t2 >> ((t6&7)*8));   
  if (t5 != 0)   
    goto vma-memory-read11189;

vma-memory-read11188:
  t6 = zero + 224;   
  t7 = t7 >> (t2 & 63);   
  t6 = t6 >> (t2 & 63);   
  if (t7 & 1)   
    goto vma-memory-read11191;

vma-memory-read11196:
  t10 = t9 >> 19;   
  /* TagType. */
  t8 = arg5 & 63;
  t10 = t10 & 64;		// Extract the CR.cleanup-bindings bit 
  t11 = t10 | t8;
  t5 = *(u64 *)&(processor->stackcachebasevma);   
  t4 = t3 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t7 = (t4 * 4);   
  t6 = LDQ_U(t4);   
  t5 = t3 - t5;   		// Stack cache offset 
  t8 = ((u64)t5 < (u64)t8) ? 1 : 0;   		// In range? 
  t5 = (t11 & 0xff) << ((t4&7)*8);   
  t6 = t6 & ~(0xffL << (t4&7)*8);   

force-alignment11199:
  if (_trace) printf("force-alignment11199:\n");
  t6 = t6 | t5;
  STQ_U(t4, t6);   
  *(u32 *)t7 = arg6;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write11198;

vma-memory-write11197:
  t3 = arg3 + 2;
  t5 = *(u64 *)&(processor->stackcachebasevma);   
  t4 = t3 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t7 = (t4 * 4);   
  t6 = LDQ_U(t4);   
  t5 = t3 - t5;   		// Stack cache offset 
  t8 = ((u64)t5 < (u64)t8) ? 1 : 0;   		// In range? 
  t5 = (t2 & 0xff) << ((t4&7)*8);   
  t6 = t6 & ~(0xffL << (t4&7)*8);   

force-alignment11202:
  if (_trace) printf("force-alignment11202:\n");
  t6 = t6 | t5;
  STQ_U(t4, t6);   
  *(u32 *)t7 = t1;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write11201;

vma-memory-write11200:
  t1 = (512) << 16;   
  t9 = t1 | t9;		// Set cr.cleanup-bindings bit 
  *(u32 *)&processor->control = t9;
		/* vma only */
  *(u32 *)&processor->bindingstackpointer = t3;
  goto NEXTINSTRUCTION;   

bindlocov:
  if (_trace) printf("bindlocov:\n");
  arg5 = 0;
  arg2 = 19;
  goto illegaloperand;

bindlociop:
  if (_trace) printf("bindlociop:\n");
  arg5 = 0;
  arg2 = 18;
  goto illegaloperand;

bindlocdeep:
  if (_trace) printf("bindlocdeep:\n");
  t1 = *(u64 *)&(processor->restartsp);   		// Get the SP, ->op2 
  /* Convert stack cache address to VMA */
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = t1 - t3;   		// stack cache base relative offset 
  t3 = t3 >> 3;   		// convert byte address to word address 
  t2 = t3 + t2;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 72;
  goto illegaloperand;

vma-memory-write11201:
  if (_trace) printf("vma-memory-write11201:\n");
  t5 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment11203:
  if (_trace) printf("force-alignment11203:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t5 = t3 - t5;   		// Stack cache offset 
  t4 = (t5 * 8) + t4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t4 = t1;
		/* write the stack cache */
  *(u32 *)(t4 + 4) = t2;
  goto vma-memory-write11200;   

vma-memory-write11198:
  if (_trace) printf("vma-memory-write11198:\n");
  t5 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment11204:
  if (_trace) printf("force-alignment11204:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t5 = t3 - t5;   		// Stack cache offset 
  t4 = (t5 * 8) + t4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t4 = arg6;
		/* write the stack cache */
  *(u32 *)(t4 + 4) = t11;
  goto vma-memory-write11197;   

vma-memory-read11189:
  if (_trace) printf("vma-memory-read11189:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t4 = (t4 * 8) + t5;  		// reconstruct SCA 
  t1 = *(s32 *)t4;   
  t2 = *(s32 *)(t4 + 4);   		// Read from stack cache 
  goto vma-memory-read11188;   

vma-memory-read11191:
  if (_trace) printf("vma-memory-read11191:\n");
  if ((t6 & 1) == 0)   
    goto vma-memory-read11190;
  t8 = (u32)t1;   		// Do the indirect thing 
  goto vma-memory-read11187;   

vma-memory-read11190:
  if (_trace) printf("vma-memory-read11190:\n");
  t7 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  t6 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t8;   		// stash the VMA for the (likely) trap 
  t6 = (t6 * 4) + t7;   		// Adjust for a longword load 
  t7 = *(s32 *)t6;   		// Get the memory action 

vma-memory-read11193:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 2;
  goto performmemoryaction;
#ifdef TRACING
#endif

DoBindLocativeIM:
  goto doistageerror;

/* end DoBindLocative */
  /* End of Halfword operand from stack instruction - DoBindLocative */
/* start DoUnbindN */

  /* Halfword operand from stack instruction - DoUnbindN */
  /* arg2 has the preloaded 8 bit operand. */

dounbindn:
  if (_trace) printf("dounbindn:\n");
#ifdef TRACING
#endif

DoUnbindNIM:
  if (_trace) printf("DoUnbindNIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindounbindn;   
#ifdef TRACING
#endif

DoUnbindNSP:
  if (_trace) printf("DoUnbindNSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdounbindn;   
#endif

DoUnbindNLP:
  if (_trace) printf("DoUnbindNLP:\n");
#ifdef TRACING
  goto headdounbindn;   
#endif

DoUnbindNFP:
  if (_trace) printf("DoUnbindNFP:\n");

headdounbindn:
  if (_trace) printf("headdounbindn:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindounbindn:
  if (_trace) printf("begindounbindn:\n");
  /* arg1 has the operand, not sign extended if immediate. */
#ifdef MINIMA
  arg3 = *(u64 *)&(processor->bindingstackpointer);   
#endif
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t1 = arg2 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto unbindniop;
#ifdef MINIMA
  /* BSP not a locative -> Deep-bound */
  t2 = arg3 >> 32;   
  t1 = t2 - Type_Locative;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto unbindndeep;
#endif
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto unbindnendloop;   

unbindntoploop:
  if (_trace) printf("unbindntoploop:\n");
  arg1 = arg1 - 1;   
  t1 = *(u64 *)&(processor->bindingstackpointer);   
  t4 = *(s32 *)&processor->control;   
  t1 = (u32)t1;   		// vma only 
  t2 = (512) << 16;   
  t5 = t1 - 1;   
  t3 = t4 & t2;
  t4 = t4 & ~t2;		// Turn off the bit 
  if (t3 != 0)   
    goto g11205;
  t4 = *(u64 *)&(processor->restartsp);   		// Get the SP, ->op2 
  arg5 = 0;
  arg2 = 20;
  goto illegaloperand;

g11205:
  if (_trace) printf("g11205:\n");
  /* Memory Read Internal */

vma-memory-read11206:
  arg4 = t1 + ivory;
  t6 = (arg4 * 4);   
  t7 = LDQ_U(arg4);   
  t8 = t1 - t11;   		// Stack cache offset 
  arg5 = *(u64 *)&(processor->bindread_mask);   
  arg3 = ((u64)t8 < (u64)t12) ? 1 : 0;   		// In range? 
  t6 = *(s32 *)t6;   
  t7 = (u8)(t7 >> ((arg4&7)*8));   
  if (arg3 != 0)   
    goto vma-memory-read11208;

vma-memory-read11207:
  arg4 = zero + 224;   
  arg5 = arg5 >> (t7 & 63);   
  arg4 = arg4 >> (t7 & 63);   
  if (arg5 & 1)   
    goto vma-memory-read11210;

vma-memory-read11215:
  /* Memory Read Internal */

vma-memory-read11216:
  arg4 = t5 + ivory;
  t2 = (arg4 * 4);   
  t3 = LDQ_U(arg4);   
  t8 = t5 - t11;   		// Stack cache offset 
  arg5 = *(u64 *)&(processor->bindread_mask);   
  arg3 = ((u64)t8 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t3 = (u8)(t3 >> ((arg4&7)*8));   
  if (arg3 != 0)   
    goto vma-memory-read11218;

vma-memory-read11217:
  arg4 = zero + 224;   
  arg5 = arg5 >> (t3 & 63);   
  arg4 = arg4 >> (t3 & 63);   
  t2 = (u32)t2;   
  if (arg5 & 1)   
    goto vma-memory-read11220;

vma-memory-read11225:
  /* Memory Read Internal */

vma-memory-read11226:
  arg6 = t2 + ivory;
  arg3 = (arg6 * 4);   
  t8 = LDQ_U(arg6);   
  arg4 = t2 - t11;   		// Stack cache offset 
  arg5 = ((u64)arg4 < (u64)t12) ? 1 : 0;   		// In range? 
  arg3 = *(s32 *)arg3;   
  t8 = (u8)(t8 >> ((arg6&7)*8));   
  if (arg5 != 0)   
    goto vma-memory-read11228;

vma-memory-read11227:
  arg4 = *(u64 *)&(processor->bindwrite_mask);   
  arg6 = zero + 224;   
  arg4 = arg4 >> (t8 & 63);   
  arg6 = arg6 >> (t8 & 63);   
  if (arg4 & 1)   
    goto vma-memory-read11230;

vma-memory-read11235:
  /* Merge cdr-code */
  arg3 = t7 & 63;
  t8 = t8 & 192;
  t8 = t8 | arg3;
  arg4 = t2 + ivory;
  arg3 = (arg4 * 4);   
  arg6 = LDQ_U(arg4);   
  arg5 = (t8 & 0xff) << ((arg4&7)*8);   
  arg6 = arg6 & ~(0xffL << (arg4&7)*8);   

force-alignment11238:
  if (_trace) printf("force-alignment11238:\n");
  arg6 = arg6 | arg5;
  STQ_U(arg4, arg6);   
  arg4 = *(s32 *)&processor->scovlimit;   
  arg5 = t2 - t11;   		// Stack cache offset 
  arg4 = ((u64)arg5 < (u64)arg4) ? 1 : 0;   		// In range? 
  *(u32 *)arg3 = t6;
  if (arg4 != 0)   		// J. if in cache 
    goto vma-memory-write11237;

vma-memory-write11236:
  t3 = t3 & 64;		// Get the old cleanup-bindings bit 
  t3 = t3 << 19;   
  t1 = t1 - 2;   
		/* vma only */
  *(u32 *)&processor->bindingstackpointer = t1;
  t4 = t4 | t3;
  *(u32 *)&processor->control = t4;

unbindnendloop:
  if (_trace) printf("unbindnendloop:\n");
  if ((s64)arg1 > 0)   
    goto unbindntoploop;
  t3 = *(s32 *)&processor->interruptreg;   
  t4 = t3 & 2;
  t4 = (t4 == 2) ? 1 : 0;   
  t3 = t3 | t4;
  *(u32 *)&processor->interruptreg = t3;
  if (t3 == 0) 
    goto NEXTINSTRUCTION;
  *(u64 *)&processor->stop_interpreter = t3;   
  goto NEXTINSTRUCTION;   

unbindniop:
  if (_trace) printf("unbindniop:\n");
  arg5 = 0;
  arg2 = 63;
  goto illegaloperand;
#ifdef MINIMA

unbindndeep:
  if (_trace) printf("unbindndeep:\n");
  t1 = *(u64 *)&(processor->restartsp);   		// Get the SP, ->op2 
  /* Convert stack cache address to VMA */
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = t1 - t3;   		// stack cache base relative offset 
  t3 = t3 >> 3;   		// convert byte address to word address 
  t2 = t3 + t2;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 72;
  goto illegaloperand;
#endif

vma-memory-write11237:
  if (_trace) printf("vma-memory-write11237:\n");
  arg4 = *(u64 *)&(processor->stackcachedata);   
  arg4 = (arg5 * 8) + arg4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)arg4 = t6;
		/* write the stack cache */
  *(u32 *)(arg4 + 4) = t8;
  goto vma-memory-write11236;   

vma-memory-read11228:
  if (_trace) printf("vma-memory-read11228:\n");
  arg5 = *(u64 *)&(processor->stackcachedata);   
  arg4 = (arg4 * 8) + arg5;  		// reconstruct SCA 
  arg3 = *(s32 *)arg4;   
  t8 = *(s32 *)(arg4 + 4);   		// Read from stack cache 
  goto vma-memory-read11227;   

vma-memory-read11230:
  if (_trace) printf("vma-memory-read11230:\n");
  if ((arg6 & 1) == 0)   
    goto vma-memory-read11229;
  t2 = (u32)arg3;   		// Do the indirect thing 
  goto vma-memory-read11226;   

vma-memory-read11229:
  if (_trace) printf("vma-memory-read11229:\n");
  arg4 = *(u64 *)&(processor->bindwrite);   		// Load the memory action table for cycle 
  /* TagType. */
  arg6 = t8 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t2;   		// stash the VMA for the (likely) trap 
  arg6 = (arg6 * 4) + arg4;   		// Adjust for a longword load 
  arg4 = *(s32 *)arg6;   		// Get the memory action 

vma-memory-read11232:
  /* Perform memory action */
  arg1 = arg4;
  arg2 = 3;
  goto performmemoryaction;

vma-memory-read11218:
  if (_trace) printf("vma-memory-read11218:\n");
  arg3 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + arg3;  		// reconstruct SCA 
  t2 = *(s32 *)t8;   
  t3 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read11217;   

vma-memory-read11220:
  if (_trace) printf("vma-memory-read11220:\n");
  if ((arg4 & 1) == 0)   
    goto vma-memory-read11219;
  t5 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read11216;   

vma-memory-read11219:
  if (_trace) printf("vma-memory-read11219:\n");
  arg5 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  arg4 = t3 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t5;   		// stash the VMA for the (likely) trap 
  arg4 = (arg4 * 4) + arg5;   		// Adjust for a longword load 
  arg5 = *(s32 *)arg4;   		// Get the memory action 

vma-memory-read11222:
  /* Perform memory action */
  arg1 = arg5;
  arg2 = 2;
  goto performmemoryaction;

vma-memory-read11208:
  if (_trace) printf("vma-memory-read11208:\n");
  arg3 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + arg3;  		// reconstruct SCA 
  t6 = *(s32 *)t8;   
  t7 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read11207;   

vma-memory-read11210:
  if (_trace) printf("vma-memory-read11210:\n");
  if ((arg4 & 1) == 0)   
    goto vma-memory-read11209;
  t1 = (u32)t6;   		// Do the indirect thing 
  goto vma-memory-read11206;   

vma-memory-read11209:
  if (_trace) printf("vma-memory-read11209:\n");
  arg5 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  arg4 = t7 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  arg4 = (arg4 * 4) + arg5;   		// Adjust for a longword load 
  arg5 = *(s32 *)arg4;   		// Get the memory action 

vma-memory-read11212:
  /* Perform memory action */
  arg1 = arg5;
  arg2 = 2;
  goto performmemoryaction;

/* end DoUnbindN */
  /* End of Halfword operand from stack instruction - DoUnbindN */
/* start DoRestoreBindingStack */

  /* Halfword operand from stack instruction - DoRestoreBindingStack */
  /* arg2 has the preloaded 8 bit operand. */

dorestorebindingstack:
  if (_trace) printf("dorestorebindingstack:\n");
#ifdef TRACING
#endif

DoRestoreBindingStackIM:
  if (_trace) printf("DoRestoreBindingStackIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindorestorebindingstack;   
#ifdef TRACING
#endif

DoRestoreBindingStackSP:
  if (_trace) printf("DoRestoreBindingStackSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdorestorebindingstack;   
#endif

DoRestoreBindingStackLP:
  if (_trace) printf("DoRestoreBindingStackLP:\n");
#ifdef TRACING
  goto headdorestorebindingstack;   
#endif

DoRestoreBindingStackFP:
  if (_trace) printf("DoRestoreBindingStackFP:\n");

headdorestorebindingstack:
  if (_trace) printf("headdorestorebindingstack:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindorestorebindingstack:
  if (_trace) printf("begindorestorebindingstack:\n");
  /* arg1 has the operand, not sign extended if immediate. */
#ifdef MINIMA
  arg3 = *(u64 *)&(processor->bindingstackpointer);   
#endif
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t1 = arg2 - Type_Locative;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto restorebsiop;
#ifdef MINIMA
  /* BSP not a locative -> Deep-bound */
  t2 = arg3 >> 32;   
  t1 = t2 - Type_Locative;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto restorebsdeep;
#endif
  t1 = *(u64 *)&(processor->bindingstackpointer);   
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto restorebsendloop;   

restorebstoploop:
  if (_trace) printf("restorebstoploop:\n");
  t1 = *(u64 *)&(processor->bindingstackpointer);   
  t4 = *(s32 *)&processor->control;   
  t1 = (u32)t1;   		// vma only 
  t2 = (512) << 16;   
  t5 = t1 - 1;   
  t3 = t4 & t2;
  t4 = t4 & ~t2;		// Turn off the bit 
  if (t3 != 0)   
    goto g11239;
  t4 = *(u64 *)&(processor->restartsp);   		// Get the SP, ->op2 
  arg5 = 0;
  arg2 = 20;
  goto illegaloperand;

g11239:
  if (_trace) printf("g11239:\n");
  /* Memory Read Internal */

vma-memory-read11240:
  arg4 = t1 + ivory;
  t6 = (arg4 * 4);   
  t7 = LDQ_U(arg4);   
  t8 = t1 - t11;   		// Stack cache offset 
  arg5 = *(u64 *)&(processor->bindread_mask);   
  arg3 = ((u64)t8 < (u64)t12) ? 1 : 0;   		// In range? 
  t6 = *(s32 *)t6;   
  t7 = (u8)(t7 >> ((arg4&7)*8));   
  if (arg3 != 0)   
    goto vma-memory-read11242;

vma-memory-read11241:
  arg4 = zero + 224;   
  arg5 = arg5 >> (t7 & 63);   
  arg4 = arg4 >> (t7 & 63);   
  if (arg5 & 1)   
    goto vma-memory-read11244;

vma-memory-read11249:
  /* Memory Read Internal */

vma-memory-read11250:
  arg4 = t5 + ivory;
  t2 = (arg4 * 4);   
  t3 = LDQ_U(arg4);   
  t8 = t5 - t11;   		// Stack cache offset 
  arg5 = *(u64 *)&(processor->bindread_mask);   
  arg3 = ((u64)t8 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t3 = (u8)(t3 >> ((arg4&7)*8));   
  if (arg3 != 0)   
    goto vma-memory-read11252;

vma-memory-read11251:
  arg4 = zero + 224;   
  arg5 = arg5 >> (t3 & 63);   
  arg4 = arg4 >> (t3 & 63);   
  t2 = (u32)t2;   
  if (arg5 & 1)   
    goto vma-memory-read11254;

vma-memory-read11259:
  /* Memory Read Internal */

vma-memory-read11260:
  arg6 = t2 + ivory;
  arg3 = (arg6 * 4);   
  t8 = LDQ_U(arg6);   
  arg4 = t2 - t11;   		// Stack cache offset 
  arg5 = ((u64)arg4 < (u64)t12) ? 1 : 0;   		// In range? 
  arg3 = *(s32 *)arg3;   
  t8 = (u8)(t8 >> ((arg6&7)*8));   
  if (arg5 != 0)   
    goto vma-memory-read11262;

vma-memory-read11261:
  arg4 = *(u64 *)&(processor->bindwrite_mask);   
  arg6 = zero + 224;   
  arg4 = arg4 >> (t8 & 63);   
  arg6 = arg6 >> (t8 & 63);   
  if (arg4 & 1)   
    goto vma-memory-read11264;

vma-memory-read11269:
  /* Merge cdr-code */
  arg3 = t7 & 63;
  t8 = t8 & 192;
  t8 = t8 | arg3;
  arg4 = t2 + ivory;
  arg3 = (arg4 * 4);   
  arg6 = LDQ_U(arg4);   
  arg5 = (t8 & 0xff) << ((arg4&7)*8);   
  arg6 = arg6 & ~(0xffL << (arg4&7)*8);   

force-alignment11272:
  if (_trace) printf("force-alignment11272:\n");
  arg6 = arg6 | arg5;
  STQ_U(arg4, arg6);   
  arg4 = *(s32 *)&processor->scovlimit;   
  arg5 = t2 - t11;   		// Stack cache offset 
  arg4 = ((u64)arg5 < (u64)arg4) ? 1 : 0;   		// In range? 
  *(u32 *)arg3 = t6;
  if (arg4 != 0)   		// J. if in cache 
    goto vma-memory-write11271;

vma-memory-write11270:
  t3 = t3 & 64;		// Get the old cleanup-bindings bit 
  t3 = t3 << 19;   
  t1 = t1 - 2;   
		/* vma only */
  *(u32 *)&processor->bindingstackpointer = t1;
  t4 = t4 | t3;
  *(u32 *)&processor->control = t4;

restorebsendloop:
  if (_trace) printf("restorebsendloop:\n");
  arg4 = (s32)t1 - (s32)arg1;   
  if ((s64)arg4 > 0)   
    goto restorebstoploop;
  t3 = *(s32 *)&processor->interruptreg;   
  t4 = t3 & 2;
  t4 = (t4 == 2) ? 1 : 0;   
  t3 = t3 | t4;
  *(u32 *)&processor->interruptreg = t3;
  if (t3 == 0) 
    goto NEXTINSTRUCTION;
  *(u64 *)&processor->stop_interpreter = t3;   
  goto NEXTINSTRUCTION;   

restorebsiop:
  if (_trace) printf("restorebsiop:\n");
  arg5 = 0;
  arg2 = 66;
  goto illegaloperand;
#ifdef MINIMA

restorebsdeep:
  if (_trace) printf("restorebsdeep:\n");
  t1 = *(u64 *)&(processor->restartsp);   		// Get the SP, ->op2 
  /* Convert stack cache address to VMA */
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = t1 - t3;   		// stack cache base relative offset 
  t3 = t3 >> 3;   		// convert byte address to word address 
  t2 = t3 + t2;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 66;
  goto illegaloperand;
#endif

vma-memory-write11271:
  if (_trace) printf("vma-memory-write11271:\n");
  arg4 = *(u64 *)&(processor->stackcachedata);   
  arg4 = (arg5 * 8) + arg4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)arg4 = t6;
		/* write the stack cache */
  *(u32 *)(arg4 + 4) = t8;
  goto vma-memory-write11270;   

vma-memory-read11262:
  if (_trace) printf("vma-memory-read11262:\n");
  arg5 = *(u64 *)&(processor->stackcachedata);   
  arg4 = (arg4 * 8) + arg5;  		// reconstruct SCA 
  arg3 = *(s32 *)arg4;   
  t8 = *(s32 *)(arg4 + 4);   		// Read from stack cache 
  goto vma-memory-read11261;   

vma-memory-read11264:
  if (_trace) printf("vma-memory-read11264:\n");
  if ((arg6 & 1) == 0)   
    goto vma-memory-read11263;
  t2 = (u32)arg3;   		// Do the indirect thing 
  goto vma-memory-read11260;   

vma-memory-read11263:
  if (_trace) printf("vma-memory-read11263:\n");
  arg4 = *(u64 *)&(processor->bindwrite);   		// Load the memory action table for cycle 
  /* TagType. */
  arg6 = t8 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t2;   		// stash the VMA for the (likely) trap 
  arg6 = (arg6 * 4) + arg4;   		// Adjust for a longword load 
  arg4 = *(s32 *)arg6;   		// Get the memory action 

vma-memory-read11266:
  /* Perform memory action */
  arg1 = arg4;
  arg2 = 3;
  goto performmemoryaction;

vma-memory-read11252:
  if (_trace) printf("vma-memory-read11252:\n");
  arg3 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + arg3;  		// reconstruct SCA 
  t2 = *(s32 *)t8;   
  t3 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read11251;   

vma-memory-read11254:
  if (_trace) printf("vma-memory-read11254:\n");
  if ((arg4 & 1) == 0)   
    goto vma-memory-read11253;
  t5 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read11250;   

vma-memory-read11253:
  if (_trace) printf("vma-memory-read11253:\n");
  arg5 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  arg4 = t3 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t5;   		// stash the VMA for the (likely) trap 
  arg4 = (arg4 * 4) + arg5;   		// Adjust for a longword load 
  arg5 = *(s32 *)arg4;   		// Get the memory action 

vma-memory-read11256:
  /* Perform memory action */
  arg1 = arg5;
  arg2 = 2;
  goto performmemoryaction;

vma-memory-read11242:
  if (_trace) printf("vma-memory-read11242:\n");
  arg3 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + arg3;  		// reconstruct SCA 
  t6 = *(s32 *)t8;   
  t7 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read11241;   

vma-memory-read11244:
  if (_trace) printf("vma-memory-read11244:\n");
  if ((arg4 & 1) == 0)   
    goto vma-memory-read11243;
  t1 = (u32)t6;   		// Do the indirect thing 
  goto vma-memory-read11240;   

vma-memory-read11243:
  if (_trace) printf("vma-memory-read11243:\n");
  arg5 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  arg4 = t7 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  arg4 = (arg4 * 4) + arg5;   		// Adjust for a longword load 
  arg5 = *(s32 *)arg4;   		// Get the memory action 

vma-memory-read11246:
  /* Perform memory action */
  arg1 = arg5;
  arg2 = 2;
  goto performmemoryaction;

/* end DoRestoreBindingStack */
  /* End of Halfword operand from stack instruction - DoRestoreBindingStack */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunbind.as */
