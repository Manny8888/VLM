/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/idispat.as
 ************************************************************************/

  /* This file implements the main instruction dispatch loop. */
/* start DummyDoNothingSubroutine */


dummydonothingsubroutine:
  if (_trace) printf("dummydonothingsubroutine:\n");
  goto continuecurrentinstruction;   

/* end DummyDoNothingSubroutine */
/* start MemoryReadData */


memoryreaddata:
  if (_trace) printf("memoryreaddata:\n");
  /* Memory Read Internal */

vma-memory-read8793:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read8795;

vma-memory-read8794:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read8797;

vma-memory-read8803:
  goto *r0; /* ret */

memoryreaddatadecode:
  if (_trace) printf("memoryreaddatadecode:\n");
  if (t6 == 0) 
    goto vma-memory-read8796;

vma-memory-read8795:
  if (_trace) printf("vma-memory-read8795:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  arg6 = *(s32 *)t5;   
  arg5 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read8794;   

vma-memory-read8797:
  if (_trace) printf("vma-memory-read8797:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read8796;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read8793;   

vma-memory-read8796:
  if (_trace) printf("vma-memory-read8796:\n");
  t8 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg2;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read8800:
  if (_trace) printf("vma-memory-read8800:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0) 
    goto vma-memory-read8799;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto vma-memory-read8803;   

vma-memory-read8799:

vma-memory-read8798:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

/* end MemoryReadData */
/* start MemoryReadGeneral */


memoryreadgeneral:
  if (_trace) printf("memoryreadgeneral:\n");
  /* Memory Read Internal */

vma-memory-read8804:
  t7 = arg2 + ivory;
  t8 = (arg3 * 4);   		// Cycle-number -> table offset 
  arg5 = LDQ_U(t7);   
  t8 = (t8 * 4) + ivory;   
  arg6 = (t7 * 4);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)(t8 + PROCESSORSTATE_DATAREAD_MASK);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read8806;

vma-memory-read8805:
  t8 = t8 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read8808;

vma-memory-read8814:
  goto *r0; /* ret */

memoryreadgeneraldecode:
  if (_trace) printf("memoryreadgeneraldecode:\n");
  if (t6 == 0) 
    goto vma-memory-read8807;

vma-memory-read8806:
  if (_trace) printf("vma-memory-read8806:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  arg6 = *(s32 *)t5;   
  arg5 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read8805;   

vma-memory-read8808:
  if (_trace) printf("vma-memory-read8808:\n");

vma-memory-read8807:
  if (_trace) printf("vma-memory-read8807:\n");
  t8 = (arg3 * 4);   		// Cycle-number -> table offset 
  t8 = (t8 * 4) + ivory;   
  t8 = *(u64 *)(t8 + PROCESSORSTATE_DATAREAD);   
  /* TagType. */
  t7 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg2;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read8812:
  if (_trace) printf("vma-memory-read8812:\n");
  t6 = t8 & MemoryActionIndirect;
  if (t6 == 0) 
    goto vma-memory-read8811;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read8804;   

vma-memory-read8811:
  if (_trace) printf("vma-memory-read8811:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0) 
    goto vma-memory-read8810;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto vma-memory-read8814;   

vma-memory-read8810:

vma-memory-read8809:
  /* Perform memory action */
  arg1 = t8;
  arg2 = arg3;
  goto performmemoryaction;

/* end MemoryReadGeneral */
/* start MemoryReadHeader */


memoryreadheader:
  if (_trace) printf("memoryreadheader:\n");
  /* Memory Read Internal */

vma-memory-read8815:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read8817;

vma-memory-read8816:
  t7 = zero + 64;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read8819;

vma-memory-read8823:
  goto *r0; /* ret */

memoryreadheaderdecode:
  if (_trace) printf("memoryreadheaderdecode:\n");
  if (t6 == 0) 
    goto vma-memory-read8818;

vma-memory-read8817:
  if (_trace) printf("vma-memory-read8817:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  arg6 = *(s32 *)t5;   
  arg5 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read8816;   

vma-memory-read8819:
  if (_trace) printf("vma-memory-read8819:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read8818;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read8815;   

vma-memory-read8818:
  if (_trace) printf("vma-memory-read8818:\n");
  t8 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg2;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read8820:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end MemoryReadHeader */
/* start MemoryReadCdr */


memoryreadcdr:
  if (_trace) printf("memoryreadcdr:\n");
  /* Memory Read Internal */

vma-memory-read8824:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->cdr_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read8826;

vma-memory-read8825:
  t7 = zero + 192;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read8828;

vma-memory-read8832:
  goto *r0; /* ret */

memoryreadcdrdecode:
  if (_trace) printf("memoryreadcdrdecode:\n");
  if (t6 == 0) 
    goto vma-memory-read8827;

vma-memory-read8826:
  if (_trace) printf("vma-memory-read8826:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  arg6 = *(s32 *)t5;   
  arg5 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read8825;   

vma-memory-read8828:
  if (_trace) printf("vma-memory-read8828:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read8827;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read8824;   

vma-memory-read8827:
  if (_trace) printf("vma-memory-read8827:\n");
  t8 = *(u64 *)&(processor->cdr);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg2;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read8829:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 9;
  goto performmemoryaction;

/* end MemoryReadCdr */
/* start DoICacheFill */


doicachefill:
  if (_trace) printf("doicachefill:\n");

ICACHEMISS:
  if (_trace) printf("ICACHEMISS:\n");
  /* Here when instruction cache miss detected.  Fill the cache from */
  /* PC and then resume interpreter loop */
  /* First round the PC down to an even halfword address */
  arg2 = *(u64 *)&(processor->icachebase);   		// get the base of the icache 
  epc = iPC & ~1L;		// the even PC 
  ecp = epc >> (CacheLine_RShift & 63);   
  arg1 = zero + -1;   
  arg1 = arg1 + ((4) << 16);   
  ecp = ecp << (CacheLine_LShift & 63);   
  instn = iPC >> 1;   		// instn is instruction address here 
  ecp = epc + ecp;
  ecp = ecp & arg1;
  arg3 = ecp << 5;   		// temp=cpos*32 
  ecp = ecp << 4;   		// cpos=cpos*16 
  arg4 = arg2 + arg3;		// temp2=base+cpos*32 
  ecp = arg4 + ecp;		// cpos=base+cpos*48 
  opc = epc | 1;		// the odd PC 
  iCP = ecp;		// Assume iPC is the even PC 
  arg1 = (iPC == opc) ? 1 : 0;   		// See if iPC is the odd PC 
  ocp = ecp + CACHELINE_SIZE;
  if (arg1)   		// Stash the odd cache pointer if iPC is the odd PC 
    iCP = ocp;
  hwdispatch = *(u64 *)&(processor->halfworddispatch);   
  hwopmask = zero + 1023;   
  fwdispatch = *(u64 *)&(processor->fullworddispatch);   
  count = zero + 20;   
  t11 = instn + ivory;
  iword = (t11 * 4);   
  arg4 = LDQ_U(t11);   
  iword = *(s32 *)iword;   
  arg4 = (u8)(arg4 >> ((t11&7)*8));   
  goto fillicacheprefetched;   

pcbackone:
  if (_trace) printf("pcbackone:\n");
  /* Wire in continuation for even half */
  *(u64 *)&((CACHELINEP)ocp)->nextpcdata = epc;   
  t10 = ecp - CACHELINE_SIZE;   		// Backup in cache too 
  *(u64 *)&((CACHELINEP)ocp)->nextcp = ecp;   
  arg1 = epc - 1;   		// Backup PC one halfword 
  *(u64 *)&((CACHELINEP)ecp)->nextcp = t10;   
  /* TagType. */
  arg4 = arg4 & 63;		// arg4=tag-cdr code 
  *(u64 *)&((CACHELINEP)ecp)->nextpcdata = arg1;   
  /* Wire in continuation for odd half */
  goto maybeunpack;   

pcadvone:
  if (_trace) printf("pcadvone:\n");
  *(u64 *)&((CACHELINEP)ecp)->nextpcdata = opc;   		// Simple advance of PC one halfword. 
  arg1 = opc + 1;
  *(u64 *)&((CACHELINEP)ecp)->nextcp = ocp;   
  t10 = ocp + CACHELINE_SIZE;
  *(u64 *)&((CACHELINEP)ocp)->nextpcdata = arg1;   
  /* TagType. */
  arg4 = arg4 & 63;		// arg4=tag-cdr code 
  *(u64 *)&((CACHELINEP)ocp)->nextcp = t10;   
  goto maybeunpack;   
  /* This is the cache fill loop. */

fillicache:
  if (_trace) printf("fillicache:\n");
  t11 = instn + ivory;
  iword = (t11 * 4);   
  arg4 = LDQ_U(t11);   
  iword = *(s32 *)iword;   
  arg4 = (u8)(arg4 >> ((t11&7)*8));   

fillicacheprefetched:
  if (_trace) printf("fillicacheprefetched:\n");
#ifdef CACHEMETERING
  /* Increment the fill count for both cache entries */
  t10 = *(s32 *)&((CACHELINEP)ecp)->annotation;   
  t11 = *(s32 *)&((CACHELINEP)ocp)->annotation;   
  t10 = (u32)t10;   
  t11 = (u32)t11;   
  t10 = t10 + 1;
  *(u32 *)&((CACHELINEP)ecp)->annotation = t10;
  t11 = t11 + 1;
  *(u32 *)&((CACHELINEP)ocp)->annotation = t11;
#endif
  *(u64 *)&((CACHELINEP)ecp)->pcdata = epc;   		// Set address of even cache posn. 
  arg1 = arg4 & 192;		// CDR code << 6 
  /* TagType. */
  arg4 = arg4 & 63;		// Strip cdr 
  *(u64 *)&((CACHELINEP)ocp)->pcdata = opc;   		// Set address of odd cache posn. 
  iword = (u32)iword;   		// Strip nasty bits out. 

force-alignment8833:
  if (_trace) printf("force-alignment8833:\n");
  arg2 = arg4 << 32;   		// ready to remerge 
  if (arg1 == 0) 		// Zerotag means advance one HW 
    goto pcadvone;
  arg1 = arg1 - 128;   		// 2<<6 
  if (arg1 == 0) 		// Tag=2 means backup one HW 
    goto pcbackone;
  if ((s64)arg1 < 0)   		// Tag=1 means end of compiled function 
    goto pcendcf;

pcadvtwo:
  if (_trace) printf("pcadvtwo:\n");
  /* Tag=3 means advance over one full word */
  /* Wire in continuation for even half */
  arg1 = epc + 2;		// Next word 
  r31 = r31 | r31;
  t10 = ecp + TWOCACHELINESIZE;		// corresponding CP entry 
  *(u64 *)&((CACHELINEP)ecp)->nextpcdata = arg1;   		// Next PC even of next word 
  arg1 = epc + 4;		// Skip one fullword 
  *(u64 *)&((CACHELINEP)ecp)->nextcp = t10;   		// Next CP 
  /* Wire in continuation for odd half */
  t10 = ecp + FOURCACHELINESIZE;		// corresponding CP entry 
  *(u64 *)&((CACHELINEP)ocp)->nextpcdata = arg1;   
  /* TagType. */
  arg4 = arg4 & 63;		// arg4=tag-cdr code 
  *(u64 *)&((CACHELINEP)ocp)->nextcp = t10;   
  goto maybeunpack;   

decodepackedword:
  if (_trace) printf("decodepackedword:\n");
  /* Here to decode a packed word */
#ifdef CACHEMETERING
  arg1 = *(s32 *)&processor->metervalue;   
  arg4 = *(s32 *)&processor->metercount;   		// The number of remaining tokens. 
  t10 = *(u64 *)&(processor->meterdatabuff);   		// The cache miss meter buffer. 
  arg1 = arg1 + 1;		// count the miss. 
  t11 = *(s32 *)&processor->meterpos;   		// Position for new data. 
  *(u32 *)&processor->metervalue = arg1;
  if (arg4 != 0)   
    goto maybe-meter-miss8834;
  arg2 = *(s32 *)&processor->metermask;   
  t10 = (t11 * 4) + t10;   		// position of the current data item 
  t11 = t11 + 1;
  t11 = t11 & arg2;
  arg2 = *(s32 *)&processor->metermax;   
  t12 = arg1 - arg2;   
  if ((s64)t12 > 0)   
    arg2 = arg1;
  *(u32 *)&processor->metermax = arg2;
		/* store the datapoint */
  *(u32 *)t10 = arg1;
		/* Position for new data. */
  *(u32 *)&processor->meterpos = t11;
  *(u32 *)&processor->metervalue = zero;
  arg4 = *(s32 *)&processor->meterfreq;   

maybe-meter-miss8834:
  if (_trace) printf("maybe-meter-miss8834:\n");
  *(u32 *)&processor->metercount = arg4;
#endif
  arg4 = iword >> 18;   		// arg4 contains the odd packedword 
  t10 = iword >> 8;   		// even opcode+2bits 
  *(u64 *)&((CACHELINEP)ocp)->instruction = arg4;   		// Save the odd instruction 
  t11 = iword << 54;   		// First phase of even operand sign extension. 
  t12 = iword & hwopmask;		// even operand+2bits 
#ifndef CACHEMETERING
  *(u64 *)&((CACHELINEP)ocp)->annotation = zero;   
#endif
  t10 = t10 & hwopmask;		// even opcode 
  t11 = (s64)t11 >> 38;   		// Second phase of even operand sign extension. 
  arg2 = t10 - 92;   
  t10 = (t10 * 8) + hwdispatch;  
  t12 = t11 | t12;		// Merge signed/unsigned even operand 
  arg2 = arg2 & ~3L;
  *(u32 *)&((CACHELINEP)ecp)->operand = t12;
  if (arg2 == 0)   		// clear count if finish-call seen 
    count = arg2;
  arg2 = arg4 >> 8;   		// odd opcode+2bits 
  t11 = arg4 << 54;   		// First phase of odd operand sign extension. 
  arg1 = arg4 & hwopmask;		// odd operand+2bits 
  t10 = *(u64 *)t10;   
  arg2 = arg2 & hwopmask;		// odd opcode 
  t11 = (s64)t11 >> 38;   		// Second phase of odd operand sign extension. 
  *(u64 *)&((CACHELINEP)ecp)->code = t10;   
  t12 = arg2 - 92;   
  arg2 = (arg2 * 8) + hwdispatch;  
  arg1 = t11 | arg1;		// Merge signed/unsigned odd operand 
  *(u32 *)&((CACHELINEP)ocp)->operand = arg1;
  t12 = t12 & ~3L;
  arg2 = *(u64 *)arg2;   
  if (t12 == 0)   		// clear count if finish-call seen 
    count = t12;
  *(u64 *)&((CACHELINEP)ocp)->code = arg2;   
  goto enddecode;   

maybeunpack:
  if (_trace) printf("maybeunpack:\n");
  iword = arg2 | iword;		// reassemble tag and word. 
  *(u64 *)&((CACHELINEP)ecp)->instruction = iword;   		// save the even instruction 
  t10 = arg4 - 48;   		// t10>=0 if packed 
#ifndef CACHEMETERING
  *(u64 *)&((CACHELINEP)ecp)->annotation = zero;   
#endif
#ifdef CACHEMETERING
  epc = *(s32 *)&processor->metervalue;   
  t12 = *(s32 *)&processor->metercount;   		// The number of remaining tokens. 
  t11 = *(u64 *)&(processor->meterdatabuff);   		// The cache miss meter buffer. 
  epc = epc + 1;		// count the miss. 
  arg1 = *(s32 *)&processor->meterpos;   		// Position for new data. 
  *(u32 *)&processor->metervalue = epc;
  if (t12 != 0)   
    goto maybe-meter-miss8835;
  arg2 = *(s32 *)&processor->metermask;   
  t11 = (arg1 * 4) + t11;   		// position of the current data item 
  arg1 = arg1 + 1;
  arg1 = arg1 & arg2;
  arg2 = *(s32 *)&processor->metermax;   
  t10 = epc - arg2;   
  if ((s64)t10 > 0)   
    arg2 = epc;
  *(u32 *)&processor->metermax = arg2;
		/* store the datapoint */
  *(u32 *)t11 = epc;
		/* Position for new data. */
  *(u32 *)&processor->meterpos = arg1;
  *(u32 *)&processor->metervalue = zero;
  t12 = *(s32 *)&processor->meterfreq;   

maybe-meter-miss8835:
  if (_trace) printf("maybe-meter-miss8835:\n");
  *(u32 *)&processor->metercount = t12;
#endif
  if ((s64)t10 >= 0)   		// B. if a packed instruction 
    goto decodepackedword;
  t11 = (arg4 * 8) + fwdispatch;  		// t11 is the fwdispatch index 
  t12 = *(u64 *)&(processor->i_stage_error_hook);   
  arg1 = arg4 - 33;   
  t11 = *(u64 *)t11;   		// Extract the opcode handler 
  *(u64 *)&((CACHELINEP)ocp)->code = t12;   		// Store I-STATE-ERROR at odd pc 
  if (arg1 == 0)   		// clear count if native instn seen 
    count = arg1;
  *(u64 *)&((CACHELINEP)ecp)->code = t11;   

enddecode:
  if (_trace) printf("enddecode:\n");
  /* Here we decide if to stop filling the cache and return to the */
  /* instruction interpretation stream, or whether to fill further */
  instn = instn + 1;
  if ((s64)count <= 0)  		// If count is zero, resume 
    goto cachevalid;
  epc = instn << 1;   
  count = count - 1;   		// decrement count 
  opc = epc | 1;
  t10 = *(u64 *)&(processor->endicache);   		// pointer to the end of icache 
  ocp = ocp + TWOCACHELINESIZE;
  ecp = ecp + TWOCACHELINESIZE;
  t10 = ocp - t10;   
  if ((s64)t10 <= 0)  		// Still room for more 
    goto fillicache;
  goto cachevalid;   

pcendcf:
  if (_trace) printf("pcendcf:\n");
  t11 = *(u64 *)&(processor->i_stage_error_hook);   
  count = r31 | r31;		// We reached the end of the fcn. 
  *(u64 *)&((CACHELINEP)ecp)->code = t11;   		// Store I-STATE-ERROR dispatch at even and odd pc 
  *(u64 *)&((CACHELINEP)ocp)->code = t11;   
  goto enddecode;   

/* end DoICacheFill */
  /* These are the instruction reentry points.  Instructions end by returning */
  /* control to one of these tags.  Most normal instructions reenter by jumping */
  /* to NEXTINSTRUCTION, which advances the PC and continues normally.   */
  /* Instructions that change the PC usually go directly to INTERPRETINSTRUCTION. */
  /* Instructions that fail/trap/exception etc, go to one of the other places. */
/* start iInterpret */


iinterpret:
  if (_trace) printf("iinterpret:\n");
  *(u64 *)&processor->asrr9 = r9;   
  *(u64 *)&processor->asrr10 = r10;   
  *(u64 *)&processor->asrr11 = r11;   
  *(u64 *)&processor->asrr12 = r12;   
  *(u64 *)&processor->asrr13 = r13;   
  *(u64 *)&processor->asrr15 = r15;   
  *(u64 *)&processor->asrr26 = r26;   
  *(u64 *)&processor->asrr27 = r27;   
  *(u64 *)&processor->asrr29 = r29;   
  *(u64 *)&processor->asrr30 = r30;   
  *(u64 *)&processor->asrr14 = r14;   
  ivory = arg1;		// Setup our processor object handle 
  /* Upon entry, load cached state. */
  iCP = *(u64 *)&(processor->cp);   
  iPC = *(u64 *)&(processor->epc);   
  iSP = *(u64 *)&(processor->sp);   
  iFP = *(u64 *)&(processor->fp);   
  iLP = *(u64 *)&(processor->lp);   
  if (iCP != 0)   		// First time in iCP will be zero. 
    goto INTERPRETINSTRUCTION;
  goto ICACHEMISS;   		// If this is the first time in cache is empty! 

interpretinstructionpredicted:
  if (_trace) printf("interpretinstructionpredicted:\n");
  t2 = *(u64 *)&(((CACHELINEP)arg2)->pcdata);   		// Get the PC to check cache hit. 
  arg1 = iFP;   		// Assume FP mode 
  r0 = *(u64 *)&(processor->stop_interpreter);   		// Have we been asked to stop? 
  arg4 = iSP + -8;   		// SP-pop mode constant 
  arg3 = *(u64 *)&(((CACHELINEP)arg2)->instruction);   		// Grab the instruction/operand while stalled 
  t1 = iPC - t2;   
  if (t1 != 0)   
    goto interpretinstructionforbranch;
  iCP = arg2;
  if (r0 != 0)   		// Stop the world! someone wants out. 
    goto traporsuspendmachine;
  goto continuecurrentinstruction;   

interpretinstructionforjump:
  if (_trace) printf("interpretinstructionforjump:\n");

interpretinstructionforbranch:
  if (_trace) printf("interpretinstructionforbranch:\n");
  t5 = *(u64 *)&(processor->icachebase);   		// get the base of the icache 
  t4 = zero + -1;   
  t4 = t4 + ((4) << 16);   
  arg2 = iPC >> 10;   
  t3 = zero + -64;   
  arg2 = arg2 & t3;
  arg2 = iPC + arg2;
  arg2 = arg2 & t4;
  t4 = arg2 << 5;   		// temp=cpos*32 
  arg2 = arg2 << 4;   		// cpos=cpos*16 
  t5 = t5 + t4;		// temp2=base+cpos*32 

force-alignment8836:
  if (_trace) printf("force-alignment8836:\n");
  arg2 = t5 + arg2;		// cpos=base+cpos*48 
#ifndef CACHEMETERING
  *(u64 *)&((CACHELINEP)iCP)->annotation = arg2;   
#endif
  iCP = arg2;

INTERPRETINSTRUCTION:
  if (_trace) printf("INTERPRETINSTRUCTION:\n");
  r30 = *(u64 *)&(processor->asrr30);   
  r0 = *(u64 *)&(processor->stop_interpreter);   		// Have we been asked to stop? 
  arg1 = iFP;   		// Assume FP mode 
  arg3 = *(u64 *)&(((CACHELINEP)iCP)->instruction);   		// Grab the instruction/operand while stalled 
  arg4 = iSP + -8;   		// SP-pop mode constant 
  t2 = *(u64 *)&(((CACHELINEP)iCP)->pcdata);   		// Get the PC to check cache hit. 
  if (r0 != 0)   		// Stop the world! someone wants out. 
    goto traporsuspendmachine;
  goto continuecurrentinstruction;   

/* end iInterpret */



/* End of file automatically generated from ../alpha-emulator/idispat.as */
