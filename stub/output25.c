/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunjosh.as
 ************************************************************************/

/* 'AI' instructions. */
/* start DoDereference */

/* Halfword operand from stack instruction - DoDereference */

dodereference : if (_trace) printf("dodereference:\n");
/* arg2 has the preloaded 8 bit operand. */

DoDereferenceIM : if (_trace) printf("DoDereferenceIM:\n");
/* This sequence only sucks a moderate amount */
arg2 = arg2 << 56; // sign extend the byte argument.

force_alignment46496 : if (_trace) printf("force_alignment46496:\n");
arg2 = (int64_t) arg2 >> 56; // Rest of sign extension
*(uint32_t *)&processor->immediate_arg = arg2;
arg1 = *(uint64_t *)&(processor->immediate_arg);
goto begindodereference;

DoDereferenceSP : if (_trace) printf("DoDereferenceSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoDereferenceLP : if (_trace) printf("DoDereferenceLP:\n");

DoDereferenceFP : if (_trace) printf("DoDereferenceFP:\n");

headdodereference : if (_trace) printf("headdodereference:\n");
arg1 = (arg2 * 8) + arg1; // Compute operand address
arg1 = *(uint64_t *)arg1; // Get the operand

begindodereference : if (_trace) printf("begindodereference:\n");
/* arg1 has the operand, sign extended if immediate. */
arg2 = arg1 >> 32;
arg1 = (uint32_t) arg1;
t1 = arg2 & 63; // Strip off any CDR code bits.
t2 = (t1 == Type_OneQForward) ? 1 : 0;

force_alignment46491 : if (_trace) printf("force_alignment46491:\n");
if (t2 != 0)
    goto basic_dispatch46487;
t2 = (t1 == Type_ElementForward) ? 1 : 0;

force_alignment46492 : if (_trace) printf("force_alignment46492:\n");
if (t2 != 0)
    goto basic_dispatch46487;
t2 = (t1 == Type_HeaderForward) ? 1 : 0;

force_alignment46493 : if (_trace) printf("force_alignment46493:\n");
if (t2 != 0)
    goto basic_dispatch46487;
t2 = (t1 == Type_ExternalValueCellPointer) ? 1 : 0;

force_alignment46494 : if (_trace) printf("force_alignment46494:\n");
if (t2 == 0)
    goto basic_dispatch46474;

basic_dispatch46487 : if (_trace) printf("basic_dispatch46487:\n");
/* Here if argument (TypeOneQForward TypeElementForward TypeHeaderForward
                TypeExternalValueCellPointer) */
/* Memory Read Internal */

vma_memory_read46475 : t5 = *(uint64_t *)&(processor->stackcachebasevma); // Base of stack cache
t7 = arg1 + ivory;
t6 = *(int32_t *)&processor->scovlimit;
t3 = (t7 * 4);
t4 = LDQ_U(t7);
t5 = arg1 - t5; // Stack cache offset
t8 = *(uint64_t *)&(processor->dataread_mask);
t6 = ((uint64_t) t5 < (uint64_t) t6) ? 1 : 0; // In range?
t3 = *(int32_t *)t3;
t4 = (uint8_t) (t4 >> ((t7 & 7) * 8));
if (t6 != 0)
    goto vma_memory_read46477;

vma_memory_read46476 : t7 = zero + 240;
t8 = t8 >> (t4 & 63);
t7 = t7 >> (t4 & 63);
if (t8 & 1)
    goto vma_memory_read46479;

vma_memory_read46486 : t5 = t4 & 63; // set CDR-NEXT
*(uint32_t *)(iSP + 8) = t3;
*(uint32_t *)(iSP + 12) = t5; // write the stack cache
iSP = iSP + 8;
goto NEXTINSTRUCTION;

basic_dispatch46474 : if (_trace) printf("basic_dispatch46474:\n");
t2 = (t1 == Type_LogicVariable) ? 1 : 0;

force_alignment46495 : if (_trace) printf("force_alignment46495:\n");
if (t2 == 0)
    goto basic_dispatch46488;
/* Here if argument TypeLogicVariable */
t5 = Type_ExternalValueCellPointer;
*(uint32_t *)(iSP + 8) = arg1;
*(uint32_t *)(iSP + 12) = t5; // write the stack cache
iSP = iSP + 8;
goto NEXTINSTRUCTION;

basic_dispatch46488 : if (_trace) printf("basic_dispatch46488:\n");
/* Here for all other cases */
t5 = arg2 & 63; // set CDR-NEXT
*(uint32_t *)(iSP + 8) = arg1;
*(uint32_t *)(iSP + 12) = t5; // write the stack cache
iSP = iSP + 8;
goto NEXTINSTRUCTION;

basic_dispatch46473 : if (_trace) printf("basic_dispatch46473:\n");

vma_memory_read46477 : if (_trace) printf("vma_memory_read46477:\n");
t6 = *(uint64_t *)&(processor->stackcachedata);
t5 = (t5 * 8) + t6; // reconstruct SCA
t3 = *(int32_t *)t5;
t4 = *(int32_t *)(t5 + 4); // Read from stack cache
goto vma_memory_read46476;

vma_memory_read46479 : if (_trace) printf("vma_memory_read46479:\n");
if ((t7 & 1) == 0)
    goto vma_memory_read46478;
arg1 = (uint32_t) t3; // Do the indirect thing
goto vma_memory_read46475;

vma_memory_read46478 : if (_trace) printf("vma_memory_read46478:\n");
t8 = *(uint64_t *)&(processor->dataread); // Load the memory action table for cycle
/* TagType. */
t7 = t4 & 63; // Discard the CDR code
*(uint64_t *)&processor->vma = arg1; // stash the VMA for the (likely) trap
t7 = (t7 * 4) + t8; // Adjust for a longword load
t8 = *(int32_t *)t7; // Get the memory action

vma_memory_read46483 : if (_trace) printf("vma_memory_read46483:\n");
t7 = t8 & MemoryActionTransform;
if (t7 == 0)
    goto vma_memory_read46482;
t4 = t4 & ~63L;
t4 = t4 | Type_ExternalValueCellPointer;
goto vma_memory_read46486;

vma_memory_read46482 :

    vma_memory_read46481 :
    /* Perform memory action */
    arg1
    = t8;
arg2 = 0;
goto performmemoryaction;

/* end DoDereference */
/* End of Halfword operand from stack instruction - DoDereference */
/* start DoUnify */

/* Halfword operand from stack instruction - DoUnify */

dounify : if (_trace) printf("dounify:\n");
/* arg2 has the preloaded 8 bit operand. */

DoUnifyIM : if (_trace) printf("DoUnifyIM:\n");
/* This sequence only sucks a moderate amount */
arg2 = arg2 << 56; // sign extend the byte argument.

force_alignment46497 : if (_trace) printf("force_alignment46497:\n");
arg2 = (int64_t) arg2 >> 56; // Rest of sign extension
*(uint32_t *)&processor->immediate_arg = arg2;
arg1 = *(uint64_t *)&(processor->immediate_arg);
goto begindounify;

DoUnifySP : if (_trace) printf("DoUnifySP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoUnifyLP : if (_trace) printf("DoUnifyLP:\n");

DoUnifyFP : if (_trace) printf("DoUnifyFP:\n");

headdounify : if (_trace) printf("headdounify:\n");
arg1 = (arg2 * 8) + arg1; // Compute operand address
arg1 = *(uint64_t *)arg1; // Get the operand

begindounify : if (_trace) printf("begindounify:\n");
/* arg1 has the operand, sign extended if immediate. */
/* This instruction has not been written yet. */
arg5 = 0;
arg2 = 38;
goto illegaloperand;
goto NEXTINSTRUCTION;

/* end DoUnify */
/* End of Halfword operand from stack instruction - DoUnify */
/* start DoPushLocalLogicVariables */

/* Halfword operand from stack instruction - DoPushLocalLogicVariables */
/* arg2 has the preloaded 8 bit operand. */

dopushlocallogicvariables : if (_trace) printf("dopushlocallogicvariables:\n");

DoPushLocalLogicVariablesIM : if (_trace) printf("DoPushLocalLogicVariablesIM:\n");
/* This sequence is lukewarm */
*(uint32_t *)&processor->immediate_arg = arg2;
arg1 = *(uint64_t *)&(processor->immediate_arg);
goto begindopushlocallogicvariables;

DoPushLocalLogicVariablesSP : if (_trace) printf("DoPushLocalLogicVariablesSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoPushLocalLogicVariablesLP : if (_trace) printf("DoPushLocalLogicVariablesLP:\n");

DoPushLocalLogicVariablesFP : if (_trace) printf("DoPushLocalLogicVariablesFP:\n");

headdopushlocallogicvariables : if (_trace) printf("headdopushlocallogicvariables:\n");
arg1 = (arg2 * 8) + arg1; // Compute operand address
arg1 = *(uint64_t *)arg1; // Get the operand

begindopushlocallogicvariables : if (_trace) printf("begindopushlocallogicvariables:\n");
/* arg1 has the operand, not sign extended if immediate. */
arg6 = Type_LogicVariable;
t1 = arg1 >> 32;
arg2 = (uint32_t) arg1;
t2 = t1 - Type_Fixnum;
t2 = t2 & 63; // Strip CDR code
if (t2 != 0)
    goto pllvillop;
t4 = *(int32_t *)&processor->scovlimit; // Current stack cache limit (words)
t1 = zero + 128;
t2 = *(uint64_t *)&(processor->stackcachedata); // Alpha base of stack cache
t1 = t1 + arg2; // Account for what we're about to push
t1 = (t1 * 8) + iSP; // SCA of desired end of cache
t2 = (t4 * 8) + t2; // SCA of current end of cache
t4 = ((int64_t) t1 <= (int64_t) t2) ? 1 : 0;
if (t4 == 0) // We're done if new SCA is within bounds
    goto stackcacheoverflowhandler;
goto pllvloopend;

pllvlooptop : if (_trace) printf("pllvlooptop:\n");
*(uint32_t *)(iSP + 8) = iSP;
*(uint32_t *)(iSP + 12) = arg6; // write the stack cache
iSP = iSP + 8;

pllvloopend : if (_trace) printf("pllvloopend:\n");
arg2 = arg2 - 1;
if ((int64_t) arg2 >= 0) // J. If iterations to go.
    goto pllvlooptop;
goto NEXTINSTRUCTION;

pllvillop : if (_trace) printf("pllvillop:\n");
arg5 = 0;
arg2 = 63;
goto illegaloperand;

/* end DoPushLocalLogicVariables */
/* End of Halfword operand from stack instruction - DoPushLocalLogicVariables */
/* start DoPushGlobalLogicVariable */

/* Halfword operand from stack instruction - DoPushGlobalLogicVariable */

dopushgloballogicvariable : if (_trace) printf("dopushgloballogicvariable:\n");
/* arg2 has the preloaded 8 bit operand. */

DoPushGlobalLogicVariableIM : if (_trace) printf("DoPushGlobalLogicVariableIM:\n");
/* This sequence only sucks a moderate amount */
arg2 = arg2 << 56; // sign extend the byte argument.

force_alignment46514 : if (_trace) printf("force_alignment46514:\n");
arg2 = (int64_t) arg2 >> 56; // Rest of sign extension
*(uint32_t *)&processor->immediate_arg = arg2;
arg1 = *(uint64_t *)&(processor->immediate_arg);
goto begindopushgloballogicvariable;

DoPushGlobalLogicVariableSP : if (_trace) printf("DoPushGlobalLogicVariableSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoPushGlobalLogicVariableLP : if (_trace) printf("DoPushGlobalLogicVariableLP:\n");

DoPushGlobalLogicVariableFP : if (_trace) printf("DoPushGlobalLogicVariableFP:\n");

headdopushgloballogicvariable : if (_trace) printf("headdopushgloballogicvariable:\n");
arg1 = (arg2 * 8) + arg1; // Compute operand address
arg1 = *(uint64_t *)arg1; // Get the operand

begindopushgloballogicvariable : if (_trace) printf("begindopushgloballogicvariable:\n");
/* arg1 has the operand, sign extended if immediate. */
t1 = *(int32_t *)&processor->bar2; // Get the structure stack pointer
t3 = Type_ExternalValueCellPointer;
*(uint32_t *)(iSP + 8) = t1;
*(uint32_t *)(iSP + 12) = t3; // write the stack cache
iSP = iSP + 8;
/* Memory Read Internal */

vma_memory_read46499 : t6 = *(uint64_t *)&(processor->stackcachebasevma); // Base of stack cache
t8 = t1 + ivory;
t7 = *(int32_t *)&processor->scovlimit;
t5 = (t8 * 4);
t4 = LDQ_U(t8);
t6 = t1 - t6; // Stack cache offset
t9 = *(uint64_t *)&(processor->datawrite_mask);
t7 = ((uint64_t) t6 < (uint64_t) t7) ? 1 : 0; // In range?
t5 = *(int32_t *)t5;
t4 = (uint8_t) (t4 >> ((t8 & 7) * 8));
if (t7 != 0)
    goto vma_memory_read46501;

vma_memory_read46500 : t8 = zero + 240;
t9 = t9 >> (t4 & 63);
t8 = t8 >> (t4 & 63);
if (t9 & 1)
    goto vma_memory_read46503;

vma_memory_read46509 :
    /* Merge cdr-code */
    t5
    = t3 & 63;
t4 = t4 & 192;
t4 = t4 | t5;
t7 = *(uint64_t *)&(processor->stackcachebasevma);
t6 = t1 + ivory;
t9 = *(int32_t *)&processor->scovlimit;
t5 = (t6 * 4);
t8 = LDQ_U(t6);
t7 = t1 - t7; // Stack cache offset
t9 = ((uint64_t) t7 < (uint64_t) t9) ? 1 : 0; // In range?
t7 = (t4 & 0xff) << ((t6 & 7) * 8);
t8 = t8 & ~(0xffL << (t6 & 7) * 8);

force_alignment46512 : if (_trace) printf("force_alignment46512:\n");
t8 = t8 | t7;
STQ_U(t6, t8);
*(uint32_t *)t5 = t1;
if (t9 != 0) // J. if in cache
    goto vma_memory_write46511;

vma_memory_write46510 : t2 = t1 + 1; // Increment the structure-stack-pointer
*(uint32_t *)&processor->bar2 = t2; // Set the structure stack pointer
goto NEXTINSTRUCTION;

vma_memory_write46511 : if (_trace) printf("vma_memory_write46511:\n");
t7 = *(uint64_t *)&(processor->stackcachebasevma);

force_alignment46513 : if (_trace) printf("force_alignment46513:\n");
t6 = *(uint64_t *)&(processor->stackcachedata);
t7 = t1 - t7; // Stack cache offset
t6 = (t7 * 8) + t6; // reconstruct SCA
*(uint32_t *)t6 = t1; // Store in stack
*(uint32_t *)(t6 + 4) = t4; // write the stack cache
goto vma_memory_write46510;

vma_memory_read46501 : if (_trace) printf("vma_memory_read46501:\n");
t7 = *(uint64_t *)&(processor->stackcachedata);
t6 = (t6 * 8) + t7; // reconstruct SCA
t5 = *(int32_t *)t6;
t4 = *(int32_t *)(t6 + 4); // Read from stack cache
goto vma_memory_read46500;

vma_memory_read46503 : if (_trace) printf("vma_memory_read46503:\n");
if ((t8 & 1) == 0)
    goto vma_memory_read46502;
t1 = (uint32_t) t5; // Do the indirect thing
goto vma_memory_read46499;

vma_memory_read46502 : if (_trace) printf("vma_memory_read46502:\n");
t9 = *(uint64_t *)&(processor->datawrite); // Load the memory action table for cycle
/* TagType. */
t8 = t4 & 63; // Discard the CDR code
*(uint64_t *)&processor->vma = t1; // stash the VMA for the (likely) trap
t8 = (t8 * 4) + t9; // Adjust for a longword load
t9 = *(int32_t *)t8; // Get the memory action

vma_memory_read46506 :

    vma_memory_read46505 :
    /* Perform memory action */
    arg1
    = t9;
arg2 = 1;
goto performmemoryaction;

/* end DoPushGlobalLogicVariable */
/* End of Halfword operand from stack instruction - DoPushGlobalLogicVariable */
/* start DoLogicTailTest */

/* Halfword operand from stack instruction - DoLogicTailTest */

dologictailtest : if (_trace) printf("dologictailtest:\n");
/* arg2 has the preloaded 8 bit operand. */

DoLogicTailTestIM : if (_trace) printf("DoLogicTailTestIM:\n");
/* This sequence only sucks a moderate amount */
arg2 = arg2 << 56; // sign extend the byte argument.

force_alignment46524 : if (_trace) printf("force_alignment46524:\n");
arg2 = (int64_t) arg2 >> 56; // Rest of sign extension
*(uint32_t *)&processor->immediate_arg = arg2;
arg1 = *(uint64_t *)&(processor->immediate_arg);
goto begindologictailtest;

DoLogicTailTestSP : if (_trace) printf("DoLogicTailTestSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoLogicTailTestLP : if (_trace) printf("DoLogicTailTestLP:\n");

DoLogicTailTestFP : if (_trace) printf("DoLogicTailTestFP:\n");

headdologictailtest : if (_trace) printf("headdologictailtest:\n");
arg1 = (arg2 * 8) + arg1; // Compute operand address
arg1 = *(uint64_t *)arg1; // Get the operand

begindologictailtest : if (_trace) printf("begindologictailtest:\n");
/* arg1 has the operand, sign extended if immediate. */
arg2 = arg1 >> 32;
t1 = arg2 & 63; // Strip off any CDR code bits.
t2 = (t1 == Type_List) ? 1 : 0;

force_alignment46521 : if (_trace) printf("force_alignment46521:\n");
if (t2 == 0)
    goto basic_dispatch46516;
/* Here if argument TypeList */
t3 = *(uint64_t *)&(processor->niladdress);
*(uint64_t *)(iSP + 8) = t3; // push the data
iSP = iSP + 8;
goto NEXTINSTRUCTION;

basic_dispatch46516 : if (_trace) printf("basic_dispatch46516:\n");
t2 = (t1 == Type_ExternalValueCellPointer) ? 1 : 0;

force_alignment46522 : if (_trace) printf("force_alignment46522:\n");
if (t2 == 0)
    goto basic_dispatch46517;
/* Here if argument TypeExternalValueCellPointer */
t3 = *(uint64_t *)&(processor->taddress);
*(uint64_t *)(iSP + 8) = t3; // push the data
iSP = iSP + 8;
goto NEXTINSTRUCTION;

basic_dispatch46517 : if (_trace) printf("basic_dispatch46517:\n");
t2 = (t1 == Type_ListInstance) ? 1 : 0;

force_alignment46523 : if (_trace) printf("force_alignment46523:\n");
if (t2 == 0)
    goto basic_dispatch46518;
/* Here if argument TypeListInstance */
t3 = *(uint64_t *)&(processor->niladdress);
*(uint64_t *)(iSP + 8) = t3; // push the data
iSP = iSP + 8;
goto NEXTINSTRUCTION;

basic_dispatch46518 : if (_trace) printf("basic_dispatch46518:\n");
/* Here for all other cases */
arg6 = t2; // arg6 = tag to dispatch on
arg3 = 0; // arg3 = stackp
arg1 = 1; // arg1 = instruction arity
arg4 = 0; // arg4 = arithmeticp
goto exception;

basic_dispatch46515 : if (_trace) printf("basic_dispatch46515:\n");

/* end DoLogicTailTest */
/* End of Halfword operand from stack instruction - DoLogicTailTest */
/* Fin. */

/* End of file automatically generated from ../alpha-emulator/ifunjosh.as */
