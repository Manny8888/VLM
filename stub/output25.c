/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunjosh.as
 ************************************************************************/

  /* 'AI' instructions. */
/* start DoDereference */

  /* Halfword operand from stack instruction - DoDereference */

dodereference:
  if (_trace) printf("dodereference:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoDereferenceIM:
  if (_trace) printf("DoDereferenceIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment14163:
  if (_trace) printf("force-alignment14163:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindodereference;   

DoDereferenceSP:
  if (_trace) printf("DoDereferenceSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoDereferenceLP:
  if (_trace) printf("DoDereferenceLP:\n");

DoDereferenceFP:
  if (_trace) printf("DoDereferenceFP:\n");

headdodereference:
  if (_trace) printf("headdodereference:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindodereference:
  if (_trace) printf("begindodereference:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t1 = arg2 & 63;		// Strip off any CDR code bits. 
  t2 = (t1 == Type_OneQForward) ? 1 : 0;   

force-alignment14158:
  if (_trace) printf("force-alignment14158:\n");
  if (t2 != 0)   
    goto basic-dispatch14154;
  t2 = (t1 == Type_ElementForward) ? 1 : 0;   

force-alignment14159:
  if (_trace) printf("force-alignment14159:\n");
  if (t2 != 0)   
    goto basic-dispatch14154;
  t2 = (t1 == Type_HeaderForward) ? 1 : 0;   

force-alignment14160:
  if (_trace) printf("force-alignment14160:\n");
  if (t2 != 0)   
    goto basic-dispatch14154;
  t2 = (t1 == Type_ExternalValueCellPointer) ? 1 : 0;   

force-alignment14161:
  if (_trace) printf("force-alignment14161:\n");
  if (t2 == 0) 
    goto basic-dispatch14141;

basic-dispatch14154:
  if (_trace) printf("basic-dispatch14154:\n");
  /* Here if argument (TypeOneQForward TypeElementForward TypeHeaderForward
                  TypeExternalValueCellPointer) */
  /* Memory Read Internal */

vma-memory-read14142:
  t5 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t7 = arg1 + ivory;
  t6 = *(s32 *)&processor->scovlimit;   
  t3 = (t7 * 4);   
  t4 = LDQ_U(t7);   
  t5 = arg1 - t5;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t6) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14144;

vma-memory-read14143:
  t7 = zero + 240;   
  t8 = t8 >> (t4 & 63);   
  t7 = t7 >> (t4 & 63);   
  if (t8 & 1)   
    goto vma-memory-read14146;

vma-memory-read14153:
  t5 = t4 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

basic-dispatch14141:
  if (_trace) printf("basic-dispatch14141:\n");
  t2 = (t1 == Type_LogicVariable) ? 1 : 0;   

force-alignment14162:
  if (_trace) printf("force-alignment14162:\n");
  if (t2 == 0) 
    goto basic-dispatch14155;
  /* Here if argument TypeLogicVariable */
  t5 = Type_ExternalValueCellPointer;
  *(u32 *)(iSP + 8) = arg1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

basic-dispatch14155:
  if (_trace) printf("basic-dispatch14155:\n");
  /* Here for all other cases */
  t5 = arg2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

basic-dispatch14140:
  if (_trace) printf("basic-dispatch14140:\n");

vma-memory-read14144:
  if (_trace) printf("vma-memory-read14144:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t3 = *(s32 *)t5;   
  t4 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read14143;   

vma-memory-read14146:
  if (_trace) printf("vma-memory-read14146:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14145;
  arg1 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read14142;   

vma-memory-read14145:
  if (_trace) printf("vma-memory-read14145:\n");
  t8 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read14150:
  if (_trace) printf("vma-memory-read14150:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0) 
    goto vma-memory-read14149;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto vma-memory-read14153;   

vma-memory-read14149:

vma-memory-read14148:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

/* end DoDereference */
  /* End of Halfword operand from stack instruction - DoDereference */
/* start DoUnify */

  /* Halfword operand from stack instruction - DoUnify */

dounify:
  if (_trace) printf("dounify:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoUnifyIM:
  if (_trace) printf("DoUnifyIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment14164:
  if (_trace) printf("force-alignment14164:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindounify;   

DoUnifySP:
  if (_trace) printf("DoUnifySP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoUnifyLP:
  if (_trace) printf("DoUnifyLP:\n");

DoUnifyFP:
  if (_trace) printf("DoUnifyFP:\n");

headdounify:
  if (_trace) printf("headdounify:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindounify:
  if (_trace) printf("begindounify:\n");
  /* arg1 has the operand, sign extended if immediate. */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;
  goto NEXTINSTRUCTION;   

/* end DoUnify */
  /* End of Halfword operand from stack instruction - DoUnify */
/* start DoPushLocalLogicVariables */

  /* Halfword operand from stack instruction - DoPushLocalLogicVariables */
  /* arg2 has the preloaded 8 bit operand. */

dopushlocallogicvariables:
  if (_trace) printf("dopushlocallogicvariables:\n");

DoPushLocalLogicVariablesIM:
  if (_trace) printf("DoPushLocalLogicVariablesIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindopushlocallogicvariables;   

DoPushLocalLogicVariablesSP:
  if (_trace) printf("DoPushLocalLogicVariablesSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPushLocalLogicVariablesLP:
  if (_trace) printf("DoPushLocalLogicVariablesLP:\n");

DoPushLocalLogicVariablesFP:
  if (_trace) printf("DoPushLocalLogicVariablesFP:\n");

headdopushlocallogicvariables:
  if (_trace) printf("headdopushlocallogicvariables:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindopushlocallogicvariables:
  if (_trace) printf("begindopushlocallogicvariables:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg6 = Type_LogicVariable;
  t1 = arg1 >> 32;   
  arg2 = (u32)arg1;   
  t2 = t1 - Type_Fixnum;   
  t2 = t2 & 63;		// Strip CDR code 
  if (t2 != 0)   
    goto pllvillop;
  t4 = *(s32 *)&processor->scovlimit;   		// Current stack cache limit (words) 
  t1 = zero + 128;   
  t2 = *(u64 *)&(processor->stackcachedata);   		// Alpha base of stack cache 
  t1 = t1 + arg2;		// Account for what we're about to push 
  t1 = (t1 * 8) + iSP;  		// SCA of desired end of cache 
  t2 = (t4 * 8) + t2;  		// SCA of current end of cache 
  t4 = ((s64)t1 <= (s64)t2) ? 1 : 0;   
  if (t4 == 0) 		// We're done if new SCA is within bounds 
    goto stackcacheoverflowhandler;
  goto pllvloopend;   

pllvlooptop:
  if (_trace) printf("pllvlooptop:\n");
  *(u32 *)(iSP + 8) = iSP;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = arg6;
  iSP = iSP + 8;

pllvloopend:
  if (_trace) printf("pllvloopend:\n");
  arg2 = arg2 - 1;   
  if ((s64)arg2 >= 0)   		// J. If iterations to go. 
    goto pllvlooptop;
  goto NEXTINSTRUCTION;   

pllvillop:
  if (_trace) printf("pllvillop:\n");
  arg5 = 0;
  arg2 = 63;
  goto illegaloperand;

/* end DoPushLocalLogicVariables */
  /* End of Halfword operand from stack instruction - DoPushLocalLogicVariables */
/* start DoPushGlobalLogicVariable */

  /* Halfword operand from stack instruction - DoPushGlobalLogicVariable */

dopushgloballogicvariable:
  if (_trace) printf("dopushgloballogicvariable:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoPushGlobalLogicVariableIM:
  if (_trace) printf("DoPushGlobalLogicVariableIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment14181:
  if (_trace) printf("force-alignment14181:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindopushgloballogicvariable;   

DoPushGlobalLogicVariableSP:
  if (_trace) printf("DoPushGlobalLogicVariableSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPushGlobalLogicVariableLP:
  if (_trace) printf("DoPushGlobalLogicVariableLP:\n");

DoPushGlobalLogicVariableFP:
  if (_trace) printf("DoPushGlobalLogicVariableFP:\n");

headdopushgloballogicvariable:
  if (_trace) printf("headdopushgloballogicvariable:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindopushgloballogicvariable:
  if (_trace) printf("begindopushgloballogicvariable:\n");
  /* arg1 has the operand, sign extended if immediate. */
  t1 = *(s32 *)&processor->bar2;   		// Get the structure stack pointer 
  t3 = Type_ExternalValueCellPointer;
  *(u32 *)(iSP + 8) = t1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  /* Memory Read Internal */

vma-memory-read14166:
  t6 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t8 = t1 + ivory;
  t7 = *(s32 *)&processor->scovlimit;   
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = t1 - t6;   		// Stack cache offset 
  t9 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t6 < (u64)t7) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read14168;

vma-memory-read14167:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t9 & 1)   
    goto vma-memory-read14170;

vma-memory-read14176:
  /* Merge cdr-code */
  t5 = t3 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t7 = *(u64 *)&(processor->stackcachebasevma);   
  t6 = t1 + ivory;
  t9 = *(s32 *)&processor->scovlimit;   
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = t1 - t7;   		// Stack cache offset 
  t9 = ((u64)t7 < (u64)t9) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment14179:
  if (_trace) printf("force-alignment14179:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t1;
  if (t9 != 0)   		// J. if in cache 
    goto vma-memory-write14178;

vma-memory-write14177:
  t2 = t1 + 1;		// Increment the structure-stack-pointer 
		/* Set the structure stack pointer */
  *(u32 *)&processor->bar2 = t2;
  goto NEXTINSTRUCTION;   

vma-memory-write14178:
  if (_trace) printf("vma-memory-write14178:\n");
  t7 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment14180:
  if (_trace) printf("force-alignment14180:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = t1 - t7;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = t1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto vma-memory-write14177;   

vma-memory-read14168:
  if (_trace) printf("vma-memory-read14168:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read14167;   

vma-memory-read14170:
  if (_trace) printf("vma-memory-read14170:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read14169;
  t1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read14166;   

vma-memory-read14169:
  if (_trace) printf("vma-memory-read14169:\n");
  t9 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
  t9 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read14173:

vma-memory-read14172:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoPushGlobalLogicVariable */
  /* End of Halfword operand from stack instruction - DoPushGlobalLogicVariable */
/* start DoLogicTailTest */

  /* Halfword operand from stack instruction - DoLogicTailTest */

dologictailtest:
  if (_trace) printf("dologictailtest:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoLogicTailTestIM:
  if (_trace) printf("DoLogicTailTestIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment14191:
  if (_trace) printf("force-alignment14191:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindologictailtest;   

DoLogicTailTestSP:
  if (_trace) printf("DoLogicTailTestSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoLogicTailTestLP:
  if (_trace) printf("DoLogicTailTestLP:\n");

DoLogicTailTestFP:
  if (_trace) printf("DoLogicTailTestFP:\n");

headdologictailtest:
  if (_trace) printf("headdologictailtest:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindologictailtest:
  if (_trace) printf("begindologictailtest:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg2 = arg1 >> 32;   
  t1 = arg2 & 63;		// Strip off any CDR code bits. 
  t2 = (t1 == Type_List) ? 1 : 0;   

force-alignment14188:
  if (_trace) printf("force-alignment14188:\n");
  if (t2 == 0) 
    goto basic-dispatch14183;
  /* Here if argument TypeList */
  t3 = *(u64 *)&(processor->niladdress);   
  *(u64 *)(iSP + 8) = t3;   		// push the data 
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

basic-dispatch14183:
  if (_trace) printf("basic-dispatch14183:\n");
  t2 = (t1 == Type_ExternalValueCellPointer) ? 1 : 0;   

force-alignment14189:
  if (_trace) printf("force-alignment14189:\n");
  if (t2 == 0) 
    goto basic-dispatch14184;
  /* Here if argument TypeExternalValueCellPointer */
  t3 = *(u64 *)&(processor->taddress);   
  *(u64 *)(iSP + 8) = t3;   		// push the data 
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

basic-dispatch14184:
  if (_trace) printf("basic-dispatch14184:\n");
  t2 = (t1 == Type_ListInstance) ? 1 : 0;   

force-alignment14190:
  if (_trace) printf("force-alignment14190:\n");
  if (t2 == 0) 
    goto basic-dispatch14185;
  /* Here if argument TypeListInstance */
  t3 = *(u64 *)&(processor->niladdress);   
  *(u64 *)(iSP + 8) = t3;   		// push the data 
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

basic-dispatch14185:
  if (_trace) printf("basic-dispatch14185:\n");
  /* Here for all other cases */
  arg6 = t2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

basic-dispatch14182:
  if (_trace) printf("basic-dispatch14182:\n");

/* end DoLogicTailTest */
  /* End of Halfword operand from stack instruction - DoLogicTailTest */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunjosh.as */
