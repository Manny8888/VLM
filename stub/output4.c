/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifuncom2.as
 ************************************************************************/

/* The most commonly used instructions, part 2. */
/* start DoPushInstanceVariable */

/* Halfword 10 bit immediate instruction - DoPushInstanceVariable */

dopushinstancevariable : if (_trace) printf("dopushinstancevariable:\n");
/* Actually only one entry point, but simulate others for dispatch */

DoPushInstanceVariableIM : if (_trace) printf("DoPushInstanceVariableIM:\n");

DoPushInstanceVariableSP : if (_trace) printf("DoPushInstanceVariableSP:\n");

DoPushInstanceVariableLP : if (_trace) printf("DoPushInstanceVariableLP:\n");

DoPushInstanceVariableFP : if (_trace) printf("DoPushInstanceVariableFP:\n");
/* arg1 has operand preloaded. */
arg1 = arg2;
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
/* Locate Instance Variable Mapped */
arg2 = *(s32 *)(iFP + 16); // Map
arg5 = *(s32 *)(iFP + 20);
arg2 = (u32)arg2;
t2 = arg5 - Type_Array;
t2 = t2 & 63; // Strip CDR code
if (t2 != 0)
    goto ivbadmap;
/* Memory Read Internal */

vma_memory_read44229 : t7 = arg2 + ivory;
arg6 = (t7 * 4);
arg5 = LDQ_U(t7);
t5 = arg2 - t11; // Stack cache offset
t8 = *(u64 *)&(processor->header_mask);
t6 = ((u64)t5 < (u64)t12) ? 1 : 0; // In range?
arg6 = *(s32 *)arg6;
arg5 = (u8)(arg5 >> ((t7 & 7) * 8));
if (t6 != 0)
    goto vma_memory_read44231;

vma_memory_read44230 : t7 = zero + 64;
t8 = t8 >> (arg5 & 63);
t7 = t7 >> (arg5 & 63);
if (t8 & 1)
    goto vma_memory_read44233;

vma_memory_read44238 : arg6 = arg6 & Array_LengthMask;
t3 = arg6 - arg1;
if ((s64)t3 <= 0) // J. if mapping-table-index-out-of-bounds
    goto ivbadindex;
arg2 = arg2 + arg1;
arg2 = arg2 + 1;
/* Memory Read Internal */

vma_memory_read44239 : t7 = arg2 + ivory;
arg6 = (t7 * 4);
arg5 = LDQ_U(t7);
t5 = arg2 - t11; // Stack cache offset
t8 = *(u64 *)&(processor->dataread_mask);
t6 = ((u64)t5 < (u64)t12) ? 1 : 0; // In range?
arg6 = *(s32 *)arg6;
arg5 = (u8)(arg5 >> ((t7 & 7) * 8));
if (t6 != 0)
    goto vma_memory_read44241;

vma_memory_read44240 : t7 = zero + 240;
t8 = t8 >> (arg5 & 63);
t7 = t7 >> (arg5 & 63);
arg6 = (u32)arg6;
if (t8 & 1)
    goto vma_memory_read44243;

vma_memory_read44250 : t1 = arg6;
t4 = arg5 - Type_Fixnum;
t4 = t4 & 63; // Strip CDR code
if (t4 != 0)
    goto pushivexception;
arg2 = *(s32 *)(iFP + 24); // Self
t4 = *(s32 *)(iFP + 28);
arg2 = (u32)arg2;
t3 = t4 - Type_Instance;
t3 = t3 & 60; // Strip CDR code, low bits
if (t3 != 0)
    goto ivbadinst;
t3 = t4 & 192; // Unshifted cdr code
t3 = t3 - 64; // Check for CDR code 1
if (t3 != 0) // J. if CDR code is not 1
    goto locate_instance0variable_mapped44228;

locate_instance0variable_mapped44227 : if (_trace) printf("locate_instance0variable_mapped44227:\n");
arg2 = arg2 + t1;

locate_instance0variable_mapped44226 : if (_trace) printf("locate_instance0variable_mapped44226:\n");
/* Memory Read Internal */

vma_memory_read44251 : t7 = arg2 + ivory;
arg6 = (t7 * 4);
arg5 = LDQ_U(t7);
t5 = arg2 - t11; // Stack cache offset
t8 = *(u64 *)&(processor->dataread_mask);
t6 = ((u64)t5 < (u64)t12) ? 1 : 0; // In range?
arg6 = *(s32 *)arg6;
arg5 = (u8)(arg5 >> ((t7 & 7) * 8));
if (t6 != 0)
    goto vma_memory_read44253;

vma_memory_read44252 : t7 = zero + 240;
t8 = t8 >> (arg5 & 63);
t7 = t7 >> (arg5 & 63);
if (t8 & 1)
    goto vma_memory_read44255;

vma_memory_read44262 : iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
t7 = arg5 & 63; // set CDR-NEXT
*(u32 *)(iSP + 8) = arg6;
*(u32 *)(iSP + 12) = t7; // write the stack cache
iSP = iSP + 8;
goto cachevalid;

vma_memory_read44255 : if (_trace) printf("vma_memory_read44255:\n");
if ((t7 & 1) == 0)
    goto vma_memory_read44254;
arg2 = (u32)arg6; // Do the indirect thing
goto vma_memory_read44251;

vma_memory_read44254 : if (_trace) printf("vma_memory_read44254:\n");

vma_memory_read44253 : if (_trace) printf("vma_memory_read44253:\n");
r0 = (u64) && return0021;
goto memoryreaddatadecode;
return0021 : goto vma_memory_read44262;

vma_memory_read44243 : if (_trace) printf("vma_memory_read44243:\n");
if ((t7 & 1) == 0)
    goto vma_memory_read44242;
arg2 = (u32)arg6; // Do the indirect thing
goto vma_memory_read44239;

vma_memory_read44242 : if (_trace) printf("vma_memory_read44242:\n");

vma_memory_read44241 : if (_trace) printf("vma_memory_read44241:\n");
r0 = (u64) && return0022;
goto memoryreaddatadecode;
return0022 : goto vma_memory_read44250;

vma_memory_read44233 : if (_trace) printf("vma_memory_read44233:\n");
if ((t7 & 1) == 0)
    goto vma_memory_read44232;
arg2 = (u32)arg6; // Do the indirect thing
goto vma_memory_read44229;

vma_memory_read44232 : if (_trace) printf("vma_memory_read44232:\n");

vma_memory_read44231 : if (_trace) printf("vma_memory_read44231:\n");
r0 = (u64) && return0023;
goto memoryreadheaderdecode;
return0023 : goto vma_memory_read44238;

locate_instance0variable_mapped44228 : if (_trace) printf("locate_instance0variable_mapped44228:\n");
t3 = arg2;
/* Memory Read Internal */

vma_memory_read44263 : t7 = arg2 + ivory;
arg6 = (t7 * 4);
arg5 = LDQ_U(t7);
t5 = arg2 - t11; // Stack cache offset
t8 = *(u64 *)&(processor->header_mask);
t6 = ((u64)t5 < (u64)t12) ? 1 : 0; // In range?
arg6 = *(s32 *)arg6;
arg5 = (u8)(arg5 >> ((t7 & 7) * 8));
if (t6 != 0)
    goto vma_memory_read44265;

vma_memory_read44264 : t7 = zero + 64;
t8 = t8 >> (arg5 & 63);
t7 = t7 >> (arg5 & 63);
arg6 = (u32)arg6;
if (t8 & 1)
    goto vma_memory_read44267;

vma_memory_read44272 : t3 = t3 - arg2;
if (t3 != 0)
    goto locate_instance0variable_mapped44227;
/* TagType. */
t4 = t4 & 63;
t4 = t4 | 64; // Set CDR code to 1
*(u32 *)(iFP + 24) = arg2; // Update self
*(u32 *)(iFP + 28) = t4; // write the stack cache
goto locate_instance0variable_mapped44227;

vma_memory_read44267 : if (_trace) printf("vma_memory_read44267:\n");
if ((t7 & 1) == 0)
    goto vma_memory_read44266;
arg2 = (u32)arg6; // Do the indirect thing
goto vma_memory_read44263;

vma_memory_read44266 : if (_trace) printf("vma_memory_read44266:\n");

vma_memory_read44265 : if (_trace) printf("vma_memory_read44265:\n");
r0 = (u64) && return0024;
goto memoryreadheaderdecode;
return0024 : goto vma_memory_read44272;

/* end DoPushInstanceVariable */
/* End of Halfword operand from stack instruction - DoPushInstanceVariable */
/* start DoAdd */

/* Halfword operand from stack instruction - DoAdd */
/* arg2 has the preloaded 8 bit operand. */

doadd : if (_trace) printf("doadd:\n");

DoAddSP : if (_trace) printf("DoAddSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto begindoadd;
arg6 = *(u64 *)arg4; // SP-pop, Reload TOS
arg1 = iSP; // SP-pop mode
iSP = arg4; // Adjust SP

DoAddLP : if (_trace) printf("DoAddLP:\n");

DoAddFP : if (_trace) printf("DoAddFP:\n");

begindoadd : if (_trace) printf("begindoadd:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
LDS(1, f1, *(u32 *)iSP);
t1 = (u32)(arg6 >> ((4 & 7) * 8)); // ARG1 tag
t3 = *(s32 *)(arg1 + 4); // ARG2 tag
t2 = (s32)arg6; // ARG1 data
t4 = *(s32 *)arg1; // ARG2 data
LDS(2, f2, *(u32 *)arg1);
/* NIL */
t9 = t1 & 63; // Strip off any CDR code bits.
t11 = t3 & 63; // Strip off any CDR code bits.
t10 = (t9 == Type_Fixnum) ? 1 : 0;

force_alignment44312 : if (_trace) printf("force_alignment44312:\n");
if (t10 == 0)
    goto basic_dispatch44283;
/* Here if argument TypeFixnum */
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment44289 : if (_trace) printf("force_alignment44289:\n");
if (t12 == 0)
    goto basic_dispatch44285;
/* Here if argument TypeFixnum */
t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
t5 = (u64)((s32)t2 + (s64)(s32)t4); // compute 64-bit result
if (t5 >> 31)
    exception(1, t5); /* addl/v */ // WARNING !!! THIS SHOULD REFLECT THE DIFF FILE
t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
/* trapb force the trap to occur here */ // Force the trap to occur here
*(u32 *)(iSP + 4) = t9; // Semi-cheat, we know temp2 has CDRNext/TypeFixnum
iPC = t6;
*(u32 *)iSP = t5;
iCP = t7;
goto cachevalid;

basic_dispatch44285 : if (_trace) printf("basic_dispatch44285:\n");
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment44290 : if (_trace) printf("force_alignment44290:\n");
if (t12 == 0)
    goto basic_dispatch44286;
/* Here if argument TypeSingleFloat */
CVTLQ(1, f1, f31, 1, f1);
CVTQT(1, f1, f31, 1, f1);
goto simple_binary_arithmetic_operation44273;

basic_dispatch44286 : if (_trace) printf("basic_dispatch44286:\n");
t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

force_alignment44291 : if (_trace) printf("force_alignment44291:\n");
if (t12 == 0)
    goto binary_type_dispatch44280;
/* Here if argument TypeDoubleFloat */
CVTLQ(1, f1, f31, 1, f1);
CVTQT(1, f1, f31, 1, f1);
goto simple_binary_arithmetic_operation44276;

basic_dispatch44284 : if (_trace) printf("basic_dispatch44284:\n");

basic_dispatch44283 : if (_trace) printf("basic_dispatch44283:\n");
t10 = (t9 == Type_SingleFloat) ? 1 : 0;

force_alignment44313 : if (_trace) printf("force_alignment44313:\n");
if (t10 == 0)
    goto basic_dispatch44292;
/* Here if argument TypeSingleFloat */
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment44298 : if (_trace) printf("force_alignment44298:\n");
if (t12 == 0)
    goto basic_dispatch44294;
/* Here if argument TypeSingleFloat */

simple_binary_arithmetic_operation44273 : if (_trace) printf("simple_binary_arithmetic_operation44273:\n");
ADDS(0, f0, 1, f1, 2, f2); /* adds */
/* trapb force the trap to occur here */ // Force the trap to occur here
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
t8 = Type_SingleFloat;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
goto cachevalid;

basic_dispatch44294 : if (_trace) printf("basic_dispatch44294:\n");
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment44299 : if (_trace) printf("force_alignment44299:\n");
if (t12 == 0)
    goto basic_dispatch44295;
/* Here if argument TypeFixnum */
CVTLQ(2, f2, f31, 2, f2);
CVTQT(2, f2, f31, 2, f2);
goto simple_binary_arithmetic_operation44273;

basic_dispatch44295 : if (_trace) printf("basic_dispatch44295:\n");
t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

force_alignment44300 : if (_trace) printf("force_alignment44300:\n");
if (t12 == 0)
    goto binary_type_dispatch44280;
/* Here if argument TypeDoubleFloat */

simple_binary_arithmetic_operation44276 : if (_trace) printf("simple_binary_arithmetic_operation44276:\n");
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
goto simple_binary_arithmetic_operation44277;

basic_dispatch44293 : if (_trace) printf("basic_dispatch44293:\n");

basic_dispatch44292 : if (_trace) printf("basic_dispatch44292:\n");
t10 = (t9 == Type_DoubleFloat) ? 1 : 0;

force_alignment44314 : if (_trace) printf("force_alignment44314:\n");
if (t10 == 0)
    goto basic_dispatch44301;
/* Here if argument TypeDoubleFloat */
t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

force_alignment44307 : if (_trace) printf("force_alignment44307:\n");
if (t12 == 0)
    goto basic_dispatch44303;
/* Here if argument TypeDoubleFloat */
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
arg2 = (u32)t2;
r0 = (u64) && return0025;
goto fetchdoublefloat;
return0025 : LDT(1, f1, processor->fp0);

simple_binary_arithmetic_operation44277 : if (_trace) printf("simple_binary_arithmetic_operation44277:\n");
arg2 = (u32)t4;
r0 = (u64) && return0026;
goto fetchdoublefloat;
return0026 : LDT(2, f2, processor->fp0);

simple_binary_arithmetic_operation44274 : if (_trace) printf("simple_binary_arithmetic_operation44274:\n");
ADDT(0, f0, 1, f1, 2, f2); /* addt */
STT((u64 *)&processor->fp0, 0, f0);
r0 = (u64) && return0027;
goto consdoublefloat;
return0027 : iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
t8 = Type_DoubleFloat;
*(u32 *)iSP = arg2;
*(u32 *)(iSP + 4) = t8; // write the stack cache
goto cachevalid;

basic_dispatch44303 : if (_trace) printf("basic_dispatch44303:\n");
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment44308 : if (_trace) printf("force_alignment44308:\n");
if (t12 == 0)
    goto basic_dispatch44304;
/* Here if argument TypeSingleFloat */

simple_binary_arithmetic_operation44275 : if (_trace) printf("simple_binary_arithmetic_operation44275:\n");
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
arg2 = (u32)t2;
r0 = (u64) && return0028;
goto fetchdoublefloat;
return0028 : LDT(1, f1, processor->fp0);
goto simple_binary_arithmetic_operation44274;

basic_dispatch44304 : if (_trace) printf("basic_dispatch44304:\n");
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment44309 : if (_trace) printf("force_alignment44309:\n");
if (t12 == 0)
    goto binary_type_dispatch44280;
/* Here if argument TypeFixnum */
CVTLQ(2, f2, f31, 2, f2);
CVTQT(2, f2, f31, 2, f2);
goto simple_binary_arithmetic_operation44275;

basic_dispatch44302 : if (_trace) printf("basic_dispatch44302:\n");

basic_dispatch44301 : if (_trace) printf("basic_dispatch44301:\n");
/* Here for all other cases */

binary_type_dispatch44279 : if (_trace) printf("binary_type_dispatch44279:\n");

doaddovfl : if (_trace) printf("doaddovfl:\n");
arg6 = t1; // arg6 = tag to dispatch on
arg3 = 0; // arg3 = stackp
arg1 = 2; // arg1 = instruction arity
arg4 = 1; // arg4 = arithmeticp
goto numericexception;
goto binary_type_dispatch44281;

binary_type_dispatch44280 : if (_trace) printf("binary_type_dispatch44280:\n");
t1 = t3;
goto doaddovfl;

binary_type_dispatch44281 : if (_trace) printf("binary_type_dispatch44281:\n");

basic_dispatch44282 : if (_trace) printf("basic_dispatch44282:\n");

DoAddIM : if (_trace) printf("DoAddIM:\n");
t1 = (u32)(arg6 >> ((4 & 7) * 8));
t2 = (s32)arg6; // get ARG1 tag/data
t11 = t1 & 63; // Strip off any CDR code bits.
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment44319 : if (_trace) printf("force_alignment44319:\n");
if (t12 == 0)
    goto basic_dispatch44316;
/* Here if argument TypeFixnum */
t3 = t2 + arg2; // compute 64-bit result
t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
t10 = (s32)t3; // compute 32-bit sign-extended result
t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
t10 = (t3 == t10) ? 1 : 0; // is it the same as the 64-bit result?
if (t10 == 0) // if not, we overflowed
    goto doaddovfl;
*(u32 *)(iSP + 4) = t11; // Semi-cheat, we know temp2 has CDRNext/TypeFixnum
iPC = t4;
*(u32 *)iSP = t3;
iCP = t5;
goto cachevalid;

basic_dispatch44316 : if (_trace) printf("basic_dispatch44316:\n");
/* Here for all other cases */
*(u32 *)&processor->immediate_arg = arg2;
arg1 = (u64)&processor->immediate_arg;
arg2 = zero;
goto begindoadd;

basic_dispatch44315 : if (_trace) printf("basic_dispatch44315:\n");

/* end DoAdd */
/* End of Halfword operand from stack instruction - DoAdd */
/* start DoBlock3Write */

/* Halfword operand from stack instruction - DoBlock3Write */

doblock3write : if (_trace) printf("doblock3write:\n");
/* arg2 has the preloaded 8 bit operand. */

DoBlock3WriteIM : if (_trace) printf("DoBlock3WriteIM:\n");
/* This sequence only sucks a moderate amount */
arg2 = arg2 << 56; // sign extend the byte argument.

force_alignment44320 : if (_trace) printf("force_alignment44320:\n");
arg2 = (s64)arg2 >> 56; // Rest of sign extension
*(u32 *)&processor->immediate_arg = arg2;
arg1 = *(u64 *)&(processor->immediate_arg);
goto begindoblock3write;

DoBlock3WriteSP : if (_trace) printf("DoBlock3WriteSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoBlock3WriteLP : if (_trace) printf("DoBlock3WriteLP:\n");

DoBlock3WriteFP : if (_trace) printf("DoBlock3WriteFP:\n");

headdoblock3write : if (_trace) printf("headdoblock3write:\n");
arg1 = (arg2 * 8) + arg1; // Compute operand address
arg1 = *(u64 *)arg1; // Get the operand

begindoblock3write : if (_trace) printf("begindoblock3write:\n");
/* arg1 has the operand, sign extended if immediate. */
arg3 = *(s32 *)&processor->bar3;
arg2 = (u64)&processor->bar3;
goto blockwrite;

/* end DoBlock3Write */
/* End of Halfword operand from stack instruction - DoBlock3Write */
/* start DoAset1 */

/* Halfword operand from stack instruction - DoAset1 */
/* arg2 has the preloaded 8 bit operand. */

doaset1 : if (_trace) printf("doaset1:\n");

DoAset1SP : if (_trace) printf("DoAset1SP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoAset1LP : if (_trace) printf("DoAset1LP:\n");

DoAset1FP : if (_trace) printf("DoAset1FP:\n");

headdoaset1 : if (_trace) printf("headdoaset1:\n");
arg1 = (arg2 * 8) + arg1; // Compute operand address
arg1 = *(u64 *)arg1; // Get the operand

begindoaset1 : if (_trace) printf("begindoaset1:\n");
/* arg1 has the operand, not sign extended if immediate. */
arg4 = *(s32 *)iSP; // Get the array tag/data
arg3 = *(s32 *)(iSP + 4); // Get the array tag/data
iSP = iSP - 8; // Pop Stack.
arg4 = (u32)arg4;
t6 = *(s32 *)iSP; // Get the new value tag/data
t5 = *(s32 *)(iSP + 4); // Get the new value tag/data
iSP = iSP - 8; // Pop Stack.
t6 = (u32)t6;
arg2 = (s32)arg1 + (s32)0; // (sign-extended, for fast bounds check) Index Data
t8 = zero + AutoArrayRegMask;
t8 = arg4 & t8;
arg1 = arg1 >> 32; // Index Tag
t7 = (u64)&processor->ac0array;
t7 = t7 + t8; // This is the address if the array register block.
t1 = arg1 - Type_Fixnum;
t1 = t1 & 63; // Strip CDR code
if (t1 != 0)
    goto aset1illegal;

aset1merge : if (_trace) printf("aset1merge:\n");
if (arg4 == 0)
    goto aset1regset;
t8 = *(u64 *)&(((ARRAYCACHEP)t7)->array); // Cached array object.
t1 = arg3 - Type_Array;
t1 = t1 & 62; // Strip CDR code, low bits
if (t1 != 0)
    goto reallyaset1exc;
t8 = (arg4 == t8) ? 1 : 0; // t8==1 iff cached array is ours.
if (t8 == 0) // Go and setup the array register.
    goto aset1regset;
arg6 = *(u64 *)&(((ARRAYCACHEP)t7)->arword);
t9 = *(u64 *)&(((ARRAYCACHEP)t7)->locat); // high order bits all zero
t3 = *(u64 *)&(((ARRAYCACHEP)t7)->length); // high order bits all zero
t11 = arg6 << 42;
t4 = *(u64 *)&(processor->areventcount);
t11 = t11 >> 42;
t2 = ((u64)arg2 < (u64)t3) ? 1 : 0;
t12 = t4 - t11;
if (t12 != 0) // J. if event count ticked.
    goto aset1regset;
if (t2 == 0)
    goto aset1bounds;
arg5 = arg6 >> (Array_RegisterBytePackingPos & 63);
t8 = arg6 >> (Array_RegisterElementTypePos & 63);
arg4 = arg6 >> (Array_RegisterByteOffsetPos & 63);
arg5 = arg5 & Array_RegisterBytePackingMask;
arg4 = arg4 & Array_RegisterByteOffsetMask;
arg6 = t8 & Array_RegisterElementTypeMask;

aset1restart : if (_trace) printf("aset1restart:\n");
/* Element checking and foreplay. */
/* TagType. */
t1 = t5 & 63;
t8 = (arg6 == Array_ElementTypeCharacter) ? 1 : 0;

force_alignment44331 : if (_trace) printf("force_alignment44331:\n");
if (t8 == 0)
    goto basic_dispatch44327;
/* Here if argument ArrayElementTypeCharacter */
t2 = t1 - Type_Character;
if (t2 == 0)
    goto aset_1_internal44322;
arg5 = 0;
arg2 = 29;
goto illegaloperand;

aset_1_internal44322 : if (_trace) printf("aset_1_internal44322:\n");
if (arg5 == 0) // Certainly will fit if not packed!
    goto aset_1_internal44321;
t2 = 32;
t2 = t2 >> (arg5 & 63); // Compute size of byte
t1 = ~zero;
t1 = t1 << (t2 & 63);
t1 = ~t1; // Compute mask for byte
t1 = t6 & t1;
t1 = t6 - t1;
if (t1 == 0) // J. if character fits.
    goto aset_1_internal44321;
arg5 = 0;
arg2 = 62;
goto illegaloperand;

basic_dispatch44327 : if (_trace) printf("basic_dispatch44327:\n");
t8 = (arg6 == Array_ElementTypeFixnum) ? 1 : 0;

force_alignment44332 : if (_trace) printf("force_alignment44332:\n");
if (t8 == 0)
    goto basic_dispatch44328;
/* Here if argument ArrayElementTypeFixnum */
t2 = t1 - Type_Fixnum;
if (t2 == 0)
    goto aset_1_internal44321;
arg5 = 0;
arg2 = 33;
goto illegaloperand;

basic_dispatch44328 : if (_trace) printf("basic_dispatch44328:\n");
t8 = (arg6 == Array_ElementTypeBoolean) ? 1 : 0;

force_alignment44333 : if (_trace) printf("force_alignment44333:\n");
if (t8 == 0)
    goto basic_dispatch44326;
/* Here if argument ArrayElementTypeBoolean */
t6 = 1;
t1 = t1 - Type_NIL;
if (t1 != 0) // J. if True
    goto aset_1_internal44321;
t6 = zero;
goto aset_1_internal44321; // J. if False

basic_dispatch44326 : if (_trace) printf("basic_dispatch44326:\n");
/* Shove it in. */

aset_1_internal44321 : if (_trace) printf("aset_1_internal44321:\n");
if (arg5 != 0) // J. if packed
    goto aset_1_internal44323;
t1 = arg6 - Array_ElementTypeObject;
if (t1 != 0)
    goto aset_1_internal44323;
/* Here for the simple non packed case */
t1 = t9 + arg2;
/* Memory Read Internal */

vma_memory_read44334 : t4 = *(u64 *)&(processor->stackcachebasevma); // Base of stack cache
t8 = t1 + ivory;
t7 = *(s32 *)&processor->scovlimit;
t3 = (t8 * 4);
t2 = LDQ_U(t8);
t4 = t1 - t4; // Stack cache offset
arg1 = *(u64 *)&(processor->datawrite_mask);
t7 = ((u64)t4 < (u64)t7) ? 1 : 0; // In range?
t3 = *(s32 *)t3;
t2 = (u8)(t2 >> ((t8 & 7) * 8));
if (t7 != 0)
    goto vma_memory_read44336;

vma_memory_read44335 : t8 = zero + 240;
arg1 = arg1 >> (t2 & 63);
t8 = t8 >> (t2 & 63);
if (arg1 & 1)
    goto vma_memory_read44338;

vma_memory_read44344 :
    /* Merge cdr-code */
    t3
    = t5 & 63;
t2 = t2 & 192;
t2 = t2 | t3;
t7 = *(u64 *)&(processor->stackcachebasevma);
t4 = t1 + ivory;
arg1 = *(s32 *)&processor->scovlimit;
t3 = (t4 * 4);
t8 = LDQ_U(t4);
t7 = t1 - t7; // Stack cache offset
arg1 = ((u64)t7 < (u64)arg1) ? 1 : 0; // In range?
t7 = (t2 & 0xff) << ((t4 & 7) * 8);
t8 = t8 & ~(0xffL << (t4 & 7) * 8);

force_alignment44346 : if (_trace) printf("force_alignment44346:\n");
t8 = t8 | t7;
STQ_U(t4, t8);
*(u32 *)t3 = t6;
if (arg1 != 0) // J. if in cache
    goto vma_memory_write44345;
goto NEXTINSTRUCTION;
goto NEXTINSTRUCTION;
/* Here for the slow packed version */

aset_1_internal44323 : if (_trace) printf("aset_1_internal44323:\n");
arg2 = arg4 + arg2;
t1 = arg2 >> (arg5 & 63); // Convert byte index to word index
t1 = t1 + t9; // Address of word containing byte
/* Memory Read Internal */

vma_memory_read44347 : t2 = *(u64 *)&(processor->stackcachebasevma); // Base of stack cache
t4 = t1 + ivory;
t3 = *(s32 *)&processor->scovlimit;
t9 = (t4 * 4);
arg3 = LDQ_U(t4);
t2 = t1 - t2; // Stack cache offset
t7 = *(u64 *)&(processor->dataread_mask);
t3 = ((u64)t2 < (u64)t3) ? 1 : 0; // In range?
t9 = *(s32 *)t9;
arg3 = (u8)(arg3 >> ((t4 & 7) * 8));
if (t3 != 0)
    goto vma_memory_read44349;

vma_memory_read44348 : t4 = zero + 240;
t7 = t7 >> (arg3 & 63);
t4 = t4 >> (arg3 & 63);
t9 = (u32)t9;
if (t7 & 1)
    goto vma_memory_read44351;

vma_memory_read44358 :
    /* Check fixnum element type */
    /* TagType. */
    t2
    = arg3 & 63;
t2 = t2 - Type_Fixnum;
if (t2 != 0) // J. if element type not fixnum.
    goto aset_1_internal44324;
if (arg5 == 0) // J. if unpacked fixnum element type.
    goto aset_1_internal44325;
t8 = ~zero;
t8 = t8 << (arg5 & 63);
t2 = zero - arg5;
t8 = arg2 & ~t8; // Compute subword index
t2 = t2 + 5;
t2 = t8 << (t2 & 63); // Compute shift to get byte
t8 = 32;
t8 = t8 >> (arg5 & 63); // Compute size of byte
t3 = ~zero;
t3 = t3 << (t8 & 63);
t4 = ~t3; // Compute mask for byte
if (t2 == 0) // inserting into the low byte is easy
    goto array_element_dpb44359;
/* Inserting the byte into any byte other than the low byte */
t7 = 64;
t8 = t7 - t2; // = the left shift rotate amount
t7 = t9 >> (t2 & 63); // shift selected byte into low end of word.
t9 = t9 << (t8 & 63); // rotate low bits into high end of word.
t7 = t3 & t7; // Remove unwanted bits
t9 = t9 >> (t8 & 63); // rotate low bits back into place.
t8 = t6 & t4; // Strip any extra bits from element
t7 = t8 | t7; // Insert new bits.
t7 = t7 << (t2 & 63); // reposition bits
t9 = t9 | t7; // Replace low order bits
goto array_element_dpb44360;

array_element_dpb44359 : if (_trace) printf("array_element_dpb44359:\n");
/* Inserting the byte into the low byte */
t9 = t9 & t3; // Remove the old low byte
t8 = t6 & t4; // Remove unwanted bits from the new byte
t9 = t9 | t8; // Insert the new byte in place of the old byte

array_element_dpb44360 : if (_trace) printf("array_element_dpb44360:\n");
t6 = t9;

aset_1_internal44325 : if (_trace) printf("aset_1_internal44325:\n");
t3 = *(u64 *)&(processor->stackcachebasevma);
t2 = t1 + ivory;
t8 = *(s32 *)&processor->scovlimit;
t7 = (t2 * 4);
t4 = LDQ_U(t2);
t3 = t1 - t3; // Stack cache offset
t8 = ((u64)t3 < (u64)t8) ? 1 : 0; // In range?
t3 = (arg3 & 0xff) << ((t2 & 7) * 8);
t4 = t4 & ~(0xffL << (t2 & 7) * 8);

force_alignment44362 : if (_trace) printf("force_alignment44362:\n");
t4 = t4 | t3;
STQ_U(t2, t4);
*(u32 *)t7 = t6;
if (t8 != 0) // J. if in cache
    goto vma_memory_write44361;
goto NEXTINSTRUCTION;
goto NEXTINSTRUCTION;

aset_1_internal44324 : if (_trace) printf("aset_1_internal44324:\n");
arg5 = t1;
arg2 = 25;
goto illegaloperand;

DoAset1IM : if (_trace) printf("DoAset1IM:\n");
t8 = zero + AutoArrayRegMask;
arg4 = *(s32 *)iSP; // Get the array tag/data
arg3 = *(s32 *)(iSP + 4); // Get the array tag/data
iSP = iSP - 8; // Pop Stack.
arg4 = (u32)arg4;
t7 = (u64)&processor->ac0array;
t8 = arg4 & t8;
t7 = t7 + t8; // This is the address of the array register block.
t6 = *(s32 *)iSP; // Get the new value tag/data
t5 = *(s32 *)(iSP + 4); // Get the new value tag/data
iSP = iSP - 8; // Pop Stack.
t6 = (u32)t6;
goto aset1merge;

vma_memory_write44361 : if (_trace) printf("vma_memory_write44361:\n");
t3 = *(u64 *)&(processor->stackcachebasevma);

force_alignment44363 : if (_trace) printf("force_alignment44363:\n");
t2 = *(u64 *)&(processor->stackcachedata);
t3 = t1 - t3; // Stack cache offset
t2 = (t3 * 8) + t2; // reconstruct SCA
*(u32 *)t2 = t6; // Store in stack
*(u32 *)(t2 + 4) = arg3; // write the stack cache
goto NEXTINSTRUCTION;

vma_memory_read44349 : if (_trace) printf("vma_memory_read44349:\n");
t3 = *(u64 *)&(processor->stackcachedata);
t2 = (t2 * 8) + t3; // reconstruct SCA
t9 = *(s32 *)t2;
arg3 = *(s32 *)(t2 + 4); // Read from stack cache
goto vma_memory_read44348;

vma_memory_read44351 : if (_trace) printf("vma_memory_read44351:\n");
if ((t4 & 1) == 0)
    goto vma_memory_read44350;
t1 = (u32)t9; // Do the indirect thing
goto vma_memory_read44347;

vma_memory_read44350 : if (_trace) printf("vma_memory_read44350:\n");
t7 = *(u64 *)&(processor->dataread); // Load the memory action table for cycle
/* TagType. */
t4 = arg3 & 63; // Discard the CDR code
*(u64 *)&processor->vma = t1; // stash the VMA for the (likely) trap
t4 = (t4 * 4) + t7; // Adjust for a longword load
t7 = *(s32 *)t4; // Get the memory action

vma_memory_read44355 : if (_trace) printf("vma_memory_read44355:\n");
t4 = t7 & MemoryActionTransform;
if (t4 == 0)
    goto vma_memory_read44354;
arg3 = arg3 & ~63L;
arg3 = arg3 | Type_ExternalValueCellPointer;
goto vma_memory_read44358;

vma_memory_read44354 :

    vma_memory_read44353 :
    /* Perform memory action */
    arg1
    = t7;
arg2 = 0;
goto performmemoryaction;

vma_memory_write44345 : if (_trace) printf("vma_memory_write44345:\n");
t7 = *(u64 *)&(processor->stackcachebasevma);

force_alignment44364 : if (_trace) printf("force_alignment44364:\n");
t4 = *(u64 *)&(processor->stackcachedata);
t7 = t1 - t7; // Stack cache offset
t4 = (t7 * 8) + t4; // reconstruct SCA
*(u32 *)t4 = t6; // Store in stack
*(u32 *)(t4 + 4) = t2; // write the stack cache
goto NEXTINSTRUCTION;

vma_memory_read44336 : if (_trace) printf("vma_memory_read44336:\n");
t7 = *(u64 *)&(processor->stackcachedata);
t4 = (t4 * 8) + t7; // reconstruct SCA
t3 = *(s32 *)t4;
t2 = *(s32 *)(t4 + 4); // Read from stack cache
goto vma_memory_read44335;

vma_memory_read44338 : if (_trace) printf("vma_memory_read44338:\n");
if ((t8 & 1) == 0)
    goto vma_memory_read44337;
t1 = (u32)t3; // Do the indirect thing
goto vma_memory_read44334;

vma_memory_read44337 : if (_trace) printf("vma_memory_read44337:\n");
arg1 = *(u64 *)&(processor->datawrite); // Load the memory action table for cycle
/* TagType. */
t8 = t2 & 63; // Discard the CDR code
*(u64 *)&processor->vma = t1; // stash the VMA for the (likely) trap
t8 = (t8 * 4) + arg1; // Adjust for a longword load
arg1 = *(s32 *)t8; // Get the memory action

vma_memory_read44341 :

    vma_memory_read44340 :
    /* Perform memory action */
    arg1
    = arg1;
arg2 = 1;
goto performmemoryaction;

/* end DoAset1 */
/* End of Halfword operand from stack instruction - DoAset1 */
/* start DoFastAref1 */

/* Halfword operand from stack instruction - DoFastAref1 */
/* arg2 has the preloaded 8 bit operand. */

dofastaref1 : if (_trace) printf("dofastaref1:\n");

DoFastAref1SP : if (_trace) printf("DoFastAref1SP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto begindofastaref1;
arg6 = *(u64 *)arg4; // SP-pop, Reload TOS
arg1 = iSP; // SP-pop mode
iSP = arg4; // Adjust SP

DoFastAref1LP : if (_trace) printf("DoFastAref1LP:\n");

DoFastAref1FP : if (_trace) printf("DoFastAref1FP:\n");

begindofastaref1 : if (_trace) printf("begindofastaref1:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
arg3 = (u32)(arg6 >> ((4 & 7) * 8));
arg4 = (s32)arg6;
t1 = arg3 - Type_Fixnum;
t1 = t1 & 63; // Strip CDR code
if (t1 != 0)
    goto fastaref1iop;

fastaref1retry : if (_trace) printf("fastaref1retry:\n");
arg6 = *(s32 *)arg1;
t9 = *(s32 *)(arg1 + 8);
t3 = *(s32 *)(arg1 + 16);
arg6 = (u32)arg6;
t9 = (u32)t9;
t5 = arg6 << 42;
t3 = (u32)t3;
t4 = *(u64 *)&(processor->areventcount);
t5 = t5 >> 42;
t2 = ((u64)arg4 < (u64)t3) ? 1 : 0;
if (t2 == 0)
    goto fastaref1bounds;
t6 = t4 - t5;
if (t6 != 0)
    goto aref1recomputearrayregister;
t6 = arg6 >> (Array_RegisterBytePackingPos & 63);
t7 = arg6 >> (Array_RegisterByteOffsetPos & 63);
t8 = arg6 >> (Array_RegisterElementTypePos & 63);
t6 = t6 & Array_RegisterBytePackingMask;
t7 = t7 & Array_RegisterByteOffsetMask;
t8 = t8 & Array_RegisterElementTypeMask;
if (t6 != 0)
    goto new_aref_1_internal44365;
t1 = t9 + arg4;

new_aref_1_internal44366 : if (_trace) printf("new_aref_1_internal44366:\n");
/* Memory Read Internal */

vma_memory_read44373 : t2 = *(u64 *)&(processor->stackcachebasevma); // Base of stack cache
t4 = t1 + ivory;
t3 = *(s32 *)&processor->scovlimit;
t9 = (t4 * 4);
arg5 = LDQ_U(t4);
t2 = t1 - t2; // Stack cache offset
t5 = *(u64 *)&(processor->dataread_mask);
t3 = ((u64)t2 < (u64)t3) ? 1 : 0; // In range?
t9 = *(s32 *)t9;
arg5 = (u8)(arg5 >> ((t4 & 7) * 8));
if (t3 != 0)
    goto vma_memory_read44375;

vma_memory_read44374 : t4 = zero + 240;
t5 = t5 >> (arg5 & 63);
t4 = t4 >> (arg5 & 63);
t9 = (u32)t9;
if (t5 & 1)
    goto vma_memory_read44377;

vma_memory_read44384 : if (t6 != 0) goto new_aref_1_internal44367;

new_aref_1_internal44368 : if (_trace) printf("new_aref_1_internal44368:\n");
r31 = r31 | r31;
t1 = t8 - 2;
if ((s64)t1 <= 0)
    goto new_aref_1_internal44369;
/* TagType. */
arg5 = arg5 & 63;

new_aref_1_internal44370 : if (_trace) printf("new_aref_1_internal44370:\n");
*(u32 *)(iSP + 4) = arg5;
t4 = (t6 == 0) ? 1 : 0;
if (t4 == 0)
    goto case_others_259;

case_0_253 : if (_trace) printf("case_0_253:\n");
r31 = r31 | r31;
if (t1 == 0)
    goto new_aref_1_internal44371;
*(u32 *)iSP = t9;
goto NEXTINSTRUCTION;

case_2_254 : if (_trace) printf("case_2_254:\n");
/* AREF1-8B */
r31 = r31 | r31;
t4 = arg4 & 3;
t5 = (u8)(t9 >> ((t4 & 7) * 8));
if (t1 == 0)
    goto new_aref_1_internal44371;
*(u32 *)iSP = t5;
goto NEXTINSTRUCTION;

case_3_255 : if (_trace) printf("case_3_255:\n");
/* AREF1-4B */
r31 = r31 | r31;
t4 = arg4 & 7; // byte-index
t4 = t4 << 2; // byte-position
t5 = t9 >> (t4 & 63); // byte in position
t5 = t5 & 15; // byte masked
if (t1 == 0)
    goto new_aref_1_internal44371;
*(u32 *)iSP = t5;
goto NEXTINSTRUCTION;

case_5_256 : if (_trace) printf("case_5_256:\n");
/* AREF1-1B */
r31 = r31 | r31;
t4 = arg4 & 31; // byte-index
r31 = r31 | r31;
t5 = t9 >> (t4 & 63); // byte in position
t5 = t5 & 1; // byte masked
if (t1 == 0)
    goto new_aref_1_internal44371;
*(u32 *)iSP = t5;
goto NEXTINSTRUCTION;

case_1_257 : if (_trace) printf("case_1_257:\n");
/* AREF1-16B */
t4 = arg4 & 1;
t4 = t4 + t4; // Bletch, it's a byte ref
t5 = (u16)(t9 >> ((t4 & 7) * 8));
if (t1 == 0)
    goto new_aref_1_internal44371;
*(u32 *)iSP = t5;
goto NEXTINSTRUCTION;

case_others_259 : if (_trace) printf("case_others_259:\n");
r31 = r31 | r31;
t4 = (t6 == 2) ? 1 : 0;
t5 = (t6 == 3) ? 1 : 0;
if (t4 != 0)
    goto case_2_254;
t4 = (t6 == 5) ? 1 : 0;
if (t5 != 0)
    goto case_3_255;
t5 = (t6 == 1) ? 1 : 0;
if (t4 != 0)
    goto case_5_256;
if (t5 != 0)
    goto case_1_257;

case_4_258 : if (_trace) printf("case_4_258:\n");
/* AREF1-2B */
r31 = r31 | r31;
t4 = arg4 & 15; // byte-index
t4 = t4 << 1; // byte-position
t5 = t9 >> (t4 & 63); // byte in position
t5 = t5 & 3; // byte masked
if (t1 == 0)
    goto new_aref_1_internal44371;
*(u32 *)iSP = t5;
goto NEXTINSTRUCTION;

new_aref_1_internal44365 : if (_trace) printf("new_aref_1_internal44365:\n");
arg4 = t7 + arg4;
t1 = arg4 >> (t6 & 63); // Convert byte index to word index
t1 = t1 + t9; // Address of word containing byte
goto new_aref_1_internal44366;

new_aref_1_internal44367 : if (_trace) printf("new_aref_1_internal44367:\n");
t1 = arg5 - Type_Fixnum;
t1 = t1 & 63; // Strip CDR code
if (t1 != 0)
    goto new_aref_1_internal44372;
goto new_aref_1_internal44368;

new_aref_1_internal44369 : if (_trace) printf("new_aref_1_internal44369:\n");
arg5 = Type_Character;
if (t8 & 1)
    goto new_aref_1_internal44370;
arg5 = Type_Fixnum;
if (t8 == 0)
    goto new_aref_1_internal44370;
t2 = *(u64 *)&(processor->niladdress);
t3 = *(u64 *)&(processor->taddress);
goto new_aref_1_internal44370;

new_aref_1_internal44371 : if (_trace) printf("new_aref_1_internal44371:\n");
if (t5)
    t2 = t3;
*(u64 *)iSP = t2;
goto NEXTINSTRUCTION;

new_aref_1_internal44372 : if (_trace) printf("new_aref_1_internal44372:\n");
arg5 = t1;
arg2 = 25;
goto illegaloperand;

fastaref1iop : if (_trace) printf("fastaref1iop:\n");
arg5 = 0;
arg2 = 32;
goto illegaloperand;

fastaref1bounds : if (_trace) printf("fastaref1bounds:\n");
arg5 = 0;
arg2 = 13;
goto illegaloperand;

vma_memory_read44375 : if (_trace) printf("vma_memory_read44375:\n");
t3 = *(u64 *)&(processor->stackcachedata);
t2 = (t2 * 8) + t3; // reconstruct SCA
t9 = *(s32 *)t2;
arg5 = *(s32 *)(t2 + 4); // Read from stack cache
goto vma_memory_read44374;

vma_memory_read44377 : if (_trace) printf("vma_memory_read44377:\n");
if ((t4 & 1) == 0)
    goto vma_memory_read44376;
t1 = (u32)t9; // Do the indirect thing
goto vma_memory_read44373;

vma_memory_read44376 : if (_trace) printf("vma_memory_read44376:\n");
t5 = *(u64 *)&(processor->dataread); // Load the memory action table for cycle
/* TagType. */
t4 = arg5 & 63; // Discard the CDR code
*(u64 *)&processor->vma = t1; // stash the VMA for the (likely) trap
t4 = (t4 * 4) + t5; // Adjust for a longword load
t5 = *(s32 *)t4; // Get the memory action

vma_memory_read44381 : if (_trace) printf("vma_memory_read44381:\n");
t4 = t5 & MemoryActionTransform;
if (t4 == 0)
    goto vma_memory_read44380;
arg5 = arg5 & ~63L;
arg5 = arg5 | Type_ExternalValueCellPointer;
goto vma_memory_read44384;

vma_memory_read44380 :

    vma_memory_read44379 :
    /* Perform memory action */
    arg1
    = t5;
arg2 = 0;
goto performmemoryaction;

DoFastAref1IM : goto doistageerror;

/* end DoFastAref1 */
/* End of Halfword operand from stack instruction - DoFastAref1 */
/* start DoRplaca */

/* Halfword operand from stack instruction - DoRplaca */

dorplaca : if (_trace) printf("dorplaca:\n");
/* arg2 has the preloaded 8 bit operand. */

DoRplacaIM : if (_trace) printf("DoRplacaIM:\n");
/* This sequence only sucks a moderate amount */
arg2 = arg2 << 56; // sign extend the byte argument.

force_alignment44398 : if (_trace) printf("force_alignment44398:\n");
arg2 = (s64)arg2 >> 56; // Rest of sign extension
*(u32 *)&processor->immediate_arg = arg2;
arg1 = *(u64 *)&(processor->immediate_arg);
goto begindorplaca;

DoRplacaSP : if (_trace) printf("DoRplacaSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto headdorplaca;
arg1 = arg6; // SP-pop mode, TOS->arg1
arg6 = *(u64 *)arg4; // Reload TOS
iSP = arg4; // Adjust SP
goto begindorplaca;

DoRplacaLP : if (_trace) printf("DoRplacaLP:\n");

DoRplacaFP : if (_trace) printf("DoRplacaFP:\n");

headdorplaca : if (_trace) printf("headdorplaca:\n");
arg1 = (arg2 * 8) + arg1; // Compute operand address
arg1 = *(u64 *)arg1; // Get the operand

begindorplaca : if (_trace) printf("begindorplaca:\n");
/* arg1 has the operand, sign extended if immediate. */
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
t1 = (u32)(arg6 >> ((4 & 7) * 8));
arg2 = (u32)arg6; // Read ARG1, the list
iSP = iSP - 8; // Pop Stack.
/* TagType. */
t3 = t1 & 63;
t4 = t3 - Type_List;
t4 = t4 & ~4L;
if (t4 != 0)
    goto rplacaexception;

rplacstore : if (_trace) printf("rplacstore:\n");
t2 = arg1 >> 32; // Tag for t2
arg1 = (u32)arg1; // data for t2
/* Memory Read Internal */

vma_memory_read44385 : t7 = arg2 + ivory;
arg6 = (t7 * 4);
arg5 = LDQ_U(t7);
t5 = arg2 - t11; // Stack cache offset
t8 = *(u64 *)&(processor->datawrite_mask);
t6 = ((u64)t5 < (u64)t12) ? 1 : 0; // In range?
arg6 = *(s32 *)arg6;
arg5 = (u8)(arg5 >> ((t7 & 7) * 8));
if (t6 != 0)
    goto vma_memory_read44387;

vma_memory_read44386 : t7 = zero + 240;
t8 = t8 >> (arg5 & 63);
t7 = t7 >> (arg5 & 63);
if (t8 & 1)
    goto vma_memory_read44389;

vma_memory_read44395 :
    /* Merge cdr-code */
    arg6
    = t2 & 63;
arg5 = arg5 & 192;
arg5 = arg5 | arg6;
t5 = arg2 + ivory;
arg6 = (t5 * 4);
t7 = LDQ_U(t5);
t6 = arg2 - t11; // Stack cache offset
t8 = ((u64)t6 < (u64)t12) ? 1 : 0; // In range?
t6 = (arg5 & 0xff) << ((t5 & 7) * 8);
t7 = t7 & ~(0xffL << (t5 & 7) * 8);

force_alignment44397 : if (_trace) printf("force_alignment44397:\n");
t7 = t7 | t6;
STQ_U(t5, t7);
*(u32 *)arg6 = arg1;
if (t8 != 0) // J. if in cache
    goto vma_memory_write44396;
goto NEXTINSTRUCTION;
goto NEXTINSTRUCTION;

vma_memory_write44396 : if (_trace) printf("vma_memory_write44396:\n");
t5 = *(u64 *)&(processor->stackcachedata);
t6 = arg2 - t11; // Stack cache offset
t5 = (t6 * 8) + t5; // reconstruct SCA
*(u32 *)t5 = arg1; // Store in stack
*(u32 *)(t5 + 4) = arg5; // write the stack cache
goto NEXTINSTRUCTION;

vma_memory_read44387 : if (_trace) printf("vma_memory_read44387:\n");
t6 = *(u64 *)&(processor->stackcachedata);
t5 = (t5 * 8) + t6; // reconstruct SCA
arg6 = *(s32 *)t5;
arg5 = *(s32 *)(t5 + 4); // Read from stack cache
goto vma_memory_read44386;

vma_memory_read44389 : if (_trace) printf("vma_memory_read44389:\n");
if ((t7 & 1) == 0)
    goto vma_memory_read44388;
arg2 = (u32)arg6; // Do the indirect thing
goto vma_memory_read44385;

vma_memory_read44388 : if (_trace) printf("vma_memory_read44388:\n");
t8 = *(u64 *)&(processor->datawrite); // Load the memory action table for cycle
/* TagType. */
t7 = arg5 & 63; // Discard the CDR code
*(u64 *)&processor->vma = arg2; // stash the VMA for the (likely) trap
t7 = (t7 * 4) + t8; // Adjust for a longword load
t8 = *(s32 *)t7; // Get the memory action

vma_memory_read44392 :

    vma_memory_read44391 :
    /* Perform memory action */
    arg1
    = t8;
arg2 = 1;
goto performmemoryaction;

/* end DoRplaca */
/* End of Halfword operand from stack instruction - DoRplaca */
/* start MemoryReadWrite */

memoryreadwrite : if (_trace) printf("memoryreadwrite:\n");
/* Memory Read Internal */

vma_memory_read44399 : t7 = arg2 + ivory;
arg6 = (t7 * 4);
arg5 = LDQ_U(t7);
t5 = arg2 - t11; // Stack cache offset
t8 = *(u64 *)&(processor->datawrite_mask);
t6 = ((u64)t5 < (u64)t12) ? 1 : 0; // In range?
arg6 = *(s32 *)arg6;
arg5 = (u8)(arg5 >> ((t7 & 7) * 8));
if (t6 != 0)
    goto vma_memory_read44401;

vma_memory_read44400 : t7 = zero + 240;
t8 = t8 >> (arg5 & 63);
t7 = t7 >> (arg5 & 63);
arg6 = (u32)arg6;
if (t8 & 1)
    goto vma_memory_read44403;

vma_memory_read44408 : goto *r0; /* ret */

memoryreadwritedecode : if (_trace) printf("memoryreadwritedecode:\n");
if (t6 == 0)
    goto vma_memory_read44402;

vma_memory_read44401 : if (_trace) printf("vma_memory_read44401:\n");
t6 = *(u64 *)&(processor->stackcachedata);
t5 = (t5 * 8) + t6; // reconstruct SCA
arg6 = *(s32 *)t5;
arg5 = *(s32 *)(t5 + 4); // Read from stack cache
goto vma_memory_read44400;

vma_memory_read44403 : if (_trace) printf("vma_memory_read44403:\n");
if ((t7 & 1) == 0)
    goto vma_memory_read44402;
arg2 = (u32)arg6; // Do the indirect thing
goto vma_memory_read44399;

vma_memory_read44402 : if (_trace) printf("vma_memory_read44402:\n");
t8 = *(u64 *)&(processor->datawrite); // Load the memory action table for cycle
/* TagType. */
t7 = arg5 & 63; // Discard the CDR code
*(u64 *)&processor->vma = arg2; // stash the VMA for the (likely) trap
t7 = (t7 * 4) + t8; // Adjust for a longword load
t8 = *(s32 *)t7; // Get the memory action

vma_memory_read44405 :

    vma_memory_read44404 :
    /* Perform memory action */
    arg1
    = t8;
arg2 = 1;
goto performmemoryaction;

/* end MemoryReadWrite */
/* start DoRplacd */

/* Halfword operand from stack instruction - DoRplacd */

dorplacd : if (_trace) printf("dorplacd:\n");
/* arg2 has the preloaded 8 bit operand. */

DoRplacdIM : if (_trace) printf("DoRplacdIM:\n");
/* This sequence only sucks a moderate amount */
arg2 = arg2 << 56; // sign extend the byte argument.

force_alignment44419 : if (_trace) printf("force_alignment44419:\n");
arg2 = (s64)arg2 >> 56; // Rest of sign extension
*(u32 *)&processor->immediate_arg = arg2;
arg1 = *(u64 *)&(processor->immediate_arg);
goto begindorplacd;

DoRplacdSP : if (_trace) printf("DoRplacdSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto headdorplacd;
arg1 = arg6; // SP-pop mode, TOS->arg1
arg6 = *(u64 *)arg4; // Reload TOS
iSP = arg4; // Adjust SP
goto begindorplacd;

DoRplacdLP : if (_trace) printf("DoRplacdLP:\n");

DoRplacdFP : if (_trace) printf("DoRplacdFP:\n");

headdorplacd : if (_trace) printf("headdorplacd:\n");
arg1 = (arg2 * 8) + arg1; // Compute operand address
arg1 = *(u64 *)arg1; // Get the operand

begindorplacd : if (_trace) printf("begindorplacd:\n");
/* arg1 has the operand, sign extended if immediate. */
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
t1 = (u32)(arg6 >> ((4 & 7) * 8));
arg2 = (u32)arg6; // Read ARG1, the list
iSP = iSP - 8; // Pop Stack.
/* TagType. */
t3 = t1 & 63;
t4 = t3 - Type_Locative;
if (t4 == 0)
    goto rplacstore;
t4 = t3 - Type_List;
if (t4 != 0)
    goto rplacdexception;
/* Memory Read Internal */

vma_memory_read44409 : t7 = arg2 + ivory;
arg6 = (t7 * 4);
arg5 = LDQ_U(t7);
t5 = arg2 - t11; // Stack cache offset
t8 = *(u64 *)&(processor->cdr_mask);
t6 = ((u64)t5 < (u64)t12) ? 1 : 0; // In range?
arg6 = *(s32 *)arg6;
arg5 = (u8)(arg5 >> ((t7 & 7) * 8));
if (t6 != 0)
    goto vma_memory_read44411;

vma_memory_read44410 : t7 = zero + 192;
t8 = t8 >> (arg5 & 63);
t7 = t7 >> (arg5 & 63);
if (t8 & 1)
    goto vma_memory_read44413;

vma_memory_read44418 :
    /* TagCdr. */
    arg5
    = arg5 >> 6;
arg5 = arg5 - Cdr_Normal;
if (arg5 != 0) // J. if CDR coded
    goto rplacdexception;
arg2 = arg2 + 1; // address of CDR
goto rplacstore;

vma_memory_read44413 : if (_trace) printf("vma_memory_read44413:\n");
if ((t7 & 1) == 0)
    goto vma_memory_read44412;
arg2 = (u32)arg6; // Do the indirect thing
goto vma_memory_read44409;

vma_memory_read44412 : if (_trace) printf("vma_memory_read44412:\n");

vma_memory_read44411 : if (_trace) printf("vma_memory_read44411:\n");
r0 = (u64) && return0029;
goto memoryreadcdrdecode;
return0029 : goto vma_memory_read44418;

/* end DoRplacd */
/* End of Halfword operand from stack instruction - DoRplacd */
/* start DoBranchTrueAndExtraPop */

/* Halfword 10 bit immediate instruction - DoBranchTrueAndExtraPop */

dobranchtrueandextrapop : if (_trace) printf("dobranchtrueandextrapop:\n");
/* Actually only one entry point, but simulate others for dispatch */

DoBranchTrueAndExtraPopIM : if (_trace) printf("DoBranchTrueAndExtraPopIM:\n");

DoBranchTrueAndExtraPopSP : if (_trace) printf("DoBranchTrueAndExtraPopSP:\n");

DoBranchTrueAndExtraPopLP : if (_trace) printf("DoBranchTrueAndExtraPopLP:\n");

DoBranchTrueAndExtraPopFP : if (_trace) printf("DoBranchTrueAndExtraPopFP:\n");
/* arg1 has signed operand preloaded. */
t1 = (u32)(arg6 >> ((4 & 7) * 8)); // Check tag of word in TOS.
arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
arg1 = (s64)arg3 >> 48; // Get signed 10-bit immediate arg
/* TagType. */
t1 = t1 & 63; // strip the cdr code off.
t1 = t1 - Type_NIL; // Compare to NIL
if (t1 != 0)
    goto dobrpopextrapop;
/* Here if branch not taken.  Pop the argument. */
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
iSP = iSP - 8;
goto cachevalid;

dobrpopextrapop : if (_trace) printf("dobrpopextrapop:\n");
if (arg1 == 0) // Can't branch to ourself
    goto branchexception;
iSP = iSP - 16;
iPC = iPC + arg1; // Update the PC in halfwords
if (arg2 != 0)
    goto interpretinstructionpredicted;
goto interpretinstructionforbranch;

/* end DoBranchTrueAndExtraPop */
/* End of Halfword operand from stack instruction - DoBranchTrueAndExtraPop */
/* start DoBranchFalseAndExtraPop */

/* Halfword 10 bit immediate instruction - DoBranchFalseAndExtraPop */

dobranchfalseandextrapop : if (_trace) printf("dobranchfalseandextrapop:\n");
/* Actually only one entry point, but simulate others for dispatch */

DoBranchFalseAndExtraPopIM : if (_trace) printf("DoBranchFalseAndExtraPopIM:\n");

DoBranchFalseAndExtraPopSP : if (_trace) printf("DoBranchFalseAndExtraPopSP:\n");

DoBranchFalseAndExtraPopLP : if (_trace) printf("DoBranchFalseAndExtraPopLP:\n");

DoBranchFalseAndExtraPopFP : if (_trace) printf("DoBranchFalseAndExtraPopFP:\n");
/* arg1 has signed operand preloaded. */
t1 = (u32)(arg6 >> ((4 & 7) * 8)); // Check tag of word in TOS.
arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
arg1 = (s64)arg3 >> 48; // Get signed 10-bit immediate arg
/* TagType. */
t1 = t1 & 63; // strip the cdr code off.
t1 = t1 - Type_NIL; // Compare to NIL
if (t1 == 0)
    goto dobrnpopextrapop;
/* Here if branch not taken.  Pop the argument. */
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
iSP = iSP - 8;
goto cachevalid;

dobrnpopextrapop : if (_trace) printf("dobrnpopextrapop:\n");
if (arg1 == 0) // Can't branch to ourself
    goto branchexception;
iSP = iSP - 16;
iPC = iPC + arg1; // Update the PC in halfwords
if (arg2 != 0)
    goto interpretinstructionpredicted;
goto interpretinstructionforbranch;

/* end DoBranchFalseAndExtraPop */
/* End of Halfword operand from stack instruction - DoBranchFalseAndExtraPop */
/* start DoBranchTrueAndNoPop */

/* Halfword 10 bit immediate instruction - DoBranchTrueAndNoPop */

dobranchtrueandnopop : if (_trace) printf("dobranchtrueandnopop:\n");
/* Actually only one entry point, but simulate others for dispatch */

DoBranchTrueAndNoPopIM : if (_trace) printf("DoBranchTrueAndNoPopIM:\n");

DoBranchTrueAndNoPopSP : if (_trace) printf("DoBranchTrueAndNoPopSP:\n");

DoBranchTrueAndNoPopLP : if (_trace) printf("DoBranchTrueAndNoPopLP:\n");

DoBranchTrueAndNoPopFP : if (_trace) printf("DoBranchTrueAndNoPopFP:\n");
/* arg1 has signed operand preloaded. */
t1 = (u32)(arg6 >> ((4 & 7) * 8)); // Check tag of word in TOS.
arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
arg1 = (s64)arg3 >> 48; // Get signed 10-bit immediate arg
/* TagType. */
t1 = t1 & 63; // strip the cdr code off.
t1 = t1 - Type_NIL; // Compare to NIL
if (t1 != 0)
    goto dobrelsepop;
/* Here if branch not taken.  Pop the argument. */
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
iSP = iSP - 8;
goto cachevalid;

dobrelsepop : if (_trace) printf("dobrelsepop:\n");
if (arg1 == 0) // Can't branch to ourself
    goto branchexception;
iPC = iPC + arg1; // Update the PC in halfwords
if (arg2 != 0)
    goto interpretinstructionpredicted;
goto interpretinstructionforbranch;

/* end DoBranchTrueAndNoPop */
/* End of Halfword operand from stack instruction - DoBranchTrueAndNoPop */
/* start DoBranchFalseAndNoPop */

/* Halfword 10 bit immediate instruction - DoBranchFalseAndNoPop */

dobranchfalseandnopop : if (_trace) printf("dobranchfalseandnopop:\n");
/* Actually only one entry point, but simulate others for dispatch */

DoBranchFalseAndNoPopIM : if (_trace) printf("DoBranchFalseAndNoPopIM:\n");

DoBranchFalseAndNoPopSP : if (_trace) printf("DoBranchFalseAndNoPopSP:\n");

DoBranchFalseAndNoPopLP : if (_trace) printf("DoBranchFalseAndNoPopLP:\n");

DoBranchFalseAndNoPopFP : if (_trace) printf("DoBranchFalseAndNoPopFP:\n");
/* arg1 has signed operand preloaded. */
t1 = (u32)(arg6 >> ((4 & 7) * 8)); // Check tag of word in TOS.
arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
arg1 = (s64)arg3 >> 48; // Get signed 10-bit immediate arg
/* TagType. */
t1 = t1 & 63; // strip the cdr code off.
t1 = t1 - Type_NIL; // Compare to NIL
if (t1 == 0)
    goto dobrnelsepop;
/* Here if branch not taken.  Pop the argument. */
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
iSP = iSP - 8;
goto cachevalid;

dobrnelsepop : if (_trace) printf("dobrnelsepop:\n");
if (arg1 == 0) // Can't branch to ourself
    goto branchexception;
iPC = iPC + arg1; // Update the PC in halfwords
if (arg2 != 0)
    goto interpretinstructionpredicted;
goto interpretinstructionforbranch;

/* end DoBranchFalseAndNoPop */
/* End of Halfword operand from stack instruction - DoBranchFalseAndNoPop */
/* start DoBranchFalseElseNoPop */

/* Halfword 10 bit immediate instruction - DoBranchFalseElseNoPop */

dobranchfalseelsenopop : if (_trace) printf("dobranchfalseelsenopop:\n");
/* Actually only one entry point, but simulate others for dispatch */

DoBranchFalseElseNoPopIM : if (_trace) printf("DoBranchFalseElseNoPopIM:\n");

DoBranchFalseElseNoPopSP : if (_trace) printf("DoBranchFalseElseNoPopSP:\n");

DoBranchFalseElseNoPopLP : if (_trace) printf("DoBranchFalseElseNoPopLP:\n");

DoBranchFalseElseNoPopFP : if (_trace) printf("DoBranchFalseElseNoPopFP:\n");
/* arg1 has signed operand preloaded. */
t1 = (u32)(arg6 >> ((4 & 7) * 8)); // Check tag of word in TOS.
arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
arg1 = (s64)arg3 >> 48; // Get signed 10-bit immediate arg
/* TagType. */
t1 = t1 & 63; // strip the cdr code off.
t1 = t1 - Type_NIL; // Compare to NIL
if (t1 != 0)
    goto NEXTINSTRUCTION;
if (arg1 == 0) // Can't branch to ourself
    goto branchexception;
iSP = iSP - 8;
iPC = iPC + arg1; // Update the PC in halfwords
if (arg2 != 0)
    goto interpretinstructionpredicted;
goto interpretinstructionforbranch;

/* end DoBranchFalseElseNoPop */
/* End of Halfword operand from stack instruction - DoBranchFalseElseNoPop */
/* start DoEqualNumber */

/* Halfword operand from stack instruction - DoEqualNumber */
/* arg2 has the preloaded 8 bit operand. */

doequalnumber : if (_trace) printf("doequalnumber:\n");

DoEqualNumberSP : if (_trace) printf("DoEqualNumberSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto begindoequalnumber;
arg6 = *(u64 *)arg4; // SP-pop, Reload TOS
arg1 = iSP; // SP-pop mode
iSP = arg4; // Adjust SP

DoEqualNumberLP : if (_trace) printf("DoEqualNumberLP:\n");

DoEqualNumberFP : if (_trace) printf("DoEqualNumberFP:\n");

begindoequalnumber : if (_trace) printf("begindoequalnumber:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
t11 = *(u64 *)&(processor->niladdress);
t7 = arg3 >> 12;
t12 = *(u64 *)&(processor->taddress);
arg3 = (u32)(arg6 >> ((4 & 7) * 8)); // Get ARG1 tag
t1 = *(s32 *)(arg1 + 4); // t1 is tag of arg2
LDS(1, f1, *(u32 *)iSP);
t7 = t7 & 1;
arg2 = *(s32 *)arg1;
arg4 = (s32)arg6;
LDS(2, f2, *(u32 *)arg1);
t5 = arg3 & 63; // Strip off any CDR code bits.
t4 = t1 & 63; // Strip off any CDR code bits.
t6 = (t5 == Type_Fixnum) ? 1 : 0;

force_alignment44437 : if (_trace) printf("force_alignment44437:\n");
if (t6 == 0)
    goto basic_dispatch44425;
/* Here if argument TypeFixnum */
t3 = (t4 == Type_Fixnum) ? 1 : 0;

force_alignment44429 : if (_trace) printf("force_alignment44429:\n");
if (t3 == 0)
    goto binary_type_dispatch44420;
/* Here if argument TypeFixnum */
t2 = (s32)arg4 - (s32)arg2;
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iSP = (t7 * 8) + iSP; // Pop/No-pop
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
if (t2 == 0) // T if the test succeeds
    t11 = t12;
*(u64 *)iSP = t11;
goto cachevalid;

basic_dispatch44426 : if (_trace) printf("basic_dispatch44426:\n");

basic_dispatch44425 : if (_trace) printf("basic_dispatch44425:\n");
t6 = (t5 == Type_SingleFloat) ? 1 : 0;

force_alignment44438 : if (_trace) printf("force_alignment44438:\n");
if (t6 == 0)
    goto basic_dispatch44430;
/* Here if argument TypeSingleFloat */
t3 = (t4 == Type_SingleFloat) ? 1 : 0;

force_alignment44434 : if (_trace) printf("force_alignment44434:\n");
if (t3 == 0)
    goto binary_type_dispatch44420;
/* Here if argument TypeSingleFloat */

equalnumbermmexcfltflt : if (_trace) printf("equalnumbermmexcfltflt:\n");
SETFLTT(3, f3, FLTU64(1, f1) == FLTU64(2, f2) ? 2.0 : 0);
/* trapb force the trap to occur here */ // Force the trap to occur here
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iSP = (t7 * 8) + iSP;
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
*(u64 *)iSP = t12;
if (FLTU64(3, f3) != 0.0)
    goto cachevalid;
*(u64 *)iSP = t11; // Didn't branch, answer is NIL
goto cachevalid;

basic_dispatch44431 : if (_trace) printf("basic_dispatch44431:\n");

basic_dispatch44430 : if (_trace) printf("basic_dispatch44430:\n");
/* Here for all other cases */

binary_type_dispatch44420 : if (_trace) printf("binary_type_dispatch44420:\n");
goto equalnumbermmexc;

basic_dispatch44424 : if (_trace) printf("basic_dispatch44424:\n");

DoEqualNumberIM : if (_trace) printf("DoEqualNumberIM:\n");
t11 = *(u64 *)&(processor->niladdress);
arg2 = arg2 << 56; // First half of sign extension
t12 = *(u64 *)&(processor->taddress);
t7 = arg3 >> 12;
arg3 = (u32)(arg6 >> ((4 & 7) * 8));
arg4 = (s32)arg6;
arg2 = (s64)arg2 >> 56; // Second half of sign extension
t7 = t7 & 1;
t3 = arg3 & 63; // Strip off any CDR code bits.
t4 = (t3 == Type_Fixnum) ? 1 : 0;

force_alignment44443 : if (_trace) printf("force_alignment44443:\n");
if (t4 == 0)
    goto basic_dispatch44440;
/* Here if argument TypeFixnum */
t2 = (s32)arg4 - (s32)arg2;
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iSP = (t7 * 8) + iSP;
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
if (t2 == 0) // T if the test succeeds
    t11 = t12;
*(u64 *)iSP = t11;
goto cachevalid;

basic_dispatch44440 : if (_trace) printf("basic_dispatch44440:\n");
/* Here for all other cases */
arg6 = arg3; // arg6 = tag to dispatch on
arg3 = 0; // arg3 = stackp
arg1 = 2; // arg1 = instruction arity
arg4 = 1; // arg4 = arithmeticp
goto numericexception;

basic_dispatch44439 : if (_trace) printf("basic_dispatch44439:\n");

/* end DoEqualNumber */
/* End of Halfword operand from stack instruction - DoEqualNumber */
/* start DoSetToCdrPushCar */

/* Halfword operand from stack instruction - DoSetToCdrPushCar */
/* arg2 has the preloaded 8 bit operand. */

dosettocdrpushcar : if (_trace) printf("dosettocdrpushcar:\n");

DoSetToCdrPushCarSP : if (_trace) printf("DoSetToCdrPushCarSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoSetToCdrPushCarLP : if (_trace) printf("DoSetToCdrPushCarLP:\n");

DoSetToCdrPushCarFP : if (_trace) printf("DoSetToCdrPushCarFP:\n");

begindosettocdrpushcar : if (_trace) printf("begindosettocdrpushcar:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
t2 = *(s32 *)arg1; // Get the operand from the stack.
t1 = *(s32 *)(arg1 + 4);
t2 = (u32)t2;
t3 = t1 & 192; // Save the old CDR code
t5 = t1 - Type_Locative;
t5 = t5 & 63; // Strip CDR code
if (t5 == 0)
    goto settocdrpushcarlocative;
r0 = (u64) && return0030;
goto carcdrinternal;
return0030 :
    /* TagType. */
    arg5
    = arg5 & 63;
arg5 = arg5 | t3; // Put back the original CDR codes
*(u32 *)arg1 = arg6;
*(u32 *)(arg1 + 4) = arg5; // write the stack cache
t5 = t1 & 63; // set CDR-NEXT
*(u32 *)(iSP + 8) = t2;
*(u32 *)(iSP + 12) = t5; // write the stack cache
iSP = iSP + 8;
goto NEXTINSTRUCTION;

DoSetToCdrPushCarIM : goto doistageerror;

/* end DoSetToCdrPushCar */
/* End of Halfword operand from stack instruction - DoSetToCdrPushCar */
/* start DoSub */

/* Halfword operand from stack instruction - DoSub */
/* arg2 has the preloaded 8 bit operand. */

dosub : if (_trace) printf("dosub:\n");

DoSubSP : if (_trace) printf("DoSubSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto begindosub;
arg6 = *(u64 *)arg4; // SP-pop, Reload TOS
arg1 = iSP; // SP-pop mode
iSP = arg4; // Adjust SP

DoSubLP : if (_trace) printf("DoSubLP:\n");

DoSubFP : if (_trace) printf("DoSubFP:\n");

begindosub : if (_trace) printf("begindosub:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
LDS(1, f1, *(u32 *)iSP);
t1 = (u32)(arg6 >> ((4 & 7) * 8)); // ARG1 tag
t3 = *(s32 *)(arg1 + 4); // ARG2 tag
t2 = (s32)arg6; // ARG1 data
t4 = *(s32 *)arg1; // ARG2 data
LDS(2, f2, *(u32 *)arg1);
/* NIL */
t9 = t1 & 63; // Strip off any CDR code bits.
t11 = t3 & 63; // Strip off any CDR code bits.
t10 = (t9 == Type_Fixnum) ? 1 : 0;

force_alignment44483 : if (_trace) printf("force_alignment44483:\n");
if (t10 == 0)
    goto basic_dispatch44454;
/* Here if argument TypeFixnum */
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment44460 : if (_trace) printf("force_alignment44460:\n");
if (t12 == 0)
    goto basic_dispatch44456;
/* Here if argument TypeFixnum */
t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
t5 = (s64)((s32)t2 - (s64)(s32)t4); // compute 64-bit result
if (t5 >> 31)
    exception(2, t5); /* subl/v */ // WARNING !!! THIS SHOULD REFLECT THE DIFF FILE
t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
/* trapb force the trap to occur here */ // Force the trap to occur here
*(u32 *)(iSP + 4) = t9; // Semi-cheat, we know temp2 has CDRNext/TypeFixnum
iPC = t6;
*(u32 *)iSP = t5;
iCP = t7;
goto cachevalid;

basic_dispatch44456 : if (_trace) printf("basic_dispatch44456:\n");
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment44461 : if (_trace) printf("force_alignment44461:\n");
if (t12 == 0)
    goto basic_dispatch44457;
/* Here if argument TypeSingleFloat */
CVTLQ(1, f1, f31, 1, f1);
CVTQT(1, f1, f31, 1, f1);
goto simple_binary_arithmetic_operation44444;

basic_dispatch44457 : if (_trace) printf("basic_dispatch44457:\n");
t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

force_alignment44462 : if (_trace) printf("force_alignment44462:\n");
if (t12 == 0)
    goto binary_type_dispatch44451;
/* Here if argument TypeDoubleFloat */
CVTLQ(1, f1, f31, 1, f1);
CVTQT(1, f1, f31, 1, f1);
goto simple_binary_arithmetic_operation44447;

basic_dispatch44455 : if (_trace) printf("basic_dispatch44455:\n");

basic_dispatch44454 : if (_trace) printf("basic_dispatch44454:\n");
t10 = (t9 == Type_SingleFloat) ? 1 : 0;

force_alignment44484 : if (_trace) printf("force_alignment44484:\n");
if (t10 == 0)
    goto basic_dispatch44463;
/* Here if argument TypeSingleFloat */
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment44469 : if (_trace) printf("force_alignment44469:\n");
if (t12 == 0)
    goto basic_dispatch44465;
/* Here if argument TypeSingleFloat */

simple_binary_arithmetic_operation44444 : if (_trace) printf("simple_binary_arithmetic_operation44444:\n");
SUBS(0, f0, 1, f1, 2, f2); /* subs */
/* trapb force the trap to occur here */ // Force the trap to occur here
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
t8 = Type_SingleFloat;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
goto cachevalid;

basic_dispatch44465 : if (_trace) printf("basic_dispatch44465:\n");
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment44470 : if (_trace) printf("force_alignment44470:\n");
if (t12 == 0)
    goto basic_dispatch44466;
/* Here if argument TypeFixnum */
CVTLQ(2, f2, f31, 2, f2);
CVTQT(2, f2, f31, 2, f2);
goto simple_binary_arithmetic_operation44444;

basic_dispatch44466 : if (_trace) printf("basic_dispatch44466:\n");
t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

force_alignment44471 : if (_trace) printf("force_alignment44471:\n");
if (t12 == 0)
    goto binary_type_dispatch44451;
/* Here if argument TypeDoubleFloat */

simple_binary_arithmetic_operation44447 : if (_trace) printf("simple_binary_arithmetic_operation44447:\n");
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
goto simple_binary_arithmetic_operation44448;

basic_dispatch44464 : if (_trace) printf("basic_dispatch44464:\n");

basic_dispatch44463 : if (_trace) printf("basic_dispatch44463:\n");
t10 = (t9 == Type_DoubleFloat) ? 1 : 0;

force_alignment44485 : if (_trace) printf("force_alignment44485:\n");
if (t10 == 0)
    goto basic_dispatch44472;
/* Here if argument TypeDoubleFloat */
t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

force_alignment44478 : if (_trace) printf("force_alignment44478:\n");
if (t12 == 0)
    goto basic_dispatch44474;
/* Here if argument TypeDoubleFloat */
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
arg2 = (u32)t2;
r0 = (u64) && return0031;
goto fetchdoublefloat;
return0031 : LDT(1, f1, processor->fp0);

simple_binary_arithmetic_operation44448 : if (_trace) printf("simple_binary_arithmetic_operation44448:\n");
arg2 = (u32)t4;
r0 = (u64) && return0032;
goto fetchdoublefloat;
return0032 : LDT(2, f2, processor->fp0);

simple_binary_arithmetic_operation44445 : if (_trace) printf("simple_binary_arithmetic_operation44445:\n");
SUBT(0, f0, 1, f1, 2, f2);
STT((u64 *)&processor->fp0, 0, f0);
r0 = (u64) && return0033;
goto consdoublefloat;
return0033 : iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
t8 = Type_DoubleFloat;
*(u32 *)iSP = arg2;
*(u32 *)(iSP + 4) = t8; // write the stack cache
goto cachevalid;

basic_dispatch44474 : if (_trace) printf("basic_dispatch44474:\n");
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment44479 : if (_trace) printf("force_alignment44479:\n");
if (t12 == 0)
    goto basic_dispatch44475;
/* Here if argument TypeSingleFloat */

simple_binary_arithmetic_operation44446 : if (_trace) printf("simple_binary_arithmetic_operation44446:\n");
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
arg2 = (u32)t2;
r0 = (u64) && return0034;
goto fetchdoublefloat;
return0034 : LDT(1, f1, processor->fp0);
goto simple_binary_arithmetic_operation44445;

basic_dispatch44475 : if (_trace) printf("basic_dispatch44475:\n");
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment44480 : if (_trace) printf("force_alignment44480:\n");
if (t12 == 0)
    goto binary_type_dispatch44451;
/* Here if argument TypeFixnum */
CVTLQ(2, f2, f31, 2, f2);
CVTQT(2, f2, f31, 2, f2);
goto simple_binary_arithmetic_operation44446;

basic_dispatch44473 : if (_trace) printf("basic_dispatch44473:\n");

basic_dispatch44472 : if (_trace) printf("basic_dispatch44472:\n");
/* Here for all other cases */

binary_type_dispatch44450 : if (_trace) printf("binary_type_dispatch44450:\n");

dosubovfl : if (_trace) printf("dosubovfl:\n");
arg6 = t1; // arg6 = tag to dispatch on
arg3 = 0; // arg3 = stackp
arg1 = 2; // arg1 = instruction arity
arg4 = 1; // arg4 = arithmeticp
goto numericexception;
goto binary_type_dispatch44452;

binary_type_dispatch44451 : if (_trace) printf("binary_type_dispatch44451:\n");
t1 = t3;
goto dosubovfl;

binary_type_dispatch44452 : if (_trace) printf("binary_type_dispatch44452:\n");

basic_dispatch44453 : if (_trace) printf("basic_dispatch44453:\n");

DoSubIM : if (_trace) printf("DoSubIM:\n");
t1 = (u32)(arg6 >> ((4 & 7) * 8));
t2 = (s32)arg6; // get ARG1 tag/data
t11 = t1 & 63; // Strip off any CDR code bits.
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment44490 : if (_trace) printf("force_alignment44490:\n");
if (t12 == 0)
    goto basic_dispatch44487;
/* Here if argument TypeFixnum */
t3 = t2 - arg2; // compute 64-bit result
t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
t10 = (s32)t3; // compute 32-bit sign-extended result
t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
t10 = (t3 == t10) ? 1 : 0; // is it the same as the 64-bit result?
if (t10 == 0) // if not, we overflowed
    goto dosubovfl;
*(u32 *)(iSP + 4) = t11; // Semi-cheat, we know temp2 has CDRNext/TypeFixnum
iPC = t4;
*(u32 *)iSP = t3;
iCP = t5;
goto cachevalid;

basic_dispatch44487 : if (_trace) printf("basic_dispatch44487:\n");
/* Here for all other cases */
*(u32 *)&processor->immediate_arg = arg2;
arg1 = (u64)&processor->immediate_arg;
arg2 = zero;
goto begindosub;

basic_dispatch44486 : if (_trace) printf("basic_dispatch44486:\n");

/* end DoSub */
/* End of Halfword operand from stack instruction - DoSub */
/* start DoTag */

/* Halfword operand from stack instruction - DoTag */
/* arg2 has the preloaded 8 bit operand. */

dotag : if (_trace) printf("dotag:\n");
/* arg2 has the preloaded 8 bit operand. */

DoTagIM : if (_trace) printf("DoTagIM:\n");
/* This sequence is lukewarm */
*(u32 *)&processor->immediate_arg = arg2;
arg1 = (u64)&processor->immediate_arg;
arg2 = zero;
goto begindotag;

DoTagSP : if (_trace) printf("DoTagSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoTagLP : if (_trace) printf("DoTagLP:\n");

DoTagFP : if (_trace) printf("DoTagFP:\n");

begindotag : if (_trace) printf("begindotag:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
arg1 = *(s32 *)(arg1 + 4); // Get the tag of the operand
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
t3 = Type_Fixnum;
*(u32 *)(iSP + 12) = t3; // write the stack cache
*(u32 *)(iSP + 8) = arg1;
iSP = iSP + 8;
goto cachevalid;

/* end DoTag */
/* End of Halfword operand from stack instruction - DoTag */
/* start DoEndp */

/* Halfword operand from stack instruction - DoEndp */
/* arg2 has the preloaded 8 bit operand. */

doendp : if (_trace) printf("doendp:\n");

DoEndpSP : if (_trace) printf("DoEndpSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoEndpLP : if (_trace) printf("DoEndpLP:\n");

DoEndpFP : if (_trace) printf("DoEndpFP:\n");

begindoendp : if (_trace) printf("begindoendp:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
t1 = *(u64 *)&(processor->niladdress);
arg2 = *(s32 *)(arg1 + 4); // Get tag.
t2 = *(u64 *)&(processor->taddress);
/* TagType. */
arg2 = arg2 & 63;
t6 = arg2 - Type_NIL; // Compare
if (t6 != 0)
    goto endpnotnil;
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
*(u64 *)(iSP + 8) = t2;
iSP = iSP + 8;
goto cachevalid;

endpnil : if (_trace) printf("endpnil:\n");
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
*(u64 *)(iSP + 8) = t1;
iSP = iSP + 8;
goto cachevalid;

endpnotnil : if (_trace) printf("endpnotnil:\n");
t6 = t6 - 1; // Now check for list
if (t6 == 0)
    goto endpnil;
t6 = arg2 - Type_ListInstance;
if (t6 == 0)
    goto endpnil;

DoEndpIM : if (_trace) printf("DoEndpIM:\n");
arg5 = 0;
arg2 = 64;
goto illegaloperand;

/* end DoEndp */
/* End of Halfword operand from stack instruction - DoEndp */
/* start DoMinusp */

/* Halfword operand from stack instruction - DoMinusp */
/* arg2 has the preloaded 8 bit operand. */

dominusp : if (_trace) printf("dominusp:\n");

DoMinuspSP : if (_trace) printf("DoMinuspSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoMinuspLP : if (_trace) printf("DoMinuspLP:\n");

DoMinuspFP : if (_trace) printf("DoMinuspFP:\n");

begindominusp : if (_trace) printf("begindominusp:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
t11 = *(u64 *)&(processor->niladdress);
t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
t1 = *(s32 *)(arg1 + 4);
t12 = *(u64 *)&(processor->taddress);
t2 = *(s32 *)arg1;
LDS(1, f1, *(u32 *)arg1);
t4 = t1 & 63; // Strip off any CDR code bits.
t5 = (t4 == Type_Fixnum) ? 1 : 0;

force_alignment44496 : if (_trace) printf("force_alignment44496:\n");
if (t5 == 0)
    goto basic_dispatch44492;
/* Here if argument TypeFixnum */
iPC = t6;
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
if ((s64)t2 < 0) // T if predicate succeeds
    t11 = t12;
*(u64 *)(iSP + 8) = t11;
iSP = iSP + 8;
goto cachevalid;

basic_dispatch44492 : if (_trace) printf("basic_dispatch44492:\n");
t5 = (t4 == Type_SingleFloat) ? 1 : 0;

force_alignment44497 : if (_trace) printf("force_alignment44497:\n");
if (t5 == 0)
    goto basic_dispatch44493;
/* Here if argument TypeSingleFloat */
iPC = t6;
*(u64 *)(iSP + 8) = t12;
iSP = iSP + 8;
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
if (FLTU64(1, f1) < 0.0)
    goto cachevalid;
*(u64 *)iSP = t11; // Didn't branch, answer is NIL
goto cachevalid;

basic_dispatch44493 : if (_trace) printf("basic_dispatch44493:\n");
/* Here for all other cases */
arg6 = t1; // arg6 = tag to dispatch on
arg3 = 0; // arg3 = stackp
arg1 = 1; // arg1 = instruction arity
arg4 = 1; // arg4 = arithmeticp
goto unarynumericexception;

basic_dispatch44491 : if (_trace) printf("basic_dispatch44491:\n");

DoMinuspIM : if (_trace) printf("DoMinuspIM:\n");
t1 = *(u64 *)&(processor->niladdress);
arg2 = arg2 << 56; // Turned into a signed number
t2 = *(u64 *)&(processor->taddress);
iSP = iSP + 8;
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
if ((s64)arg2 < 0) // stall 2 then di
    t1 = t2;
*(u64 *)iSP = t1; // yes Virginia, we dual issue with above yahoo
goto cachevalid;

/* end DoMinusp */
/* End of Halfword operand from stack instruction - DoMinusp */
/* start DoPlusp */

/* Halfword operand from stack instruction - DoPlusp */
/* arg2 has the preloaded 8 bit operand. */

doplusp : if (_trace) printf("doplusp:\n");

DoPluspSP : if (_trace) printf("DoPluspSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoPluspLP : if (_trace) printf("DoPluspLP:\n");

DoPluspFP : if (_trace) printf("DoPluspFP:\n");

begindoplusp : if (_trace) printf("begindoplusp:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
t11 = *(u64 *)&(processor->niladdress);
t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
t1 = *(s32 *)(arg1 + 4);
t12 = *(u64 *)&(processor->taddress);
t2 = *(s32 *)arg1;
LDS(1, f1, *(u32 *)arg1);
t4 = t1 & 63; // Strip off any CDR code bits.
t5 = (t4 == Type_Fixnum) ? 1 : 0;

force_alignment44503 : if (_trace) printf("force_alignment44503:\n");
if (t5 == 0)
    goto basic_dispatch44499;
/* Here if argument TypeFixnum */
iPC = t6;
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
if ((s64)t2 > 0) // T if predicate succeeds
    t11 = t12;
*(u64 *)(iSP + 8) = t11;
iSP = iSP + 8;
goto cachevalid;

basic_dispatch44499 : if (_trace) printf("basic_dispatch44499:\n");
t5 = (t4 == Type_SingleFloat) ? 1 : 0;

force_alignment44504 : if (_trace) printf("force_alignment44504:\n");
if (t5 == 0)
    goto basic_dispatch44500;
/* Here if argument TypeSingleFloat */
iPC = t6;
*(u64 *)(iSP + 8) = t12;
iSP = iSP + 8;
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
if (FLTU64(1, f1) > 0.0)
    goto cachevalid;
*(u64 *)iSP = t11; // Didn't branch, answer is NIL
goto cachevalid;

basic_dispatch44500 : if (_trace) printf("basic_dispatch44500:\n");
/* Here for all other cases */
arg6 = t1; // arg6 = tag to dispatch on
arg3 = 0; // arg3 = stackp
arg1 = 1; // arg1 = instruction arity
arg4 = 1; // arg4 = arithmeticp
goto unarynumericexception;

basic_dispatch44498 : if (_trace) printf("basic_dispatch44498:\n");

DoPluspIM : if (_trace) printf("DoPluspIM:\n");
t1 = *(u64 *)&(processor->niladdress);
arg2 = arg2 << 56; // Turned into a signed number
t2 = *(u64 *)&(processor->taddress);
iSP = iSP + 8;
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
if ((s64)arg2 > 0) // stall 2 then di
    t1 = t2;
*(u64 *)iSP = t1; // yes Virginia, we dual issue with above yahoo
goto cachevalid;

/* end DoPlusp */
/* End of Halfword operand from stack instruction - DoPlusp */
/* start DoLessp */

/* Halfword operand from stack instruction - DoLessp */
/* arg2 has the preloaded 8 bit operand. */

dolessp : if (_trace) printf("dolessp:\n");

DoLesspSP : if (_trace) printf("DoLesspSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto begindolessp;
arg6 = *(u64 *)arg4; // SP-pop, Reload TOS
arg1 = iSP; // SP-pop mode
iSP = arg4; // Adjust SP

DoLesspLP : if (_trace) printf("DoLesspLP:\n");

DoLesspFP : if (_trace) printf("DoLesspFP:\n");

begindolessp : if (_trace) printf("begindolessp:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
t11 = *(u64 *)&(processor->niladdress);
t7 = arg3 >> 12;
t12 = *(u64 *)&(processor->taddress);
arg3 = (u32)(arg6 >> ((4 & 7) * 8)); // Get ARG1 tag
t1 = *(s32 *)(arg1 + 4); // t1 is tag of arg2
LDS(1, f1, *(u32 *)iSP);
t7 = t7 & 1;
arg2 = *(s32 *)arg1;
arg4 = (s32)arg6;
LDS(2, f2, *(u32 *)arg1);
t5 = arg3 & 63; // Strip off any CDR code bits.
t4 = t1 & 63; // Strip off any CDR code bits.
t6 = (t5 == Type_Fixnum) ? 1 : 0;

force_alignment44522 : if (_trace) printf("force_alignment44522:\n");
if (t6 == 0)
    goto basic_dispatch44510;
/* Here if argument TypeFixnum */
t3 = (t4 == Type_Fixnum) ? 1 : 0;

force_alignment44514 : if (_trace) printf("force_alignment44514:\n");
if (t3 == 0)
    goto binary_type_dispatch44505;
/* Here if argument TypeFixnum */
t2 = arg4 - arg2;
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iSP = (t7 * 8) + iSP; // Pop/No-pop
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
if ((s64)t2 < 0) // T if the test succeeds
    t11 = t12;
*(u64 *)iSP = t11;
goto cachevalid;

basic_dispatch44511 : if (_trace) printf("basic_dispatch44511:\n");

basic_dispatch44510 : if (_trace) printf("basic_dispatch44510:\n");
t6 = (t5 == Type_SingleFloat) ? 1 : 0;

force_alignment44523 : if (_trace) printf("force_alignment44523:\n");
if (t6 == 0)
    goto basic_dispatch44515;
/* Here if argument TypeSingleFloat */
t3 = (t4 == Type_SingleFloat) ? 1 : 0;

force_alignment44519 : if (_trace) printf("force_alignment44519:\n");
if (t3 == 0)
    goto binary_type_dispatch44505;
/* Here if argument TypeSingleFloat */

lesspmmexcfltflt : if (_trace) printf("lesspmmexcfltflt:\n");
SETFLTT(3, f3, FLTU64(1, f1) < FLTU64(2, f2) ? 2.0 : 0);
/* trapb force the trap to occur here */ // Force the trap to occur here
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iSP = (t7 * 8) + iSP;
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
*(u64 *)iSP = t12;
if (FLTU64(3, f3) != 0.0)
    goto cachevalid;
*(u64 *)iSP = t11; // Didn't branch, answer is NIL
goto cachevalid;

basic_dispatch44516 : if (_trace) printf("basic_dispatch44516:\n");

basic_dispatch44515 : if (_trace) printf("basic_dispatch44515:\n");
/* Here for all other cases */

binary_type_dispatch44505 : if (_trace) printf("binary_type_dispatch44505:\n");
goto lesspmmexc;

basic_dispatch44509 : if (_trace) printf("basic_dispatch44509:\n");

DoLesspIM : if (_trace) printf("DoLesspIM:\n");
t11 = *(u64 *)&(processor->niladdress);
arg2 = arg2 << 56; // First half of sign extension
t12 = *(u64 *)&(processor->taddress);
t7 = arg3 >> 12;
arg3 = (u32)(arg6 >> ((4 & 7) * 8));
arg4 = (s32)arg6;
arg2 = (s64)arg2 >> 56; // Second half of sign extension
t7 = t7 & 1;
t3 = arg3 & 63; // Strip off any CDR code bits.
t4 = (t3 == Type_Fixnum) ? 1 : 0;

force_alignment44528 : if (_trace) printf("force_alignment44528:\n");
if (t4 == 0)
    goto basic_dispatch44525;
/* Here if argument TypeFixnum */
t2 = arg4 - arg2;
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iSP = (t7 * 8) + iSP;
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
if ((s64)t2 < 0) // T if the test succeeds
    t11 = t12;
*(u64 *)iSP = t11;
goto cachevalid;

basic_dispatch44525 : if (_trace) printf("basic_dispatch44525:\n");
/* Here for all other cases */
arg6 = arg3; // arg6 = tag to dispatch on
arg3 = 0; // arg3 = stackp
arg1 = 2; // arg1 = instruction arity
arg4 = 1; // arg4 = arithmeticp
goto numericexception;

basic_dispatch44524 : if (_trace) printf("basic_dispatch44524:\n");

/* end DoLessp */
/* End of Halfword operand from stack instruction - DoLessp */
/* start DoDecrement */

/* Halfword operand from stack instruction - DoDecrement */
/* arg2 has the preloaded 8 bit operand. */

dodecrement : if (_trace) printf("dodecrement:\n");

DoDecrementSP : if (_trace) printf("DoDecrementSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoDecrementLP : if (_trace) printf("DoDecrementLP:\n");

DoDecrementFP : if (_trace) printf("DoDecrementFP:\n");

begindodecrement : if (_trace) printf("begindodecrement:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
arg3 = *(s32 *)arg1; // read tag/data of arg1
arg2 = *(s32 *)(arg1 + 4);
arg3 = (u32)arg3;
t1 = arg2 & 63; // Strip off any CDR code bits.
t2 = (t1 == Type_Fixnum) ? 1 : 0;

force_alignment44534 : if (_trace) printf("force_alignment44534:\n");
if (t2 == 0)
    goto basic_dispatch44530;
/* Here if argument TypeFixnum */
t2 = *(u64 *)&(processor->mostnegativefixnum);
t3 = arg3 - 1;
t2 = (arg3 == t2) ? 1 : 0;
if (t2 != 0)
    goto decrementexception;
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
*(u32 *)arg1 = t3;
*(u32 *)(arg1 + 4) = arg2; // write the stack cache
goto cachevalid;

basic_dispatch44530 : if (_trace) printf("basic_dispatch44530:\n");
t2 = (t1 == Type_SingleFloat) ? 1 : 0;

force_alignment44535 : if (_trace) printf("force_alignment44535:\n");
if (t2 == 0)
    goto basic_dispatch44531;
/* Here if argument TypeSingleFloat */
/* NIL */
LDS(1, f1, *(u32 *)arg1); // Get the floating data
LDS(2, f2, processor->sfp1); // constant 1.0
SUBS(0, f0, 1, f1, 2, f2); /* subs */
/* trapb force the trap to occur here */ // Force the trap to occur here
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
STS((u32 *)arg1, 0, f0); // Put the floating result
goto cachevalid;

basic_dispatch44531 : if (_trace) printf("basic_dispatch44531:\n");
/* Here for all other cases */
goto decrementexception;

basic_dispatch44529 : if (_trace) printf("basic_dispatch44529:\n");

DoDecrementIM : goto doistageerror;

/* end DoDecrement */
/* End of Halfword operand from stack instruction - DoDecrement */
/* start DoMergeCdrNoPop */

/* Halfword operand from stack instruction - DoMergeCdrNoPop */
/* arg2 has the preloaded 8 bit operand. */

domergecdrnopop : if (_trace) printf("domergecdrnopop:\n");

DoMergeCdrNoPopSP : if (_trace) printf("DoMergeCdrNoPopSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto begindomergecdrnopop;
arg6 = *(u64 *)arg4; // SP-pop, Reload TOS
arg1 = iSP; // SP-pop mode
iSP = arg4; // Adjust SP

DoMergeCdrNoPopLP : if (_trace) printf("DoMergeCdrNoPopLP:\n");

DoMergeCdrNoPopFP : if (_trace) printf("DoMergeCdrNoPopFP:\n");

begindomergecdrnopop : if (_trace) printf("begindomergecdrnopop:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
t1 = *(s32 *)(arg1 + 4); // Get the CDR CODE/TAG of arg2
t2 = (u32)(arg6 >> ((4 & 7) * 8)); // Get the CDR CODE/TAG of arg1

force_alignment44536 : if (_trace) printf("force_alignment44536:\n");
t2 = t2 & 192; // Get Just the CDR code in position
t1 = t1 & 63; // Get the TAG of arg1
t3 = t1 | t2; // Merge the tag of arg2 with the cdr code of arg1
*(u32 *)(arg1 + 4) = t3; // Replace tag/cdr code no pop
goto cachevalid;

DoMergeCdrNoPopIM : goto doistageerror;

/* end DoMergeCdrNoPop */
/* End of Halfword operand from stack instruction - DoMergeCdrNoPop */
/* start DoEqImmediateHandler */

doeqimmediatehandler : if (_trace) printf("doeqimmediatehandler:\n");

DoEqIM : if (_trace) printf("DoEqIM:\n");
arg2 = arg2 << 56;
t4 = *(s32 *)(iSP + 4); // t4=tag t3=data
t3 = *(s32 *)iSP;
arg3 = arg3 >> 12;
t11 = *(u64 *)&(processor->niladdress);
arg2 = (s64)arg2 >> 56; // Sign extension of arg2 is complete
/* TagType. */
t4 = t4 & 63;
t12 = *(u64 *)&(processor->taddress);
arg3 = arg3 & 1; // 1 if no-pop, 0 if pop
arg2 = (s32)t3 - (s32)arg2;
t4 = t4 ^ Type_Fixnum;
iSP = (arg3 * 8) + iSP; // Either a stack-push or a stack-write
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
t4 = arg2 | t4;
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
if (t4 == 0)
    t11 = t12;
*(u64 *)iSP = t11; // Yes Virginia, this does dual issue with above
goto cachevalid;

/* end DoEqImmediateHandler */
/* start DoIncrement */

/* Halfword operand from stack instruction - DoIncrement */
/* arg2 has the preloaded 8 bit operand. */

doincrement : if (_trace) printf("doincrement:\n");

DoIncrementSP : if (_trace) printf("DoIncrementSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoIncrementLP : if (_trace) printf("DoIncrementLP:\n");

DoIncrementFP : if (_trace) printf("DoIncrementFP:\n");

begindoincrement : if (_trace) printf("begindoincrement:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
arg3 = *(s32 *)arg1; // read tag/data of arg1
arg2 = *(s32 *)(arg1 + 4);
arg3 = (u32)arg3;
t1 = arg2 & 63; // Strip off any CDR code bits.
t2 = (t1 == Type_Fixnum) ? 1 : 0;

force_alignment44542 : if (_trace) printf("force_alignment44542:\n");
if (t2 == 0)
    goto basic_dispatch44538;
/* Here if argument TypeFixnum */
t2 = *(u64 *)&(processor->mostpositivefixnum);
t3 = arg3 + 1;
t2 = (arg3 == t2) ? 1 : 0;
if (t2 != 0)
    goto incrementexception;
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
*(u32 *)arg1 = t3;
*(u32 *)(arg1 + 4) = arg2; // write the stack cache
goto cachevalid;

basic_dispatch44538 : if (_trace) printf("basic_dispatch44538:\n");
t2 = (t1 == Type_SingleFloat) ? 1 : 0;

force_alignment44543 : if (_trace) printf("force_alignment44543:\n");
if (t2 == 0)
    goto basic_dispatch44539;
/* Here if argument TypeSingleFloat */
/* NIL */
LDS(1, f1, *(u32 *)arg1); // Get the floating data
LDS(2, f2, processor->sfp1); // constant 1.0
ADDS(0, f0, 1, f1, 2, f2); /* adds */
/* trapb force the trap to occur here */ // Force the trap to occur here
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
STS((u32 *)arg1, 0, f0); // Put the floating result
goto cachevalid;

basic_dispatch44539 : if (_trace) printf("basic_dispatch44539:\n");
/* Here for all other cases */
goto incrementexception;

basic_dispatch44537 : if (_trace) printf("basic_dispatch44537:\n");

DoIncrementIM : goto doistageerror;

/* end DoIncrement */
/* End of Halfword operand from stack instruction - DoIncrement */
/* Fin. */

/* End of file automatically generated from ../alpha-emulator/ifuncom2.as */
