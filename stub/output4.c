/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifuncom2.as
 ************************************************************************/

  /* The most commonly used instructions, part 2. */
/* start DoPushInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPushInstanceVariable */

dopushinstancevariable:
  if (_trace) printf("dopushinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushInstanceVariableIM:
  if (_trace) printf("DoPushInstanceVariableIM:\n");

DoPushInstanceVariableSP:
  if (_trace) printf("DoPushInstanceVariableSP:\n");

DoPushInstanceVariableLP:
  if (_trace) printf("DoPushInstanceVariableLP:\n");

DoPushInstanceVariableFP:
  if (_trace) printf("DoPushInstanceVariableFP:\n");
  /* arg1 has operand preloaded. */
  arg1 = arg2;
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Instance Variable Mapped */
  arg2 = *(s32 *)(iFP + 16);   		// Map 
  arg5 = *(s32 *)(iFP + 20);   
  arg2 = (u32)arg2;   
  t2 = arg5 - Type_Array;   
  t2 = t2 & 63;		// Strip CDR code 
  if (t2 != 0)   
    goto ivbadmap;
  /* Memory Read Internal */

vma-memory-read9193:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9195;

vma-memory-read9194:
  t7 = zero + 64;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read9197;

vma-memory-read9202:
  arg6 = arg6 & Array_LengthMask;
  t3 = arg6 - arg1;   
  if ((s64)t3 <= 0)  		// J. if mapping-table-index-out-of-bounds 
    goto ivbadindex;
  arg2 = arg2 + arg1;
  arg2 = arg2 + 1;
  /* Memory Read Internal */

vma-memory-read9203:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9205;

vma-memory-read9204:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read9207;

vma-memory-read9214:
  t1 = arg6;
  t4 = arg5 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto pushivexception;
  arg2 = *(s32 *)(iFP + 24);   		// Self 
  t4 = *(s32 *)(iFP + 28);   
  arg2 = (u32)arg2;   
  t3 = t4 - Type_Instance;   
  t3 = t3 & 60;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto ivbadinst;
  t3 = t4 & 192;		// Unshifted cdr code 
  t3 = t3 - 64;   		// Check for CDR code 1 
  if (t3 != 0)   		// J. if CDR code is not 1 
    goto locate-instance0variable-mapped9192;

locate-instance0variable-mapped9191:
  if (_trace) printf("locate-instance0variable-mapped9191:\n");
  arg2 = arg2 + t1;

locate-instance0variable-mapped9190:
  if (_trace) printf("locate-instance0variable-mapped9190:\n");
  /* Memory Read Internal */

vma-memory-read9215:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9217;

vma-memory-read9216:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read9219;

vma-memory-read9226:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t7 = arg5 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;   

vma-memory-read9219:
  if (_trace) printf("vma-memory-read9219:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9218;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9215;   

vma-memory-read9218:
  if (_trace) printf("vma-memory-read9218:\n");

vma-memory-read9217:
  if (_trace) printf("vma-memory-read9217:\n");
  r0 = (u64)&&return0284;
  goto memoryreaddatadecode;
return0284:
  goto vma-memory-read9226;   

vma-memory-read9207:
  if (_trace) printf("vma-memory-read9207:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9206;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9203;   

vma-memory-read9206:
  if (_trace) printf("vma-memory-read9206:\n");

vma-memory-read9205:
  if (_trace) printf("vma-memory-read9205:\n");
  r0 = (u64)&&return0285;
  goto memoryreaddatadecode;
return0285:
  goto vma-memory-read9214;   

vma-memory-read9197:
  if (_trace) printf("vma-memory-read9197:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9196;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9193;   

vma-memory-read9196:
  if (_trace) printf("vma-memory-read9196:\n");

vma-memory-read9195:
  if (_trace) printf("vma-memory-read9195:\n");
  r0 = (u64)&&return0286;
  goto memoryreadheaderdecode;
return0286:
  goto vma-memory-read9202;   

locate-instance0variable-mapped9192:
  if (_trace) printf("locate-instance0variable-mapped9192:\n");
  t3 = arg2;
  /* Memory Read Internal */

vma-memory-read9227:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9229;

vma-memory-read9228:
  t7 = zero + 64;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read9231;

vma-memory-read9236:
  t3 = t3 - arg2;   
  if (t3 != 0)   
    goto locate-instance0variable-mapped9191;
  /* TagType. */
  t4 = t4 & 63;
  t4 = t4 | 64;		// Set CDR code to 1 
		/* Update self */
  *(u32 *)(iFP + 24) = arg2;
		/* write the stack cache */
  *(u32 *)(iFP + 28) = t4;
  goto locate-instance0variable-mapped9191;   

vma-memory-read9231:
  if (_trace) printf("vma-memory-read9231:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9230;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9227;   

vma-memory-read9230:
  if (_trace) printf("vma-memory-read9230:\n");

vma-memory-read9229:
  if (_trace) printf("vma-memory-read9229:\n");
  r0 = (u64)&&return0287;
  goto memoryreadheaderdecode;
return0287:
  goto vma-memory-read9236;   

/* end DoPushInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPushInstanceVariable */
/* start DoAdd */

  /* Halfword operand from stack instruction - DoAdd */
  /* arg2 has the preloaded 8 bit operand. */

doadd:
  if (_trace) printf("doadd:\n");
#ifdef TRACING
#endif

DoAddSP:
  if (_trace) printf("DoAddSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoadd;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindoadd;   
#endif

DoAddLP:
  if (_trace) printf("DoAddLP:\n");
#ifdef TRACING
  goto begindoadd;   
#endif

DoAddFP:
  if (_trace) printf("DoAddFP:\n");

begindoadd:
  if (_trace) printf("begindoadd:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  /* NIL */
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment9276:
  if (_trace) printf("force-alignment9276:\n");
  if (t10 == 0) 
    goto basic-dispatch9247;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment9253:
  if (_trace) printf("force-alignment9253:\n");
  if (t12 == 0) 
    goto basic-dispatch9249;
  /* Here if argument TypeFixnum */
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t5 = (u64)((s32)t2 + (s64)(s32)t4); 		// compute 64-bit result 
  if (t5 >> 32)
    exception();  /* addl/v */
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t9;
  iPC = t6;
  *(u32 *)iSP = t5;
  iCP = t7;
  goto cachevalid;   

basic-dispatch9249:
  if (_trace) printf("basic-dispatch9249:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment9254:
  if (_trace) printf("force-alignment9254:\n");
  if (t12 == 0) 
    goto basic-dispatch9250;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple-binary-arithmetic-operation9237;   

basic-dispatch9250:
  if (_trace) printf("basic-dispatch9250:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment9255:
  if (_trace) printf("force-alignment9255:\n");
  if (t12 == 0) 
    goto binary-type-dispatch9244;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple-binary-arithmetic-operation9240;   

basic-dispatch9248:
  if (_trace) printf("basic-dispatch9248:\n");

basic-dispatch9247:
  if (_trace) printf("basic-dispatch9247:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment9277:
  if (_trace) printf("force-alignment9277:\n");
  if (t10 == 0) 
    goto basic-dispatch9256;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment9262:
  if (_trace) printf("force-alignment9262:\n");
  if (t12 == 0) 
    goto basic-dispatch9258;
  /* Here if argument TypeSingleFloat */

simple-binary-arithmetic-operation9237:
  if (_trace) printf("simple-binary-arithmetic-operation9237:\n");
  ADDS(0, f0, 1, f1, 2, f2); /* adds */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto cachevalid;   

basic-dispatch9258:
  if (_trace) printf("basic-dispatch9258:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment9263:
  if (_trace) printf("force-alignment9263:\n");
  if (t12 == 0) 
    goto basic-dispatch9259;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple-binary-arithmetic-operation9237;   

basic-dispatch9259:
  if (_trace) printf("basic-dispatch9259:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment9264:
  if (_trace) printf("force-alignment9264:\n");
  if (t12 == 0) 
    goto binary-type-dispatch9244;
  /* Here if argument TypeDoubleFloat */

simple-binary-arithmetic-operation9240:
  if (_trace) printf("simple-binary-arithmetic-operation9240:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto simple-binary-arithmetic-operation9241;   

basic-dispatch9257:
  if (_trace) printf("basic-dispatch9257:\n");

basic-dispatch9256:
  if (_trace) printf("basic-dispatch9256:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

force-alignment9278:
  if (_trace) printf("force-alignment9278:\n");
  if (t10 == 0) 
    goto basic-dispatch9265;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment9271:
  if (_trace) printf("force-alignment9271:\n");
  if (t12 == 0) 
    goto basic-dispatch9267;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0288;
  goto fetchdoublefloat;
return0288:
  LDT(1, f1, processor->fp0);   

simple-binary-arithmetic-operation9241:
  if (_trace) printf("simple-binary-arithmetic-operation9241:\n");
  arg2 = (u32)t4;   
  r0 = (u64)&&return0289;
  goto fetchdoublefloat;
return0289:
  LDT(2, f2, processor->fp0);   

simple-binary-arithmetic-operation9238:
  if (_trace) printf("simple-binary-arithmetic-operation9238:\n");
  ADDT(0, f0, 1, f1, 2, f2); /* addt */   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0290;
  goto consdoublefloat;
return0290:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto cachevalid;   

basic-dispatch9267:
  if (_trace) printf("basic-dispatch9267:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment9272:
  if (_trace) printf("force-alignment9272:\n");
  if (t12 == 0) 
    goto basic-dispatch9268;
  /* Here if argument TypeSingleFloat */

simple-binary-arithmetic-operation9239:
  if (_trace) printf("simple-binary-arithmetic-operation9239:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0291;
  goto fetchdoublefloat;
return0291:
  LDT(1, f1, processor->fp0);   
  goto simple-binary-arithmetic-operation9238;   

basic-dispatch9268:
  if (_trace) printf("basic-dispatch9268:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment9273:
  if (_trace) printf("force-alignment9273:\n");
  if (t12 == 0) 
    goto binary-type-dispatch9244;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple-binary-arithmetic-operation9239;   

basic-dispatch9266:
  if (_trace) printf("basic-dispatch9266:\n");

basic-dispatch9265:
  if (_trace) printf("basic-dispatch9265:\n");
  /* Here for all other cases */

binary-type-dispatch9243:
  if (_trace) printf("binary-type-dispatch9243:\n");

doaddovfl:
  if (_trace) printf("doaddovfl:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch9245;   

binary-type-dispatch9244:
  if (_trace) printf("binary-type-dispatch9244:\n");
  t1 = t3;
  goto doaddovfl;   

binary-type-dispatch9245:
  if (_trace) printf("binary-type-dispatch9245:\n");

basic-dispatch9246:
  if (_trace) printf("basic-dispatch9246:\n");
#ifdef TRACING
  goto DoAddIM;   
#endif

DoAddIM:
  if (_trace) printf("DoAddIM:\n");
  t1 = (u32)(arg6 >> ((4&7)*8));   
  t2 = (s32)arg6;		// get ARG1 tag/data 
  t11 = t1 & 63;		// Strip off any CDR code bits. 
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment9283:
  if (_trace) printf("force-alignment9283:\n");
  if (t12 == 0) 
    goto basic-dispatch9280;
  /* Here if argument TypeFixnum */
  t3 = t2 + arg2;		// compute 64-bit result 
  t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t10 = (s32)t3;		// compute 32-bit sign-extended result 
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t10 = (t3 == t10) ? 1 : 0;   		// is it the same as the 64-bit result? 
  if (t10 == 0) 		// if not, we overflowed 
    goto doaddovfl;
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t11;
  iPC = t4;
  *(u32 *)iSP = t3;
  iCP = t5;
  goto cachevalid;   

basic-dispatch9280:
  if (_trace) printf("basic-dispatch9280:\n");
  /* Here for all other cases */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;   
  arg2 = zero;
  goto begindoadd;   

basic-dispatch9279:
  if (_trace) printf("basic-dispatch9279:\n");

/* end DoAdd */
  /* End of Halfword operand from stack instruction - DoAdd */
/* start DoBlock3Write */

  /* Halfword operand from stack instruction - DoBlock3Write */

doblock3write:
  if (_trace) printf("doblock3write:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoBlock3WriteIM:
  if (_trace) printf("DoBlock3WriteIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment9284:
  if (_trace) printf("force-alignment9284:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoblock3write;   
#ifdef TRACING
#endif

DoBlock3WriteSP:
  if (_trace) printf("DoBlock3WriteSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoblock3write;   
#endif

DoBlock3WriteLP:
  if (_trace) printf("DoBlock3WriteLP:\n");
#ifdef TRACING
  goto headdoblock3write;   
#endif

DoBlock3WriteFP:
  if (_trace) printf("DoBlock3WriteFP:\n");

headdoblock3write:
  if (_trace) printf("headdoblock3write:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoblock3write:
  if (_trace) printf("begindoblock3write:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg3 = *(s32 *)&processor->bar3;   
  arg2 = (u64)&processor->bar3;   
  goto blockwrite;   

/* end DoBlock3Write */
  /* End of Halfword operand from stack instruction - DoBlock3Write */
/* start DoAset1 */

  /* Halfword operand from stack instruction - DoAset1 */
  /* arg2 has the preloaded 8 bit operand. */

doaset1:
  if (_trace) printf("doaset1:\n");
#ifdef TRACING
#endif

DoAset1SP:
  if (_trace) printf("DoAset1SP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoaset1;   
#endif

DoAset1LP:
  if (_trace) printf("DoAset1LP:\n");
#ifdef TRACING
  goto headdoaset1;   
#endif

DoAset1FP:
  if (_trace) printf("DoAset1FP:\n");

headdoaset1:
  if (_trace) printf("headdoaset1:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoaset1:
  if (_trace) printf("begindoaset1:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   		// Get the array tag/data 
  arg3 = *(s32 *)(iSP + 4);   		// Get the array tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  t6 = *(s32 *)iSP;   		// Get the new value tag/data 
  t5 = *(s32 *)(iSP + 4);   		// Get the new value tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  t6 = (u32)t6;   
  arg2 = (s32)arg1 + (s32)0;		// (sign-extended, for fast bounds check) Index Data 
  t8 = zero + AutoArrayRegMask;   
  t8 = arg4 & t8;
  arg1 = arg1 >> 32;   		// Index Tag 
  t7 = (u64)&processor->ac0array;   
  t7 = t7 + t8;		// This is the address if the array register block. 
  t1 = arg1 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto aset1illegal;

aset1merge:
  if (_trace) printf("aset1merge:\n");
  if (arg4 == 0) 
    goto aset1regset;
  t8 = *(u64 *)&(((ARRAYCACHEP)t7)->array);   		// Cached array object. 
  t1 = arg3 - Type_Array;   
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto reallyaset1exc;
  t8 = (arg4 == t8) ? 1 : 0;   		// t8==1 iff cached array is ours. 
  if (t8 == 0) 		// Go and setup the array register. 
    goto aset1regset;
#ifdef SLOWARRAYS
  goto aset1regset;   
#endif
  arg6 = *(u64 *)&(((ARRAYCACHEP)t7)->arword);   
  t9 = *(u64 *)&(((ARRAYCACHEP)t7)->locat);   		// high order bits all zero 
  t3 = *(u64 *)&(((ARRAYCACHEP)t7)->length);   		// high order bits all zero 
  t11 = arg6 << 42;   
  t4 = *(u64 *)&(processor->areventcount);   
  t11 = t11 >> 42;   
  t2 = ((u64)arg2 < (u64)t3) ? 1 : 0;   
  t12 = t4 - t11;   
  if (t12 != 0)   		// J. if event count ticked. 
    goto aset1regset;
  if (t2 == 0) 
    goto aset1bounds;
  arg5 = arg6 >> (Array_RegisterBytePackingPos & 63);   
  t8 = arg6 >> (Array_RegisterElementTypePos & 63);   
  arg4 = arg6 >> (Array_RegisterByteOffsetPos & 63);   
  arg5 = arg5 & Array_RegisterBytePackingMask;
  arg4 = arg4 & Array_RegisterByteOffsetMask;
  arg6 = t8 & Array_RegisterElementTypeMask;

aset1restart:
  if (_trace) printf("aset1restart:\n");
  /* Element checking and foreplay. */
  /* TagType. */
  t1 = t5 & 63;
  t8 = (arg6 == Array_ElementTypeCharacter) ? 1 : 0;   

force-alignment9295:
  if (_trace) printf("force-alignment9295:\n");
  if (t8 == 0) 
    goto basic-dispatch9291;
  /* Here if argument ArrayElementTypeCharacter */
  t2 = t1 - Type_Character;   
  if (t2 == 0) 
    goto aset-1-internal9286;
  arg5 = 0;
  arg2 = 29;
  goto illegaloperand;

aset-1-internal9286:
  if (_trace) printf("aset-1-internal9286:\n");
  if (arg5 == 0) 		// Certainly will fit if not packed! 
    goto aset-1-internal9285;
  t2 = 32;
  t2 = t2 >> (arg5 & 63);   		// Compute size of byte 
  t1 = ~zero;   
  t1 = t1 << (t2 & 63);   
  t1 = ~t1;   		// Compute mask for byte 
  t1 = t6 & t1;
  t1 = t6 - t1;   
  if (t1 == 0) 		// J. if character fits. 
    goto aset-1-internal9285;
  arg5 = 0;
  arg2 = 62;
  goto illegaloperand;

basic-dispatch9291:
  if (_trace) printf("basic-dispatch9291:\n");
  t8 = (arg6 == Array_ElementTypeFixnum) ? 1 : 0;   

force-alignment9296:
  if (_trace) printf("force-alignment9296:\n");
  if (t8 == 0) 
    goto basic-dispatch9292;
  /* Here if argument ArrayElementTypeFixnum */
  t2 = t1 - Type_Fixnum;   
  if (t2 == 0) 
    goto aset-1-internal9285;
  arg5 = 0;
  arg2 = 33;
  goto illegaloperand;

basic-dispatch9292:
  if (_trace) printf("basic-dispatch9292:\n");
  t8 = (arg6 == Array_ElementTypeBoolean) ? 1 : 0;   

force-alignment9297:
  if (_trace) printf("force-alignment9297:\n");
  if (t8 == 0) 
    goto basic-dispatch9290;
  /* Here if argument ArrayElementTypeBoolean */
  t6 = 1;
  t1 = t1 - Type_NIL;   
  if (t1 != 0)   		// J. if True 
    goto aset-1-internal9285;
  t6 = zero;
  goto aset-1-internal9285;   		// J. if False 

basic-dispatch9290:
  if (_trace) printf("basic-dispatch9290:\n");
  /* Shove it in. */

aset-1-internal9285:
  if (_trace) printf("aset-1-internal9285:\n");
  if (arg5 != 0)   		// J. if packed 
    goto aset-1-internal9287;
  t1 = arg6 - Array_ElementTypeObject;   
  if (t1 != 0)   
    goto aset-1-internal9287;
  /* Here for the simple non packed case */
  t1 = t9 + arg2;
  /* Memory Read Internal */

vma-memory-read9298:
  t4 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t8 = t1 + ivory;
  t7 = *(s32 *)&processor->scovlimit;   
  t3 = (t8 * 4);   
  t2 = LDQ_U(t8);   
  t4 = t1 - t4;   		// Stack cache offset 
  arg1 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t4 < (u64)t7) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t2 = (u8)(t2 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read9300;

vma-memory-read9299:
  t8 = zero + 240;   
  arg1 = arg1 >> (t2 & 63);   
  t8 = t8 >> (t2 & 63);   
  if (arg1 & 1)   
    goto vma-memory-read9302;

vma-memory-read9308:
  /* Merge cdr-code */
  t3 = t5 & 63;
  t2 = t2 & 192;
  t2 = t2 | t3;
  t7 = *(u64 *)&(processor->stackcachebasevma);   
  t4 = t1 + ivory;
  arg1 = *(s32 *)&processor->scovlimit;   
  t3 = (t4 * 4);   
  t8 = LDQ_U(t4);   
  t7 = t1 - t7;   		// Stack cache offset 
  arg1 = ((u64)t7 < (u64)arg1) ? 1 : 0;   		// In range? 
  t7 = (t2 & 0xff) << ((t4&7)*8);   
  t8 = t8 & ~(0xffL << (t4&7)*8);   

force-alignment9310:
  if (_trace) printf("force-alignment9310:\n");
  t8 = t8 | t7;
  STQ_U(t4, t8);   
  *(u32 *)t3 = t6;
  if (arg1 != 0)   		// J. if in cache 
    goto vma-memory-write9309;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   
  /* Here for the slow packed version */

aset-1-internal9287:
  if (_trace) printf("aset-1-internal9287:\n");
  arg2 = arg4 + arg2;
  t1 = arg2 >> (arg5 & 63);   		// Convert byte index to word index 
  t1 = t1 + t9;		// Address of word containing byte 
  /* Memory Read Internal */

vma-memory-read9311:
  t2 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t4 = t1 + ivory;
  t3 = *(s32 *)&processor->scovlimit;   
  t9 = (t4 * 4);   
  arg3 = LDQ_U(t4);   
  t2 = t1 - t2;   		// Stack cache offset 
  t7 = *(u64 *)&(processor->dataread_mask);   
  t3 = ((u64)t2 < (u64)t3) ? 1 : 0;   		// In range? 
  t9 = *(s32 *)t9;   
  arg3 = (u8)(arg3 >> ((t4&7)*8));   
  if (t3 != 0)   
    goto vma-memory-read9313;

vma-memory-read9312:
  t4 = zero + 240;   
  t7 = t7 >> (arg3 & 63);   
  t4 = t4 >> (arg3 & 63);   
  t9 = (u32)t9;   
  if (t7 & 1)   
    goto vma-memory-read9315;

vma-memory-read9322:
  /* Check fixnum element type */
  /* TagType. */
  t2 = arg3 & 63;
  t2 = t2 - Type_Fixnum;   
  if (t2 != 0)   		// J. if element type not fixnum. 
    goto aset-1-internal9288;
  if (arg5 == 0) 		// J. if unpacked fixnum element type. 
    goto aset-1-internal9289;
  t8 = ~zero;   
  t8 = t8 << (arg5 & 63);   
  t2 = zero - arg5;   
  t8 = arg2 & ~t8;		// Compute subword index 
  t2 = t2 + 5;
  t2 = t8 << (t2 & 63);   		// Compute shift to get byte 
  t8 = 32;
  t8 = t8 >> (arg5 & 63);   		// Compute size of byte 
  t3 = ~zero;   
  t3 = t3 << (t8 & 63);   
  t4 = ~t3;   		// Compute mask for byte 
  if (t2 == 0) 		// inserting into the low byte is easy 
    goto array-element-dpb9323;
  /* Inserting the byte into any byte other than the low byte */
  t7 = 64;
  t8 = t7 - t2;   		// = the left shift rotate amount 
  t7 = t9 >> (t2 & 63);   		// shift selected byte into low end of word. 
  t9 = t9 << (t8 & 63);   		// rotate low bits into high end of word. 
  t7 = t3 & t7;		// Remove unwanted bits 
  t9 = t9 >> (t8 & 63);   		// rotate low bits back into place. 
  t8 = t6 & t4;		// Strip any extra bits from element 
  t7 = t8 | t7;		// Insert new bits. 
  t7 = t7 << (t2 & 63);   		// reposition bits 
  t9 = t9 | t7;		// Replace low order bits 
  goto array-element-dpb9324;   

array-element-dpb9323:
  if (_trace) printf("array-element-dpb9323:\n");
  /* Inserting the byte into the low byte */
  t9 = t9 & t3;		// Remove the old low byte 
  t8 = t6 & t4;		// Remove unwanted bits from the new byte 
  t9 = t9 | t8;		// Insert the new byte in place of the old byte 

array-element-dpb9324:
  if (_trace) printf("array-element-dpb9324:\n");
  t6 = t9;

aset-1-internal9289:
  if (_trace) printf("aset-1-internal9289:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t7 = (t2 * 4);   
  t4 = LDQ_U(t2);   
  t3 = t1 - t3;   		// Stack cache offset 
  t8 = ((u64)t3 < (u64)t8) ? 1 : 0;   		// In range? 
  t3 = (arg3 & 0xff) << ((t2&7)*8);   
  t4 = t4 & ~(0xffL << (t2&7)*8);   

force-alignment9326:
  if (_trace) printf("force-alignment9326:\n");
  t4 = t4 | t3;
  STQ_U(t2, t4);   
  *(u32 *)t7 = t6;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write9325;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

aset-1-internal9288:
  if (_trace) printf("aset-1-internal9288:\n");
  arg5 = t1;
  arg2 = 25;
  goto illegaloperand;
#ifdef TRACING
  goto DoAset1IM;   
#endif

DoAset1IM:
  if (_trace) printf("DoAset1IM:\n");
  t8 = zero + AutoArrayRegMask;   
  arg4 = *(s32 *)iSP;   		// Get the array tag/data 
  arg3 = *(s32 *)(iSP + 4);   		// Get the array tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  t7 = (u64)&processor->ac0array;   
  t8 = arg4 & t8;
  t7 = t7 + t8;		// This is the address of the array register block. 
  t6 = *(s32 *)iSP;   		// Get the new value tag/data 
  t5 = *(s32 *)(iSP + 4);   		// Get the new value tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  t6 = (u32)t6;   
  goto aset1merge;   

vma-memory-write9325:
  if (_trace) printf("vma-memory-write9325:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment9327:
  if (_trace) printf("force-alignment9327:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t3 = t1 - t3;   		// Stack cache offset 
  t2 = (t3 * 8) + t2;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t2 = t6;
		/* write the stack cache */
  *(u32 *)(t2 + 4) = arg3;
  goto NEXTINSTRUCTION;   

vma-memory-read9313:
  if (_trace) printf("vma-memory-read9313:\n");
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = (t2 * 8) + t3;  		// reconstruct SCA 
  t9 = *(s32 *)t2;   
  arg3 = *(s32 *)(t2 + 4);   		// Read from stack cache 
  goto vma-memory-read9312;   

vma-memory-read9315:
  if (_trace) printf("vma-memory-read9315:\n");
  if ((t4 & 1) == 0)   
    goto vma-memory-read9314;
  t1 = (u32)t9;   		// Do the indirect thing 
  goto vma-memory-read9311;   

vma-memory-read9314:
  if (_trace) printf("vma-memory-read9314:\n");
  t7 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t4 = arg3 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t4 = (t4 * 4) + t7;   		// Adjust for a longword load 
  t7 = *(s32 *)t4;   		// Get the memory action 

vma-memory-read9319:
  if (_trace) printf("vma-memory-read9319:\n");
  t4 = t7 & MemoryActionTransform;
  if (t4 == 0) 
    goto vma-memory-read9318;
  arg3 = arg3 & ~63L;
  arg3 = arg3 | Type_ExternalValueCellPointer;
  goto vma-memory-read9322;   

vma-memory-read9318:

vma-memory-read9317:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-write9309:
  if (_trace) printf("vma-memory-write9309:\n");
  t7 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment9328:
  if (_trace) printf("force-alignment9328:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t7 = t1 - t7;   		// Stack cache offset 
  t4 = (t7 * 8) + t4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t4 = t6;
		/* write the stack cache */
  *(u32 *)(t4 + 4) = t2;
  goto NEXTINSTRUCTION;   

vma-memory-read9300:
  if (_trace) printf("vma-memory-read9300:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t4 = (t4 * 8) + t7;  		// reconstruct SCA 
  t3 = *(s32 *)t4;   
  t2 = *(s32 *)(t4 + 4);   		// Read from stack cache 
  goto vma-memory-read9299;   

vma-memory-read9302:
  if (_trace) printf("vma-memory-read9302:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read9301;
  t1 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read9298;   

vma-memory-read9301:
  if (_trace) printf("vma-memory-read9301:\n");
  arg1 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + arg1;   		// Adjust for a longword load 
  arg1 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read9305:

vma-memory-read9304:
  /* Perform memory action */
  arg1 = arg1;
  arg2 = 1;
  goto performmemoryaction;

/* end DoAset1 */
  /* End of Halfword operand from stack instruction - DoAset1 */
/* start DoFastAref1 */

  /* Halfword operand from stack instruction - DoFastAref1 */
  /* arg2 has the preloaded 8 bit operand. */

dofastaref1:
  if (_trace) printf("dofastaref1:\n");
#ifdef TRACING
#endif

DoFastAref1SP:
  if (_trace) printf("DoFastAref1SP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindofastaref1;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindofastaref1;   
#endif

DoFastAref1LP:
  if (_trace) printf("DoFastAref1LP:\n");
#ifdef TRACING
  goto begindofastaref1;   
#endif

DoFastAref1FP:
  if (_trace) printf("DoFastAref1FP:\n");

begindofastaref1:
  if (_trace) printf("begindofastaref1:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg3 = (u32)(arg6 >> ((4&7)*8));   
  arg4 = (s32)arg6;
  t1 = arg3 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto fastaref1iop;

fastaref1retry:
  if (_trace) printf("fastaref1retry:\n");
  arg6 = *(s32 *)arg1;   
  t9 = *(s32 *)(arg1 + 8);   
  t3 = *(s32 *)(arg1 + 16);   
  arg6 = (u32)arg6;   
  t9 = (u32)t9;   
  t5 = arg6 << 42;   
  t3 = (u32)t3;   
  t4 = *(u64 *)&(processor->areventcount);   
  t5 = t5 >> 42;   
  t2 = ((u64)arg4 < (u64)t3) ? 1 : 0;   
  if (t2 == 0) 
    goto fastaref1bounds;
  t6 = t4 - t5;   
  if (t6 != 0)   
    goto aref1recomputearrayregister;
  t6 = arg6 >> (Array_RegisterBytePackingPos & 63);   
  t7 = arg6 >> (Array_RegisterByteOffsetPos & 63);   
  t8 = arg6 >> (Array_RegisterElementTypePos & 63);   
  t6 = t6 & Array_RegisterBytePackingMask;
  t7 = t7 & Array_RegisterByteOffsetMask;
  t8 = t8 & Array_RegisterElementTypeMask;
  if (t6 != 0)   
    goto new-aref-1-internal9329;
  t1 = t9 + arg4;

new-aref-1-internal9330:
  if (_trace) printf("new-aref-1-internal9330:\n");
  /* Memory Read Internal */

vma-memory-read9337:
  t2 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t4 = t1 + ivory;
  t3 = *(s32 *)&processor->scovlimit;   
  t9 = (t4 * 4);   
  arg5 = LDQ_U(t4);   
  t2 = t1 - t2;   		// Stack cache offset 
  t5 = *(u64 *)&(processor->dataread_mask);   
  t3 = ((u64)t2 < (u64)t3) ? 1 : 0;   		// In range? 
  t9 = *(s32 *)t9;   
  arg5 = (u8)(arg5 >> ((t4&7)*8));   
  if (t3 != 0)   
    goto vma-memory-read9339;

vma-memory-read9338:
  t4 = zero + 240;   
  t5 = t5 >> (arg5 & 63);   
  t4 = t4 >> (arg5 & 63);   
  t9 = (u32)t9;   
  if (t5 & 1)   
    goto vma-memory-read9341;

vma-memory-read9348:
  if (t6 != 0)   
    goto new-aref-1-internal9331;

new-aref-1-internal9332:
  if (_trace) printf("new-aref-1-internal9332:\n");
  r31 = r31 | r31;
  t1 = t8 - 2;   
  if ((s64)t1 <= 0)  
    goto new-aref-1-internal9333;
  /* TagType. */
  arg5 = arg5 & 63;

new-aref-1-internal9334:
  if (_trace) printf("new-aref-1-internal9334:\n");
  *(u32 *)(iSP + 4) = arg5;
  t4 = (t6 == 0) ? 1 : 0;   
  if (t4 == 0) 
    goto case_others_77;

case_0_71:
  if (_trace) printf("case_0_71:\n");
  r31 = r31 | r31;
  if (t1 == 0) 
    goto new-aref-1-internal9335;
  *(u32 *)iSP = t9;
  goto NEXTINSTRUCTION;   

case_2_72:
  if (_trace) printf("case_2_72:\n");
  /* AREF1-8B */
  r31 = r31 | r31;
  t4 = arg4 & 3;
  t5 = (u8)(t9 >> ((t4&7)*8));   
  if (t1 == 0) 
    goto new-aref-1-internal9335;
  *(u32 *)iSP = t5;
  goto NEXTINSTRUCTION;   

case_3_73:
  if (_trace) printf("case_3_73:\n");
  /* AREF1-4B */
  r31 = r31 | r31;
  t4 = arg4 & 7;		// byte-index 
  t4 = t4 << 2;   		// byte-position 
  t5 = t9 >> (t4 & 63);   		// byte in position 
  t5 = t5 & 15;		// byte masked 
  if (t1 == 0) 
    goto new-aref-1-internal9335;
  *(u32 *)iSP = t5;
  goto NEXTINSTRUCTION;   

case_5_74:
  if (_trace) printf("case_5_74:\n");
  /* AREF1-1B */
  r31 = r31 | r31;
  t4 = arg4 & 31;		// byte-index 
  r31 = r31 | r31;
  t5 = t9 >> (t4 & 63);   		// byte in position 
  t5 = t5 & 1;		// byte masked 
  if (t1 == 0) 
    goto new-aref-1-internal9335;
  *(u32 *)iSP = t5;
  goto NEXTINSTRUCTION;   

case_1_75:
  if (_trace) printf("case_1_75:\n");
  /* AREF1-16B */
  t4 = arg4 & 1;
  t4 = t4 + t4;		// Bletch, it's a byte ref 
  t5 = (u16)(t9 >> ((t4&7)*8));   
  if (t1 == 0) 
    goto new-aref-1-internal9335;
  *(u32 *)iSP = t5;
  goto NEXTINSTRUCTION;   

case_others_77:
  if (_trace) printf("case_others_77:\n");
  r31 = r31 | r31;
  t4 = (t6 == 2) ? 1 : 0;   
  t5 = (t6 == 3) ? 1 : 0;   
  if (t4 != 0)   
    goto case_2_72;
  t4 = (t6 == 5) ? 1 : 0;   
  if (t5 != 0)   
    goto case_3_73;
  t5 = (t6 == 1) ? 1 : 0;   
  if (t4 != 0)   
    goto case_5_74;
  if (t5 != 0)   
    goto case_1_75;

case_4_76:
  if (_trace) printf("case_4_76:\n");
  /* AREF1-2B */
  r31 = r31 | r31;
  t4 = arg4 & 15;		// byte-index 
  t4 = t4 << 1;   		// byte-position 
  t5 = t9 >> (t4 & 63);   		// byte in position 
  t5 = t5 & 3;		// byte masked 
  if (t1 == 0) 
    goto new-aref-1-internal9335;
  *(u32 *)iSP = t5;
  goto NEXTINSTRUCTION;   

new-aref-1-internal9329:
  if (_trace) printf("new-aref-1-internal9329:\n");
  arg4 = t7 + arg4;
  t1 = arg4 >> (t6 & 63);   		// Convert byte index to word index 
  t1 = t1 + t9;		// Address of word containing byte 
  goto new-aref-1-internal9330;   

new-aref-1-internal9331:
  if (_trace) printf("new-aref-1-internal9331:\n");
  t1 = arg5 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto new-aref-1-internal9336;
  goto new-aref-1-internal9332;   

new-aref-1-internal9333:
  if (_trace) printf("new-aref-1-internal9333:\n");
  arg5 = Type_Character;
  if (t8 & 1)   
    goto new-aref-1-internal9334;
  arg5 = Type_Fixnum;
  if (t8 == 0) 
    goto new-aref-1-internal9334;
  t2 = *(u64 *)&(processor->niladdress);   
  t3 = *(u64 *)&(processor->taddress);   
  goto new-aref-1-internal9334;   

new-aref-1-internal9335:
  if (_trace) printf("new-aref-1-internal9335:\n");
  if (t5)   
    t2 = t3;
  *(u64 *)iSP = t2;   
  goto NEXTINSTRUCTION;   

new-aref-1-internal9336:
  if (_trace) printf("new-aref-1-internal9336:\n");
  arg5 = t1;
  arg2 = 25;
  goto illegaloperand;

fastaref1iop:
  if (_trace) printf("fastaref1iop:\n");
  arg5 = 0;
  arg2 = 32;
  goto illegaloperand;

fastaref1bounds:
  if (_trace) printf("fastaref1bounds:\n");
  arg5 = 0;
  arg2 = 13;
  goto illegaloperand;

vma-memory-read9339:
  if (_trace) printf("vma-memory-read9339:\n");
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = (t2 * 8) + t3;  		// reconstruct SCA 
  t9 = *(s32 *)t2;   
  arg5 = *(s32 *)(t2 + 4);   		// Read from stack cache 
  goto vma-memory-read9338;   

vma-memory-read9341:
  if (_trace) printf("vma-memory-read9341:\n");
  if ((t4 & 1) == 0)   
    goto vma-memory-read9340;
  t1 = (u32)t9;   		// Do the indirect thing 
  goto vma-memory-read9337;   

vma-memory-read9340:
  if (_trace) printf("vma-memory-read9340:\n");
  t5 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t4 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t4 = (t4 * 4) + t5;   		// Adjust for a longword load 
  t5 = *(s32 *)t4;   		// Get the memory action 

vma-memory-read9345:
  if (_trace) printf("vma-memory-read9345:\n");
  t4 = t5 & MemoryActionTransform;
  if (t4 == 0) 
    goto vma-memory-read9344;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto vma-memory-read9348;   

vma-memory-read9344:

vma-memory-read9343:
  /* Perform memory action */
  arg1 = t5;
  arg2 = 0;
  goto performmemoryaction;
#ifdef TRACING
#endif

DoFastAref1IM:
  goto doistageerror;

/* end DoFastAref1 */
  /* End of Halfword operand from stack instruction - DoFastAref1 */
/* start DoRplaca */

  /* Halfword operand from stack instruction - DoRplaca */

dorplaca:
  if (_trace) printf("dorplaca:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoRplacaIM:
  if (_trace) printf("DoRplacaIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment9362:
  if (_trace) printf("force-alignment9362:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindorplaca;   
#ifdef TRACING
#endif

DoRplacaSP:
  if (_trace) printf("DoRplacaSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto headdorplaca;
  arg1 = arg6;		// SP-pop mode, TOS->arg1 
  arg6 = *(u64 *)arg4;   		// Reload TOS 
  iSP = arg4;		// Adjust SP 
  goto begindorplaca;   
#ifdef TRACING
  goto headdorplaca;   
#endif

DoRplacaLP:
  if (_trace) printf("DoRplacaLP:\n");
#ifdef TRACING
  goto headdorplaca;   
#endif

DoRplacaFP:
  if (_trace) printf("DoRplacaFP:\n");

headdorplaca:
  if (_trace) printf("headdorplaca:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindorplaca:
  if (_trace) printf("begindorplaca:\n");
  /* arg1 has the operand, sign extended if immediate. */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t1 = (u32)(arg6 >> ((4&7)*8));   
  arg2 = (u32)arg6;   		// Read ARG1, the list 
  iSP = iSP - 8;   		// Pop Stack. 
  /* TagType. */
  t3 = t1 & 63;
  t4 = t3 - Type_List;   
  t4 = t4 & ~4L;
  if (t4 != 0)   
    goto rplacaexception;

rplacstore:
  if (_trace) printf("rplacstore:\n");
  t2 = arg1 >> 32;   		// Tag for t2 
  arg1 = (u32)arg1;   		// data for t2 
  /* Memory Read Internal */

vma-memory-read9349:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->datawrite_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9351;

vma-memory-read9350:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read9353;

vma-memory-read9359:
  /* Merge cdr-code */
  arg6 = t2 & 63;
  arg5 = arg5 & 192;
  arg5 = arg5 | arg6;
  t5 = arg2 + ivory;
  arg6 = (t5 * 4);   
  t7 = LDQ_U(t5);   
  t6 = arg2 - t11;   		// Stack cache offset 
  t8 = ((u64)t6 < (u64)t12) ? 1 : 0;   		// In range? 
  t6 = (arg5 & 0xff) << ((t5&7)*8);   
  t7 = t7 & ~(0xffL << (t5&7)*8);   

force-alignment9361:
  if (_trace) printf("force-alignment9361:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);   
  *(u32 *)arg6 = arg1;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write9360;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

vma-memory-write9360:
  if (_trace) printf("vma-memory-write9360:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t6 = arg2 - t11;   		// Stack cache offset 
  t5 = (t6 * 8) + t5;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t5 = arg1;
		/* write the stack cache */
  *(u32 *)(t5 + 4) = arg5;
  goto NEXTINSTRUCTION;   

vma-memory-read9353:
  if (_trace) printf("vma-memory-read9353:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9352;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9349;   

vma-memory-read9352:
  if (_trace) printf("vma-memory-read9352:\n");

vma-memory-read9351:
  if (_trace) printf("vma-memory-read9351:\n");
  r0 = (u64)&&return0292;
  goto memoryreadwritedecode;
return0292:
  goto vma-memory-read9359;   

/* end DoRplaca */
  /* End of Halfword operand from stack instruction - DoRplaca */
/* start MemoryReadWrite */


memoryreadwrite:
  if (_trace) printf("memoryreadwrite:\n");
  /* Memory Read Internal */

vma-memory-read9363:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->datawrite_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9365;

vma-memory-read9364:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read9367;

vma-memory-read9372:
  goto *r0; /* ret */

memoryreadwritedecode:
  if (_trace) printf("memoryreadwritedecode:\n");
  if (t6 == 0) 
    goto vma-memory-read9366;

vma-memory-read9365:
  if (_trace) printf("vma-memory-read9365:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  arg6 = *(s32 *)t5;   
  arg5 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read9364;   

vma-memory-read9367:
  if (_trace) printf("vma-memory-read9367:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9366;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9363;   

vma-memory-read9366:
  if (_trace) printf("vma-memory-read9366:\n");
  t8 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg2;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read9369:

vma-memory-read9368:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 1;
  goto performmemoryaction;

/* end MemoryReadWrite */
/* start DoRplacd */

  /* Halfword operand from stack instruction - DoRplacd */

dorplacd:
  if (_trace) printf("dorplacd:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoRplacdIM:
  if (_trace) printf("DoRplacdIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment9383:
  if (_trace) printf("force-alignment9383:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindorplacd;   
#ifdef TRACING
#endif

DoRplacdSP:
  if (_trace) printf("DoRplacdSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto headdorplacd;
  arg1 = arg6;		// SP-pop mode, TOS->arg1 
  arg6 = *(u64 *)arg4;   		// Reload TOS 
  iSP = arg4;		// Adjust SP 
  goto begindorplacd;   
#ifdef TRACING
  goto headdorplacd;   
#endif

DoRplacdLP:
  if (_trace) printf("DoRplacdLP:\n");
#ifdef TRACING
  goto headdorplacd;   
#endif

DoRplacdFP:
  if (_trace) printf("DoRplacdFP:\n");

headdorplacd:
  if (_trace) printf("headdorplacd:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindorplacd:
  if (_trace) printf("begindorplacd:\n");
  /* arg1 has the operand, sign extended if immediate. */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t1 = (u32)(arg6 >> ((4&7)*8));   
  arg2 = (u32)arg6;   		// Read ARG1, the list 
  iSP = iSP - 8;   		// Pop Stack. 
  /* TagType. */
  t3 = t1 & 63;
  t4 = t3 - Type_Locative;   
  if (t4 == 0) 
    goto rplacstore;
  t4 = t3 - Type_List;   
  if (t4 != 0)   
    goto rplacdexception;
  /* Memory Read Internal */

vma-memory-read9373:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->cdr_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9375;

vma-memory-read9374:
  t7 = zero + 192;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read9377;

vma-memory-read9382:
  /* TagCdr. */
  arg5 = arg5 >> 6;   
  arg5 = arg5 - Cdr_Normal;   
  if (arg5 != 0)   		// J. if CDR coded 
    goto rplacdexception;
  arg2 = arg2 + 1;		// address of CDR 
  goto rplacstore;   

vma-memory-read9377:
  if (_trace) printf("vma-memory-read9377:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9376;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9373;   

vma-memory-read9376:
  if (_trace) printf("vma-memory-read9376:\n");

vma-memory-read9375:
  if (_trace) printf("vma-memory-read9375:\n");
  r0 = (u64)&&return0293;
  goto memoryreadcdrdecode;
return0293:
  goto vma-memory-read9382;   

/* end DoRplacd */
  /* End of Halfword operand from stack instruction - DoRplacd */
/* start DoBranchTrueAndExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueAndExtraPop */

dobranchtrueandextrapop:
  if (_trace) printf("dobranchtrueandextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchTrueAndExtraPopIM:
  if (_trace) printf("DoBranchTrueAndExtraPopIM:\n");

DoBranchTrueAndExtraPopSP:
  if (_trace) printf("DoBranchTrueAndExtraPopSP:\n");

DoBranchTrueAndExtraPopLP:
  if (_trace) printf("DoBranchTrueAndExtraPopLP:\n");

DoBranchTrueAndExtraPopFP:
  if (_trace) printf("DoBranchTrueAndExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
#endif
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 != 0)   
    goto dobrpopextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   
  goto cachevalid;   

dobrpopextrapop:
  if (_trace) printf("dobrpopextrapop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 16;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
#ifndef CACHEMETERING
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;   

/* end DoBranchTrueAndExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueAndExtraPop */
/* start DoBranchFalseAndExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseAndExtraPop */

dobranchfalseandextrapop:
  if (_trace) printf("dobranchfalseandextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchFalseAndExtraPopIM:
  if (_trace) printf("DoBranchFalseAndExtraPopIM:\n");

DoBranchFalseAndExtraPopSP:
  if (_trace) printf("DoBranchFalseAndExtraPopSP:\n");

DoBranchFalseAndExtraPopLP:
  if (_trace) printf("DoBranchFalseAndExtraPopLP:\n");

DoBranchFalseAndExtraPopFP:
  if (_trace) printf("DoBranchFalseAndExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
#endif
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 == 0) 
    goto dobrnpopextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   
  goto cachevalid;   

dobrnpopextrapop:
  if (_trace) printf("dobrnpopextrapop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 16;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
#ifndef CACHEMETERING
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;   

/* end DoBranchFalseAndExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseAndExtraPop */
/* start DoBranchTrueAndNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueAndNoPop */

dobranchtrueandnopop:
  if (_trace) printf("dobranchtrueandnopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchTrueAndNoPopIM:
  if (_trace) printf("DoBranchTrueAndNoPopIM:\n");

DoBranchTrueAndNoPopSP:
  if (_trace) printf("DoBranchTrueAndNoPopSP:\n");

DoBranchTrueAndNoPopLP:
  if (_trace) printf("DoBranchTrueAndNoPopLP:\n");

DoBranchTrueAndNoPopFP:
  if (_trace) printf("DoBranchTrueAndNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
#endif
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 != 0)   
    goto dobrelsepop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   
  goto cachevalid;   

dobrelsepop:
  if (_trace) printf("dobrelsepop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iPC = iPC + arg1;		// Update the PC in halfwords 
#ifndef CACHEMETERING
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;   

/* end DoBranchTrueAndNoPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueAndNoPop */
/* start DoBranchFalseAndNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseAndNoPop */

dobranchfalseandnopop:
  if (_trace) printf("dobranchfalseandnopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchFalseAndNoPopIM:
  if (_trace) printf("DoBranchFalseAndNoPopIM:\n");

DoBranchFalseAndNoPopSP:
  if (_trace) printf("DoBranchFalseAndNoPopSP:\n");

DoBranchFalseAndNoPopLP:
  if (_trace) printf("DoBranchFalseAndNoPopLP:\n");

DoBranchFalseAndNoPopFP:
  if (_trace) printf("DoBranchFalseAndNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
#endif
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 == 0) 
    goto dobrnelsepop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   
  goto cachevalid;   

dobrnelsepop:
  if (_trace) printf("dobrnelsepop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iPC = iPC + arg1;		// Update the PC in halfwords 
#ifndef CACHEMETERING
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;   

/* end DoBranchFalseAndNoPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseAndNoPop */
/* start DoBranchFalseElseNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseElseNoPop */

dobranchfalseelsenopop:
  if (_trace) printf("dobranchfalseelsenopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchFalseElseNoPopIM:
  if (_trace) printf("DoBranchFalseElseNoPopIM:\n");

DoBranchFalseElseNoPopSP:
  if (_trace) printf("DoBranchFalseElseNoPopSP:\n");

DoBranchFalseElseNoPopLP:
  if (_trace) printf("DoBranchFalseElseNoPopLP:\n");

DoBranchFalseElseNoPopFP:
  if (_trace) printf("DoBranchFalseElseNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
#endif
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 != 0)   
    goto NEXTINSTRUCTION;
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 8;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
#ifndef CACHEMETERING
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;   

/* end DoBranchFalseElseNoPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseElseNoPop */
/* start DoEqualNumber */

  /* Halfword operand from stack instruction - DoEqualNumber */
  /* arg2 has the preloaded 8 bit operand. */

doequalnumber:
  if (_trace) printf("doequalnumber:\n");
#ifdef TRACING
#endif

DoEqualNumberSP:
  if (_trace) printf("DoEqualNumberSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoequalnumber;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindoequalnumber;   
#endif

DoEqualNumberLP:
  if (_trace) printf("DoEqualNumberLP:\n");
#ifdef TRACING
  goto begindoequalnumber;   
#endif

DoEqualNumberFP:
  if (_trace) printf("DoEqualNumberFP:\n");

begindoequalnumber:
  if (_trace) printf("begindoequalnumber:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->niladdress);   
  t7 = arg3 >> 12;   
  t12 = *(u64 *)&(processor->taddress);   
  arg3 = (u32)(arg6 >> ((4&7)*8));   		// Get ARG1 tag 
  t1 = *(s32 *)(arg1 + 4);   		// t1 is tag of arg2 
  LDS(1, f1, *(u32 *)iSP );   
  t7 = t7 & 1;
  arg2 = *(s32 *)arg1;   
  arg4 = (s32)arg6;
  LDS(2, f2, *(u32 *)arg1 );   
  t5 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_Fixnum) ? 1 : 0;   

force-alignment9401:
  if (_trace) printf("force-alignment9401:\n");
  if (t6 == 0) 
    goto basic-dispatch9389;
  /* Here if argument TypeFixnum */
  t3 = (t4 == Type_Fixnum) ? 1 : 0;   

force-alignment9393:
  if (_trace) printf("force-alignment9393:\n");
  if (t3 == 0) 
    goto binary-type-dispatch9384;
  /* Here if argument TypeFixnum */
  t2 = (s32)arg4 - (s32)arg2;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  		// Pop/No-pop 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t2 == 0)   		// T if the test succeeds 
    t11 = t12;
  *(u64 *)iSP = t11;   
  goto cachevalid;   

basic-dispatch9390:
  if (_trace) printf("basic-dispatch9390:\n");

basic-dispatch9389:
  if (_trace) printf("basic-dispatch9389:\n");
  t6 = (t5 == Type_SingleFloat) ? 1 : 0;   

force-alignment9402:
  if (_trace) printf("force-alignment9402:\n");
  if (t6 == 0) 
    goto basic-dispatch9394;
  /* Here if argument TypeSingleFloat */
  t3 = (t4 == Type_SingleFloat) ? 1 : 0;   

force-alignment9398:
  if (_trace) printf("force-alignment9398:\n");
  if (t3 == 0) 
    goto binary-type-dispatch9384;
  /* Here if argument TypeSingleFloat */

equalnumbermmexcfltflt:
  if (_trace) printf("equalnumbermmexcfltflt:\n");
  SETFLTT(3,f3, FLTU64(1,f1) == FLTU64(2,f2) ? 2.0:0);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)iSP = t12;   
  if (FLTU64(3, f3) != 0.0)   
    goto cachevalid;
  *(u64 *)iSP = t11;   		// Didn't branch, answer is NIL 
  goto cachevalid;   

basic-dispatch9395:
  if (_trace) printf("basic-dispatch9395:\n");

basic-dispatch9394:
  if (_trace) printf("basic-dispatch9394:\n");
  /* Here for all other cases */

binary-type-dispatch9384:
  if (_trace) printf("binary-type-dispatch9384:\n");
  goto equalnumbermmexc;   

basic-dispatch9388:
  if (_trace) printf("basic-dispatch9388:\n");
#ifdef TRACING
  goto DoEqualNumberIM;   
#endif

DoEqualNumberIM:
  if (_trace) printf("DoEqualNumberIM:\n");
  t11 = *(u64 *)&(processor->niladdress);   
  arg2 = arg2 << 56;   		// First half of sign extension 
  t12 = *(u64 *)&(processor->taddress);   
  t7 = arg3 >> 12;   
  arg3 = (u32)(arg6 >> ((4&7)*8));   
  arg4 = (s32)arg6;
  arg2 = (s64)arg2 >> 56;   		// Second half of sign extension 
  t7 = t7 & 1;
  t3 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = (t3 == Type_Fixnum) ? 1 : 0;   

force-alignment9407:
  if (_trace) printf("force-alignment9407:\n");
  if (t4 == 0) 
    goto basic-dispatch9404;
  /* Here if argument TypeFixnum */
  t2 = (s32)arg4 - (s32)arg2;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t2 == 0)   		// T if the test succeeds 
    t11 = t12;
  *(u64 *)iSP = t11;   
  goto cachevalid;   

basic-dispatch9404:
  if (_trace) printf("basic-dispatch9404:\n");
  /* Here for all other cases */
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

basic-dispatch9403:
  if (_trace) printf("basic-dispatch9403:\n");

/* end DoEqualNumber */
  /* End of Halfword operand from stack instruction - DoEqualNumber */
/* start DoSetToCdrPushCar */

  /* Halfword operand from stack instruction - DoSetToCdrPushCar */
  /* arg2 has the preloaded 8 bit operand. */

dosettocdrpushcar:
  if (_trace) printf("dosettocdrpushcar:\n");
#ifdef TRACING
#endif

DoSetToCdrPushCarSP:
  if (_trace) printf("DoSetToCdrPushCarSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindosettocdrpushcar;   
#endif

DoSetToCdrPushCarLP:
  if (_trace) printf("DoSetToCdrPushCarLP:\n");
#ifdef TRACING
  goto begindosettocdrpushcar;   
#endif

DoSetToCdrPushCarFP:
  if (_trace) printf("DoSetToCdrPushCarFP:\n");

begindosettocdrpushcar:
  if (_trace) printf("begindosettocdrpushcar:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t2 = *(s32 *)arg1;   		// Get the operand from the stack. 
  t1 = *(s32 *)(arg1 + 4);   
  t2 = (u32)t2;   
  t3 = t1 & 192;		// Save the old CDR code 
  t5 = t1 - Type_Locative;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 == 0) 
    goto settocdrpushcarlocative;
  r0 = (u64)&&return0294;
  goto carcdrinternal;
return0294:
  /* TagType. */
  arg5 = arg5 & 63;
  arg5 = arg5 | t3;		// Put back the original CDR codes 
  *(u32 *)arg1 = arg6;
		/* write the stack cache */
  *(u32 *)(arg1 + 4) = arg5;
  t5 = t1 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   
#ifdef TRACING
#endif

DoSetToCdrPushCarIM:
  goto doistageerror;

/* end DoSetToCdrPushCar */
  /* End of Halfword operand from stack instruction - DoSetToCdrPushCar */
/* start DoSub */

  /* Halfword operand from stack instruction - DoSub */
  /* arg2 has the preloaded 8 bit operand. */

dosub:
  if (_trace) printf("dosub:\n");
#ifdef TRACING
#endif

DoSubSP:
  if (_trace) printf("DoSubSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindosub;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindosub;   
#endif

DoSubLP:
  if (_trace) printf("DoSubLP:\n");
#ifdef TRACING
  goto begindosub;   
#endif

DoSubFP:
  if (_trace) printf("DoSubFP:\n");

begindosub:
  if (_trace) printf("begindosub:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  /* NIL */
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment9447:
  if (_trace) printf("force-alignment9447:\n");
  if (t10 == 0) 
    goto basic-dispatch9418;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment9424:
  if (_trace) printf("force-alignment9424:\n");
  if (t12 == 0) 
    goto basic-dispatch9420;
  /* Here if argument TypeFixnum */
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t5 = (s64)((s32)t2 - (s64)(s32)t4); 		// compute 64-bit result 
  if (t5 >> 32)
    exception();  /* subl/v */ 
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t9;
  iPC = t6;
  *(u32 *)iSP = t5;
  iCP = t7;
  goto cachevalid;   

basic-dispatch9420:
  if (_trace) printf("basic-dispatch9420:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment9425:
  if (_trace) printf("force-alignment9425:\n");
  if (t12 == 0) 
    goto basic-dispatch9421;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple-binary-arithmetic-operation9408;   

basic-dispatch9421:
  if (_trace) printf("basic-dispatch9421:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment9426:
  if (_trace) printf("force-alignment9426:\n");
  if (t12 == 0) 
    goto binary-type-dispatch9415;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple-binary-arithmetic-operation9411;   

basic-dispatch9419:
  if (_trace) printf("basic-dispatch9419:\n");

basic-dispatch9418:
  if (_trace) printf("basic-dispatch9418:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment9448:
  if (_trace) printf("force-alignment9448:\n");
  if (t10 == 0) 
    goto basic-dispatch9427;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment9433:
  if (_trace) printf("force-alignment9433:\n");
  if (t12 == 0) 
    goto basic-dispatch9429;
  /* Here if argument TypeSingleFloat */

simple-binary-arithmetic-operation9408:
  if (_trace) printf("simple-binary-arithmetic-operation9408:\n");
  SUBS(0, f0, 1, f1, 2, f2); /* subs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto cachevalid;   

basic-dispatch9429:
  if (_trace) printf("basic-dispatch9429:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment9434:
  if (_trace) printf("force-alignment9434:\n");
  if (t12 == 0) 
    goto basic-dispatch9430;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple-binary-arithmetic-operation9408;   

basic-dispatch9430:
  if (_trace) printf("basic-dispatch9430:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment9435:
  if (_trace) printf("force-alignment9435:\n");
  if (t12 == 0) 
    goto binary-type-dispatch9415;
  /* Here if argument TypeDoubleFloat */

simple-binary-arithmetic-operation9411:
  if (_trace) printf("simple-binary-arithmetic-operation9411:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto simple-binary-arithmetic-operation9412;   

basic-dispatch9428:
  if (_trace) printf("basic-dispatch9428:\n");

basic-dispatch9427:
  if (_trace) printf("basic-dispatch9427:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

force-alignment9449:
  if (_trace) printf("force-alignment9449:\n");
  if (t10 == 0) 
    goto basic-dispatch9436;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment9442:
  if (_trace) printf("force-alignment9442:\n");
  if (t12 == 0) 
    goto basic-dispatch9438;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0295;
  goto fetchdoublefloat;
return0295:
  LDT(1, f1, processor->fp0);   

simple-binary-arithmetic-operation9412:
  if (_trace) printf("simple-binary-arithmetic-operation9412:\n");
  arg2 = (u32)t4;   
  r0 = (u64)&&return0296;
  goto fetchdoublefloat;
return0296:
  LDT(2, f2, processor->fp0);   

simple-binary-arithmetic-operation9409:
  if (_trace) printf("simple-binary-arithmetic-operation9409:\n");
  SUBT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0297;
  goto consdoublefloat;
return0297:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto cachevalid;   

basic-dispatch9438:
  if (_trace) printf("basic-dispatch9438:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment9443:
  if (_trace) printf("force-alignment9443:\n");
  if (t12 == 0) 
    goto basic-dispatch9439;
  /* Here if argument TypeSingleFloat */

simple-binary-arithmetic-operation9410:
  if (_trace) printf("simple-binary-arithmetic-operation9410:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0298;
  goto fetchdoublefloat;
return0298:
  LDT(1, f1, processor->fp0);   
  goto simple-binary-arithmetic-operation9409;   

basic-dispatch9439:
  if (_trace) printf("basic-dispatch9439:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment9444:
  if (_trace) printf("force-alignment9444:\n");
  if (t12 == 0) 
    goto binary-type-dispatch9415;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple-binary-arithmetic-operation9410;   

basic-dispatch9437:
  if (_trace) printf("basic-dispatch9437:\n");

basic-dispatch9436:
  if (_trace) printf("basic-dispatch9436:\n");
  /* Here for all other cases */

binary-type-dispatch9414:
  if (_trace) printf("binary-type-dispatch9414:\n");

dosubovfl:
  if (_trace) printf("dosubovfl:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch9416;   

binary-type-dispatch9415:
  if (_trace) printf("binary-type-dispatch9415:\n");
  t1 = t3;
  goto dosubovfl;   

binary-type-dispatch9416:
  if (_trace) printf("binary-type-dispatch9416:\n");

basic-dispatch9417:
  if (_trace) printf("basic-dispatch9417:\n");
#ifdef TRACING
  goto DoSubIM;   
#endif

DoSubIM:
  if (_trace) printf("DoSubIM:\n");
  t1 = (u32)(arg6 >> ((4&7)*8));   
  t2 = (s32)arg6;		// get ARG1 tag/data 
  t11 = t1 & 63;		// Strip off any CDR code bits. 
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment9454:
  if (_trace) printf("force-alignment9454:\n");
  if (t12 == 0) 
    goto basic-dispatch9451;
  /* Here if argument TypeFixnum */
  t3 = t2 - arg2;   		// compute 64-bit result 
  t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t10 = (s32)t3;		// compute 32-bit sign-extended result 
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t10 = (t3 == t10) ? 1 : 0;   		// is it the same as the 64-bit result? 
  if (t10 == 0) 		// if not, we overflowed 
    goto dosubovfl;
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t11;
  iPC = t4;
  *(u32 *)iSP = t3;
  iCP = t5;
  goto cachevalid;   

basic-dispatch9451:
  if (_trace) printf("basic-dispatch9451:\n");
  /* Here for all other cases */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;   
  arg2 = zero;
  goto begindosub;   

basic-dispatch9450:
  if (_trace) printf("basic-dispatch9450:\n");

/* end DoSub */
  /* End of Halfword operand from stack instruction - DoSub */
/* start DoTag */

  /* Halfword operand from stack instruction - DoTag */
  /* arg2 has the preloaded 8 bit operand. */

dotag:
  if (_trace) printf("dotag:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoTagIM:
  if (_trace) printf("DoTagIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;   
  arg2 = zero;
  goto begindotag;   
#ifdef TRACING
#endif

DoTagSP:
  if (_trace) printf("DoTagSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindotag;   
#endif

DoTagLP:
  if (_trace) printf("DoTagLP:\n");
#ifdef TRACING
  goto begindotag;   
#endif

DoTagFP:
  if (_trace) printf("DoTagFP:\n");

begindotag:
  if (_trace) printf("begindotag:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  arg1 = *(s32 *)(arg1 + 4);   		// Get the tag of the operand 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t3 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  *(u32 *)(iSP + 8) = arg1;
  iSP = iSP + 8;
  goto cachevalid;   

/* end DoTag */
  /* End of Halfword operand from stack instruction - DoTag */
/* start DoEndp */

  /* Halfword operand from stack instruction - DoEndp */
  /* arg2 has the preloaded 8 bit operand. */

doendp:
  if (_trace) printf("doendp:\n");
#ifdef TRACING
#endif

DoEndpSP:
  if (_trace) printf("DoEndpSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindoendp;   
#endif

DoEndpLP:
  if (_trace) printf("DoEndpLP:\n");
#ifdef TRACING
  goto begindoendp;   
#endif

DoEndpFP:
  if (_trace) printf("DoEndpFP:\n");

begindoendp:
  if (_trace) printf("begindoendp:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t1 = *(u64 *)&(processor->niladdress);   
  arg2 = *(s32 *)(arg1 + 4);   		// Get tag. 
  t2 = *(u64 *)&(processor->taddress);   
  /* TagType. */
  arg2 = arg2 & 63;
  t6 = arg2 - Type_NIL;   		// Compare 
  if (t6 != 0)   
    goto endpnotnil;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)(iSP + 8) = t2;   
  iSP = iSP + 8;
  goto cachevalid;   

endpnil:
  if (_trace) printf("endpnil:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)(iSP + 8) = t1;   
  iSP = iSP + 8;
  goto cachevalid;   

endpnotnil:
  if (_trace) printf("endpnotnil:\n");
  t6 = t6 - 1;   		// Now check for list 
  if (t6 == 0) 
    goto endpnil;
  t6 = arg2 - Type_ListInstance;   
  if (t6 == 0) 
    goto endpnil;
#ifdef TRACING
  goto DoEndpIM;   
#endif

DoEndpIM:
  if (_trace) printf("DoEndpIM:\n");
  arg5 = 0;
  arg2 = 64;
  goto illegaloperand;

/* end DoEndp */
  /* End of Halfword operand from stack instruction - DoEndp */
/* start DoMinusp */

  /* Halfword operand from stack instruction - DoMinusp */
  /* arg2 has the preloaded 8 bit operand. */

dominusp:
  if (_trace) printf("dominusp:\n");
#ifdef TRACING
#endif

DoMinuspSP:
  if (_trace) printf("DoMinuspSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindominusp;   
#endif

DoMinuspLP:
  if (_trace) printf("DoMinuspLP:\n");
#ifdef TRACING
  goto begindominusp;   
#endif

DoMinuspFP:
  if (_trace) printf("DoMinuspFP:\n");

begindominusp:
  if (_trace) printf("begindominusp:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->niladdress);   
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t1 = *(s32 *)(arg1 + 4);   
  t12 = *(u64 *)&(processor->taddress);   
  t2 = *(s32 *)arg1;   
  LDS(1, f1, *(u32 *)arg1 );   
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t5 = (t4 == Type_Fixnum) ? 1 : 0;   

force-alignment9460:
  if (_trace) printf("force-alignment9460:\n");
  if (t5 == 0) 
    goto basic-dispatch9456;
  /* Here if argument TypeFixnum */
  iPC = t6;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if ((s64)t2 < 0)   		// T if predicate succeeds 
    t11 = t12;
  *(u64 *)(iSP + 8) = t11;   
  iSP = iSP + 8;
  goto cachevalid;   

basic-dispatch9456:
  if (_trace) printf("basic-dispatch9456:\n");
  t5 = (t4 == Type_SingleFloat) ? 1 : 0;   

force-alignment9461:
  if (_trace) printf("force-alignment9461:\n");
  if (t5 == 0) 
    goto basic-dispatch9457;
  /* Here if argument TypeSingleFloat */
  iPC = t6;
  *(u64 *)(iSP + 8) = t12;   
  iSP = iSP + 8;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (FLTU64(1, f1) < 0.0)   
    goto cachevalid;
  *(u64 *)iSP = t11;   		// Didn't branch, answer is NIL 
  goto cachevalid;   

basic-dispatch9457:
  if (_trace) printf("basic-dispatch9457:\n");
  /* Here for all other cases */
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto unarynumericexception;

basic-dispatch9455:
  if (_trace) printf("basic-dispatch9455:\n");
#ifdef TRACING
  goto DoMinuspIM;   
#endif

DoMinuspIM:
  if (_trace) printf("DoMinuspIM:\n");
  t1 = *(u64 *)&(processor->niladdress);   
  arg2 = arg2 << 56;   		// Turned into a signed number 
  t2 = *(u64 *)&(processor->taddress);   
  iSP = iSP + 8;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if ((s64)arg2 < 0)   		// stall 2 then di 
    t1 = t2;
  *(u64 *)iSP = t1;   		// yes Virginia, we dual issue with above yahoo 
  goto cachevalid;   

/* end DoMinusp */
  /* End of Halfword operand from stack instruction - DoMinusp */
/* start DoPlusp */

  /* Halfword operand from stack instruction - DoPlusp */
  /* arg2 has the preloaded 8 bit operand. */

doplusp:
  if (_trace) printf("doplusp:\n");
#ifdef TRACING
#endif

DoPluspSP:
  if (_trace) printf("DoPluspSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindoplusp;   
#endif

DoPluspLP:
  if (_trace) printf("DoPluspLP:\n");
#ifdef TRACING
  goto begindoplusp;   
#endif

DoPluspFP:
  if (_trace) printf("DoPluspFP:\n");

begindoplusp:
  if (_trace) printf("begindoplusp:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->niladdress);   
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t1 = *(s32 *)(arg1 + 4);   
  t12 = *(u64 *)&(processor->taddress);   
  t2 = *(s32 *)arg1;   
  LDS(1, f1, *(u32 *)arg1 );   
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t5 = (t4 == Type_Fixnum) ? 1 : 0;   

force-alignment9467:
  if (_trace) printf("force-alignment9467:\n");
  if (t5 == 0) 
    goto basic-dispatch9463;
  /* Here if argument TypeFixnum */
  iPC = t6;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if ((s64)t2 > 0)   		// T if predicate succeeds 
    t11 = t12;
  *(u64 *)(iSP + 8) = t11;   
  iSP = iSP + 8;
  goto cachevalid;   

basic-dispatch9463:
  if (_trace) printf("basic-dispatch9463:\n");
  t5 = (t4 == Type_SingleFloat) ? 1 : 0;   

force-alignment9468:
  if (_trace) printf("force-alignment9468:\n");
  if (t5 == 0) 
    goto basic-dispatch9464;
  /* Here if argument TypeSingleFloat */
  iPC = t6;
  *(u64 *)(iSP + 8) = t12;   
  iSP = iSP + 8;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (FLTU64(1, f1) > 0.0)   
    goto cachevalid;
  *(u64 *)iSP = t11;   		// Didn't branch, answer is NIL 
  goto cachevalid;   

basic-dispatch9464:
  if (_trace) printf("basic-dispatch9464:\n");
  /* Here for all other cases */
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto unarynumericexception;

basic-dispatch9462:
  if (_trace) printf("basic-dispatch9462:\n");
#ifdef TRACING
  goto DoPluspIM;   
#endif

DoPluspIM:
  if (_trace) printf("DoPluspIM:\n");
  t1 = *(u64 *)&(processor->niladdress);   
  arg2 = arg2 << 56;   		// Turned into a signed number 
  t2 = *(u64 *)&(processor->taddress);   
  iSP = iSP + 8;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if ((s64)arg2 > 0)   		// stall 2 then di 
    t1 = t2;
  *(u64 *)iSP = t1;   		// yes Virginia, we dual issue with above yahoo 
  goto cachevalid;   

/* end DoPlusp */
  /* End of Halfword operand from stack instruction - DoPlusp */
/* start DoLessp */

  /* Halfword operand from stack instruction - DoLessp */
  /* arg2 has the preloaded 8 bit operand. */

dolessp:
  if (_trace) printf("dolessp:\n");
#ifdef TRACING
#endif

DoLesspSP:
  if (_trace) printf("DoLesspSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindolessp;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindolessp;   
#endif

DoLesspLP:
  if (_trace) printf("DoLesspLP:\n");
#ifdef TRACING
  goto begindolessp;   
#endif

DoLesspFP:
  if (_trace) printf("DoLesspFP:\n");

begindolessp:
  if (_trace) printf("begindolessp:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->niladdress);   
  t7 = arg3 >> 12;   
  t12 = *(u64 *)&(processor->taddress);   
  arg3 = (u32)(arg6 >> ((4&7)*8));   		// Get ARG1 tag 
  t1 = *(s32 *)(arg1 + 4);   		// t1 is tag of arg2 
  LDS(1, f1, *(u32 *)iSP );   
  t7 = t7 & 1;
  arg2 = *(s32 *)arg1;   
  arg4 = (s32)arg6;
  LDS(2, f2, *(u32 *)arg1 );   
  t5 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_Fixnum) ? 1 : 0;   

force-alignment9486:
  if (_trace) printf("force-alignment9486:\n");
  if (t6 == 0) 
    goto basic-dispatch9474;
  /* Here if argument TypeFixnum */
  t3 = (t4 == Type_Fixnum) ? 1 : 0;   

force-alignment9478:
  if (_trace) printf("force-alignment9478:\n");
  if (t3 == 0) 
    goto binary-type-dispatch9469;
  /* Here if argument TypeFixnum */
  t2 = arg4 - arg2;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  		// Pop/No-pop 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if ((s64)t2 < 0)   		// T if the test succeeds 
    t11 = t12;
  *(u64 *)iSP = t11;   
  goto cachevalid;   

basic-dispatch9475:
  if (_trace) printf("basic-dispatch9475:\n");

basic-dispatch9474:
  if (_trace) printf("basic-dispatch9474:\n");
  t6 = (t5 == Type_SingleFloat) ? 1 : 0;   

force-alignment9487:
  if (_trace) printf("force-alignment9487:\n");
  if (t6 == 0) 
    goto basic-dispatch9479;
  /* Here if argument TypeSingleFloat */
  t3 = (t4 == Type_SingleFloat) ? 1 : 0;   

force-alignment9483:
  if (_trace) printf("force-alignment9483:\n");
  if (t3 == 0) 
    goto binary-type-dispatch9469;
  /* Here if argument TypeSingleFloat */

lesspmmexcfltflt:
  if (_trace) printf("lesspmmexcfltflt:\n");
  SETFLTT(3,f3, FLTU64(1,f1) < FLTU64(2,f2) ? 2.0:0);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)iSP = t12;   
  if (FLTU64(3, f3) != 0.0)   
    goto cachevalid;
  *(u64 *)iSP = t11;   		// Didn't branch, answer is NIL 
  goto cachevalid;   

basic-dispatch9480:
  if (_trace) printf("basic-dispatch9480:\n");

basic-dispatch9479:
  if (_trace) printf("basic-dispatch9479:\n");
  /* Here for all other cases */

binary-type-dispatch9469:
  if (_trace) printf("binary-type-dispatch9469:\n");
  goto lesspmmexc;   

basic-dispatch9473:
  if (_trace) printf("basic-dispatch9473:\n");
#ifdef TRACING
  goto DoLesspIM;   
#endif

DoLesspIM:
  if (_trace) printf("DoLesspIM:\n");
  t11 = *(u64 *)&(processor->niladdress);   
  arg2 = arg2 << 56;   		// First half of sign extension 
  t12 = *(u64 *)&(processor->taddress);   
  t7 = arg3 >> 12;   
  arg3 = (u32)(arg6 >> ((4&7)*8));   
  arg4 = (s32)arg6;
  arg2 = (s64)arg2 >> 56;   		// Second half of sign extension 
  t7 = t7 & 1;
  t3 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = (t3 == Type_Fixnum) ? 1 : 0;   

force-alignment9492:
  if (_trace) printf("force-alignment9492:\n");
  if (t4 == 0) 
    goto basic-dispatch9489;
  /* Here if argument TypeFixnum */
  t2 = arg4 - arg2;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if ((s64)t2 < 0)   		// T if the test succeeds 
    t11 = t12;
  *(u64 *)iSP = t11;   
  goto cachevalid;   

basic-dispatch9489:
  if (_trace) printf("basic-dispatch9489:\n");
  /* Here for all other cases */
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

basic-dispatch9488:
  if (_trace) printf("basic-dispatch9488:\n");

/* end DoLessp */
  /* End of Halfword operand from stack instruction - DoLessp */
/* start DoDecrement */

  /* Halfword operand from stack instruction - DoDecrement */
  /* arg2 has the preloaded 8 bit operand. */

dodecrement:
  if (_trace) printf("dodecrement:\n");
#ifdef TRACING
#endif

DoDecrementSP:
  if (_trace) printf("DoDecrementSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindodecrement;   
#endif

DoDecrementLP:
  if (_trace) printf("DoDecrementLP:\n");
#ifdef TRACING
  goto begindodecrement;   
#endif

DoDecrementFP:
  if (_trace) printf("DoDecrementFP:\n");

begindodecrement:
  if (_trace) printf("begindodecrement:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg3 = *(s32 *)arg1;   		// read tag/data of arg1 
  arg2 = *(s32 *)(arg1 + 4);   
  arg3 = (u32)arg3;   
  t1 = arg2 & 63;		// Strip off any CDR code bits. 
  t2 = (t1 == Type_Fixnum) ? 1 : 0;   

force-alignment9498:
  if (_trace) printf("force-alignment9498:\n");
  if (t2 == 0) 
    goto basic-dispatch9494;
  /* Here if argument TypeFixnum */
  t2 = *(u64 *)&(processor->mostnegativefixnum);   
  t3 = arg3 - 1;   
  t2 = (arg3 == t2) ? 1 : 0;   
  if (t2 != 0)   
    goto decrementexception;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u32 *)arg1 = t3;
		/* write the stack cache */
  *(u32 *)(arg1 + 4) = arg2;
  goto cachevalid;   

basic-dispatch9494:
  if (_trace) printf("basic-dispatch9494:\n");
  t2 = (t1 == Type_SingleFloat) ? 1 : 0;   

force-alignment9499:
  if (_trace) printf("force-alignment9499:\n");
  if (t2 == 0) 
    goto basic-dispatch9495;
  /* Here if argument TypeSingleFloat */
  /* NIL */
  LDS(1, f1, *(u32 *)arg1 );   		// Get the floating data 
  LDS(2, f2, processor->sfp1);   		// constant 1.0 
  SUBS(0, f0, 1, f1, 2, f2); /* subs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  STS( (u32 *)arg1, 0, f0 );   		// Put the floating result 
  goto cachevalid;   

basic-dispatch9495:
  if (_trace) printf("basic-dispatch9495:\n");
  /* Here for all other cases */
  goto decrementexception;   

basic-dispatch9493:
  if (_trace) printf("basic-dispatch9493:\n");
#ifdef TRACING
#endif

DoDecrementIM:
  goto doistageerror;

/* end DoDecrement */
  /* End of Halfword operand from stack instruction - DoDecrement */
/* start DoMergeCdrNoPop */

  /* Halfword operand from stack instruction - DoMergeCdrNoPop */
  /* arg2 has the preloaded 8 bit operand. */

domergecdrnopop:
  if (_trace) printf("domergecdrnopop:\n");
#ifdef TRACING
#endif

DoMergeCdrNoPopSP:
  if (_trace) printf("DoMergeCdrNoPopSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomergecdrnopop;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindomergecdrnopop;   
#endif

DoMergeCdrNoPopLP:
  if (_trace) printf("DoMergeCdrNoPopLP:\n");
#ifdef TRACING
  goto begindomergecdrnopop;   
#endif

DoMergeCdrNoPopFP:
  if (_trace) printf("DoMergeCdrNoPopFP:\n");

begindomergecdrnopop:
  if (_trace) printf("begindomergecdrnopop:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t1 = *(s32 *)(arg1 + 4);   		// Get the CDR CODE/TAG of arg2 
  t2 = (u32)(arg6 >> ((4&7)*8));   		// Get the CDR CODE/TAG of arg1 

force-alignment9500:
  if (_trace) printf("force-alignment9500:\n");
  t2 = t2 & 192;		// Get Just the CDR code in position 
  t1 = t1 & 63;		// Get the TAG of arg1 
  t3 = t1 | t2;		// Merge the tag of arg2 with the cdr code of arg1 
		/* Replace tag/cdr code no pop */
  *(u32 *)(arg1 + 4) = t3;
  goto cachevalid;   
#ifdef TRACING
#endif

DoMergeCdrNoPopIM:
  goto doistageerror;

/* end DoMergeCdrNoPop */
  /* End of Halfword operand from stack instruction - DoMergeCdrNoPop */
/* start DoEqImmediateHandler */


doeqimmediatehandler:
  if (_trace) printf("doeqimmediatehandler:\n");
#ifdef TRACING
  goto DoEqIM;   
#endif

DoEqIM:
  if (_trace) printf("DoEqIM:\n");
  arg2 = arg2 << 56;   
  t4 = *(s32 *)(iSP + 4);   		// t4=tag t3=data 
  t3 = *(s32 *)iSP;   
  arg3 = arg3 >> 12;   
  t11 = *(u64 *)&(processor->niladdress);   
  arg2 = (s64)arg2 >> 56;   		// Sign extension of arg2 is complete 
  /* TagType. */
  t4 = t4 & 63;
  t12 = *(u64 *)&(processor->taddress);   
  arg3 = arg3 & 1;		// 1 if no-pop, 0 if pop 
  arg2 = (s32)t3 - (s32)arg2;   
  t4 = t4 ^ Type_Fixnum;   
  iSP = (arg3 * 8) + iSP;  		// Either a stack-push or a stack-write 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t4 = arg2 | t4;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t4 == 0)   
    t11 = t12;
  *(u64 *)iSP = t11;   		// Yes Virginia, this does dual issue with above 
  goto cachevalid;   

/* end DoEqImmediateHandler */
/* start DoIncrement */

  /* Halfword operand from stack instruction - DoIncrement */
  /* arg2 has the preloaded 8 bit operand. */

doincrement:
  if (_trace) printf("doincrement:\n");
#ifdef TRACING
#endif

DoIncrementSP:
  if (_trace) printf("DoIncrementSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindoincrement;   
#endif

DoIncrementLP:
  if (_trace) printf("DoIncrementLP:\n");
#ifdef TRACING
  goto begindoincrement;   
#endif

DoIncrementFP:
  if (_trace) printf("DoIncrementFP:\n");

begindoincrement:
  if (_trace) printf("begindoincrement:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg3 = *(s32 *)arg1;   		// read tag/data of arg1 
  arg2 = *(s32 *)(arg1 + 4);   
  arg3 = (u32)arg3;   
  t1 = arg2 & 63;		// Strip off any CDR code bits. 
  t2 = (t1 == Type_Fixnum) ? 1 : 0;   

force-alignment9506:
  if (_trace) printf("force-alignment9506:\n");
  if (t2 == 0) 
    goto basic-dispatch9502;
  /* Here if argument TypeFixnum */
  t2 = *(u64 *)&(processor->mostpositivefixnum);   
  t3 = arg3 + 1;
  t2 = (arg3 == t2) ? 1 : 0;   
  if (t2 != 0)   
    goto incrementexception;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u32 *)arg1 = t3;
		/* write the stack cache */
  *(u32 *)(arg1 + 4) = arg2;
  goto cachevalid;   

basic-dispatch9502:
  if (_trace) printf("basic-dispatch9502:\n");
  t2 = (t1 == Type_SingleFloat) ? 1 : 0;   

force-alignment9507:
  if (_trace) printf("force-alignment9507:\n");
  if (t2 == 0) 
    goto basic-dispatch9503;
  /* Here if argument TypeSingleFloat */
  /* NIL */
  LDS(1, f1, *(u32 *)arg1 );   		// Get the floating data 
  LDS(2, f2, processor->sfp1);   		// constant 1.0 
  ADDS(0, f0, 1, f1, 2, f2); /* adds */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  STS( (u32 *)arg1, 0, f0 );   		// Put the floating result 
  goto cachevalid;   

basic-dispatch9503:
  if (_trace) printf("basic-dispatch9503:\n");
  /* Here for all other cases */
  goto incrementexception;   

basic-dispatch9501:
  if (_trace) printf("basic-dispatch9501:\n");
#ifdef TRACING
#endif

DoIncrementIM:
  goto doistageerror;

/* end DoIncrement */
  /* End of Halfword operand from stack instruction - DoIncrement */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifuncom2.as */
