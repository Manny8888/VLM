/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifuncom1.as
 ************************************************************************/

  /* The most commonly used instructions, part 1.  */
/* start DoPush */

  /* Halfword operand from stack instruction - DoPush */
  /* arg2 has the preloaded 8 bit operand. */

dopush:
  if (_trace) printf("dopush:\n");
#ifdef TRACING
#endif

DoPushSP:
  if (_trace) printf("DoPushSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindopush;   
#endif

DoPushLP:
  if (_trace) printf("DoPushLP:\n");
#ifdef TRACING
  goto begindopush;   
#endif

DoPushFP:
  if (_trace) printf("DoPushFP:\n");

begindopush:
  if (_trace) printf("begindopush:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = iSP + 8;		// Push the new value 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t1 = *(s32 *)(arg1 + 4);   		// Get the tag/data 
  t2 = *(s32 *)arg1;   
		/* Store the data word */
  *(u32 *)iSP = t2;

force-alignment8843:
  if (_trace) printf("force-alignment8843:\n");
  /* TagType. */
  t1 = t1 & 63;		// make it CDR NEXT 
		/* Store the TAG - this *DOES* dual issue! */
  *(u32 *)(iSP + 4) = t1;

/* end DoPush */
  /* End of Halfword operand from stack instruction - DoPush */
/* start nextInstruction */


nextinstruction:
  if (_trace) printf("nextinstruction:\n");

cachevalid:
  if (_trace) printf("cachevalid:\n");
  arg3 = *(u64 *)&(((CACHELINEP)iCP)->instruction);   		// Grab the instruction/operand while stalled 
  arg1 = iFP;   		// Assume FP mode 
  t2 = *(u64 *)&(((CACHELINEP)iCP)->pcdata);   		// Get the PC to check cache hit. 
  arg4 = iSP + -8;   		// SP-pop mode constant 

continuecurrentinstruction:
  if (_trace) printf("continuecurrentinstruction:\n");
  t3 = *(u64 *)&(((CACHELINEP)iCP)->code);   		// Instruction handler 
  arg5 = iSP + -2040;   		// SP mode constant 
  *(u64 *)&processor->restartsp = iSP;   		// Need this in case we take a trap 
  t4 = (u8)(arg3 >> ((5&7)*8));   		// Get the mode bits 
  t2 = t2 - iPC;   		// check for HIT. 
  arg6 = *(u64 *)iSP;   		// Load TOS in free di slot 
  arg2 = (u8)(arg3 >> ((4&7)*8));   		// Extract (8-bit, unsigned) operand 
  if (t2 != 0)   		// PC didn't match, take a cache miss 
    goto takeicachemiss;
  if (t4 & 1)   		// LP or Immediate mode 
   arg1 = iLP;
#ifdef TRACING
  /* Update the instruction count. */
  t4 = *(u64 *)&(processor->instruction_count);   
  t4 = t4 - 1;   		// Decrement the instruction count. 
  if (t4 != 0)   		// J. if not reached stop point. 
    goto maybe-icount8850;
  zero = zero;		// put a breakpoint here to catch stops 

maybe-icount8850:
  if (_trace) printf("maybe-icount8850:\n");
  *(u64 *)&processor->instruction_count = t4;   
  /* Trace instructions if requested. */
  t4 = *(u64 *)&(processor->trace_hook);   
  if (t4 == 0) 		// J. if not tracing. 
    goto maybe-trace8855;
  /* Record an instruction trace entry */
  t5 = *(s32 *)&t4->tracedata_recording_p;   
  t6 = *(u64 *)&(t4->tracedata_start_pc);   
  if (t5 != 0)   		// Jump if recording is on 
    goto maybe-trace8851;
  t6 = (t6 == iPC) ? 1 : 0;   		// Turn recording on if at the start PC 
  *(u32 *)&t4->tracedata_recording_p = t6;
  if (t6 == 0) 		// Jump if not at the start PC 
    goto maybe-trace8855;

maybe-trace8851:
  if (_trace) printf("maybe-trace8851:\n");
  t5 = *(u64 *)&(t4->tracedata_current_entry);   		// Get address of next trace record  
  t6 = *(u64 *)&(processor->instruction_count);   
  *(u64 *)&t5->tracerecord_epc = iPC;   		// Save current PC 
  *(u64 *)&t5->tracerecord_counter = t6;   		// Save instruction count 
  t6 = *(u64 *)iSP;   
  /* Convert stack cache address to VMA */
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = *(u64 *)&(processor->stackcachebasevma);   
  t8 = iSP - t8;   		// stack cache base relative offset 
  t8 = t8 >> 3;   		// convert byte address to word address 
  t7 = t8 + t7;		// reconstruct VMA 
  *(u64 *)&t5->tracerecord_tos = t6;   		// Save current value of TOS 
  *(u64 *)&t5->tracerecord_sp = t7;   		// Save current SP 
  t6 = *(s32 *)&((CACHELINEP)iCP)->operand;   
  t7 = *(u64 *)&(((CACHELINEP)iCP)->code);   
		/* Save current instruction's operand */
  *(u32 *)&t5->tracerecord_operand = t6;
  *(u64 *)&t5->tracerecord_instruction = t7;   		// Save pointer to current instruction code 
  t7 = *(u64 *)&(processor->control);   
  t8 = *(u64 *)&(((CACHELINEP)iCP)->instruction);   
		/* We don't yet record catch blocks */
  *(u32 *)&t5->tracerecord_catch_block_p = zero;
  *(u64 *)&t5->tracerecord_catch_block_0 = t7;   		// Save control register 
  t6 = *(u64 *)&(processor->tvi);   
  *(u64 *)&t5->tracerecord_instruction_data = t8;   		// Save full word instruction operand 
		/* Save trap indiciator */
  *(u32 *)&t5->tracerecord_trap_p = t6;
  if (t6 == 0) 		// Jump if didn't trap 
    goto maybe-trace8852;
  t6 = *(u64 *)(iFP + 16);   
  *(u64 *)&processor->tvi = zero;   		// Zero flag to avoid false trap entries 
  t7 = *(u64 *)(iFP + 24);   
  *(u64 *)&t5->tracerecord_trap_data_0 = t6;   		// Save trap vector index 
  t8 = *(u64 *)(iFP + 32);   
  *(u64 *)&t5->tracerecord_trap_data_1 = t7;   		// Save fault PC 
  t9 = *(u64 *)(iFP + 40);   
  *(u64 *)&t5->tracerecord_trap_data_2 = t8;   		// Save two additional arguments 
  *(u64 *)&t5->tracerecord_trap_data_3 = t9;   

maybe-trace8852:
  if (_trace) printf("maybe-trace8852:\n");
  t5 = t5 + tracerecordsize;		// Bump to next trace record 
  t6 = *(u64 *)&(t4->tracedata_records_start);   		// Get pointer to start of trace records 
  *(u64 *)&t4->tracedata_current_entry = t5;   		// Set record pointer to keep printer happy 
  t7 = *(u64 *)&(t4->tracedata_records_end);   		// Get pointer to end of trace record 
  t8 = *(u64 *)&(t4->tracedata_printer);   		// Function to print trace if non-zero 
  t7 = ((s64)t7 <= (s64)t5) ? 1 : 0;   		// Non-zero iff we're about to wrap the circular buffer 
  if (t7)   		// Update next record pointer iff we wrapped 
    t5 = t6;
  if (t7 == 0)   		// Don't print if we didn't wrap 
    t8 = zero;
  if (t8 == 0) 		// Jump if we don't need to print 
    goto maybe-trace8853;
  *(u64 *)&processor->cp = iCP;   
  *(u64 *)&processor->epc = iPC;   
  *(u64 *)&processor->sp = iSP;   
  *(u64 *)&processor->fp = iFP;   
  *(u64 *)&processor->lp = iLP;   
  *(u64 *)&processor->asrf2 = arg1;   
  *(u64 *)&processor->asrf3 = arg2;   
  *(u64 *)&processor->asrf4 = arg3;   
  *(u64 *)&processor->asrf5 = arg4;   
  *(u64 *)&processor->asrf6 = arg5;   
  *(u64 *)&processor->asrf7 = arg6;   
  *(u64 *)&processor->asrf8 = t4;   
  *(u64 *)&processor->asrf9 = t5;   
  *(u64 *)&processor->long_pad1 = t3;   
  r9 = *(u64 *)&(processor->asrr9);   
  r10 = *(u64 *)&(processor->asrr10);   
  r11 = *(u64 *)&(processor->asrr11);   
  r12 = *(u64 *)&(processor->asrr12);   
  r13 = *(u64 *)&(processor->asrr13);   
  r15 = *(u64 *)&(processor->asrr15);   
  r27 = *(u64 *)&(processor->asrr27);   
  r29 = *(u64 *)&(processor->asrr29);   
  pv = t8;
    r0 = (*( u64 (*)(u64, u64) )t8)(arg1, arg2); /* jsr */  
  r9 = *(u64 *)&(processor->asrr9);   
  r10 = *(u64 *)&(processor->asrr10);   
  r11 = *(u64 *)&(processor->asrr11);   
  r12 = *(u64 *)&(processor->asrr12);   
  r13 = *(u64 *)&(processor->asrr13);   
  r15 = *(u64 *)&(processor->asrr15);   
  r27 = *(u64 *)&(processor->asrr27);   
  r29 = *(u64 *)&(processor->asrr29);   
  arg1 = *(u64 *)&(processor->asrf2);   
  arg2 = *(u64 *)&(processor->asrf3);   
  arg3 = *(u64 *)&(processor->asrf4);   
  arg4 = *(u64 *)&(processor->asrf5);   
  arg5 = *(u64 *)&(processor->asrf6);   
  arg6 = *(u64 *)&(processor->asrf7);   
  t4 = *(u64 *)&(processor->asrf8);   
  t5 = *(u64 *)&(processor->asrf9);   
  t3 = *(u64 *)&(processor->long_pad1);   
  iCP = *(u64 *)&(processor->cp);   
  iPC = *(u64 *)&(processor->epc);   
  iSP = *(u64 *)&(processor->sp);   
  iFP = *(u64 *)&(processor->fp);   
  iLP = *(u64 *)&(processor->lp);   
  t7 = zero;		// Claim we didn't wrap 

maybe-trace8853:
  if (_trace) printf("maybe-trace8853:\n");
  *(u64 *)&t4->tracedata_current_entry = t5;   		// Save next record pointer 
  if (t7 == 0) 		// Jump if we didn't wrap 
    goto maybe-trace8854;
		/* Set flag indicating that we wrapped */
  *(u32 *)&t4->tracedata_wrap_p = t7;

maybe-trace8854:
  if (_trace) printf("maybe-trace8854:\n");
  t5 = *(u64 *)&(t4->tracedata_stop_pc);   
  t5 = (t5 == iPC) ? 1 : 0;   		// Non-zero if at PC where we should stop tracing 
  t5 = (t5 == 0) ? 1 : 0;   		// Non-zero if not at the PC 
		/* Update recording flag */
  *(u32 *)&t4->tracedata_recording_p = t5;

maybe-trace8855:
  if (_trace) printf("maybe-trace8855:\n");
#endif
#ifdef STATISTICS
  t4 = *(u64 *)&(((CACHELINEP)iCP)->code);   		// The instruction. 
  t5 = *(u64 *)&(processor->statistics);   		// The usage statistics array 
  t9 = zero + 8191;   
  t6 = t4 >> 4;   
  t6 = t6 & t9;		// Extract the address 
  t7 = (t6 * 4) + t5;   		// Compute the index to the usage data for this instn. 
  t8 = *(s32 *)t7;   		// Get current usage data 
  t8 = t8 + 1;		// Increment 
		/* Set current usage data */
  *(u32 *)t7 = t8;
#endif
#ifdef CACHEMETERING
  t5 = *(s32 *)&processor->metercount;   		// The number of remaining tokens. 
  t4 = *(u64 *)&(processor->meterdatabuff);   		// The cache miss meter buffer. 
  t7 = *(s32 *)&processor->meterpos;   		// Position for new data. 
  t5 = t5 - 1;   		// record a cache hit 
  if (t5 != 0)   
    goto maybe-meter-hit8856;
  t8 = *(s32 *)&processor->metermask;   
  t4 = (t7 * 4) + t4;   		// position of the current data item 
  t9 = *(s32 *)&processor->metervalue;   
  t7 = t7 + 1;
  t7 = t7 & t8;
  t8 = *(s32 *)&processor->metermax;   
  t6 = t9 - t8;   
  if ((s64)t6 > 0)   
    t8 = t9;
  *(u32 *)&processor->metermax = t8;
		/* store the datapoint */
  *(u32 *)t4 = t9;
		/* Position for new data. */
  *(u32 *)&processor->meterpos = t7;
  *(u32 *)&processor->metervalue = zero;
  t5 = *(s32 *)&processor->meterfreq;   

maybe-meter-hit8856:
  if (_trace) printf("maybe-meter-hit8856:\n");
  *(u32 *)&processor->metercount = t5;
#endif
#ifdef DEBUGGING
  if (t3 == 0) 		// Just in case... 
    goto haltmachine;
#endif
    goto *t3; /* jmp */   		// Jump to the handler 
  /* Here to advance the PC and begin a new instruction.  Most */
  /* instructions come here when they have finished.  Instructions */
  /* that explicitly update the PC (and CP) go to interpretInstruction. */

NEXTINSTRUCTION:
  if (_trace) printf("NEXTINSTRUCTION:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   		// Load the next PC from the cache 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   		// Advance cache position 
  goto cachevalid;   

takeicachemiss:
  if (_trace) printf("takeicachemiss:\n");
  goto ICACHEMISS;

/* end nextInstruction */
/* start DoPushImmediateHandler */


dopushimmediatehandler:
  if (_trace) printf("dopushimmediatehandler:\n");
#ifdef TRACING
  goto DoPushIM;   
#endif

DoPushIM:
  if (_trace) printf("DoPushIM:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t4 = Type_Fixnum;
		/* Push it with CDR-NEXT onto the stack */
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  goto cachevalid;   

/* end DoPushImmediateHandler */
/* start DoBranchTrue */

  /* Halfword 10 bit immediate instruction - DoBranchTrue */

dobranchtrue:
  if (_trace) printf("dobranchtrue:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchTrueIM:
  if (_trace) printf("DoBranchTrueIM:\n");

DoBranchTrueSP:
  if (_trace) printf("DoBranchTrueSP:\n");

DoBranchTrueLP:
  if (_trace) printf("DoBranchTrueLP:\n");

DoBranchTrueFP:
  if (_trace) printf("DoBranchTrueFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
#endif
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 != 0)   
    goto dobrpopelsepop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   
  goto cachevalid;   

dobrpopelsepop:
  if (_trace) printf("dobrpopelsepop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 8;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
#ifndef CACHEMETERING
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;   

/* end DoBranchTrue */
  /* End of Halfword operand from stack instruction - DoBranchTrue */
/* start DoBranchFalse */

  /* Halfword 10 bit immediate instruction - DoBranchFalse */

dobranchfalse:
  if (_trace) printf("dobranchfalse:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchFalseIM:
  if (_trace) printf("DoBranchFalseIM:\n");

DoBranchFalseSP:
  if (_trace) printf("DoBranchFalseSP:\n");

DoBranchFalseLP:
  if (_trace) printf("DoBranchFalseLP:\n");

DoBranchFalseFP:
  if (_trace) printf("DoBranchFalseFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
#endif
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 == 0) 
    goto dobrnpopelsepop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   
  goto cachevalid;   

dobrnpopelsepop:
  if (_trace) printf("dobrnpopelsepop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 8;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
#ifndef CACHEMETERING
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;   

/* end DoBranchFalse */
  /* End of Halfword operand from stack instruction - DoBranchFalse */
/* start DoReturnSingle */

  /* Halfword 10 bit immediate instruction - DoReturnSingle */

doreturnsingle:
  if (_trace) printf("doreturnsingle:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoReturnSingleIM:
  if (_trace) printf("DoReturnSingleIM:\n");

DoReturnSingleSP:
  if (_trace) printf("DoReturnSingleSP:\n");

DoReturnSingleLP:
  if (_trace) printf("DoReturnSingleLP:\n");

DoReturnSingleFP:
  if (_trace) printf("DoReturnSingleFP:\n");
  /* arg1 has operand preloaded. */
  /* Fetch value based on immediate, interleaved with compute disposition dispatch */
  arg5 = *(s32 *)&processor->control;   
  arg3 = arg6 << 26;   		// Clear cdr 
  t3 = (12) << 16;   
  t1 = *(u64 *)&(processor->niladdress);   
  arg3 = arg3 >> 26;   		// Clear cdr 
  t2 = *(u64 *)&(processor->taddress);   
  t3 = t3 & arg5;		// mask disposition bits 
  t3 = t3 >> 18;   		// shift disposition bits into place 
  arg6 = *(u64 *)&(processor->stackcachedata);   
  /* arg2 is 8 bits of "kludge operand" 0=TOS 40=NIL 41=T */
  if ((s64)arg2 > 0)   
    arg3 = t1;
  arg4 = t3 - 2;   		// arg4 -2=effect -1=value 0=return 1=multiple 
  if (arg2 & 1)   
   arg3 = t2;

returncommontail:
  if (_trace) printf("returncommontail:\n");
  /* Restore machine state from frame header. */
  t3 = *(s32 *)iFP;   
  t1 = (1792) << 16;   
  t5 = *(s32 *)&processor->continuation;   
  t1 = arg5 & t1;		// Mask 
  t2 = *(s32 *)(iFP + 4);   
  t7 = iCP;
  if (t1 != 0)   		// Need to cleanup frame first 
    goto returnsinglecleanup;
  t3 = (u32)t3;   
  t4 = *((s32 *)(&processor->continuation)+1);   
  t5 = (u32)t5;   
#ifdef IVERIFY
  /* check for instruction verification suite end-of-test */
  t6 = (s32)t2 - (s32)Type_NIL;   		// check for end of run 
  if (t6 == 0) 
    goto abandon-frame-simple8857;
#endif
  t6 = *(s32 *)(iFP + 8);   		// Get saved control register 
  /* TagType. */
  t2 = t2 & 63;
  /* Restore the PC. */
  if (arg4 == 0) 
    goto abandon-frame-simple8858;
  iPC = t5 << 1;   		// Assume even PC 
  t1 = t4 & 1;
  t7 = *(u64 *)&(processor->continuationcp);   
  iPC = iPC + t1;

abandon-frame-simple8858:
  if (_trace) printf("abandon-frame-simple8858:\n");
  /* Restore the saved continuation */
  *((u32 *)(&processor->continuation)+1) = t2;
  t1 = arg5 >> 9;   		// Get the caller frame size into place 
  *(u32 *)&processor->continuation = t3;
  iSP = iFP - 8;   		// Restore the stack pointer. 
  *(u64 *)&processor->continuationcp = zero;   
  t1 = t1 & 255;		// Mask just the caller frame size. 
  t1 = (t1 * 8) + 0;  		// *8 
  t2 = (2048) << 16;   
  t2 = t2 & arg5;
  t3 = *(s32 *)&processor->interruptreg;   		// Get the preempt-pending bit 
  t6 = t2 | t6;		// Sticky trace pending bit. 
  t4 = *(u64 *)&(processor->please_stop);   		// Get the trap/suspend bits 
  iFP = iFP - t1;   		// Restore the frame pointer. 
		/* Restore the control register */
  *(u32 *)&processor->control = t6;
  t1 = t6 & 255;		// extract the argument size 
  t3 = t3 & 1;
  t3 = t4 | t3;
  *(u64 *)&processor->stop_interpreter = t3;   
  iLP = (t1 * 8) + iFP;  		// Restore the local pointer. 

force-alignment8859:
  if (_trace) printf("force-alignment8859:\n");
  arg6 = ((u64)iFP < (u64)arg6) ? 1 : 0;   		// ARG6 = stack-cache underflow 
  /* arg4 -2=effect -1=value 0=return 1=multiple */
  if (arg4 == 0) 
    goto returnsinglereturn;
  if ((arg4 & 1) == 0)   
    goto returnsingleeffect;
  *(u64 *)(iSP + 8) = arg3;   
  iSP = iSP + 8;
  if ((s64)arg4 > 0)   
    goto returnsinglemultiple;

returnsingleeffect:
  if (_trace) printf("returnsingleeffect:\n");

returnsingledone:
  if (_trace) printf("returnsingledone:\n");
  if (arg6 != 0)   
    goto returnsingleunderflow;
  if (t7 == 0) 		// No prediction, validate cache 
    goto interpretinstructionforbranch;
  iCP = t7;
  goto INTERPRETINSTRUCTION;   

returnsinglemultiple:
  if (_trace) printf("returnsinglemultiple:\n");
  t8 = Type_Fixnum;		// Multiple-value group 
  t8 = t8 << 32;   
  iSP = iSP + 8;
  t8 = t8 | 1;
  *(u64 *)iSP = t8;   		// Push Fixnum 
  goto returnsingledone;   

returnsinglereturn:
  if (_trace) printf("returnsinglereturn:\n");
  if (arg2 != 0)   
    goto returnsingledone;
  *(u64 *)(iSP + 8) = arg3;   
  iSP = iSP + 8;
  goto returnsingledone;   

returnsinglecleanup:
  if (_trace) printf("returnsinglecleanup:\n");
  goto handleframecleanup;

returnsingleunderflow:
  if (_trace) printf("returnsingleunderflow:\n");
  goto stackcacheunderflowcheck;

/* end DoReturnSingle */
  /* End of Halfword operand from stack instruction - DoReturnSingle */
/* start callindirect */

  /*  */
  /*  */
  /* Fullword instruction - callindirect */
  /* ======================= */

callindirect:
  if (_trace) printf("callindirect:\n");

callindirectprefetch:
  if (_trace) printf("callindirectprefetch:\n");
  arg2 = (u32)arg3;   		// Get operand 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg3 = zero;		// No extra arg 
  /* Memory Read Internal */

vma-memory-read8860:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read8862;

vma-memory-read8861:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read8864;

vma-memory-read8871:
  t5 = arg5 - Type_CompiledFunction;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto startcallagain;
  arg5 = Type_EvenPC;
  t7 = *((s32 *)(&processor->continuation)+1);   
  iSP = iSP + 16;		// prepare to push continuation/control register 
  t3 = *(s32 *)&processor->control;   
  t6 = Type_Fixnum+0xC0;
  t8 = *(s32 *)&processor->continuation;   
  t5 = (64) << 16;   
  t7 = t7 | 192;		// Set CDR code 3 
		/* push continuation */
  *(u32 *)(iSP + -8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + -4) = t7;
  t8 = t3 | t5;		// Set call started bit in CR 
  t5 = zero + 256;   
		/* Push control register */
  *(u32 *)iSP = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t6;
  t8 = t8 & ~t5;		// Clear the extra arg bit 
		/* Save control with new state */
  *(u32 *)&processor->control = t8;
  /* End of push-frame */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u32 *)&processor->continuation = arg6;
  *((u32 *)(&processor->continuation)+1) = arg5;
  *(u64 *)&processor->continuationcp = zero;   
  if (arg3 != 0)   
    goto callindirectextra;
  goto cachevalid;   

callindirectextra:
  if (_trace) printf("callindirectextra:\n");
  t1 = *(s32 *)&processor->control;   
  t2 = zero + 256;   
  t3 = arg3 & 63;		// set CDR-NEXT 
		/* Push the extra arg. */
  *(u32 *)(iSP + 8) = arg4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  t1 = t1 | t2;		// Set the extra arg bit 
		/* Save control with new state */
  *(u32 *)&processor->control = t1;
  goto cachevalid;   

vma-memory-read8864:
  if (_trace) printf("vma-memory-read8864:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read8863;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read8860;   

vma-memory-read8863:
  if (_trace) printf("vma-memory-read8863:\n");

vma-memory-read8862:
  if (_trace) printf("vma-memory-read8862:\n");
  r0 = (u64)&&return0264;
  goto memoryreaddatadecode;
return0264:
  goto vma-memory-read8871;   

/* end callindirect */
  /* End of Fullword instruction - callindirect */
  /* ============================== */
  /*  */
/* start DoFinishCallN */

  /* Halfword 10 bit immediate instruction - DoFinishCallN */

dofinishcalln:
  if (_trace) printf("dofinishcalln:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoFinishCallNIM:
  if (_trace) printf("DoFinishCallNIM:\n");

DoFinishCallNSP:
  if (_trace) printf("DoFinishCallNSP:\n");

DoFinishCallNLP:
  if (_trace) printf("DoFinishCallNLP:\n");

DoFinishCallNFP:
  if (_trace) printf("DoFinishCallNFP:\n");
  /* arg1 has operand preloaded. */
  /* arg2 contains the 8 bit N+1 */
  arg1 = (u8)(arg3 >> ((5&7)*8));   		// arg1 contains the disposition (two bits) 
  arg2 = (arg2 * 8) + zero;  		// convert N to words (stacked words that is) 

finishcallmerge:
  if (_trace) printf("finishcallmerge:\n");
  arg3 = arg3 >> 7;   
  t6 = *(s32 *)&processor->scovlimit;   		// Current stack cache limit (words) 
  t3 = zero + 128;   
  t4 = *(u64 *)&(processor->stackcachedata);   		// Alpha base of stack cache 
  t3 = (t3 * 8) + iSP;  		// SCA of desired end of cache 
  t4 = (t6 * 8) + t4;  		// SCA of current end of cache 
  t6 = ((s64)t3 <= (s64)t4) ? 1 : 0;   
  if (t6 == 0) 		// We're done if new SCA is within bounds 
    goto stack-cache-overflow-check8872;
  arg3 = arg3 & 8;		// 0 if not apply, 8 if apply 
  t1 = *(s32 *)&processor->control;   		// Get the control register 
  /* Compute the new LP */
  iLP = iSP + 8;   		// Assume not Apply case. 
  iLP = iLP - arg3;   		// For apply, iLP==iSP 
  /* Compute the new FP */
  t3 = t1 >> 5;   		// extra arg bit<<3 
  t2 = iSP - arg2;   
  t3 = t3 & 8;		// 8 if extra arg, 0 otherwise. 
  t2 = t2 - t3;   		// This! is the new frame pointer! 
  /* compute arg size */
  t4 = iLP - t2;   
  t4 = t4 >> 3;   		// arg size in words. 
  /* compute caller frame size. */
  t5 = t2 - iFP;   
  t5 = t5 >> 3;   		// caller frame size in words. 
  /* Now hack the control register! */
  t7 = arg1 << 18;   		// Get value disposition into place 
  t6 = *(u64 *)&(processor->fccrmask);   		// cr.caller-frame-size 
  t5 = t5 << 9;   		// Shift caller frame size into place 
  t7 = t7 | t4;		// Add arg size to new bits. 
  t4 = arg3 << 14;   		// Apply bit in place 
  t7 = t5 | t7;		// Add frame size to new bits 
  t7 = t4 | t7;		// All new bits assembled! 
  /* Set the return continuation. */
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   		// Next instruction hw format 
  t1 = t1 & t6;		// Mask off unwanted bits 
  t4 = *(s32 *)&processor->continuation;   		// Get the new PC tag/data 
  t1 = t1 | t7;		// Add argsize, apply, disposition, caller FS 
  t3 = *((s32 *)(&processor->continuation)+1);   
  /* Update the PC */
  /* Convert PC to a real continuation. */
  t6 = t5 & 1;
  t7 = t5 >> 1;   		// convert PC to a real word address. 
  t6 = t6 + Type_EvenPC;   
  t4 = (u32)t4;   
  /* Convert real continuation to PC. */
  iPC = t3 & 1;
  iPC = t4 + iPC;
  iPC = t4 + iPC;
  *(u32 *)&processor->continuation = t7;
		/* Set return address */
  *((u32 *)(&processor->continuation)+1) = t6;
  /* Update CP */
  t7 = (4096) << 16;   
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t7 = t7 & t1;
  t7 = t7 >> 1;   		// Shift into trace pending place 
  *(u64 *)&processor->continuationcp = t5;   
  t1 = t1 | t7;		// Set the cr.trace pending if appropriate. 
		/* Set the control register */
  *(u32 *)&processor->control = t1;
  iFP = t2;		// Install the new frame pointer 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  /* Check for stack overflow */
  t1 = t1 >> 30;   		// Isolate trap mode 
  t3 = *(s32 *)&processor->cslimit;   		// Limit for emulator mode 
  t4 = *(s32 *)&processor->csextralimit;   		// Limit for extra stack and higher modes 
  if (t1)   		// Get the right limit for the current trap mode 
    t3 = t4;
  t3 = (u32)t3;   		// Might have been sign extended 
  /* Convert stack cache address to VMA */
  t4 = *(u64 *)&(processor->stackcachedata);   
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t4 = iSP - t4;   		// stack cache base relative offset 
  t4 = t4 >> 3;   		// convert byte address to word address 
  t1 = t4 + t1;		// reconstruct VMA 
  t4 = ((s64)t1 < (s64)t3) ? 1 : 0;   		// Check for overflow 
  if (t4 == 0) 		// Jump if overflow 
    goto stackoverflow;
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  /* Begin execution at the computed address */
  goto interpretinstructionforbranch;   

stack-cache-overflow-check8872:
  if (_trace) printf("stack-cache-overflow-check8872:\n");
  arg2 = 0;
  goto stackcacheoverflowhandler;   

/* end DoFinishCallN */
  /* End of Halfword operand from stack instruction - DoFinishCallN */
/* start DoEntryRestNotAccepted */

  /* Field Extraction instruction - DoEntryRestNotAccepted */

doentryrestnotaccepted:
  if (_trace) printf("doentryrestnotaccepted:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoEntryRestNotAcceptedIM:
  if (_trace) printf("DoEntryRestNotAcceptedIM:\n");

DoEntryRestNotAcceptedSP:
  if (_trace) printf("DoEntryRestNotAcceptedSP:\n");

DoEntryRestNotAcceptedLP:
  if (_trace) printf("DoEntryRestNotAcceptedLP:\n");

DoEntryRestNotAcceptedFP:
  if (_trace) printf("DoEntryRestNotAcceptedFP:\n");
  arg5 = *(s32 *)&processor->control;   		// The control register 
  arg4 = arg3 >> 18;   		// Pull down the number of optionals 
  arg1 = (u8)(arg3 >> ((5&7)*8));   		// Extract the 'ptr' field while we are waiting 
  arg4 = arg4 & 255;
  /* arg1=ptr field, arg2=required, arg3=instn, arg4=optionals arg5=control-register */
  t2 = arg5 >> 27;   		// Get the cr.trace-pending bit 
  t1 = arg5 & 255;		// The supplied args 
  if (t2 & 1)   
    goto tracetrap;
  t3 = arg5 >> 17;   
  t4 = *(s32 *)(iSP + 4);   		// Get the tag of the stack top. 

force-alignment8875:
  if (_trace) printf("force-alignment8875:\n");
  if (t3 & 1)   		// J. if apply args 
    goto b-apply-argument-supplied8873;

b-apply-argument-supplied8874:
  t2 = t1 - arg2;   		// t2=supplied-minimum 
  if ((s64)t2 < 0)   		// B. if too few args. 
    goto retryernatoofew;
  arg1 = arg4 - t1;   		// maximum-supplied 
  if ((s64)arg1 < 0)   		// B. if too many args. 
    goto retryernatoomany;
  /* Compute entry position and advance PC/CP accordingly. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   		// get the next PC 
  t3 = t2 << 1;   		// Adjust index to halfword 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t2 == 0) 		// J. if index zero, no adjustment. 
    goto INTERPRETINSTRUCTION;
  iPC = iPC + t3;		// Compute the new address 
  iPC = iPC & ~1L;		// Make it an DTP-EVEN-PC 
  goto interpretinstructionforjump;   

applysupprna:
  if (_trace) printf("applysupprna:\n");
  arg1 = arg4 - t1;   
  if ((s64)arg1 <= 0)  		// B. if too many args. 
    goto retryernatoomany;
  goto pullapplyargs;   

retryernatoomany:
  if (_trace) printf("retryernatoomany:\n");
  arg5 = 0;
  arg2 = 78;
  goto illegaloperand;

retryernatoofew:
  if (_trace) printf("retryernatoofew:\n");
  arg5 = 0;
  arg2 = 77;
  goto illegaloperand;

b-apply-argument-supplied8873:
  if (_trace) printf("b-apply-argument-supplied8873:\n");
  t4 = t4 & 63;
  t4 = t4 - Type_NIL;   
  if (t4 != 0)   		// J. if apply args supplied not nil. 
    goto applysupprna;
  t3 = t3 & 1;		// keep just the apply bit! 
  t3 = t3 << 17;   		// reposition the apply bit 
  iSP = iSP - 8;   		// Pop off the null applied arg. 
  arg5 = arg5 & ~t3;		// Blast the apply arg bit away 
		/* Reset the stored cr bit */
  *(u32 *)&processor->control = arg5;
  goto b-apply-argument-supplied8874;   

/* end DoEntryRestNotAccepted */
  /* End of Halfword operand from stack instruction - DoEntryRestNotAccepted */
/* start VerifyGenericArity */


verifygenericarity:
  if (_trace) printf("verifygenericarity:\n");
  t11 = (2) << 16;   
  t11 = t11 & arg2;
  if (t11 == 0) 		// not applying 
    goto verify-generic-arity8876;
  arg1 = zero - arg5;   		// 4 - argsize 
  goto pullapplyargs;   

verify-generic-arity8876:
  if (_trace) printf("verify-generic-arity8876:\n");
  arg5 = 0;
  arg2 = 77;
  goto illegaloperand;

/* end VerifyGenericArity */
/* start PullApplyArgs */


pullapplyargs:
  if (_trace) printf("pullapplyargs:\n");
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t2 = *(s32 *)iSP;   
  t1 = *(s32 *)(iSP + 4);   
  t2 = (u32)t2;   
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t5 = (t4 == Type_List) ? 1 : 0;   

force-alignment8905:
  if (_trace) printf("force-alignment8905:\n");
  if (t5 == 0) 
    goto basic-dispatch8879;
  /* Here if argument TypeList */
  t5 = t2 - arg5;   		// Stack cache offset 
  t6 = ((u64)t5 < (u64)arg6) ? 1 : 0;   		// In range? 
  t4 = *(u64 *)&(processor->stackcachedata);   
  if (t6 == 0) 		// J. if not in cache 
    goto pull-apply-args8877;
  t4 = (t5 * 8) + t4;  		// reconstruct SCA 
  t7 = zero;
  t5 = zero + 128;   
  t6 = *(u64 *)&(processor->stackcachedata);   		// Alpha base of stack cache 
  t5 = t5 + arg1;		// Account for what we're about to push 
  t5 = (t5 * 8) + iSP;  		// SCA of desired end of cache 
  t6 = (arg6 * 8) + t6;  		// SCA of current end of cache 
  t10 = ((s64)t5 <= (s64)t6) ? 1 : 0;   
  if (t10 == 0) 		// We're done if new SCA is within bounds 
    goto stack-cache-overflow-check8886;
  iSP = iSP - 8;   		// Pop Stack. 
  goto pull-apply-args-quickly8885;   

pull-apply-args-quickly8880:
  if (_trace) printf("pull-apply-args-quickly8880:\n");
  t9 = *(s32 *)t4;   
  t8 = *(s32 *)(t4 + 4);   
  t9 = (u32)t9;   
  t7 = t7 + 1;
  t4 = t4 + 8;
  t5 = t8 & 192;		// Extract CDR code. 
  if (t5 != 0)   
    goto basic-dispatch8888;
  /* Here if argument 0 */
  t5 = t8 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  t5 = (t7 == arg1) ? 1 : 0;   
  if (t5 == 0) 
    goto pull-apply-args-quickly8880;
  goto pull-apply-args-quickly8881;   

basic-dispatch8888:
  if (_trace) printf("basic-dispatch8888:\n");
  t6 = (t5 == 64) ? 1 : 0;   

force-alignment8900:
  if (_trace) printf("force-alignment8900:\n");
  if (t6 == 0) 
    goto basic-dispatch8889;
  /* Here if argument 64 */
  t5 = t8 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;

pull-apply-args-quickly8883:
  if (_trace) printf("pull-apply-args-quickly8883:\n");
  t5 = *(s32 *)&processor->control;   
  t6 = t5 & 255;		// Get current arg size. 
  t5 = t5 & ~255L;
  t6 = t6 + t7;
  t5 = t6 + t5;		// Update the arg size 
  t6 = (2) << 16;   
  t5 = t5 & ~t6;		// turn off cr.apply 
  *(u32 *)&processor->control = t5;
  iLP = (t7 * 8) + iLP;  
  goto INTERPRETINSTRUCTION;   

basic-dispatch8889:
  if (_trace) printf("basic-dispatch8889:\n");
  t6 = (t5 == 128) ? 1 : 0;   

force-alignment8901:
  if (_trace) printf("force-alignment8901:\n");
  if (t6 == 0) 
    goto basic-dispatch8890;
  /* Here if argument 128 */
  t5 = t8 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  t11 = *(s32 *)t4;   
  t10 = *(s32 *)(t4 + 4);   
  t11 = (u32)t11;   
  t5 = t10 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_List) ? 1 : 0;   

force-alignment8896:
  if (_trace) printf("force-alignment8896:\n");
  if (t6 == 0) 
    goto basic-dispatch8892;
  /* Here if argument TypeList */
  t5 = t11 - arg5;   		// Stack cache offset 
  t6 = ((u64)t5 < (u64)arg6) ? 1 : 0;   		// In range? 
  t4 = *(u64 *)&(processor->stackcachedata);   
  if (t6 == 0) 		// J. if not in cache 
    goto pull-apply-args-quickly8882;
  t4 = (t5 * 8) + t4;  		// reconstruct SCA 
  goto pull-apply-args-quickly8885;   

basic-dispatch8892:
  if (_trace) printf("basic-dispatch8892:\n");
  t6 = (t5 == Type_NIL) ? 1 : 0;   

force-alignment8897:
  if (_trace) printf("force-alignment8897:\n");
  if (t6 == 0) 
    goto basic-dispatch8893;
  /* Here if argument TypeNIL */
  goto pull-apply-args-quickly8883;   

basic-dispatch8893:
  if (_trace) printf("basic-dispatch8893:\n");
  /* Here for all other cases */

pull-apply-args-quickly8882:
  if (_trace) printf("pull-apply-args-quickly8882:\n");
  t5 = t10 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t11;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto pull-apply-args-quickly8884;   

basic-dispatch8891:
  if (_trace) printf("basic-dispatch8891:\n");

basic-dispatch8890:
  if (_trace) printf("basic-dispatch8890:\n");
  /* Here for all other cases */
  t7 = t7 - 1;   
  t4 = t4 - 8;   
  goto pull-apply-args-quickly8881;   

basic-dispatch8887:
  if (_trace) printf("basic-dispatch8887:\n");

pull-apply-args-quickly8885:
  t5 = (t7 == arg1) ? 1 : 0;   
  if (t5 == 0) 
    goto pull-apply-args-quickly8880;

pull-apply-args-quickly8881:
  if (_trace) printf("pull-apply-args-quickly8881:\n");
  /* Here if count=n, or bad cdr */
  /* Convert stack cache address to VMA */
  t5 = *(u64 *)&(processor->stackcachedata);   
  t5 = t4 - t5;   		// stack cache base relative offset 
  t5 = t5 >> 3;   		// convert byte address to word address 
  t9 = t5 + arg5;		// reconstruct VMA 
  t5 = Type_List;
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;

pull-apply-args-quickly8884:
  if (_trace) printf("pull-apply-args-quickly8884:\n");
  t5 = *(s32 *)&processor->control;   
  t6 = t5 & 255;		// Get current arg size. 
  t5 = t5 & ~255L;
  t6 = t6 + t7;
  t5 = t6 + t5;		// Update the arg size 
  *(u32 *)&processor->control = t5;
  iLP = (t7 * 8) + iLP;  
  arg1 = arg1 - t7;   
  if ((s64)arg1 <= 0)  
    goto INTERPRETINSTRUCTION;
  goto pullapplyargsslowly;

basic-dispatch8879:
  if (_trace) printf("basic-dispatch8879:\n");
  t5 = (t4 == Type_NIL) ? 1 : 0;   

force-alignment8906:
  if (_trace) printf("force-alignment8906:\n");
  if (t5 == 0) 
    goto basic-dispatch8902;
  /* Here if argument TypeNIL */
  t6 = *(s32 *)&processor->control;   		// Get the control register 
  t7 = (2) << 16;   
  iSP = iSP - 8;   		// Discard that silly nil 
  t6 = t6 & ~t7;		// Blast away the apply arg bit. 
  *(u32 *)&processor->control = t6;
  goto INTERPRETINSTRUCTION;   

basic-dispatch8902:
  if (_trace) printf("basic-dispatch8902:\n");
  /* Here for all other cases */
  arg1 = arg1;		// Pull apply args trap needs nargs in ARG1 
  goto pullapplyargstrap;

pull-apply-args8877:
  if (_trace) printf("pull-apply-args8877:\n");
  arg1 = arg1;
  goto pullapplyargsslowly;

basic-dispatch8878:
  if (_trace) printf("basic-dispatch8878:\n");

stack-cache-overflow-check8886:
  if (_trace) printf("stack-cache-overflow-check8886:\n");
  arg2 = arg1;
  goto stackcacheoverflowhandler;   

/* end PullApplyArgs */
/* start valuecell */

  /*  */
  /*  */
  /* Fullword instruction - valuecell */
  /* ======================= */

valuecell:
  if (_trace) printf("valuecell:\n");
  arg2 = (u32)arg3;   		// Get address 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read8907:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read8909;

vma-memory-read8908:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read8911;

vma-memory-read8918:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t3 = arg5 & 63;		// set CDR-NEXT 
		/* Push the result */
  *(u32 *)(iSP + 8) = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  goto cachevalid;   

vma-memory-read8911:
  if (_trace) printf("vma-memory-read8911:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read8910;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read8907;   

vma-memory-read8910:
  if (_trace) printf("vma-memory-read8910:\n");

vma-memory-read8909:
  if (_trace) printf("vma-memory-read8909:\n");
  r0 = (u64)&&return0265;
  goto memoryreaddatadecode;
return0265:
  goto vma-memory-read8918;   

/* end valuecell */
  /* End of Fullword instruction - valuecell */
  /* ============================== */
  /*  */
/* start pushconstantvalue */

  /*  */
  /*  */
  /* Fullword instruction - pushconstantvalue */
  /* ======================= */

pushconstantvalue:
  if (_trace) printf("pushconstantvalue:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)(iSP + 8) = arg3;   
  iSP = iSP + 8;
  goto cachevalid;   

/* end pushconstantvalue */
  /* End of Fullword instruction - pushconstantvalue */
  /* ============================== */
  /*  */
/* start DoZerop */

  /* Halfword operand from stack instruction - DoZerop */
  /* arg2 has the preloaded 8 bit operand. */

dozerop:
  if (_trace) printf("dozerop:\n");
#ifdef TRACING
#endif

DoZeropSP:
  if (_trace) printf("DoZeropSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindozerop;   
#endif

DoZeropLP:
  if (_trace) printf("DoZeropLP:\n");
#ifdef TRACING
  goto begindozerop;   
#endif

DoZeropFP:
  if (_trace) printf("DoZeropFP:\n");

begindozerop:
  if (_trace) printf("begindozerop:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->niladdress);   
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t1 = *(s32 *)(arg1 + 4);   
  t12 = *(u64 *)&(processor->taddress);   
  t2 = *(s32 *)arg1;   
  LDS(1, f1, *(u32 *)arg1 );   
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t5 = (t4 == Type_Fixnum) ? 1 : 0;   

force-alignment8924:
  if (_trace) printf("force-alignment8924:\n");
  if (t5 == 0) 
    goto basic-dispatch8920;
  /* Here if argument TypeFixnum */
  iPC = t6;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t2 == 0)   		// T if predicate succeeds 
    t11 = t12;
  *(u64 *)(iSP + 8) = t11;   
  iSP = iSP + 8;
  goto cachevalid;   

basic-dispatch8920:
  if (_trace) printf("basic-dispatch8920:\n");
  t5 = (t4 == Type_SingleFloat) ? 1 : 0;   

force-alignment8925:
  if (_trace) printf("force-alignment8925:\n");
  if (t5 == 0) 
    goto basic-dispatch8921;
  /* Here if argument TypeSingleFloat */
  iPC = t6;
  *(u64 *)(iSP + 8) = t12;   
  iSP = iSP + 8;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (FLTU64(1, f1) == 0.0)   
    goto cachevalid;
  *(u64 *)iSP = t11;   		// Didn't branch, answer is NIL 
  goto cachevalid;   

basic-dispatch8921:
  if (_trace) printf("basic-dispatch8921:\n");
  /* Here for all other cases */
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto unarynumericexception;

basic-dispatch8919:
  if (_trace) printf("basic-dispatch8919:\n");
#ifdef TRACING
  goto DoZeropIM;   
#endif

DoZeropIM:
  if (_trace) printf("DoZeropIM:\n");
  t2 = *(u64 *)&(processor->taddress);   
  iSP = iSP + 8;
  t1 = *(u64 *)&(processor->niladdress);   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (arg2 == 0)   
    t1 = t2;
  *(u64 *)iSP = t1;   		// yes Virginia, we dual issue with above yahoo 
  goto cachevalid;   

/* end DoZerop */
  /* End of Halfword operand from stack instruction - DoZerop */
/* start DoSetSpToAddress */

  /* Halfword operand from stack instruction - DoSetSpToAddress */
  /* arg2 has the preloaded 8 bit operand. */

dosetsptoaddress:
  if (_trace) printf("dosetsptoaddress:\n");
#ifdef TRACING
#endif

DoSetSpToAddressSP:
  if (_trace) printf("DoSetSpToAddressSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindosetsptoaddress;   
#endif

DoSetSpToAddressLP:
  if (_trace) printf("DoSetSpToAddressLP:\n");
#ifdef TRACING
  goto begindosetsptoaddress;   
#endif

DoSetSpToAddressFP:
  if (_trace) printf("DoSetSpToAddressFP:\n");

begindosetsptoaddress:
  if (_trace) printf("begindosetsptoaddress:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = arg1;		// Set iSP=address of operand 
  goto cachevalid;   
#ifdef TRACING
#endif

DoSetSpToAddressIM:
  goto doistageerror;

/* end DoSetSpToAddress */
  /* End of Halfword operand from stack instruction - DoSetSpToAddress */
/* start DoEq */

  /* Halfword operand from stack instruction - DoEq */
  /* arg2 has the preloaded 8 bit operand. */

doeq:
  if (_trace) printf("doeq:\n");
#ifdef TRACING
#endif

DoEqSP:
  if (_trace) printf("DoEqSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoeq;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindoeq;   
#endif

DoEqLP:
  if (_trace) printf("DoEqLP:\n");
#ifdef TRACING
  goto begindoeq;   
#endif

DoEqFP:
  if (_trace) printf("DoEqFP:\n");

begindoeq:
  if (_trace) printf("begindoeq:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->niladdress);   
  arg3 = arg3 >> 12;   
  t12 = *(u64 *)&(processor->taddress);   
  arg1 = *(u64 *)arg1;   		// load op2 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  arg3 = arg3 & 1;		// 1 if no-pop, 0 if pop 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t3 = arg6 ^ arg1;   		// compare tag and data 
  t3 = t3 << 26;   		// shift off the cdr code 
  iSP = (arg3 * 8) + iSP;  		// Either a stack-push or a stack-write 
  if (t3 == 0)   		// pick up T or NIL 
    t11 = t12;
  *(u64 *)iSP = t11;   
  goto cachevalid;   

/* end DoEq */
  /* End of Halfword operand from stack instruction - DoEq */
/* start DoAref1 */

  /* Halfword operand from stack instruction - DoAref1 */
  /* arg2 has the preloaded 8 bit operand. */

doaref1:
  if (_trace) printf("doaref1:\n");
#ifdef TRACING
#endif

DoAref1SP:
  if (_trace) printf("DoAref1SP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto headdoaref1;
  arg1 = arg6;		// SP-pop mode, TOS->arg1 
  arg6 = *(u64 *)arg4;   		// Reload TOS 
  iSP = arg4;		// Adjust SP 
  goto begindoaref1;   
#ifdef TRACING
  goto headdoaref1;   
#endif

DoAref1LP:
  if (_trace) printf("DoAref1LP:\n");
#ifdef TRACING
  goto headdoaref1;   
#endif

DoAref1FP:
  if (_trace) printf("DoAref1FP:\n");

headdoaref1:
  if (_trace) printf("headdoaref1:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoaref1:
  if (_trace) printf("begindoaref1:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg3 = (u32)(arg6 >> ((4&7)*8));   
  arg4 = (u32)arg6;   		// Get the array tag/data 
  arg2 = (s32)arg1 + (s32)0;		// (sign-extended, for fast bounds check) Index Data 
  t8 = zero + AutoArrayRegMask;   
  t8 = arg4 & t8;
  arg1 = arg1 >> 32;   		// Index Tag 
  t7 = (u64)&processor->ac0array;   
  t7 = t7 + t8;		// This is the address if the array register block. 
  t1 = arg1 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto aref1illegal;

aref1merge:
  if (_trace) printf("aref1merge:\n");
  if (arg4 == 0) 
    goto aref1regset;
  t8 = *(u64 *)&(((ARRAYCACHEP)t7)->array);   		// Cached array object. 
  t1 = arg3 - Type_Array;   
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto reallyaref1exc;
  t8 = (arg4 == t8) ? 1 : 0;   		// t8==1 iff cached array is ours. 
  if (t8 == 0) 		// Go and setup the array register. 
    goto aref1regset;
#ifdef SLOWARRAYS
  goto aref1regset;   
#endif
  arg6 = *(u64 *)&(((ARRAYCACHEP)t7)->arword);   
  t9 = *(u64 *)&(((ARRAYCACHEP)t7)->locat);   		// high order bits all zero 
  t3 = *(u64 *)&(((ARRAYCACHEP)t7)->length);   		// high order bits all zero 
  t5 = arg6 << 42;   
  t4 = *(u64 *)&(processor->areventcount);   
  t5 = t5 >> 42;   
  t2 = ((u64)arg2 < (u64)t3) ? 1 : 0;   
  t6 = t4 - t5;   
  if (t6 != 0)   		// J. if event count ticked. 
    goto aref1regset;
  if (t2 == 0) 
    goto aref1bounds;
  arg5 = arg6 >> (Array_RegisterBytePackingPos & 63);   
  arg4 = arg6 >> (Array_RegisterByteOffsetPos & 63);   
  t8 = arg6 >> (Array_RegisterElementTypePos & 63);   
  arg4 = arg4 & Array_RegisterByteOffsetMask;
  arg5 = arg5 & Array_RegisterBytePackingMask;
  arg6 = t8 & Array_RegisterElementTypeMask;

aref1restart:
  if (_trace) printf("aref1restart:\n");
  if (arg5 != 0)   
    goto new-aref-1-internal8926;
  t1 = t9 + arg2;

new-aref-1-internal8927:
  if (_trace) printf("new-aref-1-internal8927:\n");
  /* Memory Read Internal */

vma-memory-read8934:
  t2 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t5 = t1 + ivory;
  t3 = *(s32 *)&processor->scovlimit;   
  t9 = (t5 * 4);   
  arg3 = LDQ_U(t5);   
  t2 = t1 - t2;   		// Stack cache offset 
  t6 = *(u64 *)&(processor->dataread_mask);   
  t3 = ((u64)t2 < (u64)t3) ? 1 : 0;   		// In range? 
  t9 = *(s32 *)t9;   
  arg3 = (u8)(arg3 >> ((t5&7)*8));   
  if (t3 != 0)   
    goto vma-memory-read8936;

vma-memory-read8935:
  t5 = zero + 240;   
  t6 = t6 >> (arg3 & 63);   
  t5 = t5 >> (arg3 & 63);   
  t9 = (u32)t9;   
  if (t6 & 1)   
    goto vma-memory-read8938;

vma-memory-read8945:
  if (arg5 != 0)   
    goto new-aref-1-internal8928;

new-aref-1-internal8929:
  if (_trace) printf("new-aref-1-internal8929:\n");
  r31 = r31 | r31;
  t1 = arg6 - 2;   
  if ((s64)t1 <= 0)  
    goto new-aref-1-internal8930;
  /* TagType. */
  arg3 = arg3 & 63;

new-aref-1-internal8931:
  if (_trace) printf("new-aref-1-internal8931:\n");
  *(u32 *)(iSP + 4) = arg3;
  t5 = (arg5 == 0) ? 1 : 0;   
  if (t5 == 0) 
    goto case_others_70;

case_0_64:
  if (_trace) printf("case_0_64:\n");
  r31 = r31 | r31;
  if (t1 == 0) 
    goto new-aref-1-internal8932;
  *(u32 *)iSP = t9;
  goto NEXTINSTRUCTION;   

case_2_65:
  if (_trace) printf("case_2_65:\n");
  /* AREF1-8B */
  r31 = r31 | r31;
  t5 = arg2 & 3;
  t6 = (u8)(t9 >> ((t5&7)*8));   
  if (t1 == 0) 
    goto new-aref-1-internal8932;
  *(u32 *)iSP = t6;
  goto NEXTINSTRUCTION;   

case_3_66:
  if (_trace) printf("case_3_66:\n");
  /* AREF1-4B */
  r31 = r31 | r31;
  t5 = arg2 & 7;		// byte-index 
  t5 = t5 << 2;   		// byte-position 
  t6 = t9 >> (t5 & 63);   		// byte in position 
  t6 = t6 & 15;		// byte masked 
  if (t1 == 0) 
    goto new-aref-1-internal8932;
  *(u32 *)iSP = t6;
  goto NEXTINSTRUCTION;   

case_5_67:
  if (_trace) printf("case_5_67:\n");
  /* AREF1-1B */
  r31 = r31 | r31;
  t5 = arg2 & 31;		// byte-index 
  r31 = r31 | r31;
  t6 = t9 >> (t5 & 63);   		// byte in position 
  t6 = t6 & 1;		// byte masked 
  if (t1 == 0) 
    goto new-aref-1-internal8932;
  *(u32 *)iSP = t6;
  goto NEXTINSTRUCTION;   

case_1_68:
  if (_trace) printf("case_1_68:\n");
  /* AREF1-16B */
  t5 = arg2 & 1;
  t5 = t5 + t5;		// Bletch, it's a byte ref 
  t6 = (u16)(t9 >> ((t5&7)*8));   
  if (t1 == 0) 
    goto new-aref-1-internal8932;
  *(u32 *)iSP = t6;
  goto NEXTINSTRUCTION;   

case_others_70:
  if (_trace) printf("case_others_70:\n");
  r31 = r31 | r31;
  t5 = (arg5 == 2) ? 1 : 0;   
  t6 = (arg5 == 3) ? 1 : 0;   
  if (t5 != 0)   
    goto case_2_65;
  t5 = (arg5 == 5) ? 1 : 0;   
  if (t6 != 0)   
    goto case_3_66;
  t6 = (arg5 == 1) ? 1 : 0;   
  if (t5 != 0)   
    goto case_5_67;
  if (t6 != 0)   
    goto case_1_68;

case_4_69:
  if (_trace) printf("case_4_69:\n");
  /* AREF1-2B */
  r31 = r31 | r31;
  t5 = arg2 & 15;		// byte-index 
  t5 = t5 << 1;   		// byte-position 
  t6 = t9 >> (t5 & 63);   		// byte in position 
  t6 = t6 & 3;		// byte masked 
  if (t1 == 0) 
    goto new-aref-1-internal8932;
  *(u32 *)iSP = t6;
  goto NEXTINSTRUCTION;   

new-aref-1-internal8926:
  if (_trace) printf("new-aref-1-internal8926:\n");
  arg2 = arg4 + arg2;
  t1 = arg2 >> (arg5 & 63);   		// Convert byte index to word index 
  t1 = t1 + t9;		// Address of word containing byte 
  goto new-aref-1-internal8927;   

new-aref-1-internal8928:
  if (_trace) printf("new-aref-1-internal8928:\n");
  t1 = arg3 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto new-aref-1-internal8933;
  goto new-aref-1-internal8929;   

new-aref-1-internal8930:
  if (_trace) printf("new-aref-1-internal8930:\n");
  arg3 = Type_Character;
  if (arg6 & 1)   
    goto new-aref-1-internal8931;
  arg3 = Type_Fixnum;
  if (arg6 == 0) 
    goto new-aref-1-internal8931;
  t2 = *(u64 *)&(processor->niladdress);   
  t3 = *(u64 *)&(processor->taddress);   
  goto new-aref-1-internal8931;   

new-aref-1-internal8932:
  if (_trace) printf("new-aref-1-internal8932:\n");
  if (t6)   
    t2 = t3;
  *(u64 *)iSP = t2;   
  goto NEXTINSTRUCTION;   

new-aref-1-internal8933:
  if (_trace) printf("new-aref-1-internal8933:\n");
  arg5 = t1;
  arg2 = 25;
  goto illegaloperand;
#ifdef TRACING
  goto DoAref1IM;   
#endif

DoAref1IM:
  if (_trace) printf("DoAref1IM:\n");
  t8 = zero + AutoArrayRegMask;   
  arg4 = *(s32 *)iSP;   		// Get the array tag/data 
  arg3 = *(s32 *)(iSP + 4);   
  arg4 = (u32)arg4;   
  t7 = (u64)&processor->ac0array;   
  t8 = arg4 & t8;
  t7 = t7 + t8;		// This is the address of the array register block. 
  goto aref1merge;   

vma-memory-read8936:
  if (_trace) printf("vma-memory-read8936:\n");
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = (t2 * 8) + t3;  		// reconstruct SCA 
  t9 = *(s32 *)t2;   
  arg3 = *(s32 *)(t2 + 4);   		// Read from stack cache 
  goto vma-memory-read8935;   

vma-memory-read8938:
  if (_trace) printf("vma-memory-read8938:\n");
  if ((t5 & 1) == 0)   
    goto vma-memory-read8937;
  t1 = (u32)t9;   		// Do the indirect thing 
  goto vma-memory-read8934;   

vma-memory-read8937:
  if (_trace) printf("vma-memory-read8937:\n");
  t6 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t5 = arg3 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t5 = (t5 * 4) + t6;   		// Adjust for a longword load 
  t6 = *(s32 *)t5;   		// Get the memory action 

vma-memory-read8942:
  if (_trace) printf("vma-memory-read8942:\n");
  t5 = t6 & MemoryActionTransform;
  if (t5 == 0) 
    goto vma-memory-read8941;
  arg3 = arg3 & ~63L;
  arg3 = arg3 | Type_ExternalValueCellPointer;
  goto vma-memory-read8945;   

vma-memory-read8941:

vma-memory-read8940:
  /* Perform memory action */
  arg1 = t6;
  arg2 = 0;
  goto performmemoryaction;

/* end DoAref1 */
  /* End of Halfword operand from stack instruction - DoAref1 */
/* start DoTypeMember */

  /* Halfword 10 bit immediate instruction - DoTypeMember */

dotypemember:
  if (_trace) printf("dotypemember:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoTypeMemberIM:
  if (_trace) printf("DoTypeMemberIM:\n");

DoTypeMemberSP:
  if (_trace) printf("DoTypeMemberSP:\n");

DoTypeMemberLP:
  if (_trace) printf("DoTypeMemberLP:\n");

DoTypeMemberFP:
  if (_trace) printf("DoTypeMemberFP:\n");
  /* arg1 has operand preloaded. */
  t6 = arg3 >> 6;   		// Position the opcode 
  t4 = *(u64 *)&(processor->taddress);   
  arg4 = *(s32 *)(iSP + 4);   		// get op1's tag 
  t1 = 1;
  t5 = *(u64 *)&(processor->niladdress);   
  t7 = arg3 >> 12;   		// Get pop-bit while stalled 
  arg1 = t6 & 60;		// Get field-number*4 from the opcode 
  /* TagType. */
  arg4 = arg4 & 63;		// Strip off CDR code. 
  t1 = t1 << (arg4 & 63);   		// T1 is type type code bit position. 
  t7 = t7 & 1;		// Pop bit 
  t2 = arg2 << (arg1 & 63);   		// t2 is the mask. 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = (t7 * 8) + iSP;  
  t3 = t2 & t1;		// t3 is the result. 

force-alignment8946:
  if (_trace) printf("force-alignment8946:\n");
  if (t3)   
    t5 = t4;
  *(u64 *)iSP = t5;   
  goto cachevalid;   

/* end DoTypeMember */
  /* End of Halfword operand from stack instruction - DoTypeMember */
/* start DoPointerPlus */

  /* Halfword operand from stack instruction - DoPointerPlus */
  /* arg2 has the preloaded 8 bit operand. */

dopointerplus:
  if (_trace) printf("dopointerplus:\n");
#ifdef TRACING
#endif

DoPointerPlusSP:
  if (_trace) printf("DoPointerPlusSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindopointerplus;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindopointerplus;   
#endif

DoPointerPlusLP:
  if (_trace) printf("DoPointerPlusLP:\n");
#ifdef TRACING
  goto begindopointerplus;   
#endif

DoPointerPlusFP:
  if (_trace) printf("DoPointerPlusFP:\n");

begindopointerplus:
  if (_trace) printf("begindopointerplus:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t2 = *(s32 *)arg1;   		// Get the data of op2 
  t3 = (s32)arg6 + (s32)t2;		// (%32-bit-plus (data arg1) (data arg2)) 
		/* Put result back on the stack */
  *(u32 *)iSP = t3;
  goto cachevalid;   
#ifdef TRACING
  goto DoPointerPlusIM;   
#endif

DoPointerPlusIM:
  if (_trace) printf("DoPointerPlusIM:\n");
  t2 = arg2 << 56;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t2 = (s64)t2 >> 56;   

force-alignment8947:
  if (_trace) printf("force-alignment8947:\n");
  t3 = (s32)arg6 + (s32)t2;		// (%32-bit-plus (data arg1) (data arg2)) 
		/* Put result back on the stack */
  *(u32 *)iSP = t3;
  goto cachevalid;   

/* end DoPointerPlus */
  /* End of Halfword operand from stack instruction - DoPointerPlus */
/* start DoLdb */

  /* Field Extraction instruction - DoLdb */

doldb:
  if (_trace) printf("doldb:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoLdbIM:
  if (_trace) printf("DoLdbIM:\n");

DoLdbSP:
  if (_trace) printf("DoLdbSP:\n");

DoLdbLP:
  if (_trace) printf("DoLdbLP:\n");

DoLdbFP:
  if (_trace) printf("DoLdbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  arg3 = (u32)(arg6 >> ((4&7)*8));   
  arg4 = (u32)arg6;   		// get ARG1 tag/data 
  /* TagType. */
  t8 = arg3 & 63;
  t9 = t8 - Type_Fixnum;   
  t3 = arg4 << (arg2 & 63);   		// Shift ARG1 left to get new high bits 
  if (t9 != 0)   		// Not a fixnum 
    goto ldbexception;
  t7 = zero + -2;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t6 = (u32)(t3 >> ((4&7)*8));   		// Get new low bits 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t7 = t7 << (arg1 & 63);   		// Unmask 
  t3 = t3 | t6;		// Glue two parts of shifted operand together 
		/* T8 is TypeFixnum from above */
  *(u32 *)(iSP + 4) = t8;
  t3 = t3 & ~t7;		// T3= masked value. 
  *(u32 *)iSP = t3;
  goto cachevalid;   

/* end DoLdb */
  /* End of Halfword operand from stack instruction - DoLdb */
/* start DoSetSpToAddressSaveTos */

  /* Halfword operand from stack instruction - DoSetSpToAddressSaveTos */
  /* arg2 has the preloaded 8 bit operand. */

dosetsptoaddresssavetos:
  if (_trace) printf("dosetsptoaddresssavetos:\n");
#ifdef TRACING
#endif

DoSetSpToAddressSaveTosSP:
  if (_trace) printf("DoSetSpToAddressSaveTosSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindosetsptoaddresssavetos;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindosetsptoaddresssavetos;   
#endif

DoSetSpToAddressSaveTosLP:
  if (_trace) printf("DoSetSpToAddressSaveTosLP:\n");
#ifdef TRACING
  goto begindosetsptoaddresssavetos;   
#endif

DoSetSpToAddressSaveTosFP:
  if (_trace) printf("DoSetSpToAddressSaveTosFP:\n");

begindosetsptoaddresssavetos:
  if (_trace) printf("begindosetsptoaddresssavetos:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = arg1;		// Set the stack top as specified. 
  *(u64 *)arg1 = arg6;   		// Restore the TOS. 
  goto cachevalid;   
#ifdef TRACING
#endif

DoSetSpToAddressSaveTosIM:
  goto doistageerror;

/* end DoSetSpToAddressSaveTos */
  /* End of Halfword operand from stack instruction - DoSetSpToAddressSaveTos */
/* start DoPop */

  /* Halfword operand from stack instruction - DoPop */
  /* arg2 has the preloaded 8 bit operand. */

dopop:
  if (_trace) printf("dopop:\n");
#ifdef TRACING
#endif

DoPopSP:
  if (_trace) printf("DoPopSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindopop;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindopop;   
#endif

DoPopLP:
  if (_trace) printf("DoPopLP:\n");
#ifdef TRACING
  goto begindopop;   
#endif

DoPopFP:
  if (_trace) printf("DoPopFP:\n");

begindopop:
  if (_trace) printf("begindopop:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   		// Pop Stack. 
  *(u64 *)arg1 = arg6;   		// Store all 40 bits on stack 
  goto cachevalid;   
#ifdef TRACING
#endif

DoPopIM:
  goto doistageerror;

/* end DoPop */
  /* End of Halfword operand from stack instruction - DoPop */
/* start DoMovem */

  /* Halfword operand from stack instruction - DoMovem */
  /* arg2 has the preloaded 8 bit operand. */

domovem:
  if (_trace) printf("domovem:\n");
#ifdef TRACING
#endif

DoMovemSP:
  if (_trace) printf("DoMovemSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomovem;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindomovem;   
#endif

DoMovemLP:
  if (_trace) printf("DoMovemLP:\n");
#ifdef TRACING
  goto begindomovem;   
#endif

DoMovemFP:
  if (_trace) printf("DoMovemFP:\n");

begindomovem:
  if (_trace) printf("begindomovem:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)arg1 = arg6;   		// Store all 40 bits of TOS on stack 
  goto cachevalid;   
#ifdef TRACING
#endif

DoMovemIM:
  goto doistageerror;

/* end DoMovem */
  /* End of Halfword operand from stack instruction - DoMovem */
/* start DoPushAddress */

  /* Halfword operand from stack instruction - DoPushAddress */
  /* arg2 has the preloaded 8 bit operand. */

dopushaddress:
  if (_trace) printf("dopushaddress:\n");
#ifdef TRACING
#endif

DoPushAddressSP:
  if (_trace) printf("DoPushAddressSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindopushaddress;   
#endif

DoPushAddressLP:
  if (_trace) printf("DoPushAddressLP:\n");
#ifdef TRACING
  goto begindopushaddress;   
#endif

DoPushAddressFP:
  if (_trace) printf("DoPushAddressFP:\n");

begindopushaddress:
  if (_trace) printf("begindopushaddress:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = arg1 - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t1 = t2 + t1;		// reconstruct VMA 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t3 = Type_Locative;
  *(u32 *)(iSP + 8) = t1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  goto cachevalid;   
#ifdef TRACING
#endif

DoPushAddressIM:
  goto doistageerror;

/* end DoPushAddress */
  /* End of Halfword operand from stack instruction - DoPushAddress */
/* start DoMemoryRead */

  /* Halfword 10 bit immediate instruction - DoMemoryRead */

domemoryread:
  if (_trace) printf("domemoryread:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoMemoryReadIM:
  if (_trace) printf("DoMemoryReadIM:\n");

DoMemoryReadSP:
  if (_trace) printf("DoMemoryReadSP:\n");

DoMemoryReadLP:
  if (_trace) printf("DoMemoryReadLP:\n");

DoMemoryReadFP:
  if (_trace) printf("DoMemoryReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  t1 = arg3 >> 10;   		// Low bit clear if memory-read, set if memory-read-address 
  t2 = arg1 & 32;		// T2 = fixnum check 
  t3 = arg1 & 16;		// T3 = reset CDR code 
  arg3 = arg1 >> 6;   		// arg3 = cycle type 
  arg1 = (u32)(arg6 >> ((4&7)*8));   
  arg2 = (u32)arg6;   		// Get tag/data 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read8948:
  t7 = arg2 + ivory;
  t8 = (arg3 * 4);   		// Cycle-number -> table offset 
  arg5 = LDQ_U(t7);   
  t8 = (t8 * 4) + ivory;   
  arg6 = (t7 * 4);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)(t8 + PROCESSORSTATE_DATAREAD_MASK);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read8950;

vma-memory-read8949:
  t8 = t8 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read8952;

vma-memory-read8959:
  if (t2 == 0) 		// J. if no check for fixnum. 
    goto mrdataok;
  t5 = arg5 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto mrnotfixnum;

mrdataok:
  if (_trace) printf("mrdataok:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if (t1 & 1)   		// Get original tag if memory-read-address 
   arg5 = arg1;
  if (t3 == 0) 		// J. if no reset CDR code 
    goto mrcdrunch;
  /* TagType. */
  arg5 = arg5 & 63;

mrcdrunch:
  if (_trace) printf("mrcdrunch:\n");
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t1 & 1)   		// Get forwarded address if memory-read-address 
   arg6 = arg2;
  *(u32 *)iSP = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = arg5;
  goto cachevalid;   

mrnotfixnum:
  if (_trace) printf("mrnotfixnum:\n");
  arg5 = 0;
  arg2 = 5;
  goto illegaloperand;

vma-memory-read8952:
  if (_trace) printf("vma-memory-read8952:\n");

vma-memory-read8950:
  if (_trace) printf("vma-memory-read8950:\n");
  r0 = (u64)&&return0266;
  goto memoryreadgeneraldecode;
return0266:
  goto vma-memory-read8959;   

/* end DoMemoryRead */
  /* End of Halfword operand from stack instruction - DoMemoryRead */
/* start DoBranch */

  /* Halfword 10 bit immediate instruction - DoBranch */

dobranch:
  if (_trace) printf("dobranch:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchIM:
  if (_trace) printf("DoBranchIM:\n");

DoBranchSP:
  if (_trace) printf("DoBranchSP:\n");

DoBranchLP:
  if (_trace) printf("DoBranchLP:\n");

DoBranchFP:
  if (_trace) printf("DoBranchFP:\n");
  arg1 = (s64)arg3 >> 48;   
  /* arg1 has signed operand preloaded. */
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
#endif
  iPC = iPC + arg1;		// Update the PC in halfwords 
#ifndef CACHEMETERING
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;   

/* end DoBranch */
  /* End of Halfword operand from stack instruction - DoBranch */
/* start DoGenericDispatch */

  /* Halfword operand from stack instruction - DoGenericDispatch */
  /* arg2 has the preloaded 8 bit operand. */

dogenericdispatch:
  if (_trace) printf("dogenericdispatch:\n");
#ifdef TRACING
#endif

DoGenericDispatchSP:
  if (_trace) printf("DoGenericDispatchSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindogenericdispatch;   
#endif

DoGenericDispatchLP:
  if (_trace) printf("DoGenericDispatchLP:\n");
#ifdef TRACING
  goto begindogenericdispatch;   
#endif

DoGenericDispatchFP:
  if (_trace) printf("DoGenericDispatchFP:\n");

begindogenericdispatch:
  if (_trace) printf("begindogenericdispatch:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg2 = *(s32 *)&processor->control;   
  arg1 = *(s32 *)(iFP + 20);   		// get generic tag and data 
  t1 = *(s32 *)(iFP + 16);   
  arg5 = arg2 & 255;		// get number of arguments 
  arg3 = *(s32 *)(iFP + 28);   		// get instance tag and data 
  arg4 = *(s32 *)(iFP + 24);   
  arg5 = arg5 - 4;   		// done if 2 or more arguments (plus 2 extra words) 
  if ((s64)arg5 < 0)   
    goto verifygenericarity;
  t1 = (u32)t1;   
  arg4 = (u32)arg4;   
  r0 = (u64)&&return0267;
  goto lookuphandler;
return0267:
  t3 = t4 - Type_EvenPC;   
  t3 = t3 & 62;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto generic-dispatch8961;
  t3 = t6 & 63;		// Strip CDR code 
  t3 = t3 - Type_NIL;   
  if (t3 == 0) 
    goto generic-dispatch8960;
  *(u32 *)(iFP + 16) = t7;
		/* write the stack cache */
  *(u32 *)(iFP + 20) = t6;

generic-dispatch8960:
  if (_trace) printf("generic-dispatch8960:\n");
  /* Convert real continuation to PC. */
  iPC = t4 & 1;
  iPC = t9 + iPC;
  iPC = t9 + iPC;
  goto interpretinstructionforjump;   

generic-dispatch8961:
  if (_trace) printf("generic-dispatch8961:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t3 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = iSP - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t3 = t2 + t3;		// reconstruct VMA 
  arg5 = t3;
  arg2 = 37;
  goto illegaloperand;
#ifdef TRACING
#endif

DoGenericDispatchIM:
  goto doistageerror;

/* end DoGenericDispatch */
  /* End of Halfword operand from stack instruction - DoGenericDispatch */
/* start LookupHandler */


lookuphandler:
  if (_trace) printf("lookuphandler:\n");
  sp = sp + -8;   
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t5 = arg3 - Type_Instance;   
  t5 = t5 & 60;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto instance-descriptor-info8965;
  arg2 = arg4;		// Don't clobber instance if it's forwarded 
  /* Memory Read Internal */

vma-memory-read8966:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read8968;

vma-memory-read8967:
  t7 = zero + 64;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read8970;

vma-memory-read8975:

instance-descriptor-info8964:
  if (_trace) printf("instance-descriptor-info8964:\n");
  arg2 = arg6;
  /* Memory Read Internal */

vma-memory-read8976:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read8978;

vma-memory-read8977:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read8980;

vma-memory-read8987:
  t2 = arg6;
  t5 = arg5 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto instance-descriptor-info8962;
  arg2 = arg2 + 1;
  /* Memory Read Internal */

vma-memory-read8988:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read8990;

vma-memory-read8989:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read8992;

vma-memory-read8999:
  t3 = arg6;
  t5 = arg5 - Type_Locative;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto instance-descriptor-info8963;
  arg2 = t2 & t1;
  t5 = arg2 << 1;   
  arg4 = arg2 + t5;		// (* (logand mask data) 3) 
  /* TagType. */
  arg1 = arg1 & 63;

lookup-handler9001:
  if (_trace) printf("lookup-handler9001:\n");
  arg2 = t3 + arg4;
  arg4 = arg4 + 3;
  /* Read key */
  /* Memory Read Internal */

vma-memory-read9002:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9004;

vma-memory-read9003:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read9006;

vma-memory-read9013:
  /* TagType. */
  arg5 = arg5 & 63;
  t5 = (arg5 == Type_NIL) ? 1 : 0;   
  if (t5 != 0)   
    goto lookup-handler9000;
  t5 = (arg1 == arg5) ? 1 : 0;   
  if (t5 == 0) 
    goto lookup-handler9001;
  t5 = (s32)t1 - (s32)arg6;   
  if (t5 != 0)   
    goto lookup-handler9001;

lookup-handler9000:
  if (_trace) printf("lookup-handler9000:\n");
  /* Read method */
  arg2 = arg2 + 1;
  /* Memory Read Internal */

vma-memory-read9014:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9016;

vma-memory-read9015:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read9018;

vma-memory-read9025:
  t4 = arg5;
  arg3 = arg6;
  /* Read parameter */
  arg2 = arg2 + 1;
  /* Memory Read Internal */

vma-memory-read9026:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9028;

vma-memory-read9027:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read9030;

vma-memory-read9037:
  t6 = arg5;
  t7 = arg6;
  t9 = arg3;
  sp = sp + 8;   
  goto *r0; /* ret */

vma-memory-read9030:
  if (_trace) printf("vma-memory-read9030:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9029;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9026;   

vma-memory-read9029:
  if (_trace) printf("vma-memory-read9029:\n");

vma-memory-read9028:
  if (_trace) printf("vma-memory-read9028:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0268;
  goto memoryreaddatadecode;
return0268:
  r0 = *(u64 *)sp;   
  goto vma-memory-read9037;   

vma-memory-read9018:
  if (_trace) printf("vma-memory-read9018:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9017;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9014;   

vma-memory-read9017:
  if (_trace) printf("vma-memory-read9017:\n");

vma-memory-read9016:
  if (_trace) printf("vma-memory-read9016:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0269;
  goto memoryreaddatadecode;
return0269:
  r0 = *(u64 *)sp;   
  goto vma-memory-read9025;   

vma-memory-read9006:
  if (_trace) printf("vma-memory-read9006:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9005;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9002;   

vma-memory-read9005:
  if (_trace) printf("vma-memory-read9005:\n");

vma-memory-read9004:
  if (_trace) printf("vma-memory-read9004:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0270;
  goto memoryreaddatadecode;
return0270:
  r0 = *(u64 *)sp;   
  goto vma-memory-read9013;   

vma-memory-read8992:
  if (_trace) printf("vma-memory-read8992:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read8991;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read8988;   

vma-memory-read8991:
  if (_trace) printf("vma-memory-read8991:\n");

vma-memory-read8990:
  if (_trace) printf("vma-memory-read8990:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0271;
  goto memoryreaddatadecode;
return0271:
  r0 = *(u64 *)sp;   
  goto vma-memory-read8999;   

vma-memory-read8980:
  if (_trace) printf("vma-memory-read8980:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read8979;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read8976;   

vma-memory-read8979:
  if (_trace) printf("vma-memory-read8979:\n");

vma-memory-read8978:
  if (_trace) printf("vma-memory-read8978:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0272;
  goto memoryreaddatadecode;
return0272:
  r0 = *(u64 *)sp;   
  goto vma-memory-read8987;   

vma-memory-read8970:
  if (_trace) printf("vma-memory-read8970:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read8969;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read8966;   

vma-memory-read8969:
  if (_trace) printf("vma-memory-read8969:\n");

vma-memory-read8968:
  if (_trace) printf("vma-memory-read8968:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0273;
  goto memoryreadheaderdecode;
return0273:
  r0 = *(u64 *)sp;   
  goto vma-memory-read8975;   

instance-descriptor-info8965:
  if (_trace) printf("instance-descriptor-info8965:\n");
  /* not an instance, flavor description comes from magic vector */
  arg2 = *(u64 *)&(processor->trapvecbase);   
  /* TagType. */
  t5 = arg3 & 63;
  arg2 = arg2 + 2560;   
  arg2 = t5 + arg2;
  /* Memory Read Internal */

vma-memory-read9038:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9040;

vma-memory-read9039:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read9042;
  goto instance-descriptor-info8964;   

instance-descriptor-info8962:
  if (_trace) printf("instance-descriptor-info8962:\n");
  arg5 = arg2;
  arg2 = 34;
  goto illegaloperand;

instance-descriptor-info8963:
  if (_trace) printf("instance-descriptor-info8963:\n");
  arg5 = arg2;
  arg2 = 35;
  goto illegaloperand;

vma-memory-read9042:
  if (_trace) printf("vma-memory-read9042:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9041;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9038;   

vma-memory-read9041:
  if (_trace) printf("vma-memory-read9041:\n");

vma-memory-read9040:
  if (_trace) printf("vma-memory-read9040:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0274;
  goto memoryreaddatadecode;
return0274:
  r0 = *(u64 *)sp;   
  goto instance-descriptor-info8964;   

/* end LookupHandler */
/* start DoSetTag */

  /* Halfword operand from stack instruction - DoSetTag */
  /* arg2 has the preloaded 8 bit operand. */

dosettag:
  if (_trace) printf("dosettag:\n");
#ifdef TRACING
#endif

DoSetTagSP:
  if (_trace) printf("DoSetTagSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindosettag;   
#endif

DoSetTagLP:
  if (_trace) printf("DoSetTagLP:\n");
#ifdef TRACING
  goto begindosettag;   
#endif

DoSetTagFP:
  if (_trace) printf("DoSetTagFP:\n");

begindosettag:
  if (_trace) printf("begindosettag:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t1 = *(s32 *)(arg1 + 4);   		// Get tag/data of op2 
  arg2 = *(s32 *)arg1;   
  t3 = t1 - Type_Fixnum;   
  t3 = t3 & 63;		// Strip CDR code 
  if (t3 != 0)   
    goto settagexc;
#ifdef TRACING
  goto DoSetTagIM;   
#endif

DoSetTagIM:
  if (_trace) printf("DoSetTagIM:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
		/* Set TAG of op1 */
  *(u32 *)(iSP + 4) = arg2;
  goto cachevalid;   

settagexc:
  if (_trace) printf("settagexc:\n");
  arg5 = 0;
  arg2 = 63;
  goto illegaloperand;

/* end DoSetTag */
  /* End of Halfword operand from stack instruction - DoSetTag */
/* start DoCar */

  /* Halfword operand from stack instruction - DoCar */
  /* arg2 has the preloaded 8 bit operand. */

docar:
  if (_trace) printf("docar:\n");
#ifdef TRACING
#endif

DoCarSP:
  if (_trace) printf("DoCarSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindocar;   
#endif

DoCarLP:
  if (_trace) printf("DoCarLP:\n");
#ifdef TRACING
  goto begindocar;   
#endif

DoCarFP:
  if (_trace) printf("DoCarFP:\n");

begindocar:
  if (_trace) printf("begindocar:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg5 = *(s32 *)(arg1 + 4);   		// Get the operand from the stack. 
  arg6 = *(s32 *)arg1;   
  r0 = (u64)&&return0275;
  goto carinternal;
return0275:
  t5 = arg5 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   
#ifdef TRACING
#endif

DoCarIM:
  goto doistageerror;

/* end DoCar */
  /* End of Halfword operand from stack instruction - DoCar */
/* start CarInternal */


carinternal:
  if (_trace) printf("carinternal:\n");
  sp = sp + -8;   
  arg2 = (u32)(arg6 >> ((zero&7)*8));   
  t5 = arg5 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_List) ? 1 : 0;   

force-alignment9069:
  if (_trace) printf("force-alignment9069:\n");
  if (t6 == 0) 
    goto basic-dispatch9052;
  /* Here if argument TypeList */

car-internal9049:
  /* Memory Read Internal */

vma-memory-read9053:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9055;

vma-memory-read9054:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read9057;

vma-memory-read9064:

basic-dispatch9051:
  if (_trace) printf("basic-dispatch9051:\n");

car-internal9050:
  if (_trace) printf("car-internal9050:\n");
  sp = sp + 8;   
  goto *r0; /* ret */

basic-dispatch9052:
  if (_trace) printf("basic-dispatch9052:\n");
  t6 = (t5 == Type_NIL) ? 1 : 0;   

force-alignment9070:
  if (_trace) printf("force-alignment9070:\n");
  if (t6 != 0)   
    goto basic-dispatch9051;

basic-dispatch9065:
  if (_trace) printf("basic-dispatch9065:\n");
  t6 = (t5 == Type_Locative) ? 1 : 0;   

force-alignment9071:
  if (_trace) printf("force-alignment9071:\n");
  if (t6 != 0)   
    goto car-internal9049;

basic-dispatch9066:
  if (_trace) printf("basic-dispatch9066:\n");
  /* Here for all other cases */
  arg6 = arg5;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto listexception;

vma-memory-read9057:
  if (_trace) printf("vma-memory-read9057:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9056;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9053;   

vma-memory-read9056:
  if (_trace) printf("vma-memory-read9056:\n");

vma-memory-read9055:
  if (_trace) printf("vma-memory-read9055:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0276;
  goto memoryreaddatadecode;
return0276:
  r0 = *(u64 *)sp;   
  goto vma-memory-read9064;   

/* end CarInternal */
/* start DoCdr */

  /* Halfword operand from stack instruction - DoCdr */
  /* arg2 has the preloaded 8 bit operand. */

docdr:
  if (_trace) printf("docdr:\n");
#ifdef TRACING
#endif

DoCdrSP:
  if (_trace) printf("DoCdrSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindocdr;   
#endif

DoCdrLP:
  if (_trace) printf("DoCdrLP:\n");
#ifdef TRACING
  goto begindocdr;   
#endif

DoCdrFP:
  if (_trace) printf("DoCdrFP:\n");

begindocdr:
  if (_trace) printf("begindocdr:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg5 = *(s32 *)(arg1 + 4);   		// Get the operand from the stack. 
  arg6 = *(s32 *)arg1;   
  r0 = (u64)&&return0277;
  goto cdrinternal;
return0277:
  t5 = arg5 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   
#ifdef TRACING
#endif

DoCdrIM:
  goto doistageerror;

/* end DoCdr */
  /* End of Halfword operand from stack instruction - DoCdr */
/* start CdrInternal */


cdrinternal:
  if (_trace) printf("cdrinternal:\n");
  sp = sp + -8;   
  arg2 = (u32)arg6;   
  t5 = arg5 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_List) ? 1 : 0;   

force-alignment9107:
  if (_trace) printf("force-alignment9107:\n");
  if (t6 == 0) 
    goto basic-dispatch9075;
  /* Here if argument TypeList */
  /* Memory Read Internal */

vma-memory-read9076:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->cdr_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9078;

vma-memory-read9077:
  t7 = zero + 192;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read9080;

vma-memory-read9085:
  t5 = arg5 & 192;		// Extract CDR code. 
  if (t5 != 0)   
    goto basic-dispatch9087;
  /* Here if argument 0 */
  arg6 = arg2 + 1;		// Address of next position is CDR 
  arg5 = Type_List;

basic-dispatch9086:
  if (_trace) printf("basic-dispatch9086:\n");

basic-dispatch9074:
  if (_trace) printf("basic-dispatch9074:\n");

cdr-internal9073:
  if (_trace) printf("cdr-internal9073:\n");
  sp = sp + 8;   
  goto *r0; /* ret */

basic-dispatch9075:
  if (_trace) printf("basic-dispatch9075:\n");
  t6 = (t5 == Type_NIL) ? 1 : 0;   

force-alignment9108:
  if (_trace) printf("force-alignment9108:\n");
  if (t6 != 0)   
    goto basic-dispatch9074;

basic-dispatch9103:
  if (_trace) printf("basic-dispatch9103:\n");
  t6 = (t5 == Type_Locative) ? 1 : 0;   

force-alignment9109:
  if (_trace) printf("force-alignment9109:\n");
  if (t6 != 0)   
    goto cdr-internal9072;

basic-dispatch9104:
  if (_trace) printf("basic-dispatch9104:\n");
  /* Here for all other cases */
  arg6 = arg5;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto listexception;

basic-dispatch9087:
  if (_trace) printf("basic-dispatch9087:\n");
  t6 = (t5 == 128) ? 1 : 0;   

force-alignment9110:
  if (_trace) printf("force-alignment9110:\n");
  if (t6 == 0) 
    goto basic-dispatch9088;
  /* Here if argument 128 */
  arg2 = arg2 + 1;

cdr-internal9072:
  if (_trace) printf("cdr-internal9072:\n");
  /* Memory Read Internal */

vma-memory-read9089:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9091;

vma-memory-read9090:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read9093;
  goto cdr-internal9073;   

basic-dispatch9088:
  if (_trace) printf("basic-dispatch9088:\n");
  t6 = (t5 == 64) ? 1 : 0;   

force-alignment9111:
  if (_trace) printf("force-alignment9111:\n");
  if (t6 == 0) 
    goto basic-dispatch9100;
  /* Here if argument 64 */
  arg6 = *(s32 *)&processor->niladdress;   
  arg5 = *((s32 *)(&processor->niladdress)+1);   
  arg6 = (u32)arg6;   
  goto cdr-internal9073;   

basic-dispatch9100:
  if (_trace) printf("basic-dispatch9100:\n");
  /* Here for all other cases */
  arg5 = arg2;
  arg2 = 15;
  goto illegaloperand;

vma-memory-read9093:
  if (_trace) printf("vma-memory-read9093:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9092;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9089;   

vma-memory-read9092:
  if (_trace) printf("vma-memory-read9092:\n");

vma-memory-read9091:
  if (_trace) printf("vma-memory-read9091:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0278;
  goto memoryreaddatadecode;
return0278:
  r0 = *(u64 *)sp;   
  goto cdr-internal9073;   

vma-memory-read9080:
  if (_trace) printf("vma-memory-read9080:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9079;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9076;   

vma-memory-read9079:
  if (_trace) printf("vma-memory-read9079:\n");

vma-memory-read9078:
  if (_trace) printf("vma-memory-read9078:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0279;
  goto memoryreadcdrdecode;
return0279:
  r0 = *(u64 *)sp;   
  goto vma-memory-read9085;   

/* end CdrInternal */
/* start DoReadInternalRegister */

  /* Halfword 10 bit immediate instruction - DoReadInternalRegister */

doreadinternalregister:
  if (_trace) printf("doreadinternalregister:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoReadInternalRegisterIM:
  if (_trace) printf("DoReadInternalRegisterIM:\n");

DoReadInternalRegisterSP:
  if (_trace) printf("DoReadInternalRegisterSP:\n");

DoReadInternalRegisterLP:
  if (_trace) printf("DoReadInternalRegisterLP:\n");

DoReadInternalRegisterFP:
  if (_trace) printf("DoReadInternalRegisterFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  t2 = *(u64 *)&(processor->internalregisterread2);   
  t3 = (s32)arg1 - (s32)512;   
  t1 = *(u64 *)&(processor->internalregisterread1);   
  if ((s64)t3 >= 0)   		// We're in the 1000's 
    goto internal-register-dispatch9112;
  t3 = arg1 & 63;		// Keep only six bits 
  t2 = ((s64)t3 <= (s64)42) ? 1 : 0;   		// In range for the low registers? 
  t3 = (t3 * 8) + t1;  
  if (t2 == 0) 
    goto ReadRegisterError;
  t3 = *(u64 *)t3;   
    goto *t3; /* jmp */   		// Jump to the handler 

internal-register-dispatch9112:
  if (_trace) printf("internal-register-dispatch9112:\n");
  t1 = ((s64)t3 <= (s64)33) ? 1 : 0;   		// In range for the high registers? 
  t3 = (t3 * 8) + t2;  
  if (t1 == 0) 
    goto ReadRegisterError;
  t3 = *(u64 *)t3;   
    goto *t3; /* jmp */   		// Jump to the handler 

/* end DoReadInternalRegister */
  /* End of Halfword operand from stack instruction - DoReadInternalRegister */
/* start DoWriteInternalRegister */

  /* Halfword 10 bit immediate instruction - DoWriteInternalRegister */

dowriteinternalregister:
  if (_trace) printf("dowriteinternalregister:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoWriteInternalRegisterIM:
  if (_trace) printf("DoWriteInternalRegisterIM:\n");

DoWriteInternalRegisterSP:
  if (_trace) printf("DoWriteInternalRegisterSP:\n");

DoWriteInternalRegisterLP:
  if (_trace) printf("DoWriteInternalRegisterLP:\n");

DoWriteInternalRegisterFP:
  if (_trace) printf("DoWriteInternalRegisterFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg2 = (u32)(arg6 >> ((4&7)*8));   
  arg3 = (u32)arg6;   		// Arg2=tag arg3=data 
  iSP = iSP - 8;   		// Pop Stack. 
  t2 = *(u64 *)&(processor->internalregisterwrite2);   
  t3 = (s32)arg1 - (s32)512;   
  t1 = *(u64 *)&(processor->internalregisterwrite1);   
  if ((s64)t3 >= 0)   		// We're in the 1000's 
    goto internal-register-dispatch9113;
  t3 = arg1 & 63;		// Keep only six bits 
  t2 = ((s64)t3 <= (s64)42) ? 1 : 0;   		// In range for the low registers? 
  t3 = (t3 * 8) + t1;  
  if (t2 == 0) 
    goto WriteRegisterError;
  t3 = *(u64 *)t3;   
    goto *t3; /* jmp */   		// Jump to the handler 

internal-register-dispatch9113:
  if (_trace) printf("internal-register-dispatch9113:\n");
  t1 = ((s64)t3 <= (s64)33) ? 1 : 0;   		// In range for the high registers? 
  t3 = (t3 * 8) + t2;  
  if (t1 == 0) 
    goto WriteRegisterError;
  t3 = *(u64 *)t3;   
    goto *t3; /* jmp */   		// Jump to the handler 

/* end DoWriteInternalRegister */
  /* End of Halfword operand from stack instruction - DoWriteInternalRegister */
/* start WriteRegisterBARx */


WriteRegisterBARx:
  if (_trace) printf("WriteRegisterBARx:\n");
  t2 = arg1 >> 7;   		// BAR number into T2 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t3 = arg2 << 32;   		// Make a quadword from tag and data 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t1 = (u64)&processor->bar0;   
  t1 = (t2 * 8) + t1;  		// Now T1 points to the BAR 
  t3 = t3 | arg3;		// Construct the combined word 
  *(u64 *)t1 = t3;   
  goto cachevalid;   

/* end WriteRegisterBARx */
/* start DoBlock3Read */

  /* Halfword 10 bit immediate instruction - DoBlock3Read */

doblock3read:
  if (_trace) printf("doblock3read:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBlock3ReadIM:
  if (_trace) printf("DoBlock3ReadIM:\n");

DoBlock3ReadSP:
  if (_trace) printf("DoBlock3ReadSP:\n");

DoBlock3ReadLP:
  if (_trace) printf("DoBlock3ReadLP:\n");

DoBlock3ReadFP:
  if (_trace) printf("DoBlock3ReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg4 = (u64)&processor->bar3;   
  goto blockread;   

/* end DoBlock3Read */
  /* End of Halfword operand from stack instruction - DoBlock3Read */
/* start DoBlock2Read */

  /* Halfword 10 bit immediate instruction - DoBlock2Read */

doblock2read:
  if (_trace) printf("doblock2read:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBlock2ReadIM:
  if (_trace) printf("DoBlock2ReadIM:\n");

DoBlock2ReadSP:
  if (_trace) printf("DoBlock2ReadSP:\n");

DoBlock2ReadLP:
  if (_trace) printf("DoBlock2ReadLP:\n");

DoBlock2ReadFP:
  if (_trace) printf("DoBlock2ReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg4 = (u64)&processor->bar2;   
  goto blockread;   

/* end DoBlock2Read */
  /* End of Halfword operand from stack instruction - DoBlock2Read */
/* start DoBlock1Read */

  /* Halfword 10 bit immediate instruction - DoBlock1Read */

doblock1read:
  if (_trace) printf("doblock1read:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBlock1ReadIM:
  if (_trace) printf("DoBlock1ReadIM:\n");

DoBlock1ReadSP:
  if (_trace) printf("DoBlock1ReadSP:\n");

DoBlock1ReadLP:
  if (_trace) printf("DoBlock1ReadLP:\n");

DoBlock1ReadFP:
  if (_trace) printf("DoBlock1ReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg4 = (u64)&processor->bar1;   

blockread:
  if (_trace) printf("blockread:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = *(s32 *)arg4;   		// Get the vma 
  arg3 = arg1 >> 6;   		// cycle type 
  t2 = arg1 & 4;		// =no-incrementp 
  t3 = arg1 & 16;		// =cdr-code-nextp 
  t4 = arg1 & 32;		// =fixnum onlyp 
  arg2 = (u32)arg2;   
  /* Do the read cycle */
  /* Memory Read Internal */

vma-memory-read9117:
  t7 = arg2 + ivory;
  t8 = (arg3 * 4);   		// Cycle-number -> table offset 
  arg5 = LDQ_U(t7);   
  t8 = (t8 * 4) + ivory;   
  arg6 = (t7 * 4);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)(t8 + PROCESSORSTATE_DATAREAD_MASK);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9119;

vma-memory-read9118:
  t8 = t8 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read9121;

vma-memory-read9128:
  if (t4 != 0)   		// J. if we have to test for fixnump. 
    goto i%block-n-read9114;

i%block-n-read9115:
  t4 = arg2 + 1;		// Compute Incremented address 

force-alignment9129:
  if (_trace) printf("force-alignment9129:\n");
  if (t2 == 0)   		// Conditionally update address 
    arg2 = t4;
		/* Store updated vma in BAR */
  *(u32 *)arg4 = arg2;
  t2 = arg5 & 63;		// Compute CDR-NEXT 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if (t3)   		// Conditionally Set CDR-NEXT 
    arg5 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u32 *)(iSP + 8) = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = arg5;
  iSP = iSP + 8;
  goto cachevalid;   

i%block-n-read9116:
  if (_trace) printf("i%block-n-read9116:\n");
  arg5 = arg2;
  arg2 = 23;
  goto illegaloperand;

vma-memory-read9121:
  if (_trace) printf("vma-memory-read9121:\n");

vma-memory-read9119:
  if (_trace) printf("vma-memory-read9119:\n");
  r0 = (u64)&&return0280;
  goto memoryreadgeneraldecode;
return0280:
  goto vma-memory-read9128;   

i%block-n-read9114:
  if (_trace) printf("i%block-n-read9114:\n");
  t5 = arg5 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto i%block-n-read9116;
  goto i%block-n-read9115;   

/* end DoBlock1Read */
  /* End of Halfword operand from stack instruction - DoBlock1Read */
/* start DoBlock2Write */

  /* Halfword operand from stack instruction - DoBlock2Write */

doblock2write:
  if (_trace) printf("doblock2write:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoBlock2WriteIM:
  if (_trace) printf("DoBlock2WriteIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment9130:
  if (_trace) printf("force-alignment9130:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoblock2write;   
#ifdef TRACING
#endif

DoBlock2WriteSP:
  if (_trace) printf("DoBlock2WriteSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoblock2write;   
#endif

DoBlock2WriteLP:
  if (_trace) printf("DoBlock2WriteLP:\n");
#ifdef TRACING
  goto headdoblock2write;   
#endif

DoBlock2WriteFP:
  if (_trace) printf("DoBlock2WriteFP:\n");

headdoblock2write:
  if (_trace) printf("headdoblock2write:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoblock2write:
  if (_trace) printf("begindoblock2write:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg3 = *(s32 *)&processor->bar2;   
  arg2 = (u64)&processor->bar2;   
  goto blockwrite;   

/* end DoBlock2Write */
  /* End of Halfword operand from stack instruction - DoBlock2Write */
/* start DoBlock1Write */

  /* Halfword operand from stack instruction - DoBlock1Write */

doblock1write:
  if (_trace) printf("doblock1write:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoBlock1WriteIM:
  if (_trace) printf("DoBlock1WriteIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment9134:
  if (_trace) printf("force-alignment9134:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoblock1write;   
#ifdef TRACING
#endif

DoBlock1WriteSP:
  if (_trace) printf("DoBlock1WriteSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoblock1write;   
#endif

DoBlock1WriteLP:
  if (_trace) printf("DoBlock1WriteLP:\n");
#ifdef TRACING
  goto headdoblock1write;   
#endif

DoBlock1WriteFP:
  if (_trace) printf("DoBlock1WriteFP:\n");

headdoblock1write:
  if (_trace) printf("headdoblock1write:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoblock1write:
  if (_trace) printf("begindoblock1write:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg3 = *(s32 *)&processor->bar1;   
  arg2 = (u64)&processor->bar1;   

blockwrite:
  if (_trace) printf("blockwrite:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg3 = (u32)arg3;   		// Unsigned vma 
  t2 = arg1 >> 32;   		// Get tag 
  t3 = (u32)arg1;   		// Get data 
  t8 = arg3 + ivory;
  t6 = (t8 * 4);   
  t5 = LDQ_U(t8);   
  t4 = arg3 - t11;   		// Stack cache offset 
  t7 = ((u64)t4 < (u64)t12) ? 1 : 0;   		// In range? 
  t4 = (t2 & 0xff) << ((t8&7)*8);   
  t5 = t5 & ~(0xffL << (t8&7)*8);   

force-alignment9133:
  if (_trace) printf("force-alignment9133:\n");
  t5 = t5 | t4;
  STQ_U(t8, t5);   
  *(u32 *)t6 = t3;
  if (t7 != 0)   		// J. if in cache 
    goto vma-memory-write9132;

vma-memory-write9131:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  arg3 = arg3 + 1;		// Increment the address 
		/* Store updated vma in BAR */
  *(u32 *)arg2 = arg3;
  goto cachevalid;   

vma-memory-write9132:
  if (_trace) printf("vma-memory-write9132:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t4 = arg3 - t11;   		// Stack cache offset 
  t8 = (t4 * 8) + t8;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t8 = t3;
		/* write the stack cache */
  *(u32 *)(t8 + 4) = t2;
  goto vma-memory-write9131;   

/* end DoBlock1Write */
  /* End of Halfword operand from stack instruction - DoBlock1Write */
/* start DoBranchTrueNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueNoPop */

dobranchtruenopop:
  if (_trace) printf("dobranchtruenopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchTrueNoPopIM:
  if (_trace) printf("DoBranchTrueNoPopIM:\n");

DoBranchTrueNoPopSP:
  if (_trace) printf("DoBranchTrueNoPopSP:\n");

DoBranchTrueNoPopLP:
  if (_trace) printf("DoBranchTrueNoPopLP:\n");

DoBranchTrueNoPopFP:
  if (_trace) printf("DoBranchTrueNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
#endif
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 == 0) 
    goto NEXTINSTRUCTION;
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iPC = iPC + arg1;		// Update the PC in halfwords 
#ifndef CACHEMETERING
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;   

/* end DoBranchTrueNoPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueNoPop */
/* start DoBranchFalseNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseNoPop */

dobranchfalsenopop:
  if (_trace) printf("dobranchfalsenopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchFalseNoPopIM:
  if (_trace) printf("DoBranchFalseNoPopIM:\n");

DoBranchFalseNoPopSP:
  if (_trace) printf("DoBranchFalseNoPopSP:\n");

DoBranchFalseNoPopLP:
  if (_trace) printf("DoBranchFalseNoPopLP:\n");

DoBranchFalseNoPopFP:
  if (_trace) printf("DoBranchFalseNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
#endif
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 != 0)   
    goto NEXTINSTRUCTION;
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iPC = iPC + arg1;		// Update the PC in halfwords 
#ifndef CACHEMETERING
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;   

/* end DoBranchFalseNoPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseNoPop */
/* start callgeneric */

  /*  */
  /*  */
  /* Fullword instruction - callgeneric */
  /* ======================= */

callgeneric:
  if (_trace) printf("callgeneric:\n");

callgenericprefetch:
  if (_trace) printf("callgenericprefetch:\n");
  t3 = *(u64 *)&(processor->trapvecbase);   
  arg4 = arg3;		// Get operand 
  arg3 = Type_GenericFunction;
  arg5 = Type_EvenPC;
  arg6 = t3 + 2636;   
  goto startcallcompiledmerge;   

/* end callgeneric */
  /* End of Fullword instruction - callgeneric */
  /* ============================== */
  /*  */
/* start callcompiledeven */

  /*  */
  /*  */
  /* Fullword instruction - callcompiledeven */
  /* ======================= */

callcompiledeven:
  if (_trace) printf("callcompiledeven:\n");

callcompiledevenprefetch:
  if (_trace) printf("callcompiledevenprefetch:\n");
  arg6 = arg3;		// Get operand 
  arg5 = Type_EvenPC;
  arg3 = zero;		// No extra arg 
  goto startcallcompiledmerge;   

/* end callcompiledeven */
  /* End of Fullword instruction - callcompiledeven */
  /* ============================== */
  /*  */
/* start DoStartCall */

  /* Halfword operand from stack instruction - DoStartCall */
  /* arg2 has the preloaded 8 bit operand. */

dostartcall:
  if (_trace) printf("dostartcall:\n");
#ifdef TRACING
#endif

DoStartCallSP:
  if (_trace) printf("DoStartCallSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindostartcall;   
#endif

DoStartCallLP:
  if (_trace) printf("DoStartCallLP:\n");
#ifdef TRACING
  goto begindostartcall;   
#endif

DoStartCallFP:
  if (_trace) printf("DoStartCallFP:\n");

begindostartcall:
  if (_trace) printf("begindostartcall:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg5 = *(s32 *)(arg1 + 4);   
  arg6 = *(s32 *)arg1;   

startcallagain:
  if (_trace) printf("startcallagain:\n");

start-call-dispatch9137:
  if (_trace) printf("start-call-dispatch9137:\n");
  t1 = *(u64 *)&(processor->trapvecbase);   
  t2 = arg5 & 63;		// Strip off any CDR code bits. 
  t3 = (t2 == Type_CompiledFunction) ? 1 : 0;   

force-alignment9185:
  if (_trace) printf("force-alignment9185:\n");
  if (t3 == 0) 
    goto basic-dispatch9142;
  /* Here if argument TypeCompiledFunction */

start-call-dispatch9138:
  if (_trace) printf("start-call-dispatch9138:\n");
  arg3 = zero;		// No extra argument 

start-call-dispatch9139:
  if (_trace) printf("start-call-dispatch9139:\n");
  arg5 = Type_EvenPC;

startcallcompiledmerge:
  if (_trace) printf("startcallcompiledmerge:\n");
  t7 = *((s32 *)(&processor->continuation)+1);   
  iSP = iSP + 16;		// prepare to push continuation/control register 
  t3 = *(s32 *)&processor->control;   
  t6 = Type_Fixnum+0xC0;
  t8 = *(s32 *)&processor->continuation;   
  t5 = (64) << 16;   
  t7 = t7 | 192;		// Set CDR code 3 
		/* push continuation */
  *(u32 *)(iSP + -8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + -4) = t7;
  t8 = t3 | t5;		// Set call started bit in CR 
  t5 = zero + 256;   
		/* Push control register */
  *(u32 *)iSP = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t6;
  t8 = t8 & ~t5;		// Clear the extra arg bit 
		/* Save control with new state */
  *(u32 *)&processor->control = t8;
  /* End of push-frame */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u32 *)&processor->continuation = arg6;
  *((u32 *)(&processor->continuation)+1) = arg5;
  *(u64 *)&processor->continuationcp = zero;   
  if (arg3 != 0)   
    goto start-call-dispatch9140;
  goto cachevalid;   

start-call-dispatch9140:
  if (_trace) printf("start-call-dispatch9140:\n");
  t1 = *(s32 *)&processor->control;   
  t2 = zero + 256;   
  t3 = arg3 & 63;		// set CDR-NEXT 
		/* Push the extra arg. */
  *(u32 *)(iSP + 8) = arg4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  t1 = t1 | t2;		// Set the extra arg bit 
		/* Save control with new state */
  *(u32 *)&processor->control = t1;
  goto cachevalid;   

basic-dispatch9142:
  if (_trace) printf("basic-dispatch9142:\n");
  t3 = (t2 == Type_GenericFunction) ? 1 : 0;   

force-alignment9186:
  if (_trace) printf("force-alignment9186:\n");
  if (t3 == 0) 
    goto basic-dispatch9143;
  /* Here if argument TypeGenericFunction */
  arg3 = arg5;
  arg4 = (u32)arg6;   
  arg6 = t1 + 2636;   
  goto start-call-dispatch9139;   

basic-dispatch9143:
  if (_trace) printf("basic-dispatch9143:\n");
  t3 = (t2 == Type_Instance) ? 1 : 0;   

force-alignment9187:
  if (_trace) printf("force-alignment9187:\n");
  if (t3 == 0) 
    goto basic-dispatch9144;
  /* Here if argument TypeInstance */
  arg3 = arg5;
  arg4 = (u32)arg6;   
  arg6 = t1 + 2638;   
  goto start-call-dispatch9139;   

basic-dispatch9144:
  if (_trace) printf("basic-dispatch9144:\n");
  t3 = (t2 == Type_Symbol) ? 1 : 0;   

force-alignment9188:
  if (_trace) printf("force-alignment9188:\n");
  if (t3 == 0) 
    goto basic-dispatch9145;
  /* Here if argument TypeSymbol */
  arg6 = (u32)arg6;   
  arg3 = zero;		// No extra argument 
  arg2 = arg6 + 2;		// Get to the function cell 
  goto startcallindirect;   

basic-dispatch9145:
  if (_trace) printf("basic-dispatch9145:\n");
  t3 = (t2 == Type_LexicalClosure) ? 1 : 0;   

force-alignment9189:
  if (_trace) printf("force-alignment9189:\n");
  if (t3 == 0) 
    goto basic-dispatch9146;
  /* Here if argument TypeLexicalClosure */
  arg2 = (u32)arg6;   
  /* Memory Read Internal */

vma-memory-read9147:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9149;

vma-memory-read9148:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read9151;

vma-memory-read9158:
  arg3 = arg5;
  arg4 = arg6;
  arg2 = arg2 + 1;

startcallindirect:
  if (_trace) printf("startcallindirect:\n");
  /* Memory Read Internal */

vma-memory-read9159:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9161;

vma-memory-read9160:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read9163;

vma-memory-read9170:
  t5 = arg5 - Type_CompiledFunction;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto start-call-dispatch9137;
  goto start-call-dispatch9139;   

basic-dispatch9146:
  if (_trace) printf("basic-dispatch9146:\n");
  /* Here for all other cases */

start-call-dispatch9135:
  if (_trace) printf("start-call-dispatch9135:\n");
  arg3 = arg5;
  arg4 = arg6;
  t3 = t1 + 2304;   
  /* TagType. */
  arg5 = arg5 & 63;
  arg2 = arg5 + t3;
  /* Memory Read Internal */

vma-memory-read9172:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9174;

vma-memory-read9173:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read9176;

vma-memory-read9183:
  t3 = arg5 - Type_EvenPC;   
  t3 = t3 & 63;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto start-call-dispatch9136;
  goto start-call-dispatch9139;   

basic-dispatch9141:
  if (_trace) printf("basic-dispatch9141:\n");

start-call-dispatch9136:
  if (_trace) printf("start-call-dispatch9136:\n");
  arg5 = t1;
  arg2 = 51;
  goto illegaloperand;

vma-memory-read9176:
  if (_trace) printf("vma-memory-read9176:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9175;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9172;   

vma-memory-read9175:
  if (_trace) printf("vma-memory-read9175:\n");

vma-memory-read9174:
  if (_trace) printf("vma-memory-read9174:\n");
  r0 = (u64)&&return0281;
  goto memoryreaddatadecode;
return0281:
  goto vma-memory-read9183;   

vma-memory-read9163:
  if (_trace) printf("vma-memory-read9163:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9162;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9159;   

vma-memory-read9162:
  if (_trace) printf("vma-memory-read9162:\n");

vma-memory-read9161:
  if (_trace) printf("vma-memory-read9161:\n");
  r0 = (u64)&&return0282;
  goto memoryreaddatadecode;
return0282:
  goto vma-memory-read9170;   

vma-memory-read9151:
  if (_trace) printf("vma-memory-read9151:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9150;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read9147;   

vma-memory-read9150:
  if (_trace) printf("vma-memory-read9150:\n");

vma-memory-read9149:
  if (_trace) printf("vma-memory-read9149:\n");
  r0 = (u64)&&return0283;
  goto memoryreaddatadecode;
return0283:
  goto vma-memory-read9158;   
#ifdef TRACING
#endif

DoStartCallIM:
  goto doistageerror;

/* end DoStartCall */
  /* End of Halfword operand from stack instruction - DoStartCall */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifuncom1.as */
