/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/idouble.as
 ************************************************************************/

  /* Support for double precision floating point. */
/* start FetchDoubleFloat */


fetchdoublefloat:
  if (_trace) printf("fetchdoublefloat:\n");
  sp = sp + -8;   
  /* Memory Read Internal */

g30690:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
		/* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto g30692;

g30691:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)   
    goto g30694;

g30701:
  t5 = arg5 - Type_Fixnum;
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto g30689;
  *((u32 *)(&processor->fp0)+1) = arg6;
  arg2 = arg2 + 1;
  /* Memory Read Internal */

g30702:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
		/* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto g30704;

g30703:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)   
    goto g30706;

g30713:
  t5 = arg5 - Type_Fixnum;
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto g30689;
  *(u32 *)&processor->fp0 = arg6;
  sp = sp + 8;   
  goto *r0; /* ret */

g30706:
  if (_trace) printf("g30706:\n");
  if ((t7 & 1) == 0)   
    goto g30705;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto g30702;   

g30705:
  if (_trace) printf("g30705:\n");

g30704:
  if (_trace) printf("g30704:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0668;
  goto memoryreaddatadecode;
return0668:
  r0 = *(u64 *)sp;
  goto g30713;   

g30694:
  if (_trace) printf("g30694:\n");
  if ((t7 & 1) == 0)   
    goto g30693;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto g30690;   

g30693:
  if (_trace) printf("g30693:\n");

g30692:
  if (_trace) printf("g30692:\n");
  *(u64 *)sp = r0;
  r0 = (u64)&&return0669;
  goto memoryreaddatadecode;
return0669:
  r0 = *(u64 *)sp;
  goto g30701;   

g30689:
  if (_trace) printf("g30689:\n");
  arg6 = Type_DoubleFloat;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

/* end FetchDoubleFloat */
/* start ConsDoubleFloat */


consdoublefloat:
  if (_trace) printf("consdoublefloat:\n");
  sp = sp + -8;   
  arg6 = *(s32 *)&processor->fp0;
  arg5 = *((s32 *)(&processor->fp0)+1);
  t5 = *(u64 *)&(processor->lcarea);
  t8 = *(u64 *)&(processor->niladdress);
  t6 = *(s32 *)&processor->lclength;
		/* Fetch address */
  arg2 = *(u64 *)&(processor->lcaddress);
  t7 = (t5 == t8) ? 1 : 0;   
  if (t7 != 0)   		// Decached area 
    goto g30714;
		/* Effectively an unsigned 32-bit compare */
  t7 = t6 - 2;
  if ((s64)t7 < 0)   		// Insufficient cache 
    goto g30714;
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
		/* Store remaining length */
  *(u32 *)&processor->lclength = t7;
  t8 = (u32)arg2;   
  t8 = t8 + 2;		// Increment address 
		/* Store updated address */
  *(u32 *)&processor->lcaddress = t8;
  arg2 = (u32)arg2;   
  t9 = Type_Fixnum;
  t9 = t9 | 128;
  t5 = arg2 + ivory;
  t8 = (t5 * 4);   
  t7 = LDQ_U(t5);   
  t6 = (t9 & 0xff) << ((t5&7)*8);   
  t7 = t7 & ~(0xffL << (t5&7)*8);

g30715:
  if (_trace) printf("g30715:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);   
  *(u32 *)t8 = arg5;
  t10 = arg2 + 1;
  t9 = Type_Fixnum;
  t9 = t9 | 64;
  t5 = t10 + ivory;
  t8 = (t5 * 4);   
  t7 = LDQ_U(t5);   
  t6 = (t9 & 0xff) << ((t5&7)*8);   
  t7 = t7 & ~(0xffL << (t5&7)*8);

g30716:
  if (_trace) printf("g30716:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);   
  *(u32 *)t8 = arg6;
  sp = sp + 8;   
  goto *r0; /* ret */

g30714:
  if (_trace) printf("g30714:\n");
  arg6 = Type_DoubleFloat;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

/* end ConsDoubleFloat */
/* start DoDoubleFloatOp */

  /* Halfword operand from stack instruction - DoDoubleFloatOp */
  /* arg2 has the preloaded 8 bit operand. */

dodoublefloatop:
  if (_trace) printf("dodoublefloatop:\n");
#ifdef TRACING
#endif

DoDoubleFloatOpIM:
  if (_trace) printf("DoDoubleFloatOpIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindodoublefloatop;   
#ifdef TRACING
#endif

DoDoubleFloatOpSP:
  if (_trace) printf("DoDoubleFloatOpSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdodoublefloatop;   
#endif

DoDoubleFloatOpLP:
  if (_trace) printf("DoDoubleFloatOpLP:\n");
#ifdef TRACING
  goto headdodoublefloatop;   
#endif

DoDoubleFloatOpFP:
  if (_trace) printf("DoDoubleFloatOpFP:\n");

headdodoublefloatop:
  if (_trace) printf("headdodoublefloatop:\n");
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
		/* Get the operand */
  arg1 = *(u64 *)arg1;

begindodoublefloatop:
  if (_trace) printf("begindodoublefloatop:\n");
  /* arg1 has the operand, not sign extended if immediate. */
		/* X high */
  arg3 = *(s32 *)(iSP + -24);
		/* X low */
  arg4 = *(s32 *)(iSP + -16);
		/* Y high */
  arg5 = *(s32 *)(iSP + -8);
		/* Y low */
  arg6 = *(s32 *)iSP;
		/* Get high part up top */
  arg3 = arg3 << 32;
  arg4 = (u32)arg4;   
		/* Get high part up top */
  arg5 = arg5 << 32;
  arg6 = (u32)arg6;   
  arg3 = arg3 | arg4;		// ARG3 is now X 
  arg5 = arg5 | arg6;		// ARG5 is now Y 
  *(u64 *)&processor->fp0 = arg3;
  *(u64 *)&processor->fp1 = arg5;
		/* Immediate tag */
  t2 = arg1 >> 32;
  t1 = (u32)arg1;   		// Immediate data 
  t3 = t2 - Type_Fixnum;
  t3 = t3 & 63;		// Strip CDR code 
  if (t3 != 0)   
    goto doublefloatiop;
  LDT(1, f1, processor->fp0);   
  LDT(2, f2, processor->fp1);   
  /* NIL */
  t3 = zero + DoubleFloatOp_Add;   
  t3 = t1 - t3;
  if (t3 != 0)   
    goto g30718;
  /* Here if argument DoubleFloatOpAdd */
  ADDT(1, f1, 1, f1, 2, f2); /* addt */
  goto g30717;   

g30718:
  if (_trace) printf("g30718:\n");
  t3 = zero + DoubleFloatOp_Sub;   
  t3 = t1 - t3;
  if (t3 != 0)   
    goto g30719;
  /* Here if argument DoubleFloatOpSub */
  SUBT(1, f1, 1, f1, 2, f2);
  goto g30717;   

g30719:
  if (_trace) printf("g30719:\n");
  t3 = zero + DoubleFloatOp_Multiply;   
  t3 = t1 - t3;
  if (t3 != 0)   
    goto g30720;
  /* Here if argument DoubleFloatOpMultiply */
  MULT(1, f1, 1, f1, 2, f2);
  goto g30717;   

g30720:
  if (_trace) printf("g30720:\n");
  t3 = zero + DoubleFloatOp_Divide;   
  t3 = t1 - t3;
  if (t3 != 0)   
    goto g30721;
  /* Here if argument DoubleFloatOpDivide */
  DIVT(1, f1, 1, f1, 2, f2);
  goto g30717;   

g30721:
  if (_trace) printf("g30721:\n");

g30717:
  if (_trace) printf("g30717:\n");
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
		/* There was no FP exception */
  t3 = *(u64 *)&(processor->niladdress);

doublefloatmerge:
  STT( (u64 *)&processor->fp0, 1, f1 );   
  t1 = *(s32 *)&processor->fp0;
  t2 = *((s32 *)(&processor->fp0)+1);
		/* Pop all the operands */
  iSP = iSP - 32;
  t4 = Type_Fixnum;
		/* Push high result */
  *(u32 *)(iSP + 8) = t2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  t4 = Type_Fixnum;
		/* Push low result */
  *(u32 *)(iSP + 8) = t1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  iSP = iSP + 8;
  t4 = t3 << 26;
  t4 = t4 >> 26;
		/* Push the exception predicate */
  *(u64 *)iSP = t4;
  goto NEXTINSTRUCTION;   

doublefloatexc:
  if (_trace) printf("doublefloatexc:\n");
		/* Indicate an FP exception occurred */
  t3 = *(u64 *)&(processor->taddress);
  goto doublefloatmerge;   

doublefloatiop:
  if (_trace) printf("doublefloatiop:\n");
  arg5 = 0;
  arg2 = 85;
  goto illegaloperand;

/* end DoDoubleFloatOp */
  /* End of Halfword operand from stack instruction - DoDoubleFloatOp */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/idouble.as */
