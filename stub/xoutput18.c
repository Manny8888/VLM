/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunblok.as
 ************************************************************************/

  /* Block Instructions. */
/* start DoBlock0Read */

  /* Halfword 10 bit immediate instruction - DoBlock0Read */

doblock0read:
  if (_trace) printf("doblock0read:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBlock0ReadIM:
  if (_trace) printf("DoBlock0ReadIM:\n");

DoBlock0ReadSP:
  if (_trace) printf("DoBlock0ReadSP:\n");

DoBlock0ReadLP:
  if (_trace) printf("DoBlock0ReadLP:\n");

DoBlock0ReadFP:
  if (_trace) printf("DoBlock0ReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar0;
  goto blockread;

/* end DoBlock0Read */
  /* End of Halfword operand from stack instruction - DoBlock0Read */
/* start DoBlock0Write */

  /* Halfword operand from stack instruction - DoBlock0Write */

doblock0write:
  if (_trace) printf("doblock0write:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoBlock0WriteIM:
  if (_trace) printf("DoBlock0WriteIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g5799:
  if (_trace) printf("g5799:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoblock0write;
#ifdef TRACING
#endif

DoBlock0WriteSP:
  if (_trace) printf("DoBlock0WriteSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoblock0write;
#endif

DoBlock0WriteLP:
  if (_trace) printf("DoBlock0WriteLP:\n");
#ifdef TRACING
  goto headdoblock0write;
#endif

DoBlock0WriteFP:
  if (_trace) printf("DoBlock0WriteFP:\n");

headdoblock0write:
  if (_trace) printf("headdoblock0write:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoblock0write:
  if (_trace) printf("begindoblock0write:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg3 = *(s32 *)&processor->bar0;
  arg2 = (u64)&processor->bar0;
  goto blockwrite;

/* end DoBlock0Write */
  /* End of Halfword operand from stack instruction - DoBlock0Write */
/* start DoBlock0ReadShift */

  /* Halfword 10 bit immediate instruction - DoBlock0ReadShift */

doblock0readshift:
  if (_trace) printf("doblock0readshift:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBlock0ReadShiftIM:
  if (_trace) printf("DoBlock0ReadShiftIM:\n");

DoBlock0ReadShiftSP:
  if (_trace) printf("DoBlock0ReadShiftSP:\n");

DoBlock0ReadShiftLP:
  if (_trace) printf("DoBlock0ReadShiftLP:\n");

DoBlock0ReadShiftFP:
  if (_trace) printf("DoBlock0ReadShiftFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar0;
  goto blockreadshift;

/* end DoBlock0ReadShift */
  /* End of Halfword operand from stack instruction - DoBlock0ReadShift */
/* start DoBlock3ReadShift */

  /* Halfword 10 bit immediate instruction - DoBlock3ReadShift */

doblock3readshift:
  if (_trace) printf("doblock3readshift:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBlock3ReadShiftIM:
  if (_trace) printf("DoBlock3ReadShiftIM:\n");

DoBlock3ReadShiftSP:
  if (_trace) printf("DoBlock3ReadShiftSP:\n");

DoBlock3ReadShiftLP:
  if (_trace) printf("DoBlock3ReadShiftLP:\n");

DoBlock3ReadShiftFP:
  if (_trace) printf("DoBlock3ReadShiftFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar3;
  goto blockreadshift;

/* end DoBlock3ReadShift */
  /* End of Halfword operand from stack instruction - DoBlock3ReadShift */
/* start DoBlock2ReadShift */

  /* Halfword 10 bit immediate instruction - DoBlock2ReadShift */

doblock2readshift:
  if (_trace) printf("doblock2readshift:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBlock2ReadShiftIM:
  if (_trace) printf("DoBlock2ReadShiftIM:\n");

DoBlock2ReadShiftSP:
  if (_trace) printf("DoBlock2ReadShiftSP:\n");

DoBlock2ReadShiftLP:
  if (_trace) printf("DoBlock2ReadShiftLP:\n");

DoBlock2ReadShiftFP:
  if (_trace) printf("DoBlock2ReadShiftFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar2;
  goto blockreadshift;

/* end DoBlock2ReadShift */
  /* End of Halfword operand from stack instruction - DoBlock2ReadShift */
/* start DoBlock1ReadShift */

  /* Halfword 10 bit immediate instruction - DoBlock1ReadShift */

doblock1readshift:
  if (_trace) printf("doblock1readshift:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBlock1ReadShiftIM:
  if (_trace) printf("DoBlock1ReadShiftIM:\n");

DoBlock1ReadShiftSP:
  if (_trace) printf("DoBlock1ReadShiftSP:\n");

DoBlock1ReadShiftLP:
  if (_trace) printf("DoBlock1ReadShiftLP:\n");

DoBlock1ReadShiftFP:
  if (_trace) printf("DoBlock1ReadShiftFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar1;

blockreadshift:
  if (_trace) printf("blockreadshift:\n");
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Get the vma */
  t2 = *(s32 *)arg2;
  /* cycle type */
  t1 = arg1 >> 6;
  /* =no-incrementp */
  t4 = arg1 & 4;
  /* =cdr-code-nextp */
  t5 = arg1 & 16;
  /* =fixnum onlyp */
  t6 = arg1 & 32;
  t2 = (u32)t2;
  /* Memory Read Internal */

g5804:
  t11 = t2 + ivory;
  /* Cycle-number -> table offset */
  t12 = (t1 * 4);
  t8 = LDQ_U(t11);
  t12 = (t12 * 4) + ivory;
  t7 = (t11 * 4);
  /* Stack cache offset */
  t9 = t2 - arg5;
  t12 = *(u64 *)(t12 + PROCESSORSTATE_DATAREAD_MASK);
  /* In range? */
  t10 = ((u64)t9 < (u64)arg6) ? 1 : 0;
  t7 = *(s32 *)t7;
  t8 = (u8)(t8 >> ((t11&7)*8));
  if (t10 != 0)
    goto g5806;

g5805:
  t12 = t12 >> (t8 & 63);
  t7 = (u32)t7;
  if (t12 & 1)
    goto g5808;

g5815:
  /* J. if we don't have to test for fixnump. */
  if (t6 == 0)
    goto g5800;
  t9 = t8 - Type_Fixnum;
  /* Strip CDR code */
  t9 = t9 & 63;
  if (t9 != 0)
    goto g5803;

g5800:
  if (_trace) printf("g5800:\n");
  /* J. if we don't have to increment the address. */
  if (t4 != 0)
    goto g5801;
  /* Increment the address */
  t2 = t2 + 1;

g5801:
  if (_trace) printf("g5801:\n");
  /* Store updated vma in BAR */
  *(u32 *)arg2 = t2;
  /* J. if we don't have to clear CDR codes. */
  if (t5 == 0)
    goto g5802;
  t8 = t8 & 63;

g5802:
  if (_trace) printf("g5802:\n");
  t1 = zero + 21504;
  /* Get rotate */
  t3 = *(u64 *)&(processor->byterotate);
  /* Get bytesize */
  t4 = *(u64 *)&(processor->bytesize);
  /* Get background */
  t2 = t1 >> 10;
  /* Extract the byte background */
  t2 = t2 & 3;
  t5 = (t2 == ALUByteBackground_Op1) ? 1 : 0;

g5822:
  if (_trace) printf("g5822:\n");
  if (t5 == 0)
    goto g5818;
  /* Here if argument ALUByteBackgroundOp1 */
  t2 = t1;

g5817:
  if (_trace) printf("g5817:\n");
  t6 = t1 >> 12;
  /* Extractthe byte rotate latch */
  t6 = t6 & 1;
  t7 = t7 << (t3 & 63);
  t5 = (u32)(t7 >> ((4&7)*8));
  t7 = (u32)t7;
  /* OP2 rotated */
  t7 = t7 | t5;
  /* Don't update rotate latch if not requested */
  if (t6 == 0)
    goto g5816;
  *(u64 *)&processor->rotatelatch = t7;

g5816:
  if (_trace) printf("g5816:\n");
  t6 = zero + -2;
  t6 = t6 << (t4 & 63);
  /* Compute mask */
  t6 = ~t6;
  /* Get byte function */
  t5 = t1 >> 13;
  t5 = t5 & 1;
  t4 = (t5 == ALUByteFunction_Dpb) ? 1 : 0;

g5827:
  if (_trace) printf("g5827:\n");
  if (t4 == 0)
    goto g5824;
  /* Here if argument ALUByteFunctionDpb */
  /* Position mask */
  t6 = t6 << (t3 & 63);

g5823:
  if (_trace) printf("g5823:\n");
  /* rotated&mask */
  t7 = t7 & t6;
  /* background&~mask */
  t2 = t2 & ~t6;
  t7 = t7 | t2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u32 *)(iSP + 8) = t7;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto cachevalid;

g5803:
  if (_trace) printf("g5803:\n");
  arg5 = t2;
  arg2 = 23;
  goto illegaloperand;

g5824:
  if (_trace) printf("g5824:\n");
  t4 = (t5 == ALUByteFunction_Ldb) ? 1 : 0;

g5828:
  if (_trace) printf("g5828:\n");
  if (t4 != 0)
    goto g5823;
  goto g5823;

g5818:
  if (_trace) printf("g5818:\n");
  t5 = (t2 == ALUByteBackground_RotateLatch) ? 1 : 0;

g5829:
  if (_trace) printf("g5829:\n");
  if (t5 == 0)
    goto g5819;
  /* Here if argument ALUByteBackgroundRotateLatch */
  t2 = *(u64 *)&(processor->rotatelatch);
  goto g5817;

g5819:
  if (_trace) printf("g5819:\n");
  t5 = (t2 == ALUByteBackground_Zero) ? 1 : 0;

g5830:
  if (_trace) printf("g5830:\n");
  if (t5 == 0)
    goto g5817;
  /* Here if argument ALUByteBackgroundZero */
  t2 = zero;
  goto g5817;

g5806:
  if (_trace) printf("g5806:\n");
  t10 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t9 = (t9 * 8) + t10;
  t7 = *(s32 *)t9;
  /* Read from stack cache */
  t8 = *(s32 *)(t9 + 4);
  goto g5805;

g5808:
  if (_trace) printf("g5808:\n");

g5807:
  if (_trace) printf("g5807:\n");
  /* Cycle-number -> table offset */
  t12 = (t1 * 4);
  t12 = (t12 * 4) + ivory;
  t12 = *(u64 *)(t12 + PROCESSORSTATE_DATAREAD);
  /* TagType. */
  /* Discard the CDR code */
  t11 = t8 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t2;
  /* Adjust for a longword load */
  t11 = (t11 * 4) + t12;
  /* Get the memory action */
  t12 = *(s32 *)t11;

g5813:
  if (_trace) printf("g5813:\n");
  t10 = t12 & MemoryActionIndirect;
  if (t10 == 0)
    goto g5812;
  /* Do the indirect thing */
  t2 = (u32)t7;
  goto g5804;

g5812:
  if (_trace) printf("g5812:\n");
  t11 = t12 & MemoryActionTransform;
  if (t11 == 0)
    goto g5811;
  t8 = t8 & ~63L;
  t8 = t8 | Type_ExternalValueCellPointer;
  goto g5815;
#ifndef MINIMA

g5811:
#endif
#ifdef MINIMA

g5811:
  if (_trace) printf("g5811:\n");
  t11 = t12 & MemoryActionBinding;
  t10 = *(u64 *)&(processor->dbcmask);
  if (t11 == 0)
    goto g5810;
  t9 = t2 << 1;
  t11 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t9 = t9 & t10;
  t10 = 1;
  t10 = t10 << (ivorymemorydata & 63);
  t9 = (s32)t9 + (s32)t11;
  /* Clear sign-extension */
  t9 = (u32)t9;
  t10 = (t9 * 4) + t10;
  /* Fetch the key */
  t9 = *(s32 *)t10;
  /* Fetch value */
  t7 = *(s32 *)(t10 + 4);
  /* Compare */
  t11 = (s32)t2 - (s32)t9;
  /* Trap on miss */
  if (t11 != 0)
    goto g5814;
  /* Extract the pointer, and indirect */
  t2 = (u32)t7;
  goto g5804;

g5814:
  if (_trace) printf("g5814:\n");
  goto dbcachemisstrap;
#endif

g5810:
  /* Perform memory action */
  arg1 = t12;
  arg2 = t1;
  goto performmemoryaction;

/* end DoBlock1ReadShift */
  /* End of Halfword operand from stack instruction - DoBlock1ReadShift */
/* start DoBlock0ReadAlu */

  /* Halfword operand from stack instruction - DoBlock0ReadAlu */
  /* arg2 has the preloaded 8 bit operand. */

doblock0readalu:
  if (_trace) printf("doblock0readalu:\n");
#ifdef TRACING
#endif

DoBlock0ReadAluSP:
  if (_trace) printf("DoBlock0ReadAluSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindoblock0readalu;
#endif

DoBlock0ReadAluLP:
  if (_trace) printf("DoBlock0ReadAluLP:\n");
#ifdef TRACING
  goto begindoblock0readalu;
#endif

DoBlock0ReadAluFP:
  if (_trace) printf("DoBlock0ReadAluFP:\n");

begindoblock0readalu:
  if (_trace) printf("begindoblock0readalu:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  arg2 = (u64)&processor->bar0;
  goto blockreadalu;
#ifdef TRACING
#endif

DoBlock0ReadAluIM:
  goto doistageerror;

/* end DoBlock0ReadAlu */
  /* End of Halfword operand from stack instruction - DoBlock0ReadAlu */
/* start DoBlock3ReadAlu */

  /* Halfword operand from stack instruction - DoBlock3ReadAlu */
  /* arg2 has the preloaded 8 bit operand. */

doblock3readalu:
  if (_trace) printf("doblock3readalu:\n");
#ifdef TRACING
#endif

DoBlock3ReadAluSP:
  if (_trace) printf("DoBlock3ReadAluSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindoblock3readalu;
#endif

DoBlock3ReadAluLP:
  if (_trace) printf("DoBlock3ReadAluLP:\n");
#ifdef TRACING
  goto begindoblock3readalu;
#endif

DoBlock3ReadAluFP:
  if (_trace) printf("DoBlock3ReadAluFP:\n");

begindoblock3readalu:
  if (_trace) printf("begindoblock3readalu:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  arg2 = (u64)&processor->bar3;
  goto blockreadalu;
#ifdef TRACING
#endif

DoBlock3ReadAluIM:
  goto doistageerror;

/* end DoBlock3ReadAlu */
  /* End of Halfword operand from stack instruction - DoBlock3ReadAlu */
/* start DoBlock2ReadAlu */

  /* Halfword operand from stack instruction - DoBlock2ReadAlu */
  /* arg2 has the preloaded 8 bit operand. */

doblock2readalu:
  if (_trace) printf("doblock2readalu:\n");
#ifdef TRACING
#endif

DoBlock2ReadAluSP:
  if (_trace) printf("DoBlock2ReadAluSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindoblock2readalu;
#endif

DoBlock2ReadAluLP:
  if (_trace) printf("DoBlock2ReadAluLP:\n");
#ifdef TRACING
  goto begindoblock2readalu;
#endif

DoBlock2ReadAluFP:
  if (_trace) printf("DoBlock2ReadAluFP:\n");

begindoblock2readalu:
  if (_trace) printf("begindoblock2readalu:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  arg2 = (u64)&processor->bar2;
  goto blockreadalu;
#ifdef TRACING
#endif

DoBlock2ReadAluIM:
  goto doistageerror;

/* end DoBlock2ReadAlu */
  /* End of Halfword operand from stack instruction - DoBlock2ReadAlu */
/* start DoBlock1ReadAlu */

  /* Halfword operand from stack instruction - DoBlock1ReadAlu */
  /* arg2 has the preloaded 8 bit operand. */

doblock1readalu:
  if (_trace) printf("doblock1readalu:\n");
#ifdef TRACING
#endif

DoBlock1ReadAluSP:
  if (_trace) printf("DoBlock1ReadAluSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindoblock1readalu;
#endif

DoBlock1ReadAluLP:
  if (_trace) printf("DoBlock1ReadAluLP:\n");
#ifdef TRACING
  goto begindoblock1readalu;
#endif

DoBlock1ReadAluFP:
  if (_trace) printf("DoBlock1ReadAluFP:\n");

begindoblock1readalu:
  if (_trace) printf("begindoblock1readalu:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  arg2 = (u64)&processor->bar1;

blockreadalu:
  if (_trace) printf("blockreadalu:\n");
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Get the vma */
  t1 = *(s32 *)arg2;
  t5 = *(s32 *)arg1;
  t4 = *(s32 *)(arg1 + 4);
  t5 = (u32)t5;
  t9 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t9 = t9 & 63;
  if (t9 != 0)
    goto g5831;
  t1 = (u32)t1;
  /* Memory Read Internal */

g5833:
  t11 = t1 + ivory;
  t3 = (t11 * 4);
  t2 = LDQ_U(t11);
  /* Stack cache offset */
  t9 = t1 - arg5;
  t12 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t10 = ((u64)t9 < (u64)arg6) ? 1 : 0;
  t3 = *(s32 *)t3;
  t2 = (u8)(t2 >> ((t11&7)*8));
  if (t10 != 0)
    goto g5835;

g5834:
  t11 = zero + 240;
  t12 = t12 >> (t2 & 63);
  t11 = t11 >> (t2 & 63);
  t3 = (u32)t3;
  if (t12 & 1)
    goto g5837;

g5844:
  t9 = t2 - Type_Fixnum;
  /* Strip CDR code */
  t9 = t9 & 63;
  if (t9 != 0)
    goto g5832;
  /* Increment the address */
  t1 = t1 + 1;
  /* Store updated vma in BAR */
  *(u32 *)arg2 = t1;
  t6 = *(u64 *)&(processor->aluop);
  *(u64 *)&processor->aluoverflow = zero;
  t7 = *(u64 *)&(processor->aluandrotatecontrol);
  t1 = (t6 == ALUFunction_Boolean) ? 1 : 0;

g5905:
  if (_trace) printf("g5905:\n");
  if (t1 == 0)
    goto g5846;
  /* Here if argument ALUFunctionBoolean */
  t8 = t7 >> 10;
  /* Extract the ALU boolean function */
  t8 = t8 & 15;
  t1 = (t8 == Boole_Clear) ? 1 : 0;

g5865:
  if (_trace) printf("g5865:\n");
  if (t1 != 0)
    goto g5847;

g5848:
  if (_trace) printf("g5848:\n");
  t1 = (t8 == Boole_And) ? 1 : 0;

g5866:
  if (_trace) printf("g5866:\n");
  if (t1 == 0)
    goto g5849;
  /* Here if argument BooleAnd */
  t8 = t3 & t5;
  goto g5847;

g5849:
  if (_trace) printf("g5849:\n");
  t1 = (t8 == Boole_AndC1) ? 1 : 0;

g5867:
  if (_trace) printf("g5867:\n");
  if (t1 == 0)
    goto g5850;
  /* Here if argument BooleAndC1 */
  t8 = t5 & ~t3;
  goto g5847;

g5850:
  if (_trace) printf("g5850:\n");
  t1 = (t8 == Boole_2) ? 1 : 0;

g5868:
  if (_trace) printf("g5868:\n");
  if (t1 == 0)
    goto g5851;
  /* Here if argument Boole2 */
  t8 = t5;
  goto g5847;

g5851:
  if (_trace) printf("g5851:\n");
  t1 = (t8 == Boole_AndC2) ? 1 : 0;

g5869:
  if (_trace) printf("g5869:\n");
  if (t1 == 0)
    goto g5852;
  /* Here if argument BooleAndC2 */
  t8 = t3 & ~t5;
  goto g5847;

g5852:
  if (_trace) printf("g5852:\n");
  t1 = (t8 == Boole_1) ? 1 : 0;

g5870:
  if (_trace) printf("g5870:\n");
  if (t1 == 0)
    goto g5853;
  /* Here if argument Boole1 */
  t8 = t3;
  goto g5847;

g5853:
  if (_trace) printf("g5853:\n");
  t1 = (t8 == Boole_Xor) ? 1 : 0;

g5871:
  if (_trace) printf("g5871:\n");
  if (t1 == 0)
    goto g5854;
  /* Here if argument BooleXor */
  t8 = t3 ^ t5;
  goto g5847;

g5854:
  if (_trace) printf("g5854:\n");
  t1 = (t8 == Boole_Ior) ? 1 : 0;

g5872:
  if (_trace) printf("g5872:\n");
  if (t1 == 0)
    goto g5855;
  /* Here if argument BooleIor */
  t8 = t3 | t5;
  goto g5847;

g5855:
  if (_trace) printf("g5855:\n");
  t1 = (t8 == Boole_Nor) ? 1 : 0;

g5873:
  if (_trace) printf("g5873:\n");
  if (t1 == 0)
    goto g5856;
  /* Here if argument BooleNor */
  t8 = t3 | t5;
  t8 = ~t8;
  goto g5847;

g5856:
  if (_trace) printf("g5856:\n");
  t1 = (t8 == Boole_Equiv) ? 1 : 0;

g5874:
  if (_trace) printf("g5874:\n");
  if (t1 == 0)
    goto g5857;
  /* Here if argument BooleEquiv */
  t8 = t3 ^ t5;
  t8 = ~t8;
  goto g5847;

g5857:
  if (_trace) printf("g5857:\n");
  t1 = (t8 == Boole_C1) ? 1 : 0;

g5875:
  if (_trace) printf("g5875:\n");
  if (t1 == 0)
    goto g5858;
  /* Here if argument BooleC1 */
  t8 = ~t3;
  goto g5847;

g5858:
  if (_trace) printf("g5858:\n");
  t1 = (t8 == Boole_OrC1) ? 1 : 0;

g5876:
  if (_trace) printf("g5876:\n");
  if (t1 == 0)
    goto g5859;
  /* Here if argument BooleOrC1 */
  t8 = t5 | ~(t3);
  goto g5847;

g5859:
  if (_trace) printf("g5859:\n");
  t1 = (t8 == Boole_C2) ? 1 : 0;

g5877:
  if (_trace) printf("g5877:\n");
  if (t1 == 0)
    goto g5860;
  /* Here if argument BooleC2 */
  t8 = ~t5;
  goto g5847;

g5860:
  if (_trace) printf("g5860:\n");
  t1 = (t8 == Boole_OrC2) ? 1 : 0;

g5878:
  if (_trace) printf("g5878:\n");
  if (t1 == 0)
    goto g5861;
  /* Here if argument BooleOrC2 */
  t8 = t3 & ~t5;
  goto g5847;

g5861:
  if (_trace) printf("g5861:\n");
  t1 = (t8 == Boole_Nand) ? 1 : 0;

g5879:
  if (_trace) printf("g5879:\n");
  if (t1 == 0)
    goto g5862;
  /* Here if argument BooleNand */
  t8 = t3 & t5;
  goto g5847;

g5862:
  if (_trace) printf("g5862:\n");
  t1 = (t8 == Boole_Set) ? 1 : 0;

g5880:
  if (_trace) printf("g5880:\n");
  if (t1 == 0)
    goto g5847;
  /* Here if argument BooleSet */
  t8 = ~zero;

g5847:
  if (_trace) printf("g5847:\n");
  *(u32 *)arg1 = t8;
  goto NEXTINSTRUCTION;

g5846:
  if (_trace) printf("g5846:\n");
  t1 = (t6 == ALUFunction_Byte) ? 1 : 0;

g5906:
  if (_trace) printf("g5906:\n");
  if (t1 == 0)
    goto g5881;
  /* Here if argument ALUFunctionByte */
  /* Get rotate */
  t9 = *(u64 *)&(processor->byterotate);
  /* Get bytesize */
  t10 = *(u64 *)&(processor->bytesize);
  /* Get background */
  t1 = t7 >> 10;
  /* Extract the byte background */
  t1 = t1 & 3;
  t11 = (t1 == ALUByteBackground_Op1) ? 1 : 0;

g5888:
  if (_trace) printf("g5888:\n");
  if (t11 == 0)
    goto g5884;
  /* Here if argument ALUByteBackgroundOp1 */
  t1 = t3;

g5883:
  if (_trace) printf("g5883:\n");
  t12 = t7 >> 12;
  /* Extractthe byte rotate latch */
  t12 = t12 & 1;
  t8 = t5 << (t9 & 63);
  t11 = (u32)(t8 >> ((4&7)*8));
  t8 = (u32)t8;
  /* OP2 rotated */
  t8 = t8 | t11;
  /* Don't update rotate latch if not requested */
  if (t12 == 0)
    goto g5882;
  *(u64 *)&processor->rotatelatch = t8;

g5882:
  if (_trace) printf("g5882:\n");
  t12 = zero + -2;
  t12 = t12 << (t10 & 63);
  /* Compute mask */
  t12 = ~t12;
  /* Get byte function */
  t11 = t7 >> 13;
  t11 = t11 & 1;
  t10 = (t11 == ALUByteFunction_Dpb) ? 1 : 0;

g5893:
  if (_trace) printf("g5893:\n");
  if (t10 == 0)
    goto g5890;
  /* Here if argument ALUByteFunctionDpb */
  /* Position mask */
  t12 = t12 << (t9 & 63);

g5889:
  if (_trace) printf("g5889:\n");
  /* rotated&mask */
  t8 = t8 & t12;
  /* background&~mask */
  t1 = t1 & ~t12;
  t8 = t8 | t1;
  *(u32 *)arg1 = t8;
  goto NEXTINSTRUCTION;

g5881:
  if (_trace) printf("g5881:\n");
  t1 = (t6 == ALUFunction_Adder) ? 1 : 0;

g5907:
  if (_trace) printf("g5907:\n");
  if (t1 == 0)
    goto g5894;
  /* Here if argument ALUFunctionAdder */
  t10 = t7 >> 11;
  /* Extract the op2 */
  t10 = t10 & 3;
  t9 = t7 >> 10;
  /* Extract the adder carry in */
  t9 = t9 & 1;
  t11 = (t10 == ALUAdderOp2_Op2) ? 1 : 0;

g5902:
  if (_trace) printf("g5902:\n");
  if (t11 == 0)
    goto g5897;
  /* Here if argument ALUAdderOp2Op2 */
  t1 = t5;

g5896:
  if (_trace) printf("g5896:\n");
  t8 = t3 + t1;
  t8 = t8 + t9;
  /* Sign bit */
  t10 = t8 >> 31;
  /* Next bit */
  t11 = t8 >> 32;
  /* Low bit is now overflow indicator */
  t10 = t10 ^ t11;
  /* Get the load-carry-in bit */
  t11 = t7 >> 24;
  *(u64 *)&processor->aluoverflow = t10;
  if ((t11 & 1) == 0)
    goto g5895;
  /* Get the carry */
  t10 = (u32)(t8 >> ((4&7)*8));
  t11 = zero + 1024;
  t7 = t7 & ~t11;
  t11 = t10 & 1;
  t11 = t11 << 10;
  /* Set the adder carry in */
  t7 = t7 | t11;
  *(u64 *)&processor->aluandrotatecontrol = t7;

g5895:
  if (_trace) printf("g5895:\n");
  t10 = ((s64)t3 < (s64)t1) ? 1 : 0;
  *(u64 *)&processor->aluborrow = t10;
  t3 = (s32)t3;
  t5 = (s32)t5;
  t10 = ((s64)t3 < (s64)t1) ? 1 : 0;
  *(u64 *)&processor->alulessthan = t10;
  *(u32 *)arg1 = t8;
  goto NEXTINSTRUCTION;

g5894:
  if (_trace) printf("g5894:\n");
  t1 = (t6 == ALUFunction_MultiplyDivide) ? 1 : 0;

g5908:
  if (_trace) printf("g5908:\n");
  if (t1 == 0)
    goto g5845;
  /* Here if argument ALUFunctionMultiplyDivide */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;
  *(u32 *)arg1 = t8;
  goto NEXTINSTRUCTION;

g5845:
  if (_trace) printf("g5845:\n");

g5831:
  if (_trace) printf("g5831:\n");
  /* Convert stack cache address to VMA */
  t9 = *(u64 *)&(processor->stackcachedata);
  /* stack cache base relative offset */
  t9 = arg1 - t9;
  /* convert byte address to word address */
  t9 = t9 >> 3;
  /* reconstruct VMA */
  t1 = t9 + arg5;
  arg5 = t1;
  arg2 = 23;
  goto illegaloperand;

g5832:
  if (_trace) printf("g5832:\n");
  arg5 = t1;
  arg2 = 23;
  goto illegaloperand;

g5897:
  if (_trace) printf("g5897:\n");
  t11 = (t10 == ALUAdderOp2_Zero) ? 1 : 0;

g5909:
  if (_trace) printf("g5909:\n");
  if (t11 == 0)
    goto g5898;
  /* Here if argument ALUAdderOp2Zero */
  t1 = zero;
  goto g5896;

g5898:
  if (_trace) printf("g5898:\n");
  t11 = (t10 == ALUAdderOp2_Invert) ? 1 : 0;

g5910:
  if (_trace) printf("g5910:\n");
  if (t11 == 0)
    goto g5899;
  /* Here if argument ALUAdderOp2Invert */
  t1 = (s32)t5;
  t1 = zero - t1;
  t1 = (u32)t1;
  goto g5896;

g5899:
  if (_trace) printf("g5899:\n");
  t11 = (t10 == ALUAdderOp2_MinusOne) ? 1 : 0;

g5911:
  if (_trace) printf("g5911:\n");
  if (t11 == 0)
    goto g5896;
  /* Here if argument ALUAdderOp2MinusOne */
  t1 = ~zero;
  t1 = (u32)t1;
  goto g5896;

g5890:
  if (_trace) printf("g5890:\n");
  t10 = (t11 == ALUByteFunction_Ldb) ? 1 : 0;

g5912:
  if (_trace) printf("g5912:\n");
  if (t10 != 0)
    goto g5889;
  goto g5889;

g5884:
  if (_trace) printf("g5884:\n");
  t11 = (t1 == ALUByteBackground_RotateLatch) ? 1 : 0;

g5913:
  if (_trace) printf("g5913:\n");
  if (t11 == 0)
    goto g5885;
  /* Here if argument ALUByteBackgroundRotateLatch */
  t1 = *(u64 *)&(processor->rotatelatch);
  goto g5883;

g5885:
  if (_trace) printf("g5885:\n");
  t11 = (t1 == ALUByteBackground_Zero) ? 1 : 0;

g5914:
  if (_trace) printf("g5914:\n");
  if (t11 == 0)
    goto g5883;
  /* Here if argument ALUByteBackgroundZero */
  t1 = zero;
  goto g5883;

g5835:
  if (_trace) printf("g5835:\n");
  t10 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t9 = (t9 * 8) + t10;
  t3 = *(s32 *)t9;
  /* Read from stack cache */
  t2 = *(s32 *)(t9 + 4);
  goto g5834;

g5837:
  if (_trace) printf("g5837:\n");
  if ((t11 & 1) == 0)
    goto g5836;
  /* Do the indirect thing */
  t1 = (u32)t3;
  goto g5833;

g5836:
  if (_trace) printf("g5836:\n");
  /* Load the memory action table for cycle */
  t12 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t11 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t11 = (t11 * 4) + t12;
  /* Get the memory action */
  t12 = *(s32 *)t11;

g5841:
  if (_trace) printf("g5841:\n");
  t11 = t12 & MemoryActionTransform;
  if (t11 == 0)
    goto g5840;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto g5844;
#ifndef MINIMA

g5840:
#endif
#ifdef MINIMA

g5840:
  if (_trace) printf("g5840:\n");
  t11 = t12 & MemoryActionBinding;
  t10 = *(u64 *)&(processor->dbcmask);
  if (t11 == 0)
    goto g5839;
  t9 = t1 << 1;
  t11 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t9 = t9 & t10;
  t10 = 1;
  t10 = t10 << (ivorymemorydata & 63);
  t9 = (s32)t9 + (s32)t11;
  /* Clear sign-extension */
  t9 = (u32)t9;
  t10 = (t9 * 4) + t10;
  /* Fetch the key */
  t9 = *(s32 *)t10;
  /* Fetch value */
  t3 = *(s32 *)(t10 + 4);
  /* Compare */
  t11 = (s32)t1 - (s32)t9;
  /* Trap on miss */
  if (t11 != 0)
    goto g5843;
  /* Extract the pointer, and indirect */
  t1 = (u32)t3;
  goto g5833;

g5843:
  if (_trace) printf("g5843:\n");
  goto dbcachemisstrap;
#endif

g5839:
  /* Perform memory action */
  arg1 = t12;
  arg2 = 0;
  goto performmemoryaction;
#ifdef TRACING
#endif

DoBlock1ReadAluIM:
  goto doistageerror;

/* end DoBlock1ReadAlu */
  /* End of Halfword operand from stack instruction - DoBlock1ReadAlu */
/* start DoBlock0ReadTest */

  /* Halfword 10 bit immediate instruction - DoBlock0ReadTest */

doblock0readtest:
  if (_trace) printf("doblock0readtest:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBlock0ReadTestIM:
  if (_trace) printf("DoBlock0ReadTestIM:\n");

DoBlock0ReadTestSP:
  if (_trace) printf("DoBlock0ReadTestSP:\n");

DoBlock0ReadTestLP:
  if (_trace) printf("DoBlock0ReadTestLP:\n");

DoBlock0ReadTestFP:
  if (_trace) printf("DoBlock0ReadTestFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar0;
  goto blockreadtest;

/* end DoBlock0ReadTest */
  /* End of Halfword operand from stack instruction - DoBlock0ReadTest */
/* start DoBlock3ReadTest */

  /* Halfword 10 bit immediate instruction - DoBlock3ReadTest */

doblock3readtest:
  if (_trace) printf("doblock3readtest:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBlock3ReadTestIM:
  if (_trace) printf("DoBlock3ReadTestIM:\n");

DoBlock3ReadTestSP:
  if (_trace) printf("DoBlock3ReadTestSP:\n");

DoBlock3ReadTestLP:
  if (_trace) printf("DoBlock3ReadTestLP:\n");

DoBlock3ReadTestFP:
  if (_trace) printf("DoBlock3ReadTestFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar3;
  goto blockreadtest;

/* end DoBlock3ReadTest */
  /* End of Halfword operand from stack instruction - DoBlock3ReadTest */
/* start DoBlock2ReadTest */

  /* Halfword 10 bit immediate instruction - DoBlock2ReadTest */

doblock2readtest:
  if (_trace) printf("doblock2readtest:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBlock2ReadTestIM:
  if (_trace) printf("DoBlock2ReadTestIM:\n");

DoBlock2ReadTestSP:
  if (_trace) printf("DoBlock2ReadTestSP:\n");

DoBlock2ReadTestLP:
  if (_trace) printf("DoBlock2ReadTestLP:\n");

DoBlock2ReadTestFP:
  if (_trace) printf("DoBlock2ReadTestFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar2;
  goto blockreadtest;

/* end DoBlock2ReadTest */
  /* End of Halfword operand from stack instruction - DoBlock2ReadTest */
/* start DoBlock1ReadTest */

  /* Halfword 10 bit immediate instruction - DoBlock1ReadTest */

doblock1readtest:
  if (_trace) printf("doblock1readtest:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBlock1ReadTestIM:
  if (_trace) printf("DoBlock1ReadTestIM:\n");

DoBlock1ReadTestSP:
  if (_trace) printf("DoBlock1ReadTestSP:\n");

DoBlock1ReadTestLP:
  if (_trace) printf("DoBlock1ReadTestLP:\n");

DoBlock1ReadTestFP:
  if (_trace) printf("DoBlock1ReadTestFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar1;

blockreadtest:
  if (_trace) printf("blockreadtest:\n");
  /* Get the vma */
  arg3 = *(s32 *)arg2;
  /* cycle type */
  t1 = arg1 >> 6;
  t5 = *(s32 *)iSP;
  t4 = *(s32 *)(iSP + 4);
  t5 = (u32)t5;
  arg3 = (u32)arg3;
  /* Memory Read Internal */

g5921:
  /* Base of stack cache */
  t9 = *(u64 *)&(processor->stackcachebasevma);
  t11 = arg3 + ivory;
  t10 = *(s32 *)&processor->scovlimit;
  /* Cycle-number -> table offset */
  t12 = (t1 * 4);
  t2 = LDQ_U(t11);
  t12 = (t12 * 4) + ivory;
  t3 = (t11 * 4);
  /* Stack cache offset */
  t9 = arg3 - t9;
  t12 = *(u64 *)(t12 + PROCESSORSTATE_DATAREAD_MASK);
  /* In range? */
  t10 = ((u64)t9 < (u64)t10) ? 1 : 0;
  t3 = *(s32 *)t3;
  t2 = (u8)(t2 >> ((t11&7)*8));
  if (t10 != 0)
    goto g5923;

g5922:
  t12 = t12 >> (t2 & 63);
  t3 = (u32)t3;
  if (t12 & 1)
    goto g5925;

g5932:
  /* =fixnum onlyp */
  t1 = arg1 & 32;
  /* J. if we don't have to test for fixnump. */
  if (t1 == 0)
    goto g5915;
  t9 = t2 - Type_Fixnum;
  /* Strip CDR code */
  t9 = t9 & 63;
  if (t9 != 0)
    goto g5918;
  t9 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t9 = t9 & 63;
  if (t9 != 0)
    goto g5919;

g5915:
  if (_trace) printf("g5915:\n");
  /* =cdr-code-nextp */
  t1 = arg1 & 16;
  /* J. if we don't have to clear CDR codes. */
  if (t1 == 0)
    goto g5917;
  /* TagType. */
  t2 = t2 & 63;

g5917:
  if (_trace) printf("g5917:\n");
  t6 = *(u64 *)&(processor->aluop);
  *(u64 *)&processor->aluoverflow = zero;
  t7 = *(u64 *)&(processor->aluandrotatecontrol);
  t1 = (t6 == ALUFunction_Boolean) ? 1 : 0;

g5993:
  if (_trace) printf("g5993:\n");
  if (t1 == 0)
    goto g5934;
  /* Here if argument ALUFunctionBoolean */
  t8 = t7 >> 10;
  /* Extract the ALU boolean function */
  t8 = t8 & 15;
  t1 = (t8 == Boole_Clear) ? 1 : 0;

g5953:
  if (_trace) printf("g5953:\n");
  if (t1 != 0)
    goto g5935;

g5936:
  if (_trace) printf("g5936:\n");
  t1 = (t8 == Boole_And) ? 1 : 0;

g5954:
  if (_trace) printf("g5954:\n");
  if (t1 == 0)
    goto g5937;
  /* Here if argument BooleAnd */
  t8 = t3 & t5;
  goto g5935;

g5937:
  if (_trace) printf("g5937:\n");
  t1 = (t8 == Boole_AndC1) ? 1 : 0;

g5955:
  if (_trace) printf("g5955:\n");
  if (t1 == 0)
    goto g5938;
  /* Here if argument BooleAndC1 */
  t8 = t5 & ~t3;
  goto g5935;

g5938:
  if (_trace) printf("g5938:\n");
  t1 = (t8 == Boole_2) ? 1 : 0;

g5956:
  if (_trace) printf("g5956:\n");
  if (t1 == 0)
    goto g5939;
  /* Here if argument Boole2 */
  t8 = t5;
  goto g5935;

g5939:
  if (_trace) printf("g5939:\n");
  t1 = (t8 == Boole_AndC2) ? 1 : 0;

g5957:
  if (_trace) printf("g5957:\n");
  if (t1 == 0)
    goto g5940;
  /* Here if argument BooleAndC2 */
  t8 = t3 & ~t5;
  goto g5935;

g5940:
  if (_trace) printf("g5940:\n");
  t1 = (t8 == Boole_1) ? 1 : 0;

g5958:
  if (_trace) printf("g5958:\n");
  if (t1 == 0)
    goto g5941;
  /* Here if argument Boole1 */
  t8 = t3;
  goto g5935;

g5941:
  if (_trace) printf("g5941:\n");
  t1 = (t8 == Boole_Xor) ? 1 : 0;

g5959:
  if (_trace) printf("g5959:\n");
  if (t1 == 0)
    goto g5942;
  /* Here if argument BooleXor */
  t8 = t3 ^ t5;
  goto g5935;

g5942:
  if (_trace) printf("g5942:\n");
  t1 = (t8 == Boole_Ior) ? 1 : 0;

g5960:
  if (_trace) printf("g5960:\n");
  if (t1 == 0)
    goto g5943;
  /* Here if argument BooleIor */
  t8 = t3 | t5;
  goto g5935;

g5943:
  if (_trace) printf("g5943:\n");
  t1 = (t8 == Boole_Nor) ? 1 : 0;

g5961:
  if (_trace) printf("g5961:\n");
  if (t1 == 0)
    goto g5944;
  /* Here if argument BooleNor */
  t8 = t3 | t5;
  t8 = ~t8;
  goto g5935;

g5944:
  if (_trace) printf("g5944:\n");
  t1 = (t8 == Boole_Equiv) ? 1 : 0;

g5962:
  if (_trace) printf("g5962:\n");
  if (t1 == 0)
    goto g5945;
  /* Here if argument BooleEquiv */
  t8 = t3 ^ t5;
  t8 = ~t8;
  goto g5935;

g5945:
  if (_trace) printf("g5945:\n");
  t1 = (t8 == Boole_C1) ? 1 : 0;

g5963:
  if (_trace) printf("g5963:\n");
  if (t1 == 0)
    goto g5946;
  /* Here if argument BooleC1 */
  t8 = ~t3;
  goto g5935;

g5946:
  if (_trace) printf("g5946:\n");
  t1 = (t8 == Boole_OrC1) ? 1 : 0;

g5964:
  if (_trace) printf("g5964:\n");
  if (t1 == 0)
    goto g5947;
  /* Here if argument BooleOrC1 */
  t8 = t5 | ~(t3);
  goto g5935;

g5947:
  if (_trace) printf("g5947:\n");
  t1 = (t8 == Boole_C2) ? 1 : 0;

g5965:
  if (_trace) printf("g5965:\n");
  if (t1 == 0)
    goto g5948;
  /* Here if argument BooleC2 */
  t8 = ~t5;
  goto g5935;

g5948:
  if (_trace) printf("g5948:\n");
  t1 = (t8 == Boole_OrC2) ? 1 : 0;

g5966:
  if (_trace) printf("g5966:\n");
  if (t1 == 0)
    goto g5949;
  /* Here if argument BooleOrC2 */
  t8 = t3 & ~t5;
  goto g5935;

g5949:
  if (_trace) printf("g5949:\n");
  t1 = (t8 == Boole_Nand) ? 1 : 0;

g5967:
  if (_trace) printf("g5967:\n");
  if (t1 == 0)
    goto g5950;
  /* Here if argument BooleNand */
  t8 = t3 & t5;
  goto g5935;

g5950:
  if (_trace) printf("g5950:\n");
  t1 = (t8 == Boole_Set) ? 1 : 0;

g5968:
  if (_trace) printf("g5968:\n");
  if (t1 == 0)
    goto g5935;
  /* Here if argument BooleSet */
  t8 = ~zero;

g5935:
  if (_trace) printf("g5935:\n");

g5933:
  if (_trace) printf("g5933:\n");
  t1 = t7 >> 16;
  /* Extract ALU condition */
  t1 = t1 & 31;
  t10 = *(u64 *)&(processor->aluoverflow);
  t11 = *(u64 *)&(processor->aluborrow);
  t12 = *(u64 *)&(processor->alulessthan);
  t9 = (t1 == ALUCondition_SignedLessThanOrEqual) ? 1 : 0;

g6025:
  if (_trace) printf("g6025:\n");
  if (t9 == 0)
    goto g5998;
  /* Here if argument ALUConditionSignedLessThanOrEqual */
  if (t12 != 0)
    goto g5994;
  if (t8 == 0)
    goto g5994;

g5997:
  if (_trace) printf("g5997:\n");

g5995:
  if (_trace) printf("g5995:\n");
  t1 = zero;
  goto g5996;

g5994:
  if (_trace) printf("g5994:\n");
  t1 = 1;

g5996:
  if (_trace) printf("g5996:\n");
  t9 = t7 >> 21;
  /* Extract the condition sense */
  t9 = t9 & 1;
  t1 = t1 ^ t9;
  if (t1 != 0)
    goto g5920;
  /* =no-incrementp */
  t1 = arg1 & 4;
  /* J. if we don't have to increment the address. */
  if (t1 != 0)
    goto g5916;
  /* Increment the address */
  arg3 = arg3 + 1;

g5916:
  if (_trace) printf("g5916:\n");
  /* Store updated vma in BAR */
  *(u32 *)arg2 = arg3;
  goto NEXTINSTRUCTION;

g5920:
  if (_trace) printf("g5920:\n");
  t10 = *(s32 *)(iSP + -8);
  t9 = *(s32 *)(iSP + -4);
  t10 = (u32)t10;
  t10 = t10 << 1;
  iPC = t9 & 1;
  iPC = iPC + t10;
  goto interpretinstructionforjump;

g5919:
  if (_trace) printf("g5919:\n");
  /* Convert stack cache address to VMA */
  t9 = *(u64 *)&(processor->stackcachedata);
  arg3 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t9 = iSP - t9;
  /* convert byte address to word address */
  t9 = t9 >> 3;
  /* reconstruct VMA */
  arg3 = t9 + arg3;
  arg5 = arg3;
  arg2 = 23;
  goto illegaloperand;

g5918:
  if (_trace) printf("g5918:\n");
  arg5 = arg3;
  arg2 = 23;
  goto illegaloperand;

g5998:
  if (_trace) printf("g5998:\n");
  t9 = (t1 == ALUCondition_SignedLessThan) ? 1 : 0;

g6026:
  if (_trace) printf("g6026:\n");
  if (t9 == 0)
    goto g5999;
  /* Here if argument ALUConditionSignedLessThan */
  if (t12 != 0)
    goto g5994;
  goto g5997;

g5999:
  if (_trace) printf("g5999:\n");
  t9 = (t1 == ALUCondition_Negative) ? 1 : 0;

g6027:
  if (_trace) printf("g6027:\n");
  if (t9 == 0)
    goto g6000;
  /* Here if argument ALUConditionNegative */
  if ((s64)t8 < 0)
    goto g5994;
  goto g5997;

g6000:
  if (_trace) printf("g6000:\n");
  t9 = (t1 == ALUCondition_SignedOverflow) ? 1 : 0;

g6028:
  if (_trace) printf("g6028:\n");
  if (t9 == 0)
    goto g6001;
  /* Here if argument ALUConditionSignedOverflow */
  if (t10 != 0)
    goto g5994;
  goto g5997;

g6001:
  if (_trace) printf("g6001:\n");
  t9 = (t1 == ALUCondition_UnsignedLessThanOrEqual) ? 1 : 0;

g6029:
  if (_trace) printf("g6029:\n");
  if (t9 == 0)
    goto g6002;
  /* Here if argument ALUConditionUnsignedLessThanOrEqual */
  if (t11 != 0)
    goto g5994;
  if (t8 == 0)
    goto g5994;
  goto g5997;

g6002:
  if (_trace) printf("g6002:\n");
  t9 = (t1 == ALUCondition_UnsignedLessThan) ? 1 : 0;

g6030:
  if (_trace) printf("g6030:\n");
  if (t9 == 0)
    goto g6003;
  /* Here if argument ALUConditionUnsignedLessThan */
  if (t11 != 0)
    goto g5994;
  goto g5997;

g6003:
  if (_trace) printf("g6003:\n");
  t9 = (t1 == ALUCondition_Zero) ? 1 : 0;

g6031:
  if (_trace) printf("g6031:\n");
  if (t9 == 0)
    goto g6004;
  /* Here if argument ALUConditionZero */
  if (t8 == 0)
    goto g5994;
  goto g5997;

g6004:
  if (_trace) printf("g6004:\n");
  t9 = (t1 == ALUCondition_High25Zero) ? 1 : 0;

g6032:
  if (_trace) printf("g6032:\n");
  if (t9 == 0)
    goto g6005;
  /* Here if argument ALUConditionHigh25Zero */
  t1 = t8 >> 7;
  if (t1 == 0)
    goto g5994;
  goto g5997;

g6005:
  if (_trace) printf("g6005:\n");
  t9 = (t1 == ALUCondition_Eq) ? 1 : 0;

g6033:
  if (_trace) printf("g6033:\n");
  if (t9 == 0)
    goto g6006;
  /* Here if argument ALUConditionEq */
  if (t8 != 0)
    goto g5995;
  t9 = t2 ^ t4;
  /* TagType. */
  t9 = t9 & 63;
  if (t9 == 0)
    goto g5994;
  goto g5997;

g6006:
  if (_trace) printf("g6006:\n");
  t9 = (t1 == ALUCondition_Op1Ephemeralp) ? 1 : 0;

g6034:
  if (_trace) printf("g6034:\n");
  if (t9 == 0)
    goto g6007;
  /* Here if argument ALUConditionOp1Ephemeralp */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g6007:
  if (_trace) printf("g6007:\n");
  t9 = (t1 == ALUCondition_ResultTypeNil) ? 1 : 0;

g6035:
  if (_trace) printf("g6035:\n");
  if (t9 == 0)
    goto g6008;
  /* Here if argument ALUConditionResultTypeNil */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g6008:
  if (_trace) printf("g6008:\n");
  t9 = (t1 == ALUCondition_Op2Fixnum) ? 1 : 0;

g6036:
  if (_trace) printf("g6036:\n");
  if (t9 == 0)
    goto g6009;
  /* Here if argument ALUConditionOp2Fixnum */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g6009:
  if (_trace) printf("g6009:\n");
  t9 = (t1 == ALUCondition_False) ? 1 : 0;

g6037:
  if (_trace) printf("g6037:\n");
  if (t9 == 0)
    goto g6010;
  /* Here if argument ALUConditionFalse */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g6010:
  if (_trace) printf("g6010:\n");
  t9 = (t1 == ALUCondition_ResultCdrLow) ? 1 : 0;

g6038:
  if (_trace) printf("g6038:\n");
  if (t9 == 0)
    goto g6011;
  /* Here if argument ALUConditionResultCdrLow */
  /* TagCdr. */
  t9 = t2 >> 6;
  t1 = t9 & 1;
  goto g5996;

g6011:
  if (_trace) printf("g6011:\n");
  t9 = (t1 == ALUCondition_CleanupBitsSet) ? 1 : 0;

g6039:
  if (_trace) printf("g6039:\n");
  if (t9 == 0)
    goto g6012;
  /* Here if argument ALUConditionCleanupBitsSet */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g6012:
  if (_trace) printf("g6012:\n");
  t9 = (t1 == ALUCondition_AddressInStackCache) ? 1 : 0;

g6040:
  if (_trace) printf("g6040:\n");
  if (t9 == 0)
    goto g6013;
  /* Here if argument ALUConditionAddressInStackCache */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g6013:
  if (_trace) printf("g6013:\n");
  t9 = (t1 == ALUCondition_ExtraStackMode) ? 1 : 0;

g6041:
  if (_trace) printf("g6041:\n");
  if (t9 == 0)
    goto g6014;
  /* Here if argument ALUConditionExtraStackMode */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g6014:
  if (_trace) printf("g6014:\n");
  t9 = (t1 == ALUCondition_FepMode) ? 1 : 0;

g6042:
  if (_trace) printf("g6042:\n");
  if (t9 == 0)
    goto g6015;
  /* Here if argument ALUConditionFepMode */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g6015:
  if (_trace) printf("g6015:\n");
  t9 = (t1 == ALUCondition_FpCoprocessorPresent) ? 1 : 0;

g6043:
  if (_trace) printf("g6043:\n");
  if (t9 == 0)
    goto g6016;
  /* Here if argument ALUConditionFpCoprocessorPresent */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g6016:
  if (_trace) printf("g6016:\n");
  t9 = (t1 == ALUCondition_Op1Oldspacep) ? 1 : 0;

g6044:
  if (_trace) printf("g6044:\n");
  if (t9 == 0)
    goto g6017;
  /* Here if argument ALUConditionOp1Oldspacep */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g6017:
  if (_trace) printf("g6017:\n");
  t9 = (t1 == ALUCondition_PendingSequenceBreakEnabled) ? 1 : 0;

g6045:
  if (_trace) printf("g6045:\n");
  if (t9 == 0)
    goto g6018;
  /* Here if argument ALUConditionPendingSequenceBreakEnabled */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g6018:
  if (_trace) printf("g6018:\n");
  t9 = (t1 == ALUCondition_Op1TypeAcceptable) ? 1 : 0;

g6046:
  if (_trace) printf("g6046:\n");
  if (t9 == 0)
    goto g6019;
  /* Here if argument ALUConditionOp1TypeAcceptable */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g6019:
  if (_trace) printf("g6019:\n");
  t9 = (t1 == ALUCondition_Op1TypeCondition) ? 1 : 0;

g6047:
  if (_trace) printf("g6047:\n");
  if (t9 == 0)
    goto g6020;
  /* Here if argument ALUConditionOp1TypeCondition */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g6020:
  if (_trace) printf("g6020:\n");
  t9 = (t1 == ALUCondition_StackCacheOverflow) ? 1 : 0;

g6048:
  if (_trace) printf("g6048:\n");
  if (t9 == 0)
    goto g6021;
  /* Here if argument ALUConditionStackCacheOverflow */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g6021:
  if (_trace) printf("g6021:\n");
  t9 = (t1 == ALUCondition_OrLogicVariable) ? 1 : 0;

g6049:
  if (_trace) printf("g6049:\n");
  if (t9 == 0)
    goto g6022;
  /* Here if argument ALUConditionOrLogicVariable */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g6022:
  if (_trace) printf("g6022:\n");
  /* Here for all other cases */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g5934:
  if (_trace) printf("g5934:\n");
  t1 = (t6 == ALUFunction_Byte) ? 1 : 0;

g6050:
  if (_trace) printf("g6050:\n");
  if (t1 == 0)
    goto g5969;
  /* Here if argument ALUFunctionByte */
  /* Get rotate */
  t9 = *(u64 *)&(processor->byterotate);
  /* Get bytesize */
  t10 = *(u64 *)&(processor->bytesize);
  /* Get background */
  t1 = t7 >> 10;
  /* Extract the byte background */
  t1 = t1 & 3;
  t11 = (t1 == ALUByteBackground_Op1) ? 1 : 0;

g5976:
  if (_trace) printf("g5976:\n");
  if (t11 == 0)
    goto g5972;
  /* Here if argument ALUByteBackgroundOp1 */
  t1 = t3;

g5971:
  if (_trace) printf("g5971:\n");
  t12 = t7 >> 12;
  /* Extractthe byte rotate latch */
  t12 = t12 & 1;
  t8 = t5 << (t9 & 63);
  t11 = (u32)(t8 >> ((4&7)*8));
  t8 = (u32)t8;
  /* OP2 rotated */
  t8 = t8 | t11;
  /* Don't update rotate latch if not requested */
  if (t12 == 0)
    goto g5970;
  *(u64 *)&processor->rotatelatch = t8;

g5970:
  if (_trace) printf("g5970:\n");
  t12 = zero + -2;
  t12 = t12 << (t10 & 63);
  /* Compute mask */
  t12 = ~t12;
  /* Get byte function */
  t11 = t7 >> 13;
  t11 = t11 & 1;
  t10 = (t11 == ALUByteFunction_Dpb) ? 1 : 0;

g5981:
  if (_trace) printf("g5981:\n");
  if (t10 == 0)
    goto g5978;
  /* Here if argument ALUByteFunctionDpb */
  /* Position mask */
  t12 = t12 << (t9 & 63);

g5977:
  if (_trace) printf("g5977:\n");
  /* rotated&mask */
  t8 = t8 & t12;
  /* background&~mask */
  t1 = t1 & ~t12;
  t8 = t8 | t1;
  goto g5933;

g5969:
  if (_trace) printf("g5969:\n");
  t1 = (t6 == ALUFunction_Adder) ? 1 : 0;

g6051:
  if (_trace) printf("g6051:\n");
  if (t1 == 0)
    goto g5982;
  /* Here if argument ALUFunctionAdder */
  t10 = t7 >> 11;
  /* Extract the op2 */
  t10 = t10 & 3;
  t9 = t7 >> 10;
  /* Extract the adder carry in */
  t9 = t9 & 1;
  t11 = (t10 == ALUAdderOp2_Op2) ? 1 : 0;

g5990:
  if (_trace) printf("g5990:\n");
  if (t11 == 0)
    goto g5985;
  /* Here if argument ALUAdderOp2Op2 */
  t1 = t5;

g5984:
  if (_trace) printf("g5984:\n");
  t8 = t3 + t1;
  t8 = t8 + t9;
  /* Sign bit */
  t10 = t8 >> 31;
  /* Next bit */
  t11 = t8 >> 32;
  /* Low bit is now overflow indicator */
  t10 = t10 ^ t11;
  /* Get the load-carry-in bit */
  t11 = t7 >> 24;
  *(u64 *)&processor->aluoverflow = t10;
  if ((t11 & 1) == 0)
    goto g5983;
  /* Get the carry */
  t10 = (u32)(t8 >> ((4&7)*8));
  t11 = zero + 1024;
  t7 = t7 & ~t11;
  t11 = t10 & 1;
  t11 = t11 << 10;
  /* Set the adder carry in */
  t7 = t7 | t11;
  *(u64 *)&processor->aluandrotatecontrol = t7;

g5983:
  if (_trace) printf("g5983:\n");
  t10 = ((s64)t3 < (s64)t1) ? 1 : 0;
  *(u64 *)&processor->aluborrow = t10;
  t3 = (s32)t3;
  t5 = (s32)t5;
  t10 = ((s64)t3 < (s64)t1) ? 1 : 0;
  *(u64 *)&processor->alulessthan = t10;
  goto g5933;

g5982:
  if (_trace) printf("g5982:\n");
  t1 = (t6 == ALUFunction_MultiplyDivide) ? 1 : 0;

g6052:
  if (_trace) printf("g6052:\n");
  if (t1 == 0)
    goto g5933;
  /* Here if argument ALUFunctionMultiplyDivide */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

g5985:
  if (_trace) printf("g5985:\n");
  t11 = (t10 == ALUAdderOp2_Zero) ? 1 : 0;

g6053:
  if (_trace) printf("g6053:\n");
  if (t11 == 0)
    goto g5986;
  /* Here if argument ALUAdderOp2Zero */
  t1 = zero;
  goto g5984;

g5986:
  if (_trace) printf("g5986:\n");
  t11 = (t10 == ALUAdderOp2_Invert) ? 1 : 0;

g6054:
  if (_trace) printf("g6054:\n");
  if (t11 == 0)
    goto g5987;
  /* Here if argument ALUAdderOp2Invert */
  t1 = (s32)t5;
  t1 = zero - t1;
  t1 = (u32)t1;
  goto g5984;

g5987:
  if (_trace) printf("g5987:\n");
  t11 = (t10 == ALUAdderOp2_MinusOne) ? 1 : 0;

g6055:
  if (_trace) printf("g6055:\n");
  if (t11 == 0)
    goto g5984;
  /* Here if argument ALUAdderOp2MinusOne */
  t1 = ~zero;
  t1 = (u32)t1;
  goto g5984;

g5978:
  if (_trace) printf("g5978:\n");
  t10 = (t11 == ALUByteFunction_Ldb) ? 1 : 0;

g6056:
  if (_trace) printf("g6056:\n");
  if (t10 != 0)
    goto g5977;
  goto g5977;

g5972:
  if (_trace) printf("g5972:\n");
  t11 = (t1 == ALUByteBackground_RotateLatch) ? 1 : 0;

g6057:
  if (_trace) printf("g6057:\n");
  if (t11 == 0)
    goto g5973;
  /* Here if argument ALUByteBackgroundRotateLatch */
  t1 = *(u64 *)&(processor->rotatelatch);
  goto g5971;

g5973:
  if (_trace) printf("g5973:\n");
  t11 = (t1 == ALUByteBackground_Zero) ? 1 : 0;

g6058:
  if (_trace) printf("g6058:\n");
  if (t11 == 0)
    goto g5971;
  /* Here if argument ALUByteBackgroundZero */
  t1 = zero;
  goto g5971;

g5923:
  if (_trace) printf("g5923:\n");
  t10 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t9 = (t9 * 8) + t10;
  t3 = *(s32 *)t9;
  /* Read from stack cache */
  t2 = *(s32 *)(t9 + 4);
  goto g5922;

g5925:
  if (_trace) printf("g5925:\n");

g5924:
  if (_trace) printf("g5924:\n");
  /* Cycle-number -> table offset */
  t12 = (t1 * 4);
  t12 = (t12 * 4) + ivory;
  t12 = *(u64 *)(t12 + PROCESSORSTATE_DATAREAD);
  /* TagType. */
  /* Discard the CDR code */
  t11 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg3;
  /* Adjust for a longword load */
  t11 = (t11 * 4) + t12;
  /* Get the memory action */
  t12 = *(s32 *)t11;

g5930:
  if (_trace) printf("g5930:\n");
  t10 = t12 & MemoryActionIndirect;
  if (t10 == 0)
    goto g5929;
  /* Do the indirect thing */
  arg3 = (u32)t3;
  goto g5921;

g5929:
  if (_trace) printf("g5929:\n");
  t11 = t12 & MemoryActionTransform;
  if (t11 == 0)
    goto g5928;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto g5932;
#ifndef MINIMA

g5928:
#endif
#ifdef MINIMA

g5928:
  if (_trace) printf("g5928:\n");
  t11 = t12 & MemoryActionBinding;
  t10 = *(u64 *)&(processor->dbcmask);
  if (t11 == 0)
    goto g5927;
  t9 = arg3 << 1;
  t11 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t9 = t9 & t10;
  t10 = 1;
  t10 = t10 << (ivorymemorydata & 63);
  t9 = (s32)t9 + (s32)t11;
  /* Clear sign-extension */
  t9 = (u32)t9;
  t10 = (t9 * 4) + t10;
  /* Fetch the key */
  t9 = *(s32 *)t10;
  /* Fetch value */
  t3 = *(s32 *)(t10 + 4);
  /* Compare */
  t11 = (s32)arg3 - (s32)t9;
  /* Trap on miss */
  if (t11 != 0)
    goto g5931;
  /* Extract the pointer, and indirect */
  arg3 = (u32)t3;
  goto g5921;

g5931:
  if (_trace) printf("g5931:\n");
  goto dbcachemisstrap;
#endif

g5927:
  /* Perform memory action */
  arg1 = t12;
  arg2 = t1;
  goto performmemoryaction;

/* end DoBlock1ReadTest */
  /* End of Halfword operand from stack instruction - DoBlock1ReadTest */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunblok.as */
