/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunfext.as
 ************************************************************************/

  /* Field extraction instruction. */
/* start DoCharLdb */

  /* Field Extraction instruction - DoCharLdb */

docharldb:
  if (_trace) printf("docharldb:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoCharLdbIM:
  if (_trace) printf("DoCharLdbIM:\n");

DoCharLdbSP:
  if (_trace) printf("DoCharLdbSP:\n");

DoCharLdbLP:
  if (_trace) printf("DoCharLdbLP:\n");

DoCharLdbFP:
  if (_trace) printf("DoCharLdbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  t7 = zero - 1;   		// t7= -1 
  arg3 = *(s32 *)(iSP + 4);   		// get ARG1 tag/data 
  arg4 = *(s32 *)iSP;   
  arg1 = arg1 + 1;   		// Size of field 
  t7 = t7 << (arg1 & 63);   		// Unmask 
  /* TagType. */
  t8 = arg3 & 63;
  t9 = t8 - Type_Character;   
  arg4 = (u32)arg4;   		// Clear sign extension now 
  if (t9 != 0)   		// Not a character 
    goto charldbexc;
  t4 = arg4 << (arg2 & 63);   		// T4= shifted value if PP==0 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t5 = t4 >> 32;   		// T5= shifted value if PP<>0 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (arg2 == 0)   		// T5= shifted value 
    t5 = t4;
  t3 = t5 & ~t7;		// T3= masked value. 
  t4 = Type_Fixnum;
  *(u32 *)iSP = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;   

charldbexc:
  if (_trace) printf("charldbexc:\n");
  arg5 = 0;
  arg2 = 28;
  goto illegaloperand;

/* end DoCharLdb */
  /* End of Halfword operand from stack instruction - DoCharLdb */
/* start DoPLdb */

  /* Field Extraction instruction - DoPLdb */

dopldb:
  if (_trace) printf("dopldb:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoPLdbIM:
  if (_trace) printf("DoPLdbIM:\n");

DoPLdbSP:
  if (_trace) printf("DoPLdbSP:\n");

DoPLdbLP:
  if (_trace) printf("DoPLdbLP:\n");

DoPLdbFP:
  if (_trace) printf("DoPLdbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  t2 = *(s32 *)iSP;   		// get arg1 tag/data 
  t1 = *(s32 *)(iSP + 4);   
  t2 = (u32)t2;   
  t3 = t1 - Type_PhysicalAddress;   
  t3 = t3 & 63;
  if (t3 == 0) 
    goto pldbillop;
  /* Memory Read Internal */

vma_memory_read29629:
  t3 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t5 = t2 + ivory;
  t4 = *(s32 *)&processor->scovlimit;   
  arg4 = (t5 * 4);   
  arg3 = LDQ_U(t5);   
  t3 = t2 - t3;   		// Stack cache offset 
  t4 = ((u64)t3 < (u64)t4) ? 1 : 0;   		// In range? 
  arg4 = *(s32 *)arg4;   
  arg3 = (u8)(arg3 >> ((t5&7)*8));   
  if (t4 != 0)   
    goto vma_memory_read29631;

vma_memory_read29630:
  arg4 = (u32)arg4;   

vma_memory_read29637:
  t7 = zero - 1;   		// t7= -1 
  arg1 = arg1 + 1;		// Size of field 
  t4 = arg4 << (arg2 & 63);   		// T4= shifted value if PP==0 
  t5 = t4 >> 32;   		// T5= shifted value if PP<>0 
  t7 = t7 << (arg1 & 63);   		// Unmask 
  if (arg2 == 0)   		// T5= shifted value 
    t5 = t4;
  t3 = t5 & ~t7;		// T3= masked value. 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t4 = Type_Fixnum;
  *(u32 *)iSP = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;   

pldbillop:
  if (_trace) printf("pldbillop:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = iSP - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t1 = t2 + t1;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 57;
  goto illegaloperand;

vma_memory_read29631:
  if (_trace) printf("vma_memory_read29631:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t3 = (t3 * 8) + t4;  		// reconstruct SCA 
  arg4 = *(s32 *)t3;   
  arg3 = *(s32 *)(t3 + 4);   		// Read from stack cache 
  goto vma_memory_read29630;   

/* end DoPLdb */
  /* End of Halfword operand from stack instruction - DoPLdb */
/* start DoPTagLdb */

  /* Field Extraction instruction - DoPTagLdb */

doptagldb:
  if (_trace) printf("doptagldb:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoPTagLdbIM:
  if (_trace) printf("DoPTagLdbIM:\n");

DoPTagLdbSP:
  if (_trace) printf("DoPTagLdbSP:\n");

DoPTagLdbLP:
  if (_trace) printf("DoPTagLdbLP:\n");

DoPTagLdbFP:
  if (_trace) printf("DoPTagLdbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  t2 = *(s32 *)iSP;   		// get arg1 tag/data 
  t1 = *(s32 *)(iSP + 4);   
  t2 = (u32)t2;   
  t3 = t1 - Type_PhysicalAddress;   
  t3 = t3 & 63;
  if (t3 == 0) 
    goto ptagldbillop;
  /* Memory Read Internal */

vma_memory_read29638:
  t3 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t5 = t2 + ivory;
  t4 = *(s32 *)&processor->scovlimit;   
  arg4 = (t5 * 4);   
  arg3 = LDQ_U(t5);   
  t3 = t2 - t3;   		// Stack cache offset 
  t4 = ((u64)t3 < (u64)t4) ? 1 : 0;   		// In range? 
  arg4 = *(s32 *)arg4;   
  arg3 = (u8)(arg3 >> ((t5&7)*8));   
  if (t4 != 0)   
    goto vma_memory_read29640;

vma_memory_read29639:

vma_memory_read29646:
  t7 = zero - 1;   		// t7= -1 
  arg1 = arg1 + 1;		// Size of field 
  t4 = arg3 << (arg2 & 63);   		// T4= shifted value if PP==0 
  t5 = t4 >> 32;   		// T5= shifted value if PP<>0 
  t7 = t7 << (arg1 & 63);   		// Unmask 
  if (arg2 == 0)   		// T5= shifted value 
    t5 = t4;
  t3 = t5 & ~t7;		// T3= masked value. 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t4 = Type_Fixnum;
  *(u32 *)iSP = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;   

ptagldbillop:
  if (_trace) printf("ptagldbillop:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = iSP - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t1 = t2 + t1;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 57;
  goto illegaloperand;

vma_memory_read29640:
  if (_trace) printf("vma_memory_read29640:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t3 = (t3 * 8) + t4;  		// reconstruct SCA 
  arg4 = *(s32 *)t3;   
  arg3 = *(s32 *)(t3 + 4);   		// Read from stack cache 
  goto vma_memory_read29639;   

/* end DoPTagLdb */
  /* End of Halfword operand from stack instruction - DoPTagLdb */
/* start DoDpb */

  /* Field Extraction instruction - DoDpb */

dodpb:
  if (_trace) printf("dodpb:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoDpbIM:
  if (_trace) printf("DoDpbIM:\n");

DoDpbSP:
  if (_trace) printf("DoDpbSP:\n");

DoDpbLP:
  if (_trace) printf("DoDpbLP:\n");

DoDpbFP:
  if (_trace) printf("DoDpbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  t6 = *(s32 *)iSP;   		// Get arg2 tag/data 
  t5 = *(s32 *)(iSP + 4);   		// Get arg2 tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  t6 = (u32)t6;   
  arg4 = *(s32 *)iSP;   		// get arg1 tag/data 
  arg3 = *(s32 *)(iSP + 4);   
  arg4 = (u32)arg4;   
  t1 = t5 & 63;		// Strip off any CDR code bits. 
  arg6 = arg3 & 63;		// Strip off any CDR code bits. 
  t2 = (t1 == Type_Fixnum) ? 1 : 0;   

force_alignment29659:
  if (_trace) printf("force_alignment29659:\n");
  if (t2 == 0) 
    goto basic_dispatch29652;
  /* Here if argument TypeFixnum */
  arg5 = (arg6 == Type_Fixnum) ? 1 : 0;   

force_alignment29656:
  if (_trace) printf("force_alignment29656:\n");
  if (arg5 == 0) 
    goto binary_type_dispatch29649;
  /* Here if argument TypeFixnum */
  t7 = zero - 2;   		// t7= -2 
  t7 = t7 << (arg1 & 63);   		// Unmask 
  t5 = ~t7;   		// reuse t5 as mask 
  t3 = arg4 & ~t7;		// T3= masked new value. 
  t5 = t5 << (arg2 & 63);   		// t5 is the inplace mask 
  t4 = t3 << (arg2 & 63);   		// t4 is the shifted field 
  t6 = t6 & ~t5;		// Clear out existing bits in arg2 field 
  t6 = t4 | t6;		// Put the new bits in 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t4 = Type_Fixnum;
  *(u32 *)iSP = t6;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;   

basic_dispatch29653:
  if (_trace) printf("basic_dispatch29653:\n");

basic_dispatch29652:
  if (_trace) printf("basic_dispatch29652:\n");
  /* Here for all other cases */

binary_type_dispatch29648:
  if (_trace) printf("binary_type_dispatch29648:\n");
  arg6 = t5;		// arg6 = tag to dispatch on 
  arg3 = 1;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary_type_dispatch29650;   

binary_type_dispatch29649:
  if (_trace) printf("binary_type_dispatch29649:\n");
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 1;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto numericexception;

binary_type_dispatch29650:
  if (_trace) printf("binary_type_dispatch29650:\n");

basic_dispatch29651:
  if (_trace) printf("basic_dispatch29651:\n");

/* end DoDpb */
  /* End of Halfword operand from stack instruction - DoDpb */
/* start DoCharDpb */

  /* Field Extraction instruction - DoCharDpb */

dochardpb:
  if (_trace) printf("dochardpb:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoCharDpbIM:
  if (_trace) printf("DoCharDpbIM:\n");

DoCharDpbSP:
  if (_trace) printf("DoCharDpbSP:\n");

DoCharDpbLP:
  if (_trace) printf("DoCharDpbLP:\n");

DoCharDpbFP:
  if (_trace) printf("DoCharDpbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  t6 = *(s32 *)iSP;   		// Get arg2 tag/data 
  t5 = *(s32 *)(iSP + 4);   		// Get arg2 tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  t6 = (u32)t6;   
  arg4 = *(s32 *)iSP;   		// get arg1 tag/data 
  arg3 = *(s32 *)(iSP + 4);   
  arg4 = (u32)arg4;   
  t1 = t5 & 63;		// Strip off any CDR code bits. 
  arg6 = arg3 & 63;		// Strip off any CDR code bits. 
  t2 = (t1 == Type_Character) ? 1 : 0;   

force_alignment29672:
  if (_trace) printf("force_alignment29672:\n");
  if (t2 == 0) 
    goto basic_dispatch29665;
  /* Here if argument TypeCharacter */
  arg5 = (arg6 == Type_Fixnum) ? 1 : 0;   

force_alignment29669:
  if (_trace) printf("force_alignment29669:\n");
  if (arg5 == 0) 
    goto binary_type_dispatch29662;
  /* Here if argument TypeFixnum */
  t7 = zero - 2;   		// t7= -2 
  t7 = t7 << (arg1 & 63);   		// Unmask 
  t5 = ~t7;   		// reuse t5 as mask 
  t3 = arg4 & ~t7;		// T3= masked new value. 
  t5 = t5 << (arg2 & 63);   		// t5 is the inplace mask 
  t4 = t3 << (arg2 & 63);   		// t4 is the shifted field 
  t6 = t6 & ~t5;		// Clear out existing bits in arg2 field 
  t6 = t4 | t6;		// Put the new bits in 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t4 = Type_Character;
  *(u32 *)iSP = t6;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;   

basic_dispatch29666:
  if (_trace) printf("basic_dispatch29666:\n");

basic_dispatch29665:
  if (_trace) printf("basic_dispatch29665:\n");
  /* Here for all other cases */

binary_type_dispatch29661:
  if (_trace) printf("binary_type_dispatch29661:\n");
  arg6 = t5;		// arg6 = tag to dispatch on 
  arg3 = 1;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 27;
  goto spareexception;
  goto binary_type_dispatch29663;   

binary_type_dispatch29662:
  if (_trace) printf("binary_type_dispatch29662:\n");
  arg5 = 0;
  arg2 = 27;
  goto illegaloperand;

binary_type_dispatch29663:
  if (_trace) printf("binary_type_dispatch29663:\n");

basic_dispatch29664:
  if (_trace) printf("basic_dispatch29664:\n");

/* end DoCharDpb */
  /* End of Halfword operand from stack instruction - DoCharDpb */
/* start DoPDpb */

  /* Field Extraction instruction - DoPDpb */

dopdpb:
  if (_trace) printf("dopdpb:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoPDpbIM:
  if (_trace) printf("DoPDpbIM:\n");

DoPDpbSP:
  if (_trace) printf("DoPDpbSP:\n");

DoPDpbLP:
  if (_trace) printf("DoPDpbLP:\n");

DoPDpbFP:
  if (_trace) printf("DoPDpbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  t2 = *(s32 *)iSP;   		// Get arg2 tag/data 
  t1 = *(s32 *)(iSP + 4);   		// Get arg2 tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  t2 = (u32)t2;   
  t3 = t1 - Type_PhysicalAddress;   
  t3 = t3 & 63;
  if (t3 == 0) 
    goto pdpbillop;
  arg4 = *(s32 *)iSP;   		// get arg1 tag/data 
  arg3 = *(s32 *)(iSP + 4);   		// get arg1 tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  /* Memory Read Internal */

vma_memory_read29673:
  t3 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t1 = t2 + ivory;
  t4 = *(s32 *)&processor->scovlimit;   
  t6 = (t1 * 4);   
  t8 = LDQ_U(t1);   
  t3 = t2 - t3;   		// Stack cache offset 
  t4 = ((u64)t3 < (u64)t4) ? 1 : 0;   		// In range? 
  t6 = *(s32 *)t6;   
  t8 = (u8)(t8 >> ((t1&7)*8));   
  if (t4 != 0)   
    goto vma_memory_read29675;

vma_memory_read29674:
  t6 = (u32)t6;   

vma_memory_read29681:
  t6 = (u32)t6;   
  t1 = arg3 & 63;		// Strip off any CDR code bits. 
  t10 = (t1 == Type_Fixnum) ? 1 : 0;   

force_alignment29688:
  if (_trace) printf("force_alignment29688:\n");
  if (t10 == 0) 
    goto basic_dispatch29683;
  /* Here if argument TypeFixnum */
  t7 = zero - 2;   		// t7= -2 
  t7 = t7 << (arg1 & 63);   		// Unmask 
  t5 = ~t7;   		// reuse t5 as mask 
  t3 = arg4 & ~t7;		// T3= masked new value. 
  t5 = t5 << (arg2 & 63);   		// t5 is the inplace mask 
  t4 = t3 << (arg2 & 63);   		// t4 is the shifted field 
  t6 = t6 & ~t5;		// Clear out existing bits in arg2 field 
  t6 = t4 | t6;		// Put the new bits in 
  t4 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = t2 + ivory;
  t10 = *(s32 *)&processor->scovlimit;   
  t5 = (t3 * 4);   
  t1 = LDQ_U(t3);   
  t4 = t2 - t4;   		// Stack cache offset 
  t10 = ((u64)t4 < (u64)t10) ? 1 : 0;   		// In range? 
  t4 = (t8 & 0xff) << ((t3&7)*8);   
  t1 = t1 & ~(0xffL << (t3&7)*8);   

force_alignment29685:
  if (_trace) printf("force_alignment29685:\n");
  t1 = t1 | t4;
  STQ_U(t3, t1);   
  *(u32 *)t5 = t6;
  if (t10 != 0)   		// J. if in cache 
    goto vma_memory_write29684;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

basic_dispatch29683:
  if (_trace) printf("basic_dispatch29683:\n");
  /* Here for all other cases */
  arg5 = 0;
  arg2 = 6;
  goto illegaloperand;

basic_dispatch29682:
  if (_trace) printf("basic_dispatch29682:\n");

pdpbillop:
  if (_trace) printf("pdpbillop:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = iSP - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t1 = t2 + t1;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 57;
  goto illegaloperand;

vma_memory_write29684:
  if (_trace) printf("vma_memory_write29684:\n");
  t4 = *(u64 *)&(processor->stackcachebasevma);   

force_alignment29689:
  if (_trace) printf("force_alignment29689:\n");
  t3 = *(u64 *)&(processor->stackcachedata);   
  t4 = t2 - t4;   		// Stack cache offset 
  t3 = (t4 * 8) + t3;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t3 = t6;
		/* write the stack cache */
  *(u32 *)(t3 + 4) = t8;
  goto NEXTINSTRUCTION;   

vma_memory_read29675:
  if (_trace) printf("vma_memory_read29675:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t3 = (t3 * 8) + t4;  		// reconstruct SCA 
  t6 = *(s32 *)t3;   
  t8 = *(s32 *)(t3 + 4);   		// Read from stack cache 
  goto vma_memory_read29674;   

/* end DoPDpb */
  /* End of Halfword operand from stack instruction - DoPDpb */
/* start DoPTagDpb */

  /* Field Extraction instruction - DoPTagDpb */

doptagdpb:
  if (_trace) printf("doptagdpb:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoPTagDpbIM:
  if (_trace) printf("DoPTagDpbIM:\n");

DoPTagDpbSP:
  if (_trace) printf("DoPTagDpbSP:\n");

DoPTagDpbLP:
  if (_trace) printf("DoPTagDpbLP:\n");

DoPTagDpbFP:
  if (_trace) printf("DoPTagDpbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  t2 = *(s32 *)iSP;   		// Get arg2 tag/data 
  t1 = *(s32 *)(iSP + 4);   		// Get arg2 tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  t2 = (u32)t2;   
  t3 = t1 - Type_PhysicalAddress;   
  t3 = t3 & 63;
  if (t3 == 0) 
    goto ptagdpbillop;
  arg4 = *(s32 *)iSP;   		// get arg1 tag/data 
  arg3 = *(s32 *)(iSP + 4);   		// get arg1 tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  /* Memory Read Internal */

vma_memory_read29690:
  t3 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t1 = t2 + ivory;
  t4 = *(s32 *)&processor->scovlimit;   
  t8 = (t1 * 4);   
  t6 = LDQ_U(t1);   
  t3 = t2 - t3;   		// Stack cache offset 
  t4 = ((u64)t3 < (u64)t4) ? 1 : 0;   		// In range? 
  t8 = *(s32 *)t8;   
  t6 = (u8)(t6 >> ((t1&7)*8));   
  if (t4 != 0)   
    goto vma_memory_read29692;

vma_memory_read29691:

vma_memory_read29698:
  t1 = arg3 & 63;		// Strip off any CDR code bits. 
  t10 = (t1 == Type_Fixnum) ? 1 : 0;   

force_alignment29705:
  if (_trace) printf("force_alignment29705:\n");
  if (t10 == 0) 
    goto basic_dispatch29700;
  /* Here if argument TypeFixnum */
  t7 = zero - 2;   		// t7= -2 
  t7 = t7 << (arg1 & 63);   		// Unmask 
  t5 = ~t7;   		// reuse t5 as mask 
  t3 = arg4 & ~t7;		// T3= masked new value. 
  t5 = t5 << (arg2 & 63);   		// t5 is the inplace mask 
  t4 = t3 << (arg2 & 63);   		// t4 is the shifted field 
  t6 = t6 & ~t5;		// Clear out existing bits in arg2 field 
  t6 = t4 | t6;		// Put the new bits in 
  t4 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = t2 + ivory;
  t10 = *(s32 *)&processor->scovlimit;   
  t5 = (t3 * 4);   
  t1 = LDQ_U(t3);   
  t4 = t2 - t4;   		// Stack cache offset 
  t10 = ((u64)t4 < (u64)t10) ? 1 : 0;   		// In range? 
  t4 = (t6 & 0xff) << ((t3&7)*8);   
  t1 = t1 & ~(0xffL << (t3&7)*8);   

force_alignment29702:
  if (_trace) printf("force_alignment29702:\n");
  t1 = t1 | t4;
  STQ_U(t3, t1);   
  *(u32 *)t5 = t8;
  if (t10 != 0)   		// J. if in cache 
    goto vma_memory_write29701;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

basic_dispatch29700:
  if (_trace) printf("basic_dispatch29700:\n");
  /* Here for all other cases */
  arg5 = 0;
  arg2 = 6;
  goto illegaloperand;

basic_dispatch29699:
  if (_trace) printf("basic_dispatch29699:\n");

ptagdpbillop:
  if (_trace) printf("ptagdpbillop:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = iSP - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t1 = t2 + t1;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 57;
  goto illegaloperand;

vma_memory_write29701:
  if (_trace) printf("vma_memory_write29701:\n");
  t4 = *(u64 *)&(processor->stackcachebasevma);   

force_alignment29706:
  if (_trace) printf("force_alignment29706:\n");
  t3 = *(u64 *)&(processor->stackcachedata);   
  t4 = t2 - t4;   		// Stack cache offset 
  t3 = (t4 * 8) + t3;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t3 = t8;
		/* write the stack cache */
  *(u32 *)(t3 + 4) = t6;
  goto NEXTINSTRUCTION;   

vma_memory_read29692:
  if (_trace) printf("vma_memory_read29692:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t3 = (t3 * 8) + t4;  		// reconstruct SCA 
  t8 = *(s32 *)t3;   
  t6 = *(s32 *)(t3 + 4);   		// Read from stack cache 
  goto vma_memory_read29691;   

/* end DoPTagDpb */
  /* End of Halfword operand from stack instruction - DoPTagDpb */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunfext.as */
