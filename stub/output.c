/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunhead.as
 ************************************************************************/

  /* Entry points into the interpretation loop. */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunhead.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/idispat.as
 ************************************************************************/

  /* This file implements the main instruction dispatch loop. */
/* start DummyDoNothingSubroutine */


dummydonothingsubroutine:
  if (_trace) printf("dummydonothingsubroutine:\n");
  goto continuecurrentinstruction;   

/* end DummyDoNothingSubroutine */
/* start MemoryReadData */


memoryreaddata:
  if (_trace) printf("memoryreaddata:\n");
  /* Memory Read Internal */

vma-memory-read14194:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14196;

vma-memory-read14195:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14198;

vma-memory-read14204:
  goto *r0; /* ret */

memoryreaddatadecode:
  if (_trace) printf("memoryreaddatadecode:\n");
  if (t6 == 0) 
    goto vma-memory-read14197;

vma-memory-read14196:
  if (_trace) printf("vma-memory-read14196:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  arg6 = *(s32 *)t5;   
  arg5 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read14195;   

vma-memory-read14198:
  if (_trace) printf("vma-memory-read14198:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14197;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14194;   

vma-memory-read14197:
  if (_trace) printf("vma-memory-read14197:\n");
  t8 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg2;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read14201:
  if (_trace) printf("vma-memory-read14201:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0) 
    goto vma-memory-read14200;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto vma-memory-read14204;   

vma-memory-read14200:

vma-memory-read14199:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

/* end MemoryReadData */
/* start MemoryReadGeneral */


memoryreadgeneral:
  if (_trace) printf("memoryreadgeneral:\n");
  /* Memory Read Internal */

vma-memory-read14205:
  t7 = arg2 + ivory;
  t8 = (arg3 * 4);   		// Cycle-number -> table offset 
  arg5 = LDQ_U(t7);   
  t8 = (t8 * 4) + ivory;   
  arg6 = (t7 * 4);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)(t8 + PROCESSORSTATE_DATAREAD_MASK);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14207;

vma-memory-read14206:
  t8 = t8 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14209;

vma-memory-read14215:
  goto *r0; /* ret */

memoryreadgeneraldecode:
  if (_trace) printf("memoryreadgeneraldecode:\n");
  if (t6 == 0) 
    goto vma-memory-read14208;

vma-memory-read14207:
  if (_trace) printf("vma-memory-read14207:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  arg6 = *(s32 *)t5;   
  arg5 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read14206;   

vma-memory-read14209:
  if (_trace) printf("vma-memory-read14209:\n");

vma-memory-read14208:
  if (_trace) printf("vma-memory-read14208:\n");
  t8 = (arg3 * 4);   		// Cycle-number -> table offset 
  t8 = (t8 * 4) + ivory;   
  t8 = *(u64 *)(t8 + PROCESSORSTATE_DATAREAD);   
  /* TagType. */
  t7 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg2;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read14213:
  if (_trace) printf("vma-memory-read14213:\n");
  t6 = t8 & MemoryActionIndirect;
  if (t6 == 0) 
    goto vma-memory-read14212;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14205;   

vma-memory-read14212:
  if (_trace) printf("vma-memory-read14212:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0) 
    goto vma-memory-read14211;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto vma-memory-read14215;   

vma-memory-read14211:

vma-memory-read14210:
  /* Perform memory action */
  arg1 = t8;
  arg2 = arg3;
  goto performmemoryaction;

/* end MemoryReadGeneral */
/* start MemoryReadHeader */


memoryreadheader:
  if (_trace) printf("memoryreadheader:\n");
  /* Memory Read Internal */

vma-memory-read14216:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14218;

vma-memory-read14217:
  t7 = zero + 64;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14220;

vma-memory-read14224:
  goto *r0; /* ret */

memoryreadheaderdecode:
  if (_trace) printf("memoryreadheaderdecode:\n");
  if (t6 == 0) 
    goto vma-memory-read14219;

vma-memory-read14218:
  if (_trace) printf("vma-memory-read14218:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  arg6 = *(s32 *)t5;   
  arg5 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read14217;   

vma-memory-read14220:
  if (_trace) printf("vma-memory-read14220:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14219;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14216;   

vma-memory-read14219:
  if (_trace) printf("vma-memory-read14219:\n");
  t8 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg2;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read14221:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end MemoryReadHeader */
/* start MemoryReadCdr */


memoryreadcdr:
  if (_trace) printf("memoryreadcdr:\n");
  /* Memory Read Internal */

vma-memory-read14225:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->cdr_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14227;

vma-memory-read14226:
  t7 = zero + 192;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14229;

vma-memory-read14233:
  goto *r0; /* ret */

memoryreadcdrdecode:
  if (_trace) printf("memoryreadcdrdecode:\n");
  if (t6 == 0) 
    goto vma-memory-read14228;

vma-memory-read14227:
  if (_trace) printf("vma-memory-read14227:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  arg6 = *(s32 *)t5;   
  arg5 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read14226;   

vma-memory-read14229:
  if (_trace) printf("vma-memory-read14229:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14228;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14225;   

vma-memory-read14228:
  if (_trace) printf("vma-memory-read14228:\n");
  t8 = *(u64 *)&(processor->cdr);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg2;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read14230:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 9;
  goto performmemoryaction;

/* end MemoryReadCdr */
/* start DoICacheFill */


doicachefill:
  if (_trace) printf("doicachefill:\n");

ICACHEMISS:
  if (_trace) printf("ICACHEMISS:\n");
  /* Here when instruction cache miss detected.  Fill the cache from */
  /* PC and then resume interpreter loop */
  /* First round the PC down to an even halfword address */
  arg2 = *(u64 *)&(processor->icachebase);   		// get the base of the icache 
  epc = iPC & ~1L;		// the even PC 
  ecp = epc >> (CacheLine_RShift & 63);   
  arg1 = zero + -1;   
  arg1 = arg1 + ((4) << 16);   
  ecp = ecp << (CacheLine_LShift & 63);   
  instn = iPC >> 1;   		// instn is instruction address here 
  ecp = epc + ecp;
  ecp = ecp & arg1;
  arg3 = ecp << 5;   		// temp=cpos*32 
  ecp = ecp << 4;   		// cpos=cpos*16 
  arg4 = arg2 + arg3;		// temp2=base+cpos*32 
  ecp = arg4 + ecp;		// cpos=base+cpos*48 
  opc = epc | 1;		// the odd PC 
  iCP = ecp;		// Assume iPC is the even PC 
  arg1 = (iPC == opc) ? 1 : 0;   		// See if iPC is the odd PC 
  ocp = ecp + CACHELINE_SIZE;
  if (arg1)   		// Stash the odd cache pointer if iPC is the odd PC 
    iCP = ocp;
  hwdispatch = *(u64 *)&(processor->halfworddispatch);   
  hwopmask = zero + 1023;   
  fwdispatch = *(u64 *)&(processor->fullworddispatch);   
  count = zero + 20;   
  t11 = instn + ivory;
  iword = (t11 * 4);   
  arg4 = LDQ_U(t11);   
  iword = *(s32 *)iword;   
  arg4 = (u8)(arg4 >> ((t11&7)*8));   
  goto fillicacheprefetched;   

pcbackone:
  if (_trace) printf("pcbackone:\n");
  /* Wire in continuation for even half */
  *(u64 *)&((CACHELINEP)ocp)->nextpcdata = epc;   
  t10 = ecp - CACHELINE_SIZE;   		// Backup in cache too 
  *(u64 *)&((CACHELINEP)ocp)->nextcp = ecp;   
  arg1 = epc - 1;   		// Backup PC one halfword 
  *(u64 *)&((CACHELINEP)ecp)->nextcp = t10;   
  /* TagType. */
  arg4 = arg4 & 63;		// arg4=tag-cdr code 
  *(u64 *)&((CACHELINEP)ecp)->nextpcdata = arg1;   
  /* Wire in continuation for odd half */
  goto maybeunpack;   

pcadvone:
  if (_trace) printf("pcadvone:\n");
  *(u64 *)&((CACHELINEP)ecp)->nextpcdata = opc;   		// Simple advance of PC one halfword. 
  arg1 = opc + 1;
  *(u64 *)&((CACHELINEP)ecp)->nextcp = ocp;   
  t10 = ocp + CACHELINE_SIZE;
  *(u64 *)&((CACHELINEP)ocp)->nextpcdata = arg1;   
  /* TagType. */
  arg4 = arg4 & 63;		// arg4=tag-cdr code 
  *(u64 *)&((CACHELINEP)ocp)->nextcp = t10;   
  goto maybeunpack;   
  /* This is the cache fill loop. */

fillicache:
  if (_trace) printf("fillicache:\n");
  t11 = instn + ivory;
  iword = (t11 * 4);   
  arg4 = LDQ_U(t11);   
  iword = *(s32 *)iword;   
  arg4 = (u8)(arg4 >> ((t11&7)*8));   

fillicacheprefetched:
  if (_trace) printf("fillicacheprefetched:\n");
#ifdef CACHEMETERING
  /* Increment the fill count for both cache entries */
  t10 = *(s32 *)&((CACHELINEP)ecp)->annotation;   
  t11 = *(s32 *)&((CACHELINEP)ocp)->annotation;   
  t10 = (u32)t10;   
  t11 = (u32)t11;   
  t10 = t10 + 1;
  *(u32 *)&((CACHELINEP)ecp)->annotation = t10;
  t11 = t11 + 1;
  *(u32 *)&((CACHELINEP)ocp)->annotation = t11;
#endif
  *(u64 *)&((CACHELINEP)ecp)->pcdata = epc;   		// Set address of even cache posn. 
  arg1 = arg4 & 192;		// CDR code << 6 
  /* TagType. */
  arg4 = arg4 & 63;		// Strip cdr 
  *(u64 *)&((CACHELINEP)ocp)->pcdata = opc;   		// Set address of odd cache posn. 
  iword = (u32)iword;   		// Strip nasty bits out. 

force-alignment14234:
  if (_trace) printf("force-alignment14234:\n");
  arg2 = arg4 << 32;   		// ready to remerge 
  if (arg1 == 0) 		// Zerotag means advance one HW 
    goto pcadvone;
  arg1 = arg1 - 128;   		// 2<<6 
  if (arg1 == 0) 		// Tag=2 means backup one HW 
    goto pcbackone;
  if ((s64)arg1 < 0)   		// Tag=1 means end of compiled function 
    goto pcendcf;

pcadvtwo:
  if (_trace) printf("pcadvtwo:\n");
  /* Tag=3 means advance over one full word */
  /* Wire in continuation for even half */
  arg1 = epc + 2;		// Next word 
  r31 = r31 | r31;
  t10 = ecp + TWOCACHELINESIZE;		// corresponding CP entry 
  *(u64 *)&((CACHELINEP)ecp)->nextpcdata = arg1;   		// Next PC even of next word 
  arg1 = epc + 4;		// Skip one fullword 
  *(u64 *)&((CACHELINEP)ecp)->nextcp = t10;   		// Next CP 
  /* Wire in continuation for odd half */
  t10 = ecp + FOURCACHELINESIZE;		// corresponding CP entry 
  *(u64 *)&((CACHELINEP)ocp)->nextpcdata = arg1;   
  /* TagType. */
  arg4 = arg4 & 63;		// arg4=tag-cdr code 
  *(u64 *)&((CACHELINEP)ocp)->nextcp = t10;   
  goto maybeunpack;   

decodepackedword:
  if (_trace) printf("decodepackedword:\n");
  /* Here to decode a packed word */
#ifdef CACHEMETERING
  arg1 = *(s32 *)&processor->metervalue;   
  arg4 = *(s32 *)&processor->metercount;   		// The number of remaining tokens. 
  t10 = *(u64 *)&(processor->meterdatabuff);   		// The cache miss meter buffer. 
  arg1 = arg1 + 1;		// count the miss. 
  t11 = *(s32 *)&processor->meterpos;   		// Position for new data. 
  *(u32 *)&processor->metervalue = arg1;
  if (arg4 != 0)   
    goto maybe-meter-miss14235;
  arg2 = *(s32 *)&processor->metermask;   
  t10 = (t11 * 4) + t10;   		// position of the current data item 
  t11 = t11 + 1;
  t11 = t11 & arg2;
  arg2 = *(s32 *)&processor->metermax;   
  t12 = arg1 - arg2;   
  if ((s64)t12 > 0)   
    arg2 = arg1;
  *(u32 *)&processor->metermax = arg2;
		/* store the datapoint */
  *(u32 *)t10 = arg1;
		/* Position for new data. */
  *(u32 *)&processor->meterpos = t11;
  *(u32 *)&processor->metervalue = zero;
  arg4 = *(s32 *)&processor->meterfreq;   

maybe-meter-miss14235:
  if (_trace) printf("maybe-meter-miss14235:\n");
  *(u32 *)&processor->metercount = arg4;
#endif
  arg4 = iword >> 18;   		// arg4 contains the odd packedword 
  t10 = iword >> 8;   		// even opcode+2bits 
  *(u64 *)&((CACHELINEP)ocp)->instruction = arg4;   		// Save the odd instruction 
  t11 = iword << 54;   		// First phase of even operand sign extension. 
  t12 = iword & hwopmask;		// even operand+2bits 
#ifndef CACHEMETERING
  *(u64 *)&((CACHELINEP)ocp)->annotation = zero;   
#endif
  t10 = t10 & hwopmask;		// even opcode 
  t11 = (s64)t11 >> 38;   		// Second phase of even operand sign extension. 
  arg2 = t10 - 92;   
  t10 = (t10 * 8) + hwdispatch;  
  t12 = t11 | t12;		// Merge signed/unsigned even operand 
  arg2 = arg2 & ~3L;
  *(u32 *)&((CACHELINEP)ecp)->operand = t12;
  if (arg2 == 0)   		// clear count if finish-call seen 
    count = arg2;
  arg2 = arg4 >> 8;   		// odd opcode+2bits 
  t11 = arg4 << 54;   		// First phase of odd operand sign extension. 
  arg1 = arg4 & hwopmask;		// odd operand+2bits 
  t10 = *(u64 *)t10;   
  arg2 = arg2 & hwopmask;		// odd opcode 
  t11 = (s64)t11 >> 38;   		// Second phase of odd operand sign extension. 
  *(u64 *)&((CACHELINEP)ecp)->code = t10;   
  t12 = arg2 - 92;   
  arg2 = (arg2 * 8) + hwdispatch;  
  arg1 = t11 | arg1;		// Merge signed/unsigned odd operand 
  *(u32 *)&((CACHELINEP)ocp)->operand = arg1;
  t12 = t12 & ~3L;
  arg2 = *(u64 *)arg2;   
  if (t12 == 0)   		// clear count if finish-call seen 
    count = t12;
  *(u64 *)&((CACHELINEP)ocp)->code = arg2;   
  goto enddecode;   

maybeunpack:
  if (_trace) printf("maybeunpack:\n");
  iword = arg2 | iword;		// reassemble tag and word. 
  *(u64 *)&((CACHELINEP)ecp)->instruction = iword;   		// save the even instruction 
  t10 = arg4 - 48;   		// t10>=0 if packed 
#ifndef CACHEMETERING
  *(u64 *)&((CACHELINEP)ecp)->annotation = zero;   
#endif
#ifdef CACHEMETERING
  epc = *(s32 *)&processor->metervalue;   
  t12 = *(s32 *)&processor->metercount;   		// The number of remaining tokens. 
  t11 = *(u64 *)&(processor->meterdatabuff);   		// The cache miss meter buffer. 
  epc = epc + 1;		// count the miss. 
  arg1 = *(s32 *)&processor->meterpos;   		// Position for new data. 
  *(u32 *)&processor->metervalue = epc;
  if (t12 != 0)   
    goto maybe-meter-miss14236;
  arg2 = *(s32 *)&processor->metermask;   
  t11 = (arg1 * 4) + t11;   		// position of the current data item 
  arg1 = arg1 + 1;
  arg1 = arg1 & arg2;
  arg2 = *(s32 *)&processor->metermax;   
  t10 = epc - arg2;   
  if ((s64)t10 > 0)   
    arg2 = epc;
  *(u32 *)&processor->metermax = arg2;
		/* store the datapoint */
  *(u32 *)t11 = epc;
		/* Position for new data. */
  *(u32 *)&processor->meterpos = arg1;
  *(u32 *)&processor->metervalue = zero;
  t12 = *(s32 *)&processor->meterfreq;   

maybe-meter-miss14236:
  if (_trace) printf("maybe-meter-miss14236:\n");
  *(u32 *)&processor->metercount = t12;
#endif
  if ((s64)t10 >= 0)   		// B. if a packed instruction 
    goto decodepackedword;
  t11 = (arg4 * 8) + fwdispatch;  		// t11 is the fwdispatch index 
  t12 = *(u64 *)&(processor->i_stage_error_hook);   
  arg1 = arg4 - 33;   
  t11 = *(u64 *)t11;   		// Extract the opcode handler 
  *(u64 *)&((CACHELINEP)ocp)->code = t12;   		// Store I-STATE-ERROR at odd pc 
  if (arg1 == 0)   		// clear count if native instn seen 
    count = arg1;
  *(u64 *)&((CACHELINEP)ecp)->code = t11;   

enddecode:
  if (_trace) printf("enddecode:\n");
  /* Here we decide if to stop filling the cache and return to the */
  /* instruction interpretation stream, or whether to fill further */
  instn = instn + 1;
  if ((s64)count <= 0)  		// If count is zero, resume 
    goto cachevalid;
  epc = instn << 1;   
  count = count - 1;   		// decrement count 
  opc = epc | 1;
  t10 = *(u64 *)&(processor->endicache);   		// pointer to the end of icache 
  ocp = ocp + TWOCACHELINESIZE;
  ecp = ecp + TWOCACHELINESIZE;
  t10 = ocp - t10;   
  if ((s64)t10 <= 0)  		// Still room for more 
    goto fillicache;
  goto cachevalid;   

pcendcf:
  if (_trace) printf("pcendcf:\n");
  t11 = *(u64 *)&(processor->i_stage_error_hook);   
  count = r31 | r31;		// We reached the end of the fcn. 
  *(u64 *)&((CACHELINEP)ecp)->code = t11;   		// Store I-STATE-ERROR dispatch at even and odd pc 
  *(u64 *)&((CACHELINEP)ocp)->code = t11;   
  goto enddecode;   

/* end DoICacheFill */
  /* These are the instruction reentry points.  Instructions end by returning */
  /* control to one of these tags.  Most normal instructions reenter by jumping */
  /* to NEXTINSTRUCTION, which advances the PC and continues normally.   */
  /* Instructions that change the PC usually go directly to INTERPRETINSTRUCTION. */
  /* Instructions that fail/trap/exception etc, go to one of the other places. */
/* start iInterpret */


iinterpret:
  if (_trace) printf("iinterpret:\n");
  *(u64 *)&processor->asrr9 = r9;   
  *(u64 *)&processor->asrr10 = r10;   
  *(u64 *)&processor->asrr11 = r11;   
  *(u64 *)&processor->asrr12 = r12;   
  *(u64 *)&processor->asrr13 = r13;   
  *(u64 *)&processor->asrr15 = r15;   
  *(u64 *)&processor->asrr26 = r26;   
  *(u64 *)&processor->asrr27 = r27;   
  *(u64 *)&processor->asrr29 = r29;   
  *(u64 *)&processor->asrr30 = r30;   
  *(u64 *)&processor->asrr14 = r14;   
  ivory = arg1;		// Setup our processor object handle 
  /* Upon entry, load cached state. */
  iCP = *(u64 *)&(processor->cp);   
  iPC = *(u64 *)&(processor->epc);   
  iSP = *(u64 *)&(processor->sp);   
  iFP = *(u64 *)&(processor->fp);   
  iLP = *(u64 *)&(processor->lp);   
  if (iCP != 0)   		// First time in iCP will be zero. 
    goto INTERPRETINSTRUCTION;
  goto ICACHEMISS;   		// If this is the first time in cache is empty! 

interpretinstructionpredicted:
  if (_trace) printf("interpretinstructionpredicted:\n");
  t2 = *(u64 *)&(((CACHELINEP)arg2)->pcdata);   		// Get the PC to check cache hit. 
  arg1 = iFP;   		// Assume FP mode 
  r0 = *(u64 *)&(processor->stop_interpreter);   		// Have we been asked to stop? 
  arg4 = iSP + -8;   		// SP-pop mode constant 
  arg3 = *(u64 *)&(((CACHELINEP)arg2)->instruction);   		// Grab the instruction/operand while stalled 
  t1 = iPC - t2;   
  if (t1 != 0)   
    goto interpretinstructionforbranch;
  iCP = arg2;
  if (r0 != 0)   		// Stop the world! someone wants out. 
    goto traporsuspendmachine;
  goto continuecurrentinstruction;   

interpretinstructionforjump:
  if (_trace) printf("interpretinstructionforjump:\n");

interpretinstructionforbranch:
  if (_trace) printf("interpretinstructionforbranch:\n");
  t5 = *(u64 *)&(processor->icachebase);   		// get the base of the icache 
  t4 = zero + -1;   
  t4 = t4 + ((4) << 16);   
  arg2 = iPC >> 10;   
  t3 = zero + -64;   
  arg2 = arg2 & t3;
  arg2 = iPC + arg2;
  arg2 = arg2 & t4;
  t4 = arg2 << 5;   		// temp=cpos*32 
  arg2 = arg2 << 4;   		// cpos=cpos*16 
  t5 = t5 + t4;		// temp2=base+cpos*32 

force-alignment14237:
  if (_trace) printf("force-alignment14237:\n");
  arg2 = t5 + arg2;		// cpos=base+cpos*48 
#ifndef CACHEMETERING
  *(u64 *)&((CACHELINEP)iCP)->annotation = arg2;   
#endif
  iCP = arg2;

INTERPRETINSTRUCTION:
  if (_trace) printf("INTERPRETINSTRUCTION:\n");
  r30 = *(u64 *)&(processor->asrr30);   
  r0 = *(u64 *)&(processor->stop_interpreter);   		// Have we been asked to stop? 
  arg1 = iFP;   		// Assume FP mode 
  arg3 = *(u64 *)&(((CACHELINEP)iCP)->instruction);   		// Grab the instruction/operand while stalled 
  arg4 = iSP + -8;   		// SP-pop mode constant 
  t2 = *(u64 *)&(((CACHELINEP)iCP)->pcdata);   		// Get the PC to check cache hit. 
  if (r0 != 0)   		// Stop the world! someone wants out. 
    goto traporsuspendmachine;
  goto continuecurrentinstruction;   

/* end iInterpret */



/* End of file automatically generated from ../alpha-emulator/idispat.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifuncom1.as
 ************************************************************************/

  /* The most commonly used instructions, part 1.  */
/* start DoPush */

  /* Halfword operand from stack instruction - DoPush */
  /* arg2 has the preloaded 8 bit operand. */

dopush:
  if (_trace) printf("dopush:\n");

DoPushSP:
  if (_trace) printf("DoPushSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPushLP:
  if (_trace) printf("DoPushLP:\n");

DoPushFP:
  if (_trace) printf("DoPushFP:\n");

begindopush:
  if (_trace) printf("begindopush:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = iSP + 8;		// Push the new value 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t1 = *(s32 *)(arg1 + 4);   		// Get the tag/data 
  t2 = *(s32 *)arg1;   
		/* Store the data word */
  *(u32 *)iSP = t2;

force-alignment14244:
  if (_trace) printf("force-alignment14244:\n");
  /* TagType. */
  t1 = t1 & 63;		// make it CDR NEXT 
		/* Store the TAG - this *DOES* dual issue! */
  *(u32 *)(iSP + 4) = t1;

/* end DoPush */
  /* End of Halfword operand from stack instruction - DoPush */
/* start nextInstruction */


nextinstruction:
  if (_trace) printf("nextinstruction:\n");

cachevalid:
  if (_trace) printf("cachevalid:\n");
  arg3 = *(u64 *)&(((CACHELINEP)iCP)->instruction);   		// Grab the instruction/operand while stalled 
  arg1 = iFP;   		// Assume FP mode 
  t2 = *(u64 *)&(((CACHELINEP)iCP)->pcdata);   		// Get the PC to check cache hit. 
  arg4 = iSP + -8;   		// SP-pop mode constant 

continuecurrentinstruction:
  if (_trace) printf("continuecurrentinstruction:\n");
  t3 = *(u64 *)&(((CACHELINEP)iCP)->code);   		// Instruction handler 
  arg5 = iSP + -2040;   		// SP mode constant 
  *(u64 *)&processor->restartsp = iSP;   		// Need this in case we take a trap 
  t4 = (u8)(arg3 >> ((5&7)*8));   		// Get the mode bits 
  t2 = t2 - iPC;   		// check for HIT. 
  arg6 = *(u64 *)iSP;   		// Load TOS in free di slot 
  arg2 = (u8)(arg3 >> ((4&7)*8));   		// Extract (8-bit, unsigned) operand 
  if (t2 != 0)   		// PC didn't match, take a cache miss 
    goto takeicachemiss;
  if (t4 & 1)   		// LP or Immediate mode 
   arg1 = iLP;
#ifdef TRACING
  /* Update the instruction count. */
  t4 = *(u64 *)&(processor->instruction_count);   
  t4 = t4 - 1;   		// Decrement the instruction count. 
  if (t4 != 0)   		// J. if not reached stop point. 
    goto maybe-icount14251;
  zero = zero;		// put a breakpoint here to catch stops 

maybe-icount14251:
  if (_trace) printf("maybe-icount14251:\n");
  *(u64 *)&processor->instruction_count = t4;   
  /* Trace instructions if requested. */
  t4 = *(u64 *)&(processor->trace_hook);   
  if (t4 == 0) 		// J. if not tracing. 
    goto maybe-trace14256;
  /* Record an instruction trace entry */
  t5 = *(s32 *)&t4->tracedata_recording_p;   
  t6 = *(u64 *)&(t4->tracedata_start_pc);   
  if (t5 != 0)   		// Jump if recording is on 
    goto maybe-trace14252;
  t6 = (t6 == iPC) ? 1 : 0;   		// Turn recording on if at the start PC 
  *(u32 *)&t4->tracedata_recording_p = t6;
  if (t6 == 0) 		// Jump if not at the start PC 
    goto maybe-trace14256;

maybe-trace14252:
  if (_trace) printf("maybe-trace14252:\n");
  t5 = *(u64 *)&(t4->tracedata_current_entry);   		// Get address of next trace record  
  t6 = *(u64 *)&(processor->instruction_count);   
  *(u64 *)&t5->tracerecord_epc = iPC;   		// Save current PC 
  *(u64 *)&t5->tracerecord_counter = t6;   		// Save instruction count 
  t6 = *(u64 *)iSP;   
  /* Convert stack cache address to VMA */
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = *(u64 *)&(processor->stackcachebasevma);   
  t8 = iSP - t8;   		// stack cache base relative offset 
  t8 = t8 >> 3;   		// convert byte address to word address 
  t7 = t8 + t7;		// reconstruct VMA 
  *(u64 *)&t5->tracerecord_tos = t6;   		// Save current value of TOS 
  *(u64 *)&t5->tracerecord_sp = t7;   		// Save current SP 
  t6 = *(s32 *)&((CACHELINEP)iCP)->operand;   
  t7 = *(u64 *)&(((CACHELINEP)iCP)->code);   
		/* Save current instruction's operand */
  *(u32 *)&t5->tracerecord_operand = t6;
  *(u64 *)&t5->tracerecord_instruction = t7;   		// Save pointer to current instruction code 
  t7 = *(u64 *)&(processor->control);   
  t8 = *(u64 *)&(((CACHELINEP)iCP)->instruction);   
		/* We don't yet record catch blocks */
  *(u32 *)&t5->tracerecord_catch_block_p = zero;
  *(u64 *)&t5->tracerecord_catch_block_0 = t7;   		// Save control register 
  t6 = *(u64 *)&(processor->tvi);   
  *(u64 *)&t5->tracerecord_instruction_data = t8;   		// Save full word instruction operand 
		/* Save trap indiciator */
  *(u32 *)&t5->tracerecord_trap_p = t6;
  if (t6 == 0) 		// Jump if didn't trap 
    goto maybe-trace14253;
  t6 = *(u64 *)(iFP + 16);   
  *(u64 *)&processor->tvi = zero;   		// Zero flag to avoid false trap entries 
  t7 = *(u64 *)(iFP + 24);   
  *(u64 *)&t5->tracerecord_trap_data_0 = t6;   		// Save trap vector index 
  t8 = *(u64 *)(iFP + 32);   
  *(u64 *)&t5->tracerecord_trap_data_1 = t7;   		// Save fault PC 
  t9 = *(u64 *)(iFP + 40);   
  *(u64 *)&t5->tracerecord_trap_data_2 = t8;   		// Save two additional arguments 
  *(u64 *)&t5->tracerecord_trap_data_3 = t9;   

maybe-trace14253:
  if (_trace) printf("maybe-trace14253:\n");
  t5 = t5 + tracerecordsize;		// Bump to next trace record 
  t6 = *(u64 *)&(t4->tracedata_records_start);   		// Get pointer to start of trace records 
  *(u64 *)&t4->tracedata_current_entry = t5;   		// Set record pointer to keep printer happy 
  t7 = *(u64 *)&(t4->tracedata_records_end);   		// Get pointer to end of trace record 
  t8 = *(u64 *)&(t4->tracedata_printer);   		// Function to print trace if non-zero 
  t7 = ((s64)t7 <= (s64)t5) ? 1 : 0;   		// Non-zero iff we're about to wrap the circular buffer 
  if (t7)   		// Update next record pointer iff we wrapped 
    t5 = t6;
  if (t7 == 0)   		// Don't print if we didn't wrap 
    t8 = zero;
  if (t8 == 0) 		// Jump if we don't need to print 
    goto maybe-trace14254;
  *(u64 *)&processor->cp = iCP;   
  *(u64 *)&processor->epc = iPC;   
  *(u64 *)&processor->sp = iSP;   
  *(u64 *)&processor->fp = iFP;   
  *(u64 *)&processor->lp = iLP;   
  *(u64 *)&processor->asrf2 = arg1;   
  *(u64 *)&processor->asrf3 = arg2;   
  *(u64 *)&processor->asrf4 = arg3;   
  *(u64 *)&processor->asrf5 = arg4;   
  *(u64 *)&processor->asrf6 = arg5;   
  *(u64 *)&processor->asrf7 = arg6;   
  *(u64 *)&processor->asrf8 = t4;   
  *(u64 *)&processor->asrf9 = t5;   
  *(u64 *)&processor->long_pad1 = t3;   
  r9 = *(u64 *)&(processor->asrr9);   
  r10 = *(u64 *)&(processor->asrr10);   
  r11 = *(u64 *)&(processor->asrr11);   
  r12 = *(u64 *)&(processor->asrr12);   
  r13 = *(u64 *)&(processor->asrr13);   
  r15 = *(u64 *)&(processor->asrr15);   
  r27 = *(u64 *)&(processor->asrr27);   
  r29 = *(u64 *)&(processor->asrr29);   
  pv = t8;
    r0 = (*( u64 (*)(u64, u64) )t8)(arg1, arg2); /* jsr */  
  r9 = *(u64 *)&(processor->asrr9);   
  r10 = *(u64 *)&(processor->asrr10);   
  r11 = *(u64 *)&(processor->asrr11);   
  r12 = *(u64 *)&(processor->asrr12);   
  r13 = *(u64 *)&(processor->asrr13);   
  r15 = *(u64 *)&(processor->asrr15);   
  r27 = *(u64 *)&(processor->asrr27);   
  r29 = *(u64 *)&(processor->asrr29);   
  arg1 = *(u64 *)&(processor->asrf2);   
  arg2 = *(u64 *)&(processor->asrf3);   
  arg3 = *(u64 *)&(processor->asrf4);   
  arg4 = *(u64 *)&(processor->asrf5);   
  arg5 = *(u64 *)&(processor->asrf6);   
  arg6 = *(u64 *)&(processor->asrf7);   
  t4 = *(u64 *)&(processor->asrf8);   
  t5 = *(u64 *)&(processor->asrf9);   
  t3 = *(u64 *)&(processor->long_pad1);   
  iCP = *(u64 *)&(processor->cp);   
  iPC = *(u64 *)&(processor->epc);   
  iSP = *(u64 *)&(processor->sp);   
  iFP = *(u64 *)&(processor->fp);   
  iLP = *(u64 *)&(processor->lp);   
  t7 = zero;		// Claim we didn't wrap 

maybe-trace14254:
  if (_trace) printf("maybe-trace14254:\n");
  *(u64 *)&t4->tracedata_current_entry = t5;   		// Save next record pointer 
  if (t7 == 0) 		// Jump if we didn't wrap 
    goto maybe-trace14255;
		/* Set flag indicating that we wrapped */
  *(u32 *)&t4->tracedata_wrap_p = t7;

maybe-trace14255:
  if (_trace) printf("maybe-trace14255:\n");
  t5 = *(u64 *)&(t4->tracedata_stop_pc);   
  t5 = (t5 == iPC) ? 1 : 0;   		// Non-zero if at PC where we should stop tracing 
  t5 = (t5 == 0) ? 1 : 0;   		// Non-zero if not at the PC 
		/* Update recording flag */
  *(u32 *)&t4->tracedata_recording_p = t5;

maybe-trace14256:
  if (_trace) printf("maybe-trace14256:\n");
#endif
#ifdef STATISTICS
  t4 = *(u64 *)&(((CACHELINEP)iCP)->code);   		// The instruction. 
  t5 = *(u64 *)&(processor->statistics);   		// The usage statistics array 
  t9 = zero + 8191;   
  t6 = t4 >> 4;   
  t6 = t6 & t9;		// Extract the address 
  t7 = (t6 * 4) + t5;   		// Compute the index to the usage data for this instn. 
  t8 = *(s32 *)t7;   		// Get current usage data 
  t8 = t8 + 1;		// Increment 
		/* Set current usage data */
  *(u32 *)t7 = t8;
#endif
#ifdef CACHEMETERING
  t5 = *(s32 *)&processor->metercount;   		// The number of remaining tokens. 
  t4 = *(u64 *)&(processor->meterdatabuff);   		// The cache miss meter buffer. 
  t7 = *(s32 *)&processor->meterpos;   		// Position for new data. 
  t5 = t5 - 1;   		// record a cache hit 
  if (t5 != 0)   
    goto maybe-meter-hit14257;
  t8 = *(s32 *)&processor->metermask;   
  t4 = (t7 * 4) + t4;   		// position of the current data item 
  t9 = *(s32 *)&processor->metervalue;   
  t7 = t7 + 1;
  t7 = t7 & t8;
  t8 = *(s32 *)&processor->metermax;   
  t6 = t9 - t8;   
  if ((s64)t6 > 0)   
    t8 = t9;
  *(u32 *)&processor->metermax = t8;
		/* store the datapoint */
  *(u32 *)t4 = t9;
		/* Position for new data. */
  *(u32 *)&processor->meterpos = t7;
  *(u32 *)&processor->metervalue = zero;
  t5 = *(s32 *)&processor->meterfreq;   

maybe-meter-hit14257:
  if (_trace) printf("maybe-meter-hit14257:\n");
  *(u32 *)&processor->metercount = t5;
#endif
#ifdef DEBUGGING
  if (t3 == 0) 		// Just in case... 
    goto haltmachine;
#endif
    goto *t3; /* jmp */   		// Jump to the handler 
  /* Here to advance the PC and begin a new instruction.  Most */
  /* instructions come here when they have finished.  Instructions */
  /* that explicitly update the PC (and CP) go to interpretInstruction. */

NEXTINSTRUCTION:
  if (_trace) printf("NEXTINSTRUCTION:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   		// Load the next PC from the cache 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   		// Advance cache position 
  goto cachevalid;   

takeicachemiss:
  if (_trace) printf("takeicachemiss:\n");
  goto ICACHEMISS;

/* end nextInstruction */
/* start DoPushImmediateHandler */


dopushimmediatehandler:
  if (_trace) printf("dopushimmediatehandler:\n");

DoPushIM:
  if (_trace) printf("DoPushIM:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t4 = Type_Fixnum;
		/* Push it with CDR-NEXT onto the stack */
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  goto cachevalid;   

/* end DoPushImmediateHandler */
/* start DoBranchTrue */

  /* Halfword 10 bit immediate instruction - DoBranchTrue */

dobranchtrue:
  if (_trace) printf("dobranchtrue:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchTrueIM:
  if (_trace) printf("DoBranchTrueIM:\n");

DoBranchTrueSP:
  if (_trace) printf("DoBranchTrueSP:\n");

DoBranchTrueLP:
  if (_trace) printf("DoBranchTrueLP:\n");

DoBranchTrueFP:
  if (_trace) printf("DoBranchTrueFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 != 0)   
    goto dobrpopelsepop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   
  goto cachevalid;   

dobrpopelsepop:
  if (_trace) printf("dobrpopelsepop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 8;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchTrue */
  /* End of Halfword operand from stack instruction - DoBranchTrue */
/* start DoBranchFalse */

  /* Halfword 10 bit immediate instruction - DoBranchFalse */

dobranchfalse:
  if (_trace) printf("dobranchfalse:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchFalseIM:
  if (_trace) printf("DoBranchFalseIM:\n");

DoBranchFalseSP:
  if (_trace) printf("DoBranchFalseSP:\n");

DoBranchFalseLP:
  if (_trace) printf("DoBranchFalseLP:\n");

DoBranchFalseFP:
  if (_trace) printf("DoBranchFalseFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 == 0) 
    goto dobrnpopelsepop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   
  goto cachevalid;   

dobrnpopelsepop:
  if (_trace) printf("dobrnpopelsepop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 8;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchFalse */
  /* End of Halfword operand from stack instruction - DoBranchFalse */
/* start DoReturnSingle */

  /* Halfword 10 bit immediate instruction - DoReturnSingle */

doreturnsingle:
  if (_trace) printf("doreturnsingle:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoReturnSingleIM:
  if (_trace) printf("DoReturnSingleIM:\n");

DoReturnSingleSP:
  if (_trace) printf("DoReturnSingleSP:\n");

DoReturnSingleLP:
  if (_trace) printf("DoReturnSingleLP:\n");

DoReturnSingleFP:
  if (_trace) printf("DoReturnSingleFP:\n");
  /* arg1 has operand preloaded. */
  /* Fetch value based on immediate, interleaved with compute disposition dispatch */
  arg5 = *(s32 *)&processor->control;   
  arg3 = arg6 << 26;   		// Clear cdr 
  t3 = (12) << 16;   
  t1 = *(u64 *)&(processor->niladdress);   
  arg3 = arg3 >> 26;   		// Clear cdr 
  t2 = *(u64 *)&(processor->taddress);   
  t3 = t3 & arg5;		// mask disposition bits 
  t3 = t3 >> 18;   		// shift disposition bits into place 
  arg6 = *(u64 *)&(processor->stackcachedata);   
  /* arg2 is 8 bits of "kludge operand" 0=TOS 40=NIL 41=T */
  if ((s64)arg2 > 0)   
    arg3 = t1;
  arg4 = t3 - 2;   		// arg4 -2=effect -1=value 0=return 1=multiple 
  if (arg2 & 1)   
   arg3 = t2;

returncommontail:
  if (_trace) printf("returncommontail:\n");
  /* Restore machine state from frame header. */
  t3 = *(s32 *)iFP;   
  t1 = (1792) << 16;   
  t5 = *(s32 *)&processor->continuation;   
  t1 = arg5 & t1;		// Mask 
  t2 = *(s32 *)(iFP + 4);   
  t7 = iCP;
  if (t1 != 0)   		// Need to cleanup frame first 
    goto returnsinglecleanup;
  t3 = (u32)t3;   
  t4 = *((s32 *)(&processor->continuation)+1);   
  t5 = (u32)t5;   
#ifdef IVERIFY
  /* check for instruction verification suite end-of-test */
  t6 = (s32)t2 - (s32)Type_NIL;   		// check for end of run 
  if (t6 == 0) 
    goto abandon-frame-simple14258;
#endif
  t6 = *(s32 *)(iFP + 8);   		// Get saved control register 
  /* TagType. */
  t2 = t2 & 63;
  /* Restore the PC. */
  if (arg4 == 0) 
    goto abandon-frame-simple14259;
  iPC = t5 << 1;   		// Assume even PC 
  t1 = t4 & 1;
  t7 = *(u64 *)&(processor->continuationcp);   
  iPC = iPC + t1;

abandon-frame-simple14259:
  if (_trace) printf("abandon-frame-simple14259:\n");
  /* Restore the saved continuation */
  *((u32 *)(&processor->continuation)+1) = t2;
  t1 = arg5 >> 9;   		// Get the caller frame size into place 
  *(u32 *)&processor->continuation = t3;
  iSP = iFP - 8;   		// Restore the stack pointer. 
  *(u64 *)&processor->continuationcp = zero;   
  t1 = t1 & 255;		// Mask just the caller frame size. 
  t1 = (t1 * 8) + 0;  		// *8 
  t2 = (2048) << 16;   
  t2 = t2 & arg5;
  t3 = *(s32 *)&processor->interruptreg;   		// Get the preempt-pending bit 
  t6 = t2 | t6;		// Sticky trace pending bit. 
  t4 = *(u64 *)&(processor->please_stop);   		// Get the trap/suspend bits 
  iFP = iFP - t1;   		// Restore the frame pointer. 
		/* Restore the control register */
  *(u32 *)&processor->control = t6;
  t1 = t6 & 255;		// extract the argument size 
  t3 = t3 & 1;
  t3 = t4 | t3;
  *(u64 *)&processor->stop_interpreter = t3;   
  iLP = (t1 * 8) + iFP;  		// Restore the local pointer. 

force-alignment14260:
  if (_trace) printf("force-alignment14260:\n");
  arg6 = ((u64)iFP < (u64)arg6) ? 1 : 0;   		// ARG6 = stack-cache underflow 
  /* arg4 -2=effect -1=value 0=return 1=multiple */
  if (arg4 == 0) 
    goto returnsinglereturn;
  if ((arg4 & 1) == 0)   
    goto returnsingleeffect;
  *(u64 *)(iSP + 8) = arg3;   
  iSP = iSP + 8;
  if ((s64)arg4 > 0)   
    goto returnsinglemultiple;

returnsingleeffect:
  if (_trace) printf("returnsingleeffect:\n");

returnsingledone:
  if (_trace) printf("returnsingledone:\n");
  if (arg6 != 0)   
    goto returnsingleunderflow;
  if (t7 == 0) 		// No prediction, validate cache 
    goto interpretinstructionforbranch;
  iCP = t7;
  goto INTERPRETINSTRUCTION;   

returnsinglemultiple:
  if (_trace) printf("returnsinglemultiple:\n");
  t8 = Type_Fixnum;		// Multiple-value group 
  t8 = t8 << 32;   
  iSP = iSP + 8;
  t8 = t8 | 1;
  *(u64 *)iSP = t8;   		// Push Fixnum 
  goto returnsingledone;   

returnsinglereturn:
  if (_trace) printf("returnsinglereturn:\n");
  if (arg2 != 0)   
    goto returnsingledone;
  *(u64 *)(iSP + 8) = arg3;   
  iSP = iSP + 8;
  goto returnsingledone;   

returnsinglecleanup:
  if (_trace) printf("returnsinglecleanup:\n");
  goto handleframecleanup;

returnsingleunderflow:
  if (_trace) printf("returnsingleunderflow:\n");
  goto stackcacheunderflowcheck;

/* end DoReturnSingle */
  /* End of Halfword operand from stack instruction - DoReturnSingle */
/* start callindirect */

  /*  */
  /*  */
  /* Fullword instruction - callindirect */
  /* ======================= */

callindirect:
  if (_trace) printf("callindirect:\n");

callindirectprefetch:
  if (_trace) printf("callindirectprefetch:\n");
  arg2 = (u32)arg3;   		// Get operand 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg3 = zero;		// No extra arg 
  /* Memory Read Internal */

vma-memory-read14261:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14263;

vma-memory-read14262:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read14265;

vma-memory-read14272:
  t5 = arg5 - Type_CompiledFunction;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto startcallagain;
  arg5 = Type_EvenPC;
  t7 = *((s32 *)(&processor->continuation)+1);   
  iSP = iSP + 16;		// prepare to push continuation/control register 
  t3 = *(s32 *)&processor->control;   
  t6 = Type_Fixnum+0xC0;
  t8 = *(s32 *)&processor->continuation;   
  t5 = (64) << 16;   
  t7 = t7 | 192;		// Set CDR code 3 
		/* push continuation */
  *(u32 *)(iSP + -8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + -4) = t7;
  t8 = t3 | t5;		// Set call started bit in CR 
  t5 = zero + 256;   
		/* Push control register */
  *(u32 *)iSP = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t6;
  t8 = t8 & ~t5;		// Clear the extra arg bit 
		/* Save control with new state */
  *(u32 *)&processor->control = t8;
  /* End of push-frame */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u32 *)&processor->continuation = arg6;
  *((u32 *)(&processor->continuation)+1) = arg5;
  *(u64 *)&processor->continuationcp = zero;   
  if (arg3 != 0)   
    goto callindirectextra;
  goto cachevalid;   

callindirectextra:
  if (_trace) printf("callindirectextra:\n");
  t1 = *(s32 *)&processor->control;   
  t2 = zero + 256;   
  t3 = arg3 & 63;		// set CDR-NEXT 
		/* Push the extra arg. */
  *(u32 *)(iSP + 8) = arg4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  t1 = t1 | t2;		// Set the extra arg bit 
		/* Save control with new state */
  *(u32 *)&processor->control = t1;
  goto cachevalid;   

vma-memory-read14265:
  if (_trace) printf("vma-memory-read14265:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14264;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14261;   

vma-memory-read14264:
  if (_trace) printf("vma-memory-read14264:\n");

vma-memory-read14263:
  if (_trace) printf("vma-memory-read14263:\n");
  r0 = (u64)&&return0456;
  goto memoryreaddatadecode;
return0456:
  goto vma-memory-read14272;   

/* end callindirect */
  /* End of Fullword instruction - callindirect */
  /* ============================== */
  /*  */
/* start DoFinishCallN */

  /* Halfword 10 bit immediate instruction - DoFinishCallN */

dofinishcalln:
  if (_trace) printf("dofinishcalln:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoFinishCallNIM:
  if (_trace) printf("DoFinishCallNIM:\n");

DoFinishCallNSP:
  if (_trace) printf("DoFinishCallNSP:\n");

DoFinishCallNLP:
  if (_trace) printf("DoFinishCallNLP:\n");

DoFinishCallNFP:
  if (_trace) printf("DoFinishCallNFP:\n");
  /* arg1 has operand preloaded. */
  /* arg2 contains the 8 bit N+1 */
  arg1 = (u8)(arg3 >> ((5&7)*8));   		// arg1 contains the disposition (two bits) 
  arg2 = (arg2 * 8) + zero;  		// convert N to words (stacked words that is) 

finishcallmerge:
  if (_trace) printf("finishcallmerge:\n");
  arg3 = arg3 >> 7;   
  t6 = *(s32 *)&processor->scovlimit;   		// Current stack cache limit (words) 
  t3 = zero + 128;   
  t4 = *(u64 *)&(processor->stackcachedata);   		// Alpha base of stack cache 
  t3 = (t3 * 8) + iSP;  		// SCA of desired end of cache 
  t4 = (t6 * 8) + t4;  		// SCA of current end of cache 
  t6 = ((s64)t3 <= (s64)t4) ? 1 : 0;   
  if (t6 == 0) 		// We're done if new SCA is within bounds 
    goto stack-cache-overflow-check14273;
  arg3 = arg3 & 8;		// 0 if not apply, 8 if apply 
  t1 = *(s32 *)&processor->control;   		// Get the control register 
  /* Compute the new LP */
  iLP = iSP + 8;   		// Assume not Apply case. 
  iLP = iLP - arg3;   		// For apply, iLP==iSP 
  /* Compute the new FP */
  t3 = t1 >> 5;   		// extra arg bit<<3 
  t2 = iSP - arg2;   
  t3 = t3 & 8;		// 8 if extra arg, 0 otherwise. 
  t2 = t2 - t3;   		// This! is the new frame pointer! 
  /* compute arg size */
  t4 = iLP - t2;   
  t4 = t4 >> 3;   		// arg size in words. 
  /* compute caller frame size. */
  t5 = t2 - iFP;   
  t5 = t5 >> 3;   		// caller frame size in words. 
  /* Now hack the control register! */
  t7 = arg1 << 18;   		// Get value disposition into place 
  t6 = *(u64 *)&(processor->fccrmask);   		// cr.caller-frame-size 
  t5 = t5 << 9;   		// Shift caller frame size into place 
  t7 = t7 | t4;		// Add arg size to new bits. 
  t4 = arg3 << 14;   		// Apply bit in place 
  t7 = t5 | t7;		// Add frame size to new bits 
  t7 = t4 | t7;		// All new bits assembled! 
  /* Set the return continuation. */
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   		// Next instruction hw format 
  t1 = t1 & t6;		// Mask off unwanted bits 
  t4 = *(s32 *)&processor->continuation;   		// Get the new PC tag/data 
  t1 = t1 | t7;		// Add argsize, apply, disposition, caller FS 
  t3 = *((s32 *)(&processor->continuation)+1);   
  /* Update the PC */
  /* Convert PC to a real continuation. */
  t6 = t5 & 1;
  t7 = t5 >> 1;   		// convert PC to a real word address. 
  t6 = t6 + Type_EvenPC;   
  t4 = (u32)t4;   
  /* Convert real continuation to PC. */
  iPC = t3 & 1;
  iPC = t4 + iPC;
  iPC = t4 + iPC;
  *(u32 *)&processor->continuation = t7;
		/* Set return address */
  *((u32 *)(&processor->continuation)+1) = t6;
  /* Update CP */
  t7 = (4096) << 16;   
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t7 = t7 & t1;
  t7 = t7 >> 1;   		// Shift into trace pending place 
  *(u64 *)&processor->continuationcp = t5;   
  t1 = t1 | t7;		// Set the cr.trace pending if appropriate. 
		/* Set the control register */
  *(u32 *)&processor->control = t1;
  iFP = t2;		// Install the new frame pointer 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  /* Check for stack overflow */
  t1 = t1 >> 30;   		// Isolate trap mode 
  t3 = *(s32 *)&processor->cslimit;   		// Limit for emulator mode 
  t4 = *(s32 *)&processor->csextralimit;   		// Limit for extra stack and higher modes 
  if (t1)   		// Get the right limit for the current trap mode 
    t3 = t4;
  t3 = (u32)t3;   		// Might have been sign extended 
  /* Convert stack cache address to VMA */
  t4 = *(u64 *)&(processor->stackcachedata);   
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t4 = iSP - t4;   		// stack cache base relative offset 
  t4 = t4 >> 3;   		// convert byte address to word address 
  t1 = t4 + t1;		// reconstruct VMA 
  t4 = ((s64)t1 < (s64)t3) ? 1 : 0;   		// Check for overflow 
  if (t4 == 0) 		// Jump if overflow 
    goto stackoverflow;
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  /* Begin execution at the computed address */
  goto interpretinstructionforbranch;   

stack-cache-overflow-check14273:
  if (_trace) printf("stack-cache-overflow-check14273:\n");
  arg2 = 0;
  goto stackcacheoverflowhandler;   

/* end DoFinishCallN */
  /* End of Halfword operand from stack instruction - DoFinishCallN */
/* start DoEntryRestNotAccepted */

  /* Field Extraction instruction - DoEntryRestNotAccepted */

doentryrestnotaccepted:
  if (_trace) printf("doentryrestnotaccepted:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoEntryRestNotAcceptedIM:
  if (_trace) printf("DoEntryRestNotAcceptedIM:\n");

DoEntryRestNotAcceptedSP:
  if (_trace) printf("DoEntryRestNotAcceptedSP:\n");

DoEntryRestNotAcceptedLP:
  if (_trace) printf("DoEntryRestNotAcceptedLP:\n");

DoEntryRestNotAcceptedFP:
  if (_trace) printf("DoEntryRestNotAcceptedFP:\n");
  arg5 = *(s32 *)&processor->control;   		// The control register 
  arg4 = arg3 >> 18;   		// Pull down the number of optionals 
  arg1 = (u8)(arg3 >> ((5&7)*8));   		// Extract the 'ptr' field while we are waiting 
  arg4 = arg4 & 255;
  /* arg1=ptr field, arg2=required, arg3=instn, arg4=optionals arg5=control-register */
  t2 = arg5 >> 27;   		// Get the cr.trace-pending bit 
  t1 = arg5 & 255;		// The supplied args 
  if (t2 & 1)   
    goto tracetrap;
  t3 = arg5 >> 17;   
  t4 = *(s32 *)(iSP + 4);   		// Get the tag of the stack top. 

force-alignment14276:
  if (_trace) printf("force-alignment14276:\n");
  if (t3 & 1)   		// J. if apply args 
    goto b-apply-argument-supplied14274;

b-apply-argument-supplied14275:
  t2 = t1 - arg2;   		// t2=supplied-minimum 
  if ((s64)t2 < 0)   		// B. if too few args. 
    goto retryernatoofew;
  arg1 = arg4 - t1;   		// maximum-supplied 
  if ((s64)arg1 < 0)   		// B. if too many args. 
    goto retryernatoomany;
  /* Compute entry position and advance PC/CP accordingly. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   		// get the next PC 
  t3 = t2 << 1;   		// Adjust index to halfword 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t2 == 0) 		// J. if index zero, no adjustment. 
    goto INTERPRETINSTRUCTION;
  iPC = iPC + t3;		// Compute the new address 
  iPC = iPC & ~1L;		// Make it an DTP-EVEN-PC 
  goto interpretinstructionforjump;   

applysupprna:
  if (_trace) printf("applysupprna:\n");
  arg1 = arg4 - t1;   
  if ((s64)arg1 <= 0)  		// B. if too many args. 
    goto retryernatoomany;
  goto pullapplyargs;   

retryernatoomany:
  if (_trace) printf("retryernatoomany:\n");
  arg5 = 0;
  arg2 = 78;
  goto illegaloperand;

retryernatoofew:
  if (_trace) printf("retryernatoofew:\n");
  arg5 = 0;
  arg2 = 77;
  goto illegaloperand;

b-apply-argument-supplied14274:
  if (_trace) printf("b-apply-argument-supplied14274:\n");
  t4 = t4 & 63;
  t4 = t4 - Type_NIL;   
  if (t4 != 0)   		// J. if apply args supplied not nil. 
    goto applysupprna;
  t3 = t3 & 1;		// keep just the apply bit! 
  t3 = t3 << 17;   		// reposition the apply bit 
  iSP = iSP - 8;   		// Pop off the null applied arg. 
  arg5 = arg5 & ~t3;		// Blast the apply arg bit away 
		/* Reset the stored cr bit */
  *(u32 *)&processor->control = arg5;
  goto b-apply-argument-supplied14275;   

/* end DoEntryRestNotAccepted */
  /* End of Halfword operand from stack instruction - DoEntryRestNotAccepted */
/* start VerifyGenericArity */


verifygenericarity:
  if (_trace) printf("verifygenericarity:\n");
  t11 = (2) << 16;   
  t11 = t11 & arg2;
  if (t11 == 0) 		// not applying 
    goto verify-generic-arity14277;
  arg1 = zero - arg5;   		// 4 - argsize 
  goto pullapplyargs;   

verify-generic-arity14277:
  if (_trace) printf("verify-generic-arity14277:\n");
  arg5 = 0;
  arg2 = 77;
  goto illegaloperand;

/* end VerifyGenericArity */
/* start PullApplyArgs */


pullapplyargs:
  if (_trace) printf("pullapplyargs:\n");
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t2 = *(s32 *)iSP;   
  t1 = *(s32 *)(iSP + 4);   
  t2 = (u32)t2;   
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t5 = (t4 == Type_List) ? 1 : 0;   

force-alignment14306:
  if (_trace) printf("force-alignment14306:\n");
  if (t5 == 0) 
    goto basic-dispatch14280;
  /* Here if argument TypeList */
  t5 = t2 - arg5;   		// Stack cache offset 
  t6 = ((u64)t5 < (u64)arg6) ? 1 : 0;   		// In range? 
  t4 = *(u64 *)&(processor->stackcachedata);   
  if (t6 == 0) 		// J. if not in cache 
    goto pull-apply-args14278;
  t4 = (t5 * 8) + t4;  		// reconstruct SCA 
  t7 = zero;
  t5 = zero + 128;   
  t6 = *(u64 *)&(processor->stackcachedata);   		// Alpha base of stack cache 
  t5 = t5 + arg1;		// Account for what we're about to push 
  t5 = (t5 * 8) + iSP;  		// SCA of desired end of cache 
  t6 = (arg6 * 8) + t6;  		// SCA of current end of cache 
  t10 = ((s64)t5 <= (s64)t6) ? 1 : 0;   
  if (t10 == 0) 		// We're done if new SCA is within bounds 
    goto stack-cache-overflow-check14287;
  iSP = iSP - 8;   		// Pop Stack. 
  goto pull-apply-args-quickly14286;   

pull-apply-args-quickly14281:
  if (_trace) printf("pull-apply-args-quickly14281:\n");
  t9 = *(s32 *)t4;   
  t8 = *(s32 *)(t4 + 4);   
  t9 = (u32)t9;   
  t7 = t7 + 1;
  t4 = t4 + 8;
  t5 = t8 & 192;		// Extract CDR code. 
  if (t5 != 0)   
    goto basic-dispatch14289;
  /* Here if argument 0 */
  t5 = t8 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  t5 = (t7 == arg1) ? 1 : 0;   
  if (t5 == 0) 
    goto pull-apply-args-quickly14281;
  goto pull-apply-args-quickly14282;   

basic-dispatch14289:
  if (_trace) printf("basic-dispatch14289:\n");
  t6 = (t5 == 64) ? 1 : 0;   

force-alignment14301:
  if (_trace) printf("force-alignment14301:\n");
  if (t6 == 0) 
    goto basic-dispatch14290;
  /* Here if argument 64 */
  t5 = t8 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;

pull-apply-args-quickly14284:
  if (_trace) printf("pull-apply-args-quickly14284:\n");
  t5 = *(s32 *)&processor->control;   
  t6 = t5 & 255;		// Get current arg size. 
  t5 = t5 & ~255L;
  t6 = t6 + t7;
  t5 = t6 + t5;		// Update the arg size 
  t6 = (2) << 16;   
  t5 = t5 & ~t6;		// turn off cr.apply 
  *(u32 *)&processor->control = t5;
  iLP = (t7 * 8) + iLP;  
  goto INTERPRETINSTRUCTION;   

basic-dispatch14290:
  if (_trace) printf("basic-dispatch14290:\n");
  t6 = (t5 == 128) ? 1 : 0;   

force-alignment14302:
  if (_trace) printf("force-alignment14302:\n");
  if (t6 == 0) 
    goto basic-dispatch14291;
  /* Here if argument 128 */
  t5 = t8 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  t11 = *(s32 *)t4;   
  t10 = *(s32 *)(t4 + 4);   
  t11 = (u32)t11;   
  t5 = t10 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_List) ? 1 : 0;   

force-alignment14297:
  if (_trace) printf("force-alignment14297:\n");
  if (t6 == 0) 
    goto basic-dispatch14293;
  /* Here if argument TypeList */
  t5 = t11 - arg5;   		// Stack cache offset 
  t6 = ((u64)t5 < (u64)arg6) ? 1 : 0;   		// In range? 
  t4 = *(u64 *)&(processor->stackcachedata);   
  if (t6 == 0) 		// J. if not in cache 
    goto pull-apply-args-quickly14283;
  t4 = (t5 * 8) + t4;  		// reconstruct SCA 
  goto pull-apply-args-quickly14286;   

basic-dispatch14293:
  if (_trace) printf("basic-dispatch14293:\n");
  t6 = (t5 == Type_NIL) ? 1 : 0;   

force-alignment14298:
  if (_trace) printf("force-alignment14298:\n");
  if (t6 == 0) 
    goto basic-dispatch14294;
  /* Here if argument TypeNIL */
  goto pull-apply-args-quickly14284;   

basic-dispatch14294:
  if (_trace) printf("basic-dispatch14294:\n");
  /* Here for all other cases */

pull-apply-args-quickly14283:
  if (_trace) printf("pull-apply-args-quickly14283:\n");
  t5 = t10 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t11;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto pull-apply-args-quickly14285;   

basic-dispatch14292:
  if (_trace) printf("basic-dispatch14292:\n");

basic-dispatch14291:
  if (_trace) printf("basic-dispatch14291:\n");
  /* Here for all other cases */
  t7 = t7 - 1;   
  t4 = t4 - 8;   
  goto pull-apply-args-quickly14282;   

basic-dispatch14288:
  if (_trace) printf("basic-dispatch14288:\n");

pull-apply-args-quickly14286:
  t5 = (t7 == arg1) ? 1 : 0;   
  if (t5 == 0) 
    goto pull-apply-args-quickly14281;

pull-apply-args-quickly14282:
  if (_trace) printf("pull-apply-args-quickly14282:\n");
  /* Here if count=n, or bad cdr */
  /* Convert stack cache address to VMA */
  t5 = *(u64 *)&(processor->stackcachedata);   
  t5 = t4 - t5;   		// stack cache base relative offset 
  t5 = t5 >> 3;   		// convert byte address to word address 
  t9 = t5 + arg5;		// reconstruct VMA 
  t5 = Type_List;
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;

pull-apply-args-quickly14285:
  if (_trace) printf("pull-apply-args-quickly14285:\n");
  t5 = *(s32 *)&processor->control;   
  t6 = t5 & 255;		// Get current arg size. 
  t5 = t5 & ~255L;
  t6 = t6 + t7;
  t5 = t6 + t5;		// Update the arg size 
  *(u32 *)&processor->control = t5;
  iLP = (t7 * 8) + iLP;  
  arg1 = arg1 - t7;   
  if ((s64)arg1 <= 0)  
    goto INTERPRETINSTRUCTION;
  goto pullapplyargsslowly;

basic-dispatch14280:
  if (_trace) printf("basic-dispatch14280:\n");
  t5 = (t4 == Type_NIL) ? 1 : 0;   

force-alignment14307:
  if (_trace) printf("force-alignment14307:\n");
  if (t5 == 0) 
    goto basic-dispatch14303;
  /* Here if argument TypeNIL */
  t6 = *(s32 *)&processor->control;   		// Get the control register 
  t7 = (2) << 16;   
  iSP = iSP - 8;   		// Discard that silly nil 
  t6 = t6 & ~t7;		// Blast away the apply arg bit. 
  *(u32 *)&processor->control = t6;
  goto INTERPRETINSTRUCTION;   

basic-dispatch14303:
  if (_trace) printf("basic-dispatch14303:\n");
  /* Here for all other cases */
  arg1 = arg1;		// Pull apply args trap needs nargs in ARG1 
  goto pullapplyargstrap;

pull-apply-args14278:
  if (_trace) printf("pull-apply-args14278:\n");
  arg1 = arg1;
  goto pullapplyargsslowly;

basic-dispatch14279:
  if (_trace) printf("basic-dispatch14279:\n");

stack-cache-overflow-check14287:
  if (_trace) printf("stack-cache-overflow-check14287:\n");
  arg2 = arg1;
  goto stackcacheoverflowhandler;   

/* end PullApplyArgs */
/* start valuecell */

  /*  */
  /*  */
  /* Fullword instruction - valuecell */
  /* ======================= */

valuecell:
  if (_trace) printf("valuecell:\n");
  arg2 = (u32)arg3;   		// Get address 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read14308:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14310;

vma-memory-read14309:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read14312;

vma-memory-read14319:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t3 = arg5 & 63;		// set CDR-NEXT 
		/* Push the result */
  *(u32 *)(iSP + 8) = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  goto cachevalid;   

vma-memory-read14312:
  if (_trace) printf("vma-memory-read14312:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14311;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14308;   

vma-memory-read14311:
  if (_trace) printf("vma-memory-read14311:\n");

vma-memory-read14310:
  if (_trace) printf("vma-memory-read14310:\n");
  r0 = (u64)&&return0457;
  goto memoryreaddatadecode;
return0457:
  goto vma-memory-read14319;   

/* end valuecell */
  /* End of Fullword instruction - valuecell */
  /* ============================== */
  /*  */
/* start pushconstantvalue */

  /*  */
  /*  */
  /* Fullword instruction - pushconstantvalue */
  /* ======================= */

pushconstantvalue:
  if (_trace) printf("pushconstantvalue:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)(iSP + 8) = arg3;   
  iSP = iSP + 8;
  goto cachevalid;   

/* end pushconstantvalue */
  /* End of Fullword instruction - pushconstantvalue */
  /* ============================== */
  /*  */
/* start DoZerop */

  /* Halfword operand from stack instruction - DoZerop */
  /* arg2 has the preloaded 8 bit operand. */

dozerop:
  if (_trace) printf("dozerop:\n");

DoZeropSP:
  if (_trace) printf("DoZeropSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoZeropLP:
  if (_trace) printf("DoZeropLP:\n");

DoZeropFP:
  if (_trace) printf("DoZeropFP:\n");

begindozerop:
  if (_trace) printf("begindozerop:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->niladdress);   
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t1 = *(s32 *)(arg1 + 4);   
  t12 = *(u64 *)&(processor->taddress);   
  t2 = *(s32 *)arg1;   
  LDS(1, f1, *(u32 *)arg1 );   
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t5 = (t4 == Type_Fixnum) ? 1 : 0;   

force-alignment14325:
  if (_trace) printf("force-alignment14325:\n");
  if (t5 == 0) 
    goto basic-dispatch14321;
  /* Here if argument TypeFixnum */
  iPC = t6;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t2 == 0)   		// T if predicate succeeds 
    t11 = t12;
  *(u64 *)(iSP + 8) = t11;   
  iSP = iSP + 8;
  goto cachevalid;   

basic-dispatch14321:
  if (_trace) printf("basic-dispatch14321:\n");
  t5 = (t4 == Type_SingleFloat) ? 1 : 0;   

force-alignment14326:
  if (_trace) printf("force-alignment14326:\n");
  if (t5 == 0) 
    goto basic-dispatch14322;
  /* Here if argument TypeSingleFloat */
  iPC = t6;
  *(u64 *)(iSP + 8) = t12;   
  iSP = iSP + 8;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (FLTU64(1, f1) == 0.0)   
    goto cachevalid;
  *(u64 *)iSP = t11;   		// Didn't branch, answer is NIL 
  goto cachevalid;   

basic-dispatch14322:
  if (_trace) printf("basic-dispatch14322:\n");
  /* Here for all other cases */
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto unarynumericexception;

basic-dispatch14320:
  if (_trace) printf("basic-dispatch14320:\n");

DoZeropIM:
  if (_trace) printf("DoZeropIM:\n");
  t2 = *(u64 *)&(processor->taddress);   
  iSP = iSP + 8;
  t1 = *(u64 *)&(processor->niladdress);   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (arg2 == 0)   
    t1 = t2;
  *(u64 *)iSP = t1;   		// yes Virginia, we dual issue with above yahoo 
  goto cachevalid;   

/* end DoZerop */
  /* End of Halfword operand from stack instruction - DoZerop */
/* start DoSetSpToAddress */

  /* Halfword operand from stack instruction - DoSetSpToAddress */
  /* arg2 has the preloaded 8 bit operand. */

dosetsptoaddress:
  if (_trace) printf("dosetsptoaddress:\n");

DoSetSpToAddressSP:
  if (_trace) printf("DoSetSpToAddressSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoSetSpToAddressLP:
  if (_trace) printf("DoSetSpToAddressLP:\n");

DoSetSpToAddressFP:
  if (_trace) printf("DoSetSpToAddressFP:\n");

begindosetsptoaddress:
  if (_trace) printf("begindosetsptoaddress:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = arg1;		// Set iSP=address of operand 
  goto cachevalid;   

DoSetSpToAddressIM:
  goto doistageerror;

/* end DoSetSpToAddress */
  /* End of Halfword operand from stack instruction - DoSetSpToAddress */
/* start DoEq */

  /* Halfword operand from stack instruction - DoEq */
  /* arg2 has the preloaded 8 bit operand. */

doeq:
  if (_trace) printf("doeq:\n");

DoEqSP:
  if (_trace) printf("DoEqSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoeq;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoEqLP:
  if (_trace) printf("DoEqLP:\n");

DoEqFP:
  if (_trace) printf("DoEqFP:\n");

begindoeq:
  if (_trace) printf("begindoeq:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->niladdress);   
  arg3 = arg3 >> 12;   
  t12 = *(u64 *)&(processor->taddress);   
  arg1 = *(u64 *)arg1;   		// load op2 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  arg3 = arg3 & 1;		// 1 if no-pop, 0 if pop 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t3 = arg6 ^ arg1;   		// compare tag and data 
  t3 = t3 << 26;   		// shift off the cdr code 
  iSP = (arg3 * 8) + iSP;  		// Either a stack-push or a stack-write 
  if (t3 == 0)   		// pick up T or NIL 
    t11 = t12;
  *(u64 *)iSP = t11;   
  goto cachevalid;   

/* end DoEq */
  /* End of Halfword operand from stack instruction - DoEq */
/* start DoAref1 */

  /* Halfword operand from stack instruction - DoAref1 */
  /* arg2 has the preloaded 8 bit operand. */

doaref1:
  if (_trace) printf("doaref1:\n");

DoAref1SP:
  if (_trace) printf("DoAref1SP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto headdoaref1;
  arg1 = arg6;		// SP-pop mode, TOS->arg1 
  arg6 = *(u64 *)arg4;   		// Reload TOS 
  iSP = arg4;		// Adjust SP 
  goto begindoaref1;   

DoAref1LP:
  if (_trace) printf("DoAref1LP:\n");

DoAref1FP:
  if (_trace) printf("DoAref1FP:\n");

headdoaref1:
  if (_trace) printf("headdoaref1:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoaref1:
  if (_trace) printf("begindoaref1:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg3 = (u32)(arg6 >> ((4&7)*8));   
  arg4 = (u32)arg6;   		// Get the array tag/data 
  arg2 = (s32)arg1 + (s32)0;		// (sign-extended, for fast bounds check) Index Data 
  t8 = zero + AutoArrayRegMask;   
  t8 = arg4 & t8;
  arg1 = arg1 >> 32;   		// Index Tag 
  t7 = (u64)&processor->ac0array;   
  t7 = t7 + t8;		// This is the address if the array register block. 
  t1 = arg1 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto aref1illegal;

aref1merge:
  if (_trace) printf("aref1merge:\n");
  if (arg4 == 0) 
    goto aref1regset;
  t8 = *(u64 *)&(((ARRAYCACHEP)t7)->array);   		// Cached array object. 
  t1 = arg3 - Type_Array;   
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto reallyaref1exc;
  t8 = (arg4 == t8) ? 1 : 0;   		// t8==1 iff cached array is ours. 
  if (t8 == 0) 		// Go and setup the array register. 
    goto aref1regset;
#ifdef SLOWARRAYS
  goto aref1regset;   
#endif
  arg6 = *(u64 *)&(((ARRAYCACHEP)t7)->arword);   
  t9 = *(u64 *)&(((ARRAYCACHEP)t7)->locat);   		// high order bits all zero 
  t3 = *(u64 *)&(((ARRAYCACHEP)t7)->length);   		// high order bits all zero 
  t5 = arg6 << 42;   
  t4 = *(u64 *)&(processor->areventcount);   
  t5 = t5 >> 42;   
  t2 = ((u64)arg2 < (u64)t3) ? 1 : 0;   
  t6 = t4 - t5;   
  if (t6 != 0)   		// J. if event count ticked. 
    goto aref1regset;
  if (t2 == 0) 
    goto aref1bounds;
  arg5 = arg6 >> (Array_RegisterBytePackingPos & 63);   
  arg4 = arg6 >> (Array_RegisterByteOffsetPos & 63);   
  t8 = arg6 >> (Array_RegisterElementTypePos & 63);   
  arg4 = arg4 & Array_RegisterByteOffsetMask;
  arg5 = arg5 & Array_RegisterBytePackingMask;
  arg6 = t8 & Array_RegisterElementTypeMask;

aref1restart:
  if (_trace) printf("aref1restart:\n");
  if (arg5 != 0)   
    goto new-aref-1-internal14327;
  t1 = t9 + arg2;

new-aref-1-internal14328:
  if (_trace) printf("new-aref-1-internal14328:\n");
  /* Memory Read Internal */

vma-memory-read14335:
  t2 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t5 = t1 + ivory;
  t3 = *(s32 *)&processor->scovlimit;   
  t9 = (t5 * 4);   
  arg3 = LDQ_U(t5);   
  t2 = t1 - t2;   		// Stack cache offset 
  t6 = *(u64 *)&(processor->dataread_mask);   
  t3 = ((u64)t2 < (u64)t3) ? 1 : 0;   		// In range? 
  t9 = *(s32 *)t9;   
  arg3 = (u8)(arg3 >> ((t5&7)*8));   
  if (t3 != 0)   
    goto vma-memory-read14337;

vma-memory-read14336:
  t5 = zero + 240;   
  t6 = t6 >> (arg3 & 63);   
  t5 = t5 >> (arg3 & 63);   
  t9 = (u32)t9;   
  if (t6 & 1)   
    goto vma-memory-read14339;

vma-memory-read14346:
  if (arg5 != 0)   
    goto new-aref-1-internal14329;

new-aref-1-internal14330:
  if (_trace) printf("new-aref-1-internal14330:\n");
  r31 = r31 | r31;
  t1 = arg6 - 2;   
  if ((s64)t1 <= 0)  
    goto new-aref-1-internal14331;
  /* TagType. */
  arg3 = arg3 & 63;

new-aref-1-internal14332:
  if (_trace) printf("new-aref-1-internal14332:\n");
  *(u32 *)(iSP + 4) = arg3;
  t5 = (arg5 == 0) ? 1 : 0;   
  if (t5 == 0) 
    goto case_others_98;

case_0_92:
  if (_trace) printf("case_0_92:\n");
  r31 = r31 | r31;
  if (t1 == 0) 
    goto new-aref-1-internal14333;
  *(u32 *)iSP = t9;
  goto NEXTINSTRUCTION;   

case_2_93:
  if (_trace) printf("case_2_93:\n");
  /* AREF1-8B */
  r31 = r31 | r31;
  t5 = arg2 & 3;
  t6 = (u8)(t9 >> ((t5&7)*8));   
  if (t1 == 0) 
    goto new-aref-1-internal14333;
  *(u32 *)iSP = t6;
  goto NEXTINSTRUCTION;   

case_3_94:
  if (_trace) printf("case_3_94:\n");
  /* AREF1-4B */
  r31 = r31 | r31;
  t5 = arg2 & 7;		// byte-index 
  t5 = t5 << 2;   		// byte-position 
  t6 = t9 >> (t5 & 63);   		// byte in position 
  t6 = t6 & 15;		// byte masked 
  if (t1 == 0) 
    goto new-aref-1-internal14333;
  *(u32 *)iSP = t6;
  goto NEXTINSTRUCTION;   

case_5_95:
  if (_trace) printf("case_5_95:\n");
  /* AREF1-1B */
  r31 = r31 | r31;
  t5 = arg2 & 31;		// byte-index 
  r31 = r31 | r31;
  t6 = t9 >> (t5 & 63);   		// byte in position 
  t6 = t6 & 1;		// byte masked 
  if (t1 == 0) 
    goto new-aref-1-internal14333;
  *(u32 *)iSP = t6;
  goto NEXTINSTRUCTION;   

case_1_96:
  if (_trace) printf("case_1_96:\n");
  /* AREF1-16B */
  t5 = arg2 & 1;
  t5 = t5 + t5;		// Bletch, it's a byte ref 
  t6 = (u16)(t9 >> ((t5&7)*8));   
  if (t1 == 0) 
    goto new-aref-1-internal14333;
  *(u32 *)iSP = t6;
  goto NEXTINSTRUCTION;   

case_others_98:
  if (_trace) printf("case_others_98:\n");
  r31 = r31 | r31;
  t5 = (arg5 == 2) ? 1 : 0;   
  t6 = (arg5 == 3) ? 1 : 0;   
  if (t5 != 0)   
    goto case_2_93;
  t5 = (arg5 == 5) ? 1 : 0;   
  if (t6 != 0)   
    goto case_3_94;
  t6 = (arg5 == 1) ? 1 : 0;   
  if (t5 != 0)   
    goto case_5_95;
  if (t6 != 0)   
    goto case_1_96;

case_4_97:
  if (_trace) printf("case_4_97:\n");
  /* AREF1-2B */
  r31 = r31 | r31;
  t5 = arg2 & 15;		// byte-index 
  t5 = t5 << 1;   		// byte-position 
  t6 = t9 >> (t5 & 63);   		// byte in position 
  t6 = t6 & 3;		// byte masked 
  if (t1 == 0) 
    goto new-aref-1-internal14333;
  *(u32 *)iSP = t6;
  goto NEXTINSTRUCTION;   

new-aref-1-internal14327:
  if (_trace) printf("new-aref-1-internal14327:\n");
  arg2 = arg4 + arg2;
  t1 = arg2 >> (arg5 & 63);   		// Convert byte index to word index 
  t1 = t1 + t9;		// Address of word containing byte 
  goto new-aref-1-internal14328;   

new-aref-1-internal14329:
  if (_trace) printf("new-aref-1-internal14329:\n");
  t1 = arg3 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto new-aref-1-internal14334;
  goto new-aref-1-internal14330;   

new-aref-1-internal14331:
  if (_trace) printf("new-aref-1-internal14331:\n");
  arg3 = Type_Character;
  if (arg6 & 1)   
    goto new-aref-1-internal14332;
  arg3 = Type_Fixnum;
  if (arg6 == 0) 
    goto new-aref-1-internal14332;
  t2 = *(u64 *)&(processor->niladdress);   
  t3 = *(u64 *)&(processor->taddress);   
  goto new-aref-1-internal14332;   

new-aref-1-internal14333:
  if (_trace) printf("new-aref-1-internal14333:\n");
  if (t6)   
    t2 = t3;
  *(u64 *)iSP = t2;   
  goto NEXTINSTRUCTION;   

new-aref-1-internal14334:
  if (_trace) printf("new-aref-1-internal14334:\n");
  arg5 = t1;
  arg2 = 25;
  goto illegaloperand;

DoAref1IM:
  if (_trace) printf("DoAref1IM:\n");
  t8 = zero + AutoArrayRegMask;   
  arg4 = *(s32 *)iSP;   		// Get the array tag/data 
  arg3 = *(s32 *)(iSP + 4);   
  arg4 = (u32)arg4;   
  t7 = (u64)&processor->ac0array;   
  t8 = arg4 & t8;
  t7 = t7 + t8;		// This is the address of the array register block. 
  goto aref1merge;   

vma-memory-read14337:
  if (_trace) printf("vma-memory-read14337:\n");
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = (t2 * 8) + t3;  		// reconstruct SCA 
  t9 = *(s32 *)t2;   
  arg3 = *(s32 *)(t2 + 4);   		// Read from stack cache 
  goto vma-memory-read14336;   

vma-memory-read14339:
  if (_trace) printf("vma-memory-read14339:\n");
  if ((t5 & 1) == 0)   
    goto vma-memory-read14338;
  t1 = (u32)t9;   		// Do the indirect thing 
  goto vma-memory-read14335;   

vma-memory-read14338:
  if (_trace) printf("vma-memory-read14338:\n");
  t6 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t5 = arg3 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t5 = (t5 * 4) + t6;   		// Adjust for a longword load 
  t6 = *(s32 *)t5;   		// Get the memory action 

vma-memory-read14343:
  if (_trace) printf("vma-memory-read14343:\n");
  t5 = t6 & MemoryActionTransform;
  if (t5 == 0) 
    goto vma-memory-read14342;
  arg3 = arg3 & ~63L;
  arg3 = arg3 | Type_ExternalValueCellPointer;
  goto vma-memory-read14346;   

vma-memory-read14342:

vma-memory-read14341:
  /* Perform memory action */
  arg1 = t6;
  arg2 = 0;
  goto performmemoryaction;

/* end DoAref1 */
  /* End of Halfword operand from stack instruction - DoAref1 */
/* start DoTypeMember */

  /* Halfword 10 bit immediate instruction - DoTypeMember */

dotypemember:
  if (_trace) printf("dotypemember:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoTypeMemberIM:
  if (_trace) printf("DoTypeMemberIM:\n");

DoTypeMemberSP:
  if (_trace) printf("DoTypeMemberSP:\n");

DoTypeMemberLP:
  if (_trace) printf("DoTypeMemberLP:\n");

DoTypeMemberFP:
  if (_trace) printf("DoTypeMemberFP:\n");
  /* arg1 has operand preloaded. */
  t6 = arg3 >> 6;   		// Position the opcode 
  t4 = *(u64 *)&(processor->taddress);   
  arg4 = *(s32 *)(iSP + 4);   		// get op1's tag 
  t1 = 1;
  t5 = *(u64 *)&(processor->niladdress);   
  t7 = arg3 >> 12;   		// Get pop-bit while stalled 
  arg1 = t6 & 60;		// Get field-number*4 from the opcode 
  /* TagType. */
  arg4 = arg4 & 63;		// Strip off CDR code. 
  t1 = t1 << (arg4 & 63);   		// T1 is type type code bit position. 
  t7 = t7 & 1;		// Pop bit 
  t2 = arg2 << (arg1 & 63);   		// t2 is the mask. 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = (t7 * 8) + iSP;  
  t3 = t2 & t1;		// t3 is the result. 

force-alignment14347:
  if (_trace) printf("force-alignment14347:\n");
  if (t3)   
    t5 = t4;
  *(u64 *)iSP = t5;   
  goto cachevalid;   

/* end DoTypeMember */
  /* End of Halfword operand from stack instruction - DoTypeMember */
/* start DoPointerPlus */

  /* Halfword operand from stack instruction - DoPointerPlus */
  /* arg2 has the preloaded 8 bit operand. */

dopointerplus:
  if (_trace) printf("dopointerplus:\n");

DoPointerPlusSP:
  if (_trace) printf("DoPointerPlusSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindopointerplus;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoPointerPlusLP:
  if (_trace) printf("DoPointerPlusLP:\n");

DoPointerPlusFP:
  if (_trace) printf("DoPointerPlusFP:\n");

begindopointerplus:
  if (_trace) printf("begindopointerplus:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t2 = *(s32 *)arg1;   		// Get the data of op2 
  t3 = (s32)arg6 + (s32)t2;		// (%32-bit-plus (data arg1) (data arg2)) 
		/* Put result back on the stack */
  *(u32 *)iSP = t3;
  goto cachevalid;   

DoPointerPlusIM:
  if (_trace) printf("DoPointerPlusIM:\n");
  t2 = arg2 << 56;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t2 = (s64)t2 >> 56;   

force-alignment14348:
  if (_trace) printf("force-alignment14348:\n");
  t3 = (s32)arg6 + (s32)t2;		// (%32-bit-plus (data arg1) (data arg2)) 
		/* Put result back on the stack */
  *(u32 *)iSP = t3;
  goto cachevalid;   

/* end DoPointerPlus */
  /* End of Halfword operand from stack instruction - DoPointerPlus */
/* start DoLdb */

  /* Field Extraction instruction - DoLdb */

doldb:
  if (_trace) printf("doldb:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoLdbIM:
  if (_trace) printf("DoLdbIM:\n");

DoLdbSP:
  if (_trace) printf("DoLdbSP:\n");

DoLdbLP:
  if (_trace) printf("DoLdbLP:\n");

DoLdbFP:
  if (_trace) printf("DoLdbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  arg3 = (u32)(arg6 >> ((4&7)*8));   
  arg4 = (u32)arg6;   		// get ARG1 tag/data 
  /* TagType. */
  t8 = arg3 & 63;
  t9 = t8 - Type_Fixnum;   
  t3 = arg4 << (arg2 & 63);   		// Shift ARG1 left to get new high bits 
  if (t9 != 0)   		// Not a fixnum 
    goto ldbexception;
  t7 = zero + -2;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t6 = (u32)(t3 >> ((4&7)*8));   		// Get new low bits 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t7 = t7 << (arg1 & 63);   		// Unmask 
  t3 = t3 | t6;		// Glue two parts of shifted operand together 
		/* T8 is TypeFixnum from above */
  *(u32 *)(iSP + 4) = t8;
  t3 = t3 & ~t7;		// T3= masked value. 
  *(u32 *)iSP = t3;
  goto cachevalid;   

/* end DoLdb */
  /* End of Halfword operand from stack instruction - DoLdb */
/* start DoSetSpToAddressSaveTos */

  /* Halfword operand from stack instruction - DoSetSpToAddressSaveTos */
  /* arg2 has the preloaded 8 bit operand. */

dosetsptoaddresssavetos:
  if (_trace) printf("dosetsptoaddresssavetos:\n");

DoSetSpToAddressSaveTosSP:
  if (_trace) printf("DoSetSpToAddressSaveTosSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindosetsptoaddresssavetos;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoSetSpToAddressSaveTosLP:
  if (_trace) printf("DoSetSpToAddressSaveTosLP:\n");

DoSetSpToAddressSaveTosFP:
  if (_trace) printf("DoSetSpToAddressSaveTosFP:\n");

begindosetsptoaddresssavetos:
  if (_trace) printf("begindosetsptoaddresssavetos:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = arg1;		// Set the stack top as specified. 
  *(u64 *)arg1 = arg6;   		// Restore the TOS. 
  goto cachevalid;   

DoSetSpToAddressSaveTosIM:
  goto doistageerror;

/* end DoSetSpToAddressSaveTos */
  /* End of Halfword operand from stack instruction - DoSetSpToAddressSaveTos */
/* start DoPop */

  /* Halfword operand from stack instruction - DoPop */
  /* arg2 has the preloaded 8 bit operand. */

dopop:
  if (_trace) printf("dopop:\n");

DoPopSP:
  if (_trace) printf("DoPopSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindopop;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoPopLP:
  if (_trace) printf("DoPopLP:\n");

DoPopFP:
  if (_trace) printf("DoPopFP:\n");

begindopop:
  if (_trace) printf("begindopop:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   		// Pop Stack. 
  *(u64 *)arg1 = arg6;   		// Store all 40 bits on stack 
  goto cachevalid;   

DoPopIM:
  goto doistageerror;

/* end DoPop */
  /* End of Halfword operand from stack instruction - DoPop */
/* start DoMovem */

  /* Halfword operand from stack instruction - DoMovem */
  /* arg2 has the preloaded 8 bit operand. */

domovem:
  if (_trace) printf("domovem:\n");

DoMovemSP:
  if (_trace) printf("DoMovemSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomovem;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoMovemLP:
  if (_trace) printf("DoMovemLP:\n");

DoMovemFP:
  if (_trace) printf("DoMovemFP:\n");

begindomovem:
  if (_trace) printf("begindomovem:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)arg1 = arg6;   		// Store all 40 bits of TOS on stack 
  goto cachevalid;   

DoMovemIM:
  goto doistageerror;

/* end DoMovem */
  /* End of Halfword operand from stack instruction - DoMovem */
/* start DoPushAddress */

  /* Halfword operand from stack instruction - DoPushAddress */
  /* arg2 has the preloaded 8 bit operand. */

dopushaddress:
  if (_trace) printf("dopushaddress:\n");

DoPushAddressSP:
  if (_trace) printf("DoPushAddressSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPushAddressLP:
  if (_trace) printf("DoPushAddressLP:\n");

DoPushAddressFP:
  if (_trace) printf("DoPushAddressFP:\n");

begindopushaddress:
  if (_trace) printf("begindopushaddress:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = arg1 - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t1 = t2 + t1;		// reconstruct VMA 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t3 = Type_Locative;
  *(u32 *)(iSP + 8) = t1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  goto cachevalid;   

DoPushAddressIM:
  goto doistageerror;

/* end DoPushAddress */
  /* End of Halfword operand from stack instruction - DoPushAddress */
/* start DoMemoryRead */

  /* Halfword 10 bit immediate instruction - DoMemoryRead */

domemoryread:
  if (_trace) printf("domemoryread:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoMemoryReadIM:
  if (_trace) printf("DoMemoryReadIM:\n");

DoMemoryReadSP:
  if (_trace) printf("DoMemoryReadSP:\n");

DoMemoryReadLP:
  if (_trace) printf("DoMemoryReadLP:\n");

DoMemoryReadFP:
  if (_trace) printf("DoMemoryReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  t1 = arg3 >> 10;   		// Low bit clear if memory-read, set if memory-read-address 
  t2 = arg1 & 32;		// T2 = fixnum check 
  t3 = arg1 & 16;		// T3 = reset CDR code 
  arg3 = arg1 >> 6;   		// arg3 = cycle type 
  arg1 = (u32)(arg6 >> ((4&7)*8));   
  arg2 = (u32)arg6;   		// Get tag/data 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read14349:
  t7 = arg2 + ivory;
  t8 = (arg3 * 4);   		// Cycle-number -> table offset 
  arg5 = LDQ_U(t7);   
  t8 = (t8 * 4) + ivory;   
  arg6 = (t7 * 4);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)(t8 + PROCESSORSTATE_DATAREAD_MASK);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14351;

vma-memory-read14350:
  t8 = t8 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read14353;

vma-memory-read14360:
  if (t2 == 0) 		// J. if no check for fixnum. 
    goto mrdataok;
  t5 = arg5 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto mrnotfixnum;

mrdataok:
  if (_trace) printf("mrdataok:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if (t1 & 1)   		// Get original tag if memory-read-address 
   arg5 = arg1;
  if (t3 == 0) 		// J. if no reset CDR code 
    goto mrcdrunch;
  /* TagType. */
  arg5 = arg5 & 63;

mrcdrunch:
  if (_trace) printf("mrcdrunch:\n");
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t1 & 1)   		// Get forwarded address if memory-read-address 
   arg6 = arg2;
  *(u32 *)iSP = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = arg5;
  goto cachevalid;   

mrnotfixnum:
  if (_trace) printf("mrnotfixnum:\n");
  arg5 = 0;
  arg2 = 5;
  goto illegaloperand;

vma-memory-read14353:
  if (_trace) printf("vma-memory-read14353:\n");

vma-memory-read14351:
  if (_trace) printf("vma-memory-read14351:\n");
  r0 = (u64)&&return0458;
  goto memoryreadgeneraldecode;
return0458:
  goto vma-memory-read14360;   

/* end DoMemoryRead */
  /* End of Halfword operand from stack instruction - DoMemoryRead */
/* start DoBranch */

  /* Halfword 10 bit immediate instruction - DoBranch */

dobranch:
  if (_trace) printf("dobranch:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchIM:
  if (_trace) printf("DoBranchIM:\n");

DoBranchSP:
  if (_trace) printf("DoBranchSP:\n");

DoBranchLP:
  if (_trace) printf("DoBranchLP:\n");

DoBranchFP:
  if (_trace) printf("DoBranchFP:\n");
  arg1 = (s64)arg3 >> 48;   
  /* arg1 has signed operand preloaded. */
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
#endif
  iPC = iPC + arg1;		// Update the PC in halfwords 
#ifndef CACHEMETERING
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;   

/* end DoBranch */
  /* End of Halfword operand from stack instruction - DoBranch */
/* start DoGenericDispatch */

  /* Halfword operand from stack instruction - DoGenericDispatch */
  /* arg2 has the preloaded 8 bit operand. */

dogenericdispatch:
  if (_trace) printf("dogenericdispatch:\n");

DoGenericDispatchSP:
  if (_trace) printf("DoGenericDispatchSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoGenericDispatchLP:
  if (_trace) printf("DoGenericDispatchLP:\n");

DoGenericDispatchFP:
  if (_trace) printf("DoGenericDispatchFP:\n");

begindogenericdispatch:
  if (_trace) printf("begindogenericdispatch:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg2 = *(s32 *)&processor->control;   
  arg1 = *(s32 *)(iFP + 20);   		// get generic tag and data 
  t1 = *(s32 *)(iFP + 16);   
  arg5 = arg2 & 255;		// get number of arguments 
  arg3 = *(s32 *)(iFP + 28);   		// get instance tag and data 
  arg4 = *(s32 *)(iFP + 24);   
  arg5 = arg5 - 4;   		// done if 2 or more arguments (plus 2 extra words) 
  if ((s64)arg5 < 0)   
    goto verifygenericarity;
  t1 = (u32)t1;   
  arg4 = (u32)arg4;   
  r0 = (u64)&&return0459;
  goto lookuphandler;
return0459:
  t3 = t4 - Type_EvenPC;   
  t3 = t3 & 62;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto generic-dispatch14362;
  t3 = t6 & 63;		// Strip CDR code 
  t3 = t3 - Type_NIL;   
  if (t3 == 0) 
    goto generic-dispatch14361;
  *(u32 *)(iFP + 16) = t7;
		/* write the stack cache */
  *(u32 *)(iFP + 20) = t6;

generic-dispatch14361:
  if (_trace) printf("generic-dispatch14361:\n");
  /* Convert real continuation to PC. */
  iPC = t4 & 1;
  iPC = t9 + iPC;
  iPC = t9 + iPC;
  goto interpretinstructionforjump;   

generic-dispatch14362:
  if (_trace) printf("generic-dispatch14362:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t3 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = iSP - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t3 = t2 + t3;		// reconstruct VMA 
  arg5 = t3;
  arg2 = 37;
  goto illegaloperand;

DoGenericDispatchIM:
  goto doistageerror;

/* end DoGenericDispatch */
  /* End of Halfword operand from stack instruction - DoGenericDispatch */
/* start LookupHandler */


lookuphandler:
  if (_trace) printf("lookuphandler:\n");
  sp = sp + -8;   
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t5 = arg3 - Type_Instance;   
  t5 = t5 & 60;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto instance-descriptor-info14366;
  arg2 = arg4;		// Don't clobber instance if it's forwarded 
  /* Memory Read Internal */

vma-memory-read14367:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14369;

vma-memory-read14368:
  t7 = zero + 64;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14371;

vma-memory-read14376:

instance-descriptor-info14365:
  if (_trace) printf("instance-descriptor-info14365:\n");
  arg2 = arg6;
  /* Memory Read Internal */

vma-memory-read14377:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14379;

vma-memory-read14378:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14381;

vma-memory-read14388:
  t2 = arg6;
  t5 = arg5 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto instance-descriptor-info14363;
  arg2 = arg2 + 1;
  /* Memory Read Internal */

vma-memory-read14389:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14391;

vma-memory-read14390:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14393;

vma-memory-read14400:
  t3 = arg6;
  t5 = arg5 - Type_Locative;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto instance-descriptor-info14364;
  arg2 = t2 & t1;
  t5 = arg2 << 1;   
  arg4 = arg2 + t5;		// (* (logand mask data) 3) 
  /* TagType. */
  arg1 = arg1 & 63;

lookup-handler14402:
  if (_trace) printf("lookup-handler14402:\n");
  arg2 = t3 + arg4;
  arg4 = arg4 + 3;
  /* Read key */
  /* Memory Read Internal */

vma-memory-read14403:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14405;

vma-memory-read14404:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read14407;

vma-memory-read14414:
  /* TagType. */
  arg5 = arg5 & 63;
  t5 = (arg5 == Type_NIL) ? 1 : 0;   
  if (t5 != 0)   
    goto lookup-handler14401;
  t5 = (arg1 == arg5) ? 1 : 0;   
  if (t5 == 0) 
    goto lookup-handler14402;
  t5 = (s32)t1 - (s32)arg6;   
  if (t5 != 0)   
    goto lookup-handler14402;

lookup-handler14401:
  if (_trace) printf("lookup-handler14401:\n");
  /* Read method */
  arg2 = arg2 + 1;
  /* Memory Read Internal */

vma-memory-read14415:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14417;

vma-memory-read14416:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14419;

vma-memory-read14426:
  t4 = arg5;
  arg3 = arg6;
  /* Read parameter */
  arg2 = arg2 + 1;
  /* Memory Read Internal */

vma-memory-read14427:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14429;

vma-memory-read14428:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14431;

vma-memory-read14438:
  t6 = arg5;
  t7 = arg6;
  t9 = arg3;
  sp = sp + 8;   
  goto *r0; /* ret */

vma-memory-read14431:
  if (_trace) printf("vma-memory-read14431:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14430;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14427;   

vma-memory-read14430:
  if (_trace) printf("vma-memory-read14430:\n");

vma-memory-read14429:
  if (_trace) printf("vma-memory-read14429:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0460;
  goto memoryreaddatadecode;
return0460:
  r0 = *(u64 *)sp;   
  goto vma-memory-read14438;   

vma-memory-read14419:
  if (_trace) printf("vma-memory-read14419:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14418;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14415;   

vma-memory-read14418:
  if (_trace) printf("vma-memory-read14418:\n");

vma-memory-read14417:
  if (_trace) printf("vma-memory-read14417:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0461;
  goto memoryreaddatadecode;
return0461:
  r0 = *(u64 *)sp;   
  goto vma-memory-read14426;   

vma-memory-read14407:
  if (_trace) printf("vma-memory-read14407:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14406;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14403;   

vma-memory-read14406:
  if (_trace) printf("vma-memory-read14406:\n");

vma-memory-read14405:
  if (_trace) printf("vma-memory-read14405:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0462;
  goto memoryreaddatadecode;
return0462:
  r0 = *(u64 *)sp;   
  goto vma-memory-read14414;   

vma-memory-read14393:
  if (_trace) printf("vma-memory-read14393:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14392;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14389;   

vma-memory-read14392:
  if (_trace) printf("vma-memory-read14392:\n");

vma-memory-read14391:
  if (_trace) printf("vma-memory-read14391:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0463;
  goto memoryreaddatadecode;
return0463:
  r0 = *(u64 *)sp;   
  goto vma-memory-read14400;   

vma-memory-read14381:
  if (_trace) printf("vma-memory-read14381:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14380;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14377;   

vma-memory-read14380:
  if (_trace) printf("vma-memory-read14380:\n");

vma-memory-read14379:
  if (_trace) printf("vma-memory-read14379:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0464;
  goto memoryreaddatadecode;
return0464:
  r0 = *(u64 *)sp;   
  goto vma-memory-read14388;   

vma-memory-read14371:
  if (_trace) printf("vma-memory-read14371:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14370;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14367;   

vma-memory-read14370:
  if (_trace) printf("vma-memory-read14370:\n");

vma-memory-read14369:
  if (_trace) printf("vma-memory-read14369:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0465;
  goto memoryreadheaderdecode;
return0465:
  r0 = *(u64 *)sp;   
  goto vma-memory-read14376;   

instance-descriptor-info14366:
  if (_trace) printf("instance-descriptor-info14366:\n");
  /* not an instance, flavor description comes from magic vector */
  arg2 = *(u64 *)&(processor->trapvecbase);   
  /* TagType. */
  t5 = arg3 & 63;
  arg2 = arg2 + 2560;   
  arg2 = t5 + arg2;
  /* Memory Read Internal */

vma-memory-read14439:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14441;

vma-memory-read14440:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14443;
  goto instance-descriptor-info14365;   

instance-descriptor-info14363:
  if (_trace) printf("instance-descriptor-info14363:\n");
  arg5 = arg2;
  arg2 = 34;
  goto illegaloperand;

instance-descriptor-info14364:
  if (_trace) printf("instance-descriptor-info14364:\n");
  arg5 = arg2;
  arg2 = 35;
  goto illegaloperand;

vma-memory-read14443:
  if (_trace) printf("vma-memory-read14443:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14442;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14439;   

vma-memory-read14442:
  if (_trace) printf("vma-memory-read14442:\n");

vma-memory-read14441:
  if (_trace) printf("vma-memory-read14441:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0466;
  goto memoryreaddatadecode;
return0466:
  r0 = *(u64 *)sp;   
  goto instance-descriptor-info14365;   

/* end LookupHandler */
/* start DoSetTag */

  /* Halfword operand from stack instruction - DoSetTag */
  /* arg2 has the preloaded 8 bit operand. */

dosettag:
  if (_trace) printf("dosettag:\n");

DoSetTagSP:
  if (_trace) printf("DoSetTagSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoSetTagLP:
  if (_trace) printf("DoSetTagLP:\n");

DoSetTagFP:
  if (_trace) printf("DoSetTagFP:\n");

begindosettag:
  if (_trace) printf("begindosettag:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t1 = *(s32 *)(arg1 + 4);   		// Get tag/data of op2 
  arg2 = *(s32 *)arg1;   
  t3 = t1 - Type_Fixnum;   
  t3 = t3 & 63;		// Strip CDR code 
  if (t3 != 0)   
    goto settagexc;

DoSetTagIM:
  if (_trace) printf("DoSetTagIM:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
		/* Set TAG of op1 */
  *(u32 *)(iSP + 4) = arg2;
  goto cachevalid;   

settagexc:
  if (_trace) printf("settagexc:\n");
  arg5 = 0;
  arg2 = 63;
  goto illegaloperand;

/* end DoSetTag */
  /* End of Halfword operand from stack instruction - DoSetTag */
/* start DoCar */

  /* Halfword operand from stack instruction - DoCar */
  /* arg2 has the preloaded 8 bit operand. */

docar:
  if (_trace) printf("docar:\n");

DoCarSP:
  if (_trace) printf("DoCarSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoCarLP:
  if (_trace) printf("DoCarLP:\n");

DoCarFP:
  if (_trace) printf("DoCarFP:\n");

begindocar:
  if (_trace) printf("begindocar:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg5 = *(s32 *)(arg1 + 4);   		// Get the operand from the stack. 
  arg6 = *(s32 *)arg1;   
  r0 = (u64)&&return0467;
  goto carinternal;
return0467:
  t5 = arg5 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

DoCarIM:
  goto doistageerror;

/* end DoCar */
  /* End of Halfword operand from stack instruction - DoCar */
/* start CarInternal */


carinternal:
  if (_trace) printf("carinternal:\n");
  sp = sp + -8;   
  arg2 = (u32)(arg6 >> ((zero&7)*8));   
  t5 = arg5 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_List) ? 1 : 0;   

force-alignment14470:
  if (_trace) printf("force-alignment14470:\n");
  if (t6 == 0) 
    goto basic-dispatch14453;
  /* Here if argument TypeList */

car-internal14450:
  /* Memory Read Internal */

vma-memory-read14454:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14456;

vma-memory-read14455:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14458;

vma-memory-read14465:

basic-dispatch14452:
  if (_trace) printf("basic-dispatch14452:\n");

car-internal14451:
  if (_trace) printf("car-internal14451:\n");
  sp = sp + 8;   
  goto *r0; /* ret */

basic-dispatch14453:
  if (_trace) printf("basic-dispatch14453:\n");
  t6 = (t5 == Type_NIL) ? 1 : 0;   

force-alignment14471:
  if (_trace) printf("force-alignment14471:\n");
  if (t6 != 0)   
    goto basic-dispatch14452;

basic-dispatch14466:
  if (_trace) printf("basic-dispatch14466:\n");
  t6 = (t5 == Type_Locative) ? 1 : 0;   

force-alignment14472:
  if (_trace) printf("force-alignment14472:\n");
  if (t6 != 0)   
    goto car-internal14450;

basic-dispatch14467:
  if (_trace) printf("basic-dispatch14467:\n");
  /* Here for all other cases */
  arg6 = arg5;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto listexception;

vma-memory-read14458:
  if (_trace) printf("vma-memory-read14458:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14457;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14454;   

vma-memory-read14457:
  if (_trace) printf("vma-memory-read14457:\n");

vma-memory-read14456:
  if (_trace) printf("vma-memory-read14456:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0468;
  goto memoryreaddatadecode;
return0468:
  r0 = *(u64 *)sp;   
  goto vma-memory-read14465;   

/* end CarInternal */
/* start DoCdr */

  /* Halfword operand from stack instruction - DoCdr */
  /* arg2 has the preloaded 8 bit operand. */

docdr:
  if (_trace) printf("docdr:\n");

DoCdrSP:
  if (_trace) printf("DoCdrSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoCdrLP:
  if (_trace) printf("DoCdrLP:\n");

DoCdrFP:
  if (_trace) printf("DoCdrFP:\n");

begindocdr:
  if (_trace) printf("begindocdr:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg5 = *(s32 *)(arg1 + 4);   		// Get the operand from the stack. 
  arg6 = *(s32 *)arg1;   
  r0 = (u64)&&return0469;
  goto cdrinternal;
return0469:
  t5 = arg5 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

DoCdrIM:
  goto doistageerror;

/* end DoCdr */
  /* End of Halfword operand from stack instruction - DoCdr */
/* start CdrInternal */


cdrinternal:
  if (_trace) printf("cdrinternal:\n");
  sp = sp + -8;   
  arg2 = (u32)arg6;   
  t5 = arg5 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_List) ? 1 : 0;   

force-alignment14508:
  if (_trace) printf("force-alignment14508:\n");
  if (t6 == 0) 
    goto basic-dispatch14476;
  /* Here if argument TypeList */
  /* Memory Read Internal */

vma-memory-read14477:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->cdr_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14479;

vma-memory-read14478:
  t7 = zero + 192;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read14481;

vma-memory-read14486:
  t5 = arg5 & 192;		// Extract CDR code. 
  if (t5 != 0)   
    goto basic-dispatch14488;
  /* Here if argument 0 */
  arg6 = arg2 + 1;		// Address of next position is CDR 
  arg5 = Type_List;

basic-dispatch14487:
  if (_trace) printf("basic-dispatch14487:\n");

basic-dispatch14475:
  if (_trace) printf("basic-dispatch14475:\n");

cdr-internal14474:
  if (_trace) printf("cdr-internal14474:\n");
  sp = sp + 8;   
  goto *r0; /* ret */

basic-dispatch14476:
  if (_trace) printf("basic-dispatch14476:\n");
  t6 = (t5 == Type_NIL) ? 1 : 0;   

force-alignment14509:
  if (_trace) printf("force-alignment14509:\n");
  if (t6 != 0)   
    goto basic-dispatch14475;

basic-dispatch14504:
  if (_trace) printf("basic-dispatch14504:\n");
  t6 = (t5 == Type_Locative) ? 1 : 0;   

force-alignment14510:
  if (_trace) printf("force-alignment14510:\n");
  if (t6 != 0)   
    goto cdr-internal14473;

basic-dispatch14505:
  if (_trace) printf("basic-dispatch14505:\n");
  /* Here for all other cases */
  arg6 = arg5;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto listexception;

basic-dispatch14488:
  if (_trace) printf("basic-dispatch14488:\n");
  t6 = (t5 == 128) ? 1 : 0;   

force-alignment14511:
  if (_trace) printf("force-alignment14511:\n");
  if (t6 == 0) 
    goto basic-dispatch14489;
  /* Here if argument 128 */
  arg2 = arg2 + 1;

cdr-internal14473:
  if (_trace) printf("cdr-internal14473:\n");
  /* Memory Read Internal */

vma-memory-read14490:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14492;

vma-memory-read14491:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14494;
  goto cdr-internal14474;   

basic-dispatch14489:
  if (_trace) printf("basic-dispatch14489:\n");
  t6 = (t5 == 64) ? 1 : 0;   

force-alignment14512:
  if (_trace) printf("force-alignment14512:\n");
  if (t6 == 0) 
    goto basic-dispatch14501;
  /* Here if argument 64 */
  arg6 = *(s32 *)&processor->niladdress;   
  arg5 = *((s32 *)(&processor->niladdress)+1);   
  arg6 = (u32)arg6;   
  goto cdr-internal14474;   

basic-dispatch14501:
  if (_trace) printf("basic-dispatch14501:\n");
  /* Here for all other cases */
  arg5 = arg2;
  arg2 = 15;
  goto illegaloperand;

vma-memory-read14494:
  if (_trace) printf("vma-memory-read14494:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14493;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14490;   

vma-memory-read14493:
  if (_trace) printf("vma-memory-read14493:\n");

vma-memory-read14492:
  if (_trace) printf("vma-memory-read14492:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0470;
  goto memoryreaddatadecode;
return0470:
  r0 = *(u64 *)sp;   
  goto cdr-internal14474;   

vma-memory-read14481:
  if (_trace) printf("vma-memory-read14481:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14480;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14477;   

vma-memory-read14480:
  if (_trace) printf("vma-memory-read14480:\n");

vma-memory-read14479:
  if (_trace) printf("vma-memory-read14479:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0471;
  goto memoryreadcdrdecode;
return0471:
  r0 = *(u64 *)sp;   
  goto vma-memory-read14486;   

/* end CdrInternal */
/* start DoReadInternalRegister */

  /* Halfword 10 bit immediate instruction - DoReadInternalRegister */

doreadinternalregister:
  if (_trace) printf("doreadinternalregister:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoReadInternalRegisterIM:
  if (_trace) printf("DoReadInternalRegisterIM:\n");

DoReadInternalRegisterSP:
  if (_trace) printf("DoReadInternalRegisterSP:\n");

DoReadInternalRegisterLP:
  if (_trace) printf("DoReadInternalRegisterLP:\n");

DoReadInternalRegisterFP:
  if (_trace) printf("DoReadInternalRegisterFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  t2 = *(u64 *)&(processor->internalregisterread2);   
  t3 = (s32)arg1 - (s32)512;   
  t1 = *(u64 *)&(processor->internalregisterread1);   
  if ((s64)t3 >= 0)   		// We're in the 1000's 
    goto internal-register-dispatch14513;
  t3 = arg1 & 63;		// Keep only six bits 
  t2 = ((s64)t3 <= (s64)42) ? 1 : 0;   		// In range for the low registers? 
  t3 = (t3 * 8) + t1;  
  if (t2 == 0) 
    goto ReadRegisterError;
  t3 = *(u64 *)t3;   
    goto *t3; /* jmp */   		// Jump to the handler 

internal-register-dispatch14513:
  if (_trace) printf("internal-register-dispatch14513:\n");
  t1 = ((s64)t3 <= (s64)33) ? 1 : 0;   		// In range for the high registers? 
  t3 = (t3 * 8) + t2;  
  if (t1 == 0) 
    goto ReadRegisterError;
  t3 = *(u64 *)t3;   
    goto *t3; /* jmp */   		// Jump to the handler 

/* end DoReadInternalRegister */
  /* End of Halfword operand from stack instruction - DoReadInternalRegister */
/* start DoWriteInternalRegister */

  /* Halfword 10 bit immediate instruction - DoWriteInternalRegister */

dowriteinternalregister:
  if (_trace) printf("dowriteinternalregister:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoWriteInternalRegisterIM:
  if (_trace) printf("DoWriteInternalRegisterIM:\n");

DoWriteInternalRegisterSP:
  if (_trace) printf("DoWriteInternalRegisterSP:\n");

DoWriteInternalRegisterLP:
  if (_trace) printf("DoWriteInternalRegisterLP:\n");

DoWriteInternalRegisterFP:
  if (_trace) printf("DoWriteInternalRegisterFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg2 = (u32)(arg6 >> ((4&7)*8));   
  arg3 = (u32)arg6;   		// Arg2=tag arg3=data 
  iSP = iSP - 8;   		// Pop Stack. 
  t2 = *(u64 *)&(processor->internalregisterwrite2);   
  t3 = (s32)arg1 - (s32)512;   
  t1 = *(u64 *)&(processor->internalregisterwrite1);   
  if ((s64)t3 >= 0)   		// We're in the 1000's 
    goto internal-register-dispatch14514;
  t3 = arg1 & 63;		// Keep only six bits 
  t2 = ((s64)t3 <= (s64)42) ? 1 : 0;   		// In range for the low registers? 
  t3 = (t3 * 8) + t1;  
  if (t2 == 0) 
    goto WriteRegisterError;
  t3 = *(u64 *)t3;   
    goto *t3; /* jmp */   		// Jump to the handler 

internal-register-dispatch14514:
  if (_trace) printf("internal-register-dispatch14514:\n");
  t1 = ((s64)t3 <= (s64)33) ? 1 : 0;   		// In range for the high registers? 
  t3 = (t3 * 8) + t2;  
  if (t1 == 0) 
    goto WriteRegisterError;
  t3 = *(u64 *)t3;   
    goto *t3; /* jmp */   		// Jump to the handler 

/* end DoWriteInternalRegister */
  /* End of Halfword operand from stack instruction - DoWriteInternalRegister */
/* start WriteRegisterBARx */


WriteRegisterBARx:
  if (_trace) printf("WriteRegisterBARx:\n");
  t2 = arg1 >> 7;   		// BAR number into T2 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t3 = arg2 << 32;   		// Make a quadword from tag and data 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t1 = (u64)&processor->bar0;   
  t1 = (t2 * 8) + t1;  		// Now T1 points to the BAR 
  t3 = t3 | arg3;		// Construct the combined word 
  *(u64 *)t1 = t3;   
  goto cachevalid;   

/* end WriteRegisterBARx */
/* start DoBlock3Read */

  /* Halfword 10 bit immediate instruction - DoBlock3Read */

doblock3read:
  if (_trace) printf("doblock3read:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBlock3ReadIM:
  if (_trace) printf("DoBlock3ReadIM:\n");

DoBlock3ReadSP:
  if (_trace) printf("DoBlock3ReadSP:\n");

DoBlock3ReadLP:
  if (_trace) printf("DoBlock3ReadLP:\n");

DoBlock3ReadFP:
  if (_trace) printf("DoBlock3ReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg4 = (u64)&processor->bar3;   
  goto blockread;   

/* end DoBlock3Read */
  /* End of Halfword operand from stack instruction - DoBlock3Read */
/* start DoBlock2Read */

  /* Halfword 10 bit immediate instruction - DoBlock2Read */

doblock2read:
  if (_trace) printf("doblock2read:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBlock2ReadIM:
  if (_trace) printf("DoBlock2ReadIM:\n");

DoBlock2ReadSP:
  if (_trace) printf("DoBlock2ReadSP:\n");

DoBlock2ReadLP:
  if (_trace) printf("DoBlock2ReadLP:\n");

DoBlock2ReadFP:
  if (_trace) printf("DoBlock2ReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg4 = (u64)&processor->bar2;   
  goto blockread;   

/* end DoBlock2Read */
  /* End of Halfword operand from stack instruction - DoBlock2Read */
/* start DoBlock1Read */

  /* Halfword 10 bit immediate instruction - DoBlock1Read */

doblock1read:
  if (_trace) printf("doblock1read:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBlock1ReadIM:
  if (_trace) printf("DoBlock1ReadIM:\n");

DoBlock1ReadSP:
  if (_trace) printf("DoBlock1ReadSP:\n");

DoBlock1ReadLP:
  if (_trace) printf("DoBlock1ReadLP:\n");

DoBlock1ReadFP:
  if (_trace) printf("DoBlock1ReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg4 = (u64)&processor->bar1;   

blockread:
  if (_trace) printf("blockread:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = *(s32 *)arg4;   		// Get the vma 
  arg3 = arg1 >> 6;   		// cycle type 
  t2 = arg1 & 4;		// =no-incrementp 
  t3 = arg1 & 16;		// =cdr-code-nextp 
  t4 = arg1 & 32;		// =fixnum onlyp 
  arg2 = (u32)arg2;   
  /* Do the read cycle */
  /* Memory Read Internal */

vma-memory-read14518:
  t7 = arg2 + ivory;
  t8 = (arg3 * 4);   		// Cycle-number -> table offset 
  arg5 = LDQ_U(t7);   
  t8 = (t8 * 4) + ivory;   
  arg6 = (t7 * 4);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)(t8 + PROCESSORSTATE_DATAREAD_MASK);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14520;

vma-memory-read14519:
  t8 = t8 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read14522;

vma-memory-read14529:
  if (t4 != 0)   		// J. if we have to test for fixnump. 
    goto i%block-n-read14515;

i%block-n-read14516:
  t4 = arg2 + 1;		// Compute Incremented address 

force-alignment14530:
  if (_trace) printf("force-alignment14530:\n");
  if (t2 == 0)   		// Conditionally update address 
    arg2 = t4;
		/* Store updated vma in BAR */
  *(u32 *)arg4 = arg2;
  t2 = arg5 & 63;		// Compute CDR-NEXT 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if (t3)   		// Conditionally Set CDR-NEXT 
    arg5 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u32 *)(iSP + 8) = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = arg5;
  iSP = iSP + 8;
  goto cachevalid;   

i%block-n-read14517:
  if (_trace) printf("i%block-n-read14517:\n");
  arg5 = arg2;
  arg2 = 23;
  goto illegaloperand;

vma-memory-read14522:
  if (_trace) printf("vma-memory-read14522:\n");

vma-memory-read14520:
  if (_trace) printf("vma-memory-read14520:\n");
  r0 = (u64)&&return0472;
  goto memoryreadgeneraldecode;
return0472:
  goto vma-memory-read14529;   

i%block-n-read14515:
  if (_trace) printf("i%block-n-read14515:\n");
  t5 = arg5 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto i%block-n-read14517;
  goto i%block-n-read14516;   

/* end DoBlock1Read */
  /* End of Halfword operand from stack instruction - DoBlock1Read */
/* start DoBlock2Write */

  /* Halfword operand from stack instruction - DoBlock2Write */

doblock2write:
  if (_trace) printf("doblock2write:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoBlock2WriteIM:
  if (_trace) printf("DoBlock2WriteIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment14531:
  if (_trace) printf("force-alignment14531:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoblock2write;   

DoBlock2WriteSP:
  if (_trace) printf("DoBlock2WriteSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoBlock2WriteLP:
  if (_trace) printf("DoBlock2WriteLP:\n");

DoBlock2WriteFP:
  if (_trace) printf("DoBlock2WriteFP:\n");

headdoblock2write:
  if (_trace) printf("headdoblock2write:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoblock2write:
  if (_trace) printf("begindoblock2write:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg3 = *(s32 *)&processor->bar2;   
  arg2 = (u64)&processor->bar2;   
  goto blockwrite;   

/* end DoBlock2Write */
  /* End of Halfword operand from stack instruction - DoBlock2Write */
/* start DoBlock1Write */

  /* Halfword operand from stack instruction - DoBlock1Write */

doblock1write:
  if (_trace) printf("doblock1write:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoBlock1WriteIM:
  if (_trace) printf("DoBlock1WriteIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment14535:
  if (_trace) printf("force-alignment14535:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoblock1write;   

DoBlock1WriteSP:
  if (_trace) printf("DoBlock1WriteSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoBlock1WriteLP:
  if (_trace) printf("DoBlock1WriteLP:\n");

DoBlock1WriteFP:
  if (_trace) printf("DoBlock1WriteFP:\n");

headdoblock1write:
  if (_trace) printf("headdoblock1write:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoblock1write:
  if (_trace) printf("begindoblock1write:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg3 = *(s32 *)&processor->bar1;   
  arg2 = (u64)&processor->bar1;   

blockwrite:
  if (_trace) printf("blockwrite:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg3 = (u32)arg3;   		// Unsigned vma 
  t2 = arg1 >> 32;   		// Get tag 
  t3 = (u32)arg1;   		// Get data 
  t8 = arg3 + ivory;
  t6 = (t8 * 4);   
  t5 = LDQ_U(t8);   
  t4 = arg3 - t11;   		// Stack cache offset 
  t7 = ((u64)t4 < (u64)t12) ? 1 : 0;   		// In range? 
  t4 = (t2 & 0xff) << ((t8&7)*8);   
  t5 = t5 & ~(0xffL << (t8&7)*8);   

force-alignment14534:
  if (_trace) printf("force-alignment14534:\n");
  t5 = t5 | t4;
  STQ_U(t8, t5);   
  *(u32 *)t6 = t3;
  if (t7 != 0)   		// J. if in cache 
    goto vma-memory-write14533;

vma-memory-write14532:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  arg3 = arg3 + 1;		// Increment the address 
		/* Store updated vma in BAR */
  *(u32 *)arg2 = arg3;
  goto cachevalid;   

vma-memory-write14533:
  if (_trace) printf("vma-memory-write14533:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t4 = arg3 - t11;   		// Stack cache offset 
  t8 = (t4 * 8) + t8;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t8 = t3;
		/* write the stack cache */
  *(u32 *)(t8 + 4) = t2;
  goto vma-memory-write14532;   

/* end DoBlock1Write */
  /* End of Halfword operand from stack instruction - DoBlock1Write */
/* start DoBranchTrueNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueNoPop */

dobranchtruenopop:
  if (_trace) printf("dobranchtruenopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchTrueNoPopIM:
  if (_trace) printf("DoBranchTrueNoPopIM:\n");

DoBranchTrueNoPopSP:
  if (_trace) printf("DoBranchTrueNoPopSP:\n");

DoBranchTrueNoPopLP:
  if (_trace) printf("DoBranchTrueNoPopLP:\n");

DoBranchTrueNoPopFP:
  if (_trace) printf("DoBranchTrueNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 == 0) 
    goto NEXTINSTRUCTION;
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchTrueNoPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueNoPop */
/* start DoBranchFalseNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseNoPop */

dobranchfalsenopop:
  if (_trace) printf("dobranchfalsenopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchFalseNoPopIM:
  if (_trace) printf("DoBranchFalseNoPopIM:\n");

DoBranchFalseNoPopSP:
  if (_trace) printf("DoBranchFalseNoPopSP:\n");

DoBranchFalseNoPopLP:
  if (_trace) printf("DoBranchFalseNoPopLP:\n");

DoBranchFalseNoPopFP:
  if (_trace) printf("DoBranchFalseNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 != 0)   
    goto NEXTINSTRUCTION;
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchFalseNoPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseNoPop */
/* start callgeneric */

  /*  */
  /*  */
  /* Fullword instruction - callgeneric */
  /* ======================= */

callgeneric:
  if (_trace) printf("callgeneric:\n");

callgenericprefetch:
  if (_trace) printf("callgenericprefetch:\n");
  t3 = *(u64 *)&(processor->trapvecbase);   
  arg4 = arg3;		// Get operand 
  arg3 = Type_GenericFunction;
  arg5 = Type_EvenPC;
  arg6 = t3 + 2636;   
  goto startcallcompiledmerge;   

/* end callgeneric */
  /* End of Fullword instruction - callgeneric */
  /* ============================== */
  /*  */
/* start callcompiledeven */

  /*  */
  /*  */
  /* Fullword instruction - callcompiledeven */
  /* ======================= */

callcompiledeven:
  if (_trace) printf("callcompiledeven:\n");

callcompiledevenprefetch:
  if (_trace) printf("callcompiledevenprefetch:\n");
  arg6 = arg3;		// Get operand 
  arg5 = Type_EvenPC;
  arg3 = zero;		// No extra arg 
  goto startcallcompiledmerge;   

/* end callcompiledeven */
  /* End of Fullword instruction - callcompiledeven */
  /* ============================== */
  /*  */
/* start DoStartCall */

  /* Halfword operand from stack instruction - DoStartCall */
  /* arg2 has the preloaded 8 bit operand. */

dostartcall:
  if (_trace) printf("dostartcall:\n");

DoStartCallSP:
  if (_trace) printf("DoStartCallSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoStartCallLP:
  if (_trace) printf("DoStartCallLP:\n");

DoStartCallFP:
  if (_trace) printf("DoStartCallFP:\n");

begindostartcall:
  if (_trace) printf("begindostartcall:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg5 = *(s32 *)(arg1 + 4);   
  arg6 = *(s32 *)arg1;   

startcallagain:
  if (_trace) printf("startcallagain:\n");

start-call-dispatch14538:
  if (_trace) printf("start-call-dispatch14538:\n");
  t1 = *(u64 *)&(processor->trapvecbase);   
  t2 = arg5 & 63;		// Strip off any CDR code bits. 
  t3 = (t2 == Type_CompiledFunction) ? 1 : 0;   

force-alignment14586:
  if (_trace) printf("force-alignment14586:\n");
  if (t3 == 0) 
    goto basic-dispatch14543;
  /* Here if argument TypeCompiledFunction */

start-call-dispatch14539:
  if (_trace) printf("start-call-dispatch14539:\n");
  arg3 = zero;		// No extra argument 

start-call-dispatch14540:
  if (_trace) printf("start-call-dispatch14540:\n");
  arg5 = Type_EvenPC;

startcallcompiledmerge:
  if (_trace) printf("startcallcompiledmerge:\n");
  t7 = *((s32 *)(&processor->continuation)+1);   
  iSP = iSP + 16;		// prepare to push continuation/control register 
  t3 = *(s32 *)&processor->control;   
  t6 = Type_Fixnum+0xC0;
  t8 = *(s32 *)&processor->continuation;   
  t5 = (64) << 16;   
  t7 = t7 | 192;		// Set CDR code 3 
		/* push continuation */
  *(u32 *)(iSP + -8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + -4) = t7;
  t8 = t3 | t5;		// Set call started bit in CR 
  t5 = zero + 256;   
		/* Push control register */
  *(u32 *)iSP = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t6;
  t8 = t8 & ~t5;		// Clear the extra arg bit 
		/* Save control with new state */
  *(u32 *)&processor->control = t8;
  /* End of push-frame */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u32 *)&processor->continuation = arg6;
  *((u32 *)(&processor->continuation)+1) = arg5;
  *(u64 *)&processor->continuationcp = zero;   
  if (arg3 != 0)   
    goto start-call-dispatch14541;
  goto cachevalid;   

start-call-dispatch14541:
  if (_trace) printf("start-call-dispatch14541:\n");
  t1 = *(s32 *)&processor->control;   
  t2 = zero + 256;   
  t3 = arg3 & 63;		// set CDR-NEXT 
		/* Push the extra arg. */
  *(u32 *)(iSP + 8) = arg4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  t1 = t1 | t2;		// Set the extra arg bit 
		/* Save control with new state */
  *(u32 *)&processor->control = t1;
  goto cachevalid;   

basic-dispatch14543:
  if (_trace) printf("basic-dispatch14543:\n");
  t3 = (t2 == Type_GenericFunction) ? 1 : 0;   

force-alignment14587:
  if (_trace) printf("force-alignment14587:\n");
  if (t3 == 0) 
    goto basic-dispatch14544;
  /* Here if argument TypeGenericFunction */
  arg3 = arg5;
  arg4 = (u32)arg6;   
  arg6 = t1 + 2636;   
  goto start-call-dispatch14540;   

basic-dispatch14544:
  if (_trace) printf("basic-dispatch14544:\n");
  t3 = (t2 == Type_Instance) ? 1 : 0;   

force-alignment14588:
  if (_trace) printf("force-alignment14588:\n");
  if (t3 == 0) 
    goto basic-dispatch14545;
  /* Here if argument TypeInstance */
  arg3 = arg5;
  arg4 = (u32)arg6;   
  arg6 = t1 + 2638;   
  goto start-call-dispatch14540;   

basic-dispatch14545:
  if (_trace) printf("basic-dispatch14545:\n");
  t3 = (t2 == Type_Symbol) ? 1 : 0;   

force-alignment14589:
  if (_trace) printf("force-alignment14589:\n");
  if (t3 == 0) 
    goto basic-dispatch14546;
  /* Here if argument TypeSymbol */
  arg6 = (u32)arg6;   
  arg3 = zero;		// No extra argument 
  arg2 = arg6 + 2;		// Get to the function cell 
  goto startcallindirect;   

basic-dispatch14546:
  if (_trace) printf("basic-dispatch14546:\n");
  t3 = (t2 == Type_LexicalClosure) ? 1 : 0;   

force-alignment14590:
  if (_trace) printf("force-alignment14590:\n");
  if (t3 == 0) 
    goto basic-dispatch14547;
  /* Here if argument TypeLexicalClosure */
  arg2 = (u32)arg6;   
  /* Memory Read Internal */

vma-memory-read14548:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14550;

vma-memory-read14549:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read14552;

vma-memory-read14559:
  arg3 = arg5;
  arg4 = arg6;
  arg2 = arg2 + 1;

startcallindirect:
  if (_trace) printf("startcallindirect:\n");
  /* Memory Read Internal */

vma-memory-read14560:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14562;

vma-memory-read14561:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read14564;

vma-memory-read14571:
  t5 = arg5 - Type_CompiledFunction;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto start-call-dispatch14538;
  goto start-call-dispatch14540;   

basic-dispatch14547:
  if (_trace) printf("basic-dispatch14547:\n");
  /* Here for all other cases */

start-call-dispatch14536:
  if (_trace) printf("start-call-dispatch14536:\n");
  arg3 = arg5;
  arg4 = arg6;
  t3 = t1 + 2304;   
  /* TagType. */
  arg5 = arg5 & 63;
  arg2 = arg5 + t3;
  /* Memory Read Internal */

vma-memory-read14573:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14575;

vma-memory-read14574:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read14577;

vma-memory-read14584:
  t3 = arg5 - Type_EvenPC;   
  t3 = t3 & 63;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto start-call-dispatch14537;
  goto start-call-dispatch14540;   

basic-dispatch14542:
  if (_trace) printf("basic-dispatch14542:\n");

start-call-dispatch14537:
  if (_trace) printf("start-call-dispatch14537:\n");
  arg5 = t1;
  arg2 = 51;
  goto illegaloperand;

vma-memory-read14577:
  if (_trace) printf("vma-memory-read14577:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14576;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14573;   

vma-memory-read14576:
  if (_trace) printf("vma-memory-read14576:\n");

vma-memory-read14575:
  if (_trace) printf("vma-memory-read14575:\n");
  r0 = (u64)&&return0473;
  goto memoryreaddatadecode;
return0473:
  goto vma-memory-read14584;   

vma-memory-read14564:
  if (_trace) printf("vma-memory-read14564:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14563;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14560;   

vma-memory-read14563:
  if (_trace) printf("vma-memory-read14563:\n");

vma-memory-read14562:
  if (_trace) printf("vma-memory-read14562:\n");
  r0 = (u64)&&return0474;
  goto memoryreaddatadecode;
return0474:
  goto vma-memory-read14571;   

vma-memory-read14552:
  if (_trace) printf("vma-memory-read14552:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14551;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14548;   

vma-memory-read14551:
  if (_trace) printf("vma-memory-read14551:\n");

vma-memory-read14550:
  if (_trace) printf("vma-memory-read14550:\n");
  r0 = (u64)&&return0475;
  goto memoryreaddatadecode;
return0475:
  goto vma-memory-read14559;   

DoStartCallIM:
  goto doistageerror;

/* end DoStartCall */
  /* End of Halfword operand from stack instruction - DoStartCall */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifuncom1.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifuncom2.as
 ************************************************************************/

  /* The most commonly used instructions, part 2. */
/* start DoPushInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPushInstanceVariable */

dopushinstancevariable:
  if (_trace) printf("dopushinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoPushInstanceVariableIM:
  if (_trace) printf("DoPushInstanceVariableIM:\n");

DoPushInstanceVariableSP:
  if (_trace) printf("DoPushInstanceVariableSP:\n");

DoPushInstanceVariableLP:
  if (_trace) printf("DoPushInstanceVariableLP:\n");

DoPushInstanceVariableFP:
  if (_trace) printf("DoPushInstanceVariableFP:\n");
  /* arg1 has operand preloaded. */
  arg1 = arg2;
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Instance Variable Mapped */
  arg2 = *(s32 *)(iFP + 16);   		// Map 
  arg5 = *(s32 *)(iFP + 20);   
  arg2 = (u32)arg2;   
  t2 = arg5 - Type_Array;   
  t2 = t2 & 63;		// Strip CDR code 
  if (t2 != 0)   
    goto ivbadmap;
  /* Memory Read Internal */

vma-memory-read14594:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14596;

vma-memory-read14595:
  t7 = zero + 64;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read14598;

vma-memory-read14603:
  arg6 = arg6 & Array_LengthMask;
  t3 = arg6 - arg1;   
  if ((s64)t3 <= 0)  		// J. if mapping-table-index-out-of-bounds 
    goto ivbadindex;
  arg2 = arg2 + arg1;
  arg2 = arg2 + 1;
  /* Memory Read Internal */

vma-memory-read14604:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14606;

vma-memory-read14605:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14608;

vma-memory-read14615:
  t1 = arg6;
  t4 = arg5 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto pushivexception;
  arg2 = *(s32 *)(iFP + 24);   		// Self 
  t4 = *(s32 *)(iFP + 28);   
  arg2 = (u32)arg2;   
  t3 = t4 - Type_Instance;   
  t3 = t3 & 60;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto ivbadinst;
  t3 = t4 & 192;		// Unshifted cdr code 
  t3 = t3 - 64;   		// Check for CDR code 1 
  if (t3 != 0)   		// J. if CDR code is not 1 
    goto locate-instance0variable-mapped14593;

locate-instance0variable-mapped14592:
  if (_trace) printf("locate-instance0variable-mapped14592:\n");
  arg2 = arg2 + t1;

locate-instance0variable-mapped14591:
  if (_trace) printf("locate-instance0variable-mapped14591:\n");
  /* Memory Read Internal */

vma-memory-read14616:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14618;

vma-memory-read14617:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read14620;

vma-memory-read14627:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t7 = arg5 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;   

vma-memory-read14620:
  if (_trace) printf("vma-memory-read14620:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14619;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14616;   

vma-memory-read14619:
  if (_trace) printf("vma-memory-read14619:\n");

vma-memory-read14618:
  if (_trace) printf("vma-memory-read14618:\n");
  r0 = (u64)&&return0476;
  goto memoryreaddatadecode;
return0476:
  goto vma-memory-read14627;   

vma-memory-read14608:
  if (_trace) printf("vma-memory-read14608:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14607;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14604;   

vma-memory-read14607:
  if (_trace) printf("vma-memory-read14607:\n");

vma-memory-read14606:
  if (_trace) printf("vma-memory-read14606:\n");
  r0 = (u64)&&return0477;
  goto memoryreaddatadecode;
return0477:
  goto vma-memory-read14615;   

vma-memory-read14598:
  if (_trace) printf("vma-memory-read14598:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14597;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14594;   

vma-memory-read14597:
  if (_trace) printf("vma-memory-read14597:\n");

vma-memory-read14596:
  if (_trace) printf("vma-memory-read14596:\n");
  r0 = (u64)&&return0478;
  goto memoryreadheaderdecode;
return0478:
  goto vma-memory-read14603;   

locate-instance0variable-mapped14593:
  if (_trace) printf("locate-instance0variable-mapped14593:\n");
  t3 = arg2;
  /* Memory Read Internal */

vma-memory-read14628:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14630;

vma-memory-read14629:
  t7 = zero + 64;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14632;

vma-memory-read14637:
  t3 = t3 - arg2;   
  if (t3 != 0)   
    goto locate-instance0variable-mapped14592;
  /* TagType. */
  t4 = t4 & 63;
  t4 = t4 | 64;		// Set CDR code to 1 
		/* Update self */
  *(u32 *)(iFP + 24) = arg2;
		/* write the stack cache */
  *(u32 *)(iFP + 28) = t4;
  goto locate-instance0variable-mapped14592;   

vma-memory-read14632:
  if (_trace) printf("vma-memory-read14632:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14631;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14628;   

vma-memory-read14631:
  if (_trace) printf("vma-memory-read14631:\n");

vma-memory-read14630:
  if (_trace) printf("vma-memory-read14630:\n");
  r0 = (u64)&&return0479;
  goto memoryreadheaderdecode;
return0479:
  goto vma-memory-read14637;   

/* end DoPushInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPushInstanceVariable */
/* start DoAdd */

  /* Halfword operand from stack instruction - DoAdd */
  /* arg2 has the preloaded 8 bit operand. */

doadd:
  if (_trace) printf("doadd:\n");

DoAddSP:
  if (_trace) printf("DoAddSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoadd;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoAddLP:
  if (_trace) printf("DoAddLP:\n");

DoAddFP:
  if (_trace) printf("DoAddFP:\n");

begindoadd:
  if (_trace) printf("begindoadd:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  /* NIL */
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment14677:
  if (_trace) printf("force-alignment14677:\n");
  if (t10 == 0) 
    goto basic-dispatch14648;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment14654:
  if (_trace) printf("force-alignment14654:\n");
  if (t12 == 0) 
    goto basic-dispatch14650;
  /* Here if argument TypeFixnum */
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t5 = (u64)((s32)t2 + (s64)(s32)t4); 		// compute 64-bit result 
  if (t5 >> 32)
    exception();  /* addl/v */
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t9;
  iPC = t6;
  *(u32 *)iSP = t5;
  iCP = t7;
  goto cachevalid;   

basic-dispatch14650:
  if (_trace) printf("basic-dispatch14650:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment14655:
  if (_trace) printf("force-alignment14655:\n");
  if (t12 == 0) 
    goto basic-dispatch14651;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple-binary-arithmetic-operation14638;   

basic-dispatch14651:
  if (_trace) printf("basic-dispatch14651:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment14656:
  if (_trace) printf("force-alignment14656:\n");
  if (t12 == 0) 
    goto binary-type-dispatch14645;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple-binary-arithmetic-operation14641;   

basic-dispatch14649:
  if (_trace) printf("basic-dispatch14649:\n");

basic-dispatch14648:
  if (_trace) printf("basic-dispatch14648:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment14678:
  if (_trace) printf("force-alignment14678:\n");
  if (t10 == 0) 
    goto basic-dispatch14657;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment14663:
  if (_trace) printf("force-alignment14663:\n");
  if (t12 == 0) 
    goto basic-dispatch14659;
  /* Here if argument TypeSingleFloat */

simple-binary-arithmetic-operation14638:
  if (_trace) printf("simple-binary-arithmetic-operation14638:\n");
  ADDS(0, f0, 1, f1, 2, f2); /* adds */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto cachevalid;   

basic-dispatch14659:
  if (_trace) printf("basic-dispatch14659:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment14664:
  if (_trace) printf("force-alignment14664:\n");
  if (t12 == 0) 
    goto basic-dispatch14660;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple-binary-arithmetic-operation14638;   

basic-dispatch14660:
  if (_trace) printf("basic-dispatch14660:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment14665:
  if (_trace) printf("force-alignment14665:\n");
  if (t12 == 0) 
    goto binary-type-dispatch14645;
  /* Here if argument TypeDoubleFloat */

simple-binary-arithmetic-operation14641:
  if (_trace) printf("simple-binary-arithmetic-operation14641:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto simple-binary-arithmetic-operation14642;   

basic-dispatch14658:
  if (_trace) printf("basic-dispatch14658:\n");

basic-dispatch14657:
  if (_trace) printf("basic-dispatch14657:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

force-alignment14679:
  if (_trace) printf("force-alignment14679:\n");
  if (t10 == 0) 
    goto basic-dispatch14666;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment14672:
  if (_trace) printf("force-alignment14672:\n");
  if (t12 == 0) 
    goto basic-dispatch14668;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0480;
  goto fetchdoublefloat;
return0480:
  LDT(1, f1, processor->fp0);   

simple-binary-arithmetic-operation14642:
  if (_trace) printf("simple-binary-arithmetic-operation14642:\n");
  arg2 = (u32)t4;   
  r0 = (u64)&&return0481;
  goto fetchdoublefloat;
return0481:
  LDT(2, f2, processor->fp0);   

simple-binary-arithmetic-operation14639:
  if (_trace) printf("simple-binary-arithmetic-operation14639:\n");
  ADDT(0, f0, 1, f1, 2, f2); /* addt */   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0482;
  goto consdoublefloat;
return0482:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto cachevalid;   

basic-dispatch14668:
  if (_trace) printf("basic-dispatch14668:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment14673:
  if (_trace) printf("force-alignment14673:\n");
  if (t12 == 0) 
    goto basic-dispatch14669;
  /* Here if argument TypeSingleFloat */

simple-binary-arithmetic-operation14640:
  if (_trace) printf("simple-binary-arithmetic-operation14640:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0483;
  goto fetchdoublefloat;
return0483:
  LDT(1, f1, processor->fp0);   
  goto simple-binary-arithmetic-operation14639;   

basic-dispatch14669:
  if (_trace) printf("basic-dispatch14669:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment14674:
  if (_trace) printf("force-alignment14674:\n");
  if (t12 == 0) 
    goto binary-type-dispatch14645;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple-binary-arithmetic-operation14640;   

basic-dispatch14667:
  if (_trace) printf("basic-dispatch14667:\n");

basic-dispatch14666:
  if (_trace) printf("basic-dispatch14666:\n");
  /* Here for all other cases */

binary-type-dispatch14644:
  if (_trace) printf("binary-type-dispatch14644:\n");

doaddovfl:
  if (_trace) printf("doaddovfl:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch14646;   

binary-type-dispatch14645:
  if (_trace) printf("binary-type-dispatch14645:\n");
  t1 = t3;
  goto doaddovfl;   

binary-type-dispatch14646:
  if (_trace) printf("binary-type-dispatch14646:\n");

basic-dispatch14647:
  if (_trace) printf("basic-dispatch14647:\n");

DoAddIM:
  if (_trace) printf("DoAddIM:\n");
  t1 = (u32)(arg6 >> ((4&7)*8));   
  t2 = (s32)arg6;		// get ARG1 tag/data 
  t11 = t1 & 63;		// Strip off any CDR code bits. 
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment14684:
  if (_trace) printf("force-alignment14684:\n");
  if (t12 == 0) 
    goto basic-dispatch14681;
  /* Here if argument TypeFixnum */
  t3 = t2 + arg2;		// compute 64-bit result 
  t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t10 = (s32)t3;		// compute 32-bit sign-extended result 
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t10 = (t3 == t10) ? 1 : 0;   		// is it the same as the 64-bit result? 
  if (t10 == 0) 		// if not, we overflowed 
    goto doaddovfl;
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t11;
  iPC = t4;
  *(u32 *)iSP = t3;
  iCP = t5;
  goto cachevalid;   

basic-dispatch14681:
  if (_trace) printf("basic-dispatch14681:\n");
  /* Here for all other cases */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;   
  arg2 = zero;
  goto begindoadd;   

basic-dispatch14680:
  if (_trace) printf("basic-dispatch14680:\n");

/* end DoAdd */
  /* End of Halfword operand from stack instruction - DoAdd */
/* start DoBlock3Write */

  /* Halfword operand from stack instruction - DoBlock3Write */

doblock3write:
  if (_trace) printf("doblock3write:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoBlock3WriteIM:
  if (_trace) printf("DoBlock3WriteIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment14685:
  if (_trace) printf("force-alignment14685:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoblock3write;   

DoBlock3WriteSP:
  if (_trace) printf("DoBlock3WriteSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoBlock3WriteLP:
  if (_trace) printf("DoBlock3WriteLP:\n");

DoBlock3WriteFP:
  if (_trace) printf("DoBlock3WriteFP:\n");

headdoblock3write:
  if (_trace) printf("headdoblock3write:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoblock3write:
  if (_trace) printf("begindoblock3write:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg3 = *(s32 *)&processor->bar3;   
  arg2 = (u64)&processor->bar3;   
  goto blockwrite;   

/* end DoBlock3Write */
  /* End of Halfword operand from stack instruction - DoBlock3Write */
/* start DoAset1 */

  /* Halfword operand from stack instruction - DoAset1 */
  /* arg2 has the preloaded 8 bit operand. */

doaset1:
  if (_trace) printf("doaset1:\n");

DoAset1SP:
  if (_trace) printf("DoAset1SP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoAset1LP:
  if (_trace) printf("DoAset1LP:\n");

DoAset1FP:
  if (_trace) printf("DoAset1FP:\n");

headdoaset1:
  if (_trace) printf("headdoaset1:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoaset1:
  if (_trace) printf("begindoaset1:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   		// Get the array tag/data 
  arg3 = *(s32 *)(iSP + 4);   		// Get the array tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  t6 = *(s32 *)iSP;   		// Get the new value tag/data 
  t5 = *(s32 *)(iSP + 4);   		// Get the new value tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  t6 = (u32)t6;   
  arg2 = (s32)arg1 + (s32)0;		// (sign-extended, for fast bounds check) Index Data 
  t8 = zero + AutoArrayRegMask;   
  t8 = arg4 & t8;
  arg1 = arg1 >> 32;   		// Index Tag 
  t7 = (u64)&processor->ac0array;   
  t7 = t7 + t8;		// This is the address if the array register block. 
  t1 = arg1 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto aset1illegal;

aset1merge:
  if (_trace) printf("aset1merge:\n");
  if (arg4 == 0) 
    goto aset1regset;
  t8 = *(u64 *)&(((ARRAYCACHEP)t7)->array);   		// Cached array object. 
  t1 = arg3 - Type_Array;   
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto reallyaset1exc;
  t8 = (arg4 == t8) ? 1 : 0;   		// t8==1 iff cached array is ours. 
  if (t8 == 0) 		// Go and setup the array register. 
    goto aset1regset;
#ifdef SLOWARRAYS
  goto aset1regset;   
#endif
  arg6 = *(u64 *)&(((ARRAYCACHEP)t7)->arword);   
  t9 = *(u64 *)&(((ARRAYCACHEP)t7)->locat);   		// high order bits all zero 
  t3 = *(u64 *)&(((ARRAYCACHEP)t7)->length);   		// high order bits all zero 
  t11 = arg6 << 42;   
  t4 = *(u64 *)&(processor->areventcount);   
  t11 = t11 >> 42;   
  t2 = ((u64)arg2 < (u64)t3) ? 1 : 0;   
  t12 = t4 - t11;   
  if (t12 != 0)   		// J. if event count ticked. 
    goto aset1regset;
  if (t2 == 0) 
    goto aset1bounds;
  arg5 = arg6 >> (Array_RegisterBytePackingPos & 63);   
  t8 = arg6 >> (Array_RegisterElementTypePos & 63);   
  arg4 = arg6 >> (Array_RegisterByteOffsetPos & 63);   
  arg5 = arg5 & Array_RegisterBytePackingMask;
  arg4 = arg4 & Array_RegisterByteOffsetMask;
  arg6 = t8 & Array_RegisterElementTypeMask;

aset1restart:
  if (_trace) printf("aset1restart:\n");
  /* Element checking and foreplay. */
  /* TagType. */
  t1 = t5 & 63;
  t8 = (arg6 == Array_ElementTypeCharacter) ? 1 : 0;   

force-alignment14696:
  if (_trace) printf("force-alignment14696:\n");
  if (t8 == 0) 
    goto basic-dispatch14692;
  /* Here if argument ArrayElementTypeCharacter */
  t2 = t1 - Type_Character;   
  if (t2 == 0) 
    goto aset-1-internal14687;
  arg5 = 0;
  arg2 = 29;
  goto illegaloperand;

aset-1-internal14687:
  if (_trace) printf("aset-1-internal14687:\n");
  if (arg5 == 0) 		// Certainly will fit if not packed! 
    goto aset-1-internal14686;
  t2 = 32;
  t2 = t2 >> (arg5 & 63);   		// Compute size of byte 
  t1 = ~zero;   
  t1 = t1 << (t2 & 63);   
  t1 = ~t1;   		// Compute mask for byte 
  t1 = t6 & t1;
  t1 = t6 - t1;   
  if (t1 == 0) 		// J. if character fits. 
    goto aset-1-internal14686;
  arg5 = 0;
  arg2 = 62;
  goto illegaloperand;

basic-dispatch14692:
  if (_trace) printf("basic-dispatch14692:\n");
  t8 = (arg6 == Array_ElementTypeFixnum) ? 1 : 0;   

force-alignment14697:
  if (_trace) printf("force-alignment14697:\n");
  if (t8 == 0) 
    goto basic-dispatch14693;
  /* Here if argument ArrayElementTypeFixnum */
  t2 = t1 - Type_Fixnum;   
  if (t2 == 0) 
    goto aset-1-internal14686;
  arg5 = 0;
  arg2 = 33;
  goto illegaloperand;

basic-dispatch14693:
  if (_trace) printf("basic-dispatch14693:\n");
  t8 = (arg6 == Array_ElementTypeBoolean) ? 1 : 0;   

force-alignment14698:
  if (_trace) printf("force-alignment14698:\n");
  if (t8 == 0) 
    goto basic-dispatch14691;
  /* Here if argument ArrayElementTypeBoolean */
  t6 = 1;
  t1 = t1 - Type_NIL;   
  if (t1 != 0)   		// J. if True 
    goto aset-1-internal14686;
  t6 = zero;
  goto aset-1-internal14686;   		// J. if False 

basic-dispatch14691:
  if (_trace) printf("basic-dispatch14691:\n");
  /* Shove it in. */

aset-1-internal14686:
  if (_trace) printf("aset-1-internal14686:\n");
  if (arg5 != 0)   		// J. if packed 
    goto aset-1-internal14688;
  t1 = arg6 - Array_ElementTypeObject;   
  if (t1 != 0)   
    goto aset-1-internal14688;
  /* Here for the simple non packed case */
  t1 = t9 + arg2;
  /* Memory Read Internal */

vma-memory-read14699:
  t4 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t8 = t1 + ivory;
  t7 = *(s32 *)&processor->scovlimit;   
  t3 = (t8 * 4);   
  t2 = LDQ_U(t8);   
  t4 = t1 - t4;   		// Stack cache offset 
  arg1 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t4 < (u64)t7) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t2 = (u8)(t2 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read14701;

vma-memory-read14700:
  t8 = zero + 240;   
  arg1 = arg1 >> (t2 & 63);   
  t8 = t8 >> (t2 & 63);   
  if (arg1 & 1)   
    goto vma-memory-read14703;

vma-memory-read14709:
  /* Merge cdr-code */
  t3 = t5 & 63;
  t2 = t2 & 192;
  t2 = t2 | t3;
  t7 = *(u64 *)&(processor->stackcachebasevma);   
  t4 = t1 + ivory;
  arg1 = *(s32 *)&processor->scovlimit;   
  t3 = (t4 * 4);   
  t8 = LDQ_U(t4);   
  t7 = t1 - t7;   		// Stack cache offset 
  arg1 = ((u64)t7 < (u64)arg1) ? 1 : 0;   		// In range? 
  t7 = (t2 & 0xff) << ((t4&7)*8);   
  t8 = t8 & ~(0xffL << (t4&7)*8);   

force-alignment14711:
  if (_trace) printf("force-alignment14711:\n");
  t8 = t8 | t7;
  STQ_U(t4, t8);   
  *(u32 *)t3 = t6;
  if (arg1 != 0)   		// J. if in cache 
    goto vma-memory-write14710;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   
  /* Here for the slow packed version */

aset-1-internal14688:
  if (_trace) printf("aset-1-internal14688:\n");
  arg2 = arg4 + arg2;
  t1 = arg2 >> (arg5 & 63);   		// Convert byte index to word index 
  t1 = t1 + t9;		// Address of word containing byte 
  /* Memory Read Internal */

vma-memory-read14712:
  t2 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t4 = t1 + ivory;
  t3 = *(s32 *)&processor->scovlimit;   
  t9 = (t4 * 4);   
  arg3 = LDQ_U(t4);   
  t2 = t1 - t2;   		// Stack cache offset 
  t7 = *(u64 *)&(processor->dataread_mask);   
  t3 = ((u64)t2 < (u64)t3) ? 1 : 0;   		// In range? 
  t9 = *(s32 *)t9;   
  arg3 = (u8)(arg3 >> ((t4&7)*8));   
  if (t3 != 0)   
    goto vma-memory-read14714;

vma-memory-read14713:
  t4 = zero + 240;   
  t7 = t7 >> (arg3 & 63);   
  t4 = t4 >> (arg3 & 63);   
  t9 = (u32)t9;   
  if (t7 & 1)   
    goto vma-memory-read14716;

vma-memory-read14723:
  /* Check fixnum element type */
  /* TagType. */
  t2 = arg3 & 63;
  t2 = t2 - Type_Fixnum;   
  if (t2 != 0)   		// J. if element type not fixnum. 
    goto aset-1-internal14689;
  if (arg5 == 0) 		// J. if unpacked fixnum element type. 
    goto aset-1-internal14690;
  t8 = ~zero;   
  t8 = t8 << (arg5 & 63);   
  t2 = zero - arg5;   
  t8 = arg2 & ~t8;		// Compute subword index 
  t2 = t2 + 5;
  t2 = t8 << (t2 & 63);   		// Compute shift to get byte 
  t8 = 32;
  t8 = t8 >> (arg5 & 63);   		// Compute size of byte 
  t3 = ~zero;   
  t3 = t3 << (t8 & 63);   
  t4 = ~t3;   		// Compute mask for byte 
  if (t2 == 0) 		// inserting into the low byte is easy 
    goto array-element-dpb14724;
  /* Inserting the byte into any byte other than the low byte */
  t7 = 64;
  t8 = t7 - t2;   		// = the left shift rotate amount 
  t7 = t9 >> (t2 & 63);   		// shift selected byte into low end of word. 
  t9 = t9 << (t8 & 63);   		// rotate low bits into high end of word. 
  t7 = t3 & t7;		// Remove unwanted bits 
  t9 = t9 >> (t8 & 63);   		// rotate low bits back into place. 
  t8 = t6 & t4;		// Strip any extra bits from element 
  t7 = t8 | t7;		// Insert new bits. 
  t7 = t7 << (t2 & 63);   		// reposition bits 
  t9 = t9 | t7;		// Replace low order bits 
  goto array-element-dpb14725;   

array-element-dpb14724:
  if (_trace) printf("array-element-dpb14724:\n");
  /* Inserting the byte into the low byte */
  t9 = t9 & t3;		// Remove the old low byte 
  t8 = t6 & t4;		// Remove unwanted bits from the new byte 
  t9 = t9 | t8;		// Insert the new byte in place of the old byte 

array-element-dpb14725:
  if (_trace) printf("array-element-dpb14725:\n");
  t6 = t9;

aset-1-internal14690:
  if (_trace) printf("aset-1-internal14690:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t7 = (t2 * 4);   
  t4 = LDQ_U(t2);   
  t3 = t1 - t3;   		// Stack cache offset 
  t8 = ((u64)t3 < (u64)t8) ? 1 : 0;   		// In range? 
  t3 = (arg3 & 0xff) << ((t2&7)*8);   
  t4 = t4 & ~(0xffL << (t2&7)*8);   

force-alignment14727:
  if (_trace) printf("force-alignment14727:\n");
  t4 = t4 | t3;
  STQ_U(t2, t4);   
  *(u32 *)t7 = t6;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write14726;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

aset-1-internal14689:
  if (_trace) printf("aset-1-internal14689:\n");
  arg5 = t1;
  arg2 = 25;
  goto illegaloperand;

DoAset1IM:
  if (_trace) printf("DoAset1IM:\n");
  t8 = zero + AutoArrayRegMask;   
  arg4 = *(s32 *)iSP;   		// Get the array tag/data 
  arg3 = *(s32 *)(iSP + 4);   		// Get the array tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  t7 = (u64)&processor->ac0array;   
  t8 = arg4 & t8;
  t7 = t7 + t8;		// This is the address of the array register block. 
  t6 = *(s32 *)iSP;   		// Get the new value tag/data 
  t5 = *(s32 *)(iSP + 4);   		// Get the new value tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  t6 = (u32)t6;   
  goto aset1merge;   

vma-memory-write14726:
  if (_trace) printf("vma-memory-write14726:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment14728:
  if (_trace) printf("force-alignment14728:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t3 = t1 - t3;   		// Stack cache offset 
  t2 = (t3 * 8) + t2;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t2 = t6;
		/* write the stack cache */
  *(u32 *)(t2 + 4) = arg3;
  goto NEXTINSTRUCTION;   

vma-memory-read14714:
  if (_trace) printf("vma-memory-read14714:\n");
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = (t2 * 8) + t3;  		// reconstruct SCA 
  t9 = *(s32 *)t2;   
  arg3 = *(s32 *)(t2 + 4);   		// Read from stack cache 
  goto vma-memory-read14713;   

vma-memory-read14716:
  if (_trace) printf("vma-memory-read14716:\n");
  if ((t4 & 1) == 0)   
    goto vma-memory-read14715;
  t1 = (u32)t9;   		// Do the indirect thing 
  goto vma-memory-read14712;   

vma-memory-read14715:
  if (_trace) printf("vma-memory-read14715:\n");
  t7 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t4 = arg3 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t4 = (t4 * 4) + t7;   		// Adjust for a longword load 
  t7 = *(s32 *)t4;   		// Get the memory action 

vma-memory-read14720:
  if (_trace) printf("vma-memory-read14720:\n");
  t4 = t7 & MemoryActionTransform;
  if (t4 == 0) 
    goto vma-memory-read14719;
  arg3 = arg3 & ~63L;
  arg3 = arg3 | Type_ExternalValueCellPointer;
  goto vma-memory-read14723;   

vma-memory-read14719:

vma-memory-read14718:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-write14710:
  if (_trace) printf("vma-memory-write14710:\n");
  t7 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment14729:
  if (_trace) printf("force-alignment14729:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t7 = t1 - t7;   		// Stack cache offset 
  t4 = (t7 * 8) + t4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t4 = t6;
		/* write the stack cache */
  *(u32 *)(t4 + 4) = t2;
  goto NEXTINSTRUCTION;   

vma-memory-read14701:
  if (_trace) printf("vma-memory-read14701:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t4 = (t4 * 8) + t7;  		// reconstruct SCA 
  t3 = *(s32 *)t4;   
  t2 = *(s32 *)(t4 + 4);   		// Read from stack cache 
  goto vma-memory-read14700;   

vma-memory-read14703:
  if (_trace) printf("vma-memory-read14703:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read14702;
  t1 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read14699;   

vma-memory-read14702:
  if (_trace) printf("vma-memory-read14702:\n");
  arg1 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + arg1;   		// Adjust for a longword load 
  arg1 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read14706:

vma-memory-read14705:
  /* Perform memory action */
  arg1 = arg1;
  arg2 = 1;
  goto performmemoryaction;

/* end DoAset1 */
  /* End of Halfword operand from stack instruction - DoAset1 */
/* start DoFastAref1 */

  /* Halfword operand from stack instruction - DoFastAref1 */
  /* arg2 has the preloaded 8 bit operand. */

dofastaref1:
  if (_trace) printf("dofastaref1:\n");

DoFastAref1SP:
  if (_trace) printf("DoFastAref1SP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindofastaref1;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoFastAref1LP:
  if (_trace) printf("DoFastAref1LP:\n");

DoFastAref1FP:
  if (_trace) printf("DoFastAref1FP:\n");

begindofastaref1:
  if (_trace) printf("begindofastaref1:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg3 = (u32)(arg6 >> ((4&7)*8));   
  arg4 = (s32)arg6;
  t1 = arg3 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto fastaref1iop;

fastaref1retry:
  if (_trace) printf("fastaref1retry:\n");
  arg6 = *(s32 *)arg1;   
  t9 = *(s32 *)(arg1 + 8);   
  t3 = *(s32 *)(arg1 + 16);   
  arg6 = (u32)arg6;   
  t9 = (u32)t9;   
  t5 = arg6 << 42;   
  t3 = (u32)t3;   
  t4 = *(u64 *)&(processor->areventcount);   
  t5 = t5 >> 42;   
  t2 = ((u64)arg4 < (u64)t3) ? 1 : 0;   
  if (t2 == 0) 
    goto fastaref1bounds;
  t6 = t4 - t5;   
  if (t6 != 0)   
    goto aref1recomputearrayregister;
  t6 = arg6 >> (Array_RegisterBytePackingPos & 63);   
  t7 = arg6 >> (Array_RegisterByteOffsetPos & 63);   
  t8 = arg6 >> (Array_RegisterElementTypePos & 63);   
  t6 = t6 & Array_RegisterBytePackingMask;
  t7 = t7 & Array_RegisterByteOffsetMask;
  t8 = t8 & Array_RegisterElementTypeMask;
  if (t6 != 0)   
    goto new-aref-1-internal14730;
  t1 = t9 + arg4;

new-aref-1-internal14731:
  if (_trace) printf("new-aref-1-internal14731:\n");
  /* Memory Read Internal */

vma-memory-read14738:
  t2 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t4 = t1 + ivory;
  t3 = *(s32 *)&processor->scovlimit;   
  t9 = (t4 * 4);   
  arg5 = LDQ_U(t4);   
  t2 = t1 - t2;   		// Stack cache offset 
  t5 = *(u64 *)&(processor->dataread_mask);   
  t3 = ((u64)t2 < (u64)t3) ? 1 : 0;   		// In range? 
  t9 = *(s32 *)t9;   
  arg5 = (u8)(arg5 >> ((t4&7)*8));   
  if (t3 != 0)   
    goto vma-memory-read14740;

vma-memory-read14739:
  t4 = zero + 240;   
  t5 = t5 >> (arg5 & 63);   
  t4 = t4 >> (arg5 & 63);   
  t9 = (u32)t9;   
  if (t5 & 1)   
    goto vma-memory-read14742;

vma-memory-read14749:
  if (t6 != 0)   
    goto new-aref-1-internal14732;

new-aref-1-internal14733:
  if (_trace) printf("new-aref-1-internal14733:\n");
  r31 = r31 | r31;
  t1 = t8 - 2;   
  if ((s64)t1 <= 0)  
    goto new-aref-1-internal14734;
  /* TagType. */
  arg5 = arg5 & 63;

new-aref-1-internal14735:
  if (_trace) printf("new-aref-1-internal14735:\n");
  *(u32 *)(iSP + 4) = arg5;
  t4 = (t6 == 0) ? 1 : 0;   
  if (t4 == 0) 
    goto case_others_105;

case_0_99:
  if (_trace) printf("case_0_99:\n");
  r31 = r31 | r31;
  if (t1 == 0) 
    goto new-aref-1-internal14736;
  *(u32 *)iSP = t9;
  goto NEXTINSTRUCTION;   

case_2_100:
  if (_trace) printf("case_2_100:\n");
  /* AREF1-8B */
  r31 = r31 | r31;
  t4 = arg4 & 3;
  t5 = (u8)(t9 >> ((t4&7)*8));   
  if (t1 == 0) 
    goto new-aref-1-internal14736;
  *(u32 *)iSP = t5;
  goto NEXTINSTRUCTION;   

case_3_101:
  if (_trace) printf("case_3_101:\n");
  /* AREF1-4B */
  r31 = r31 | r31;
  t4 = arg4 & 7;		// byte-index 
  t4 = t4 << 2;   		// byte-position 
  t5 = t9 >> (t4 & 63);   		// byte in position 
  t5 = t5 & 15;		// byte masked 
  if (t1 == 0) 
    goto new-aref-1-internal14736;
  *(u32 *)iSP = t5;
  goto NEXTINSTRUCTION;   

case_5_102:
  if (_trace) printf("case_5_102:\n");
  /* AREF1-1B */
  r31 = r31 | r31;
  t4 = arg4 & 31;		// byte-index 
  r31 = r31 | r31;
  t5 = t9 >> (t4 & 63);   		// byte in position 
  t5 = t5 & 1;		// byte masked 
  if (t1 == 0) 
    goto new-aref-1-internal14736;
  *(u32 *)iSP = t5;
  goto NEXTINSTRUCTION;   

case_1_103:
  if (_trace) printf("case_1_103:\n");
  /* AREF1-16B */
  t4 = arg4 & 1;
  t4 = t4 + t4;		// Bletch, it's a byte ref 
  t5 = (u16)(t9 >> ((t4&7)*8));   
  if (t1 == 0) 
    goto new-aref-1-internal14736;
  *(u32 *)iSP = t5;
  goto NEXTINSTRUCTION;   

case_others_105:
  if (_trace) printf("case_others_105:\n");
  r31 = r31 | r31;
  t4 = (t6 == 2) ? 1 : 0;   
  t5 = (t6 == 3) ? 1 : 0;   
  if (t4 != 0)   
    goto case_2_100;
  t4 = (t6 == 5) ? 1 : 0;   
  if (t5 != 0)   
    goto case_3_101;
  t5 = (t6 == 1) ? 1 : 0;   
  if (t4 != 0)   
    goto case_5_102;
  if (t5 != 0)   
    goto case_1_103;

case_4_104:
  if (_trace) printf("case_4_104:\n");
  /* AREF1-2B */
  r31 = r31 | r31;
  t4 = arg4 & 15;		// byte-index 
  t4 = t4 << 1;   		// byte-position 
  t5 = t9 >> (t4 & 63);   		// byte in position 
  t5 = t5 & 3;		// byte masked 
  if (t1 == 0) 
    goto new-aref-1-internal14736;
  *(u32 *)iSP = t5;
  goto NEXTINSTRUCTION;   

new-aref-1-internal14730:
  if (_trace) printf("new-aref-1-internal14730:\n");
  arg4 = t7 + arg4;
  t1 = arg4 >> (t6 & 63);   		// Convert byte index to word index 
  t1 = t1 + t9;		// Address of word containing byte 
  goto new-aref-1-internal14731;   

new-aref-1-internal14732:
  if (_trace) printf("new-aref-1-internal14732:\n");
  t1 = arg5 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto new-aref-1-internal14737;
  goto new-aref-1-internal14733;   

new-aref-1-internal14734:
  if (_trace) printf("new-aref-1-internal14734:\n");
  arg5 = Type_Character;
  if (t8 & 1)   
    goto new-aref-1-internal14735;
  arg5 = Type_Fixnum;
  if (t8 == 0) 
    goto new-aref-1-internal14735;
  t2 = *(u64 *)&(processor->niladdress);   
  t3 = *(u64 *)&(processor->taddress);   
  goto new-aref-1-internal14735;   

new-aref-1-internal14736:
  if (_trace) printf("new-aref-1-internal14736:\n");
  if (t5)   
    t2 = t3;
  *(u64 *)iSP = t2;   
  goto NEXTINSTRUCTION;   

new-aref-1-internal14737:
  if (_trace) printf("new-aref-1-internal14737:\n");
  arg5 = t1;
  arg2 = 25;
  goto illegaloperand;

fastaref1iop:
  if (_trace) printf("fastaref1iop:\n");
  arg5 = 0;
  arg2 = 32;
  goto illegaloperand;

fastaref1bounds:
  if (_trace) printf("fastaref1bounds:\n");
  arg5 = 0;
  arg2 = 13;
  goto illegaloperand;

vma-memory-read14740:
  if (_trace) printf("vma-memory-read14740:\n");
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = (t2 * 8) + t3;  		// reconstruct SCA 
  t9 = *(s32 *)t2;   
  arg5 = *(s32 *)(t2 + 4);   		// Read from stack cache 
  goto vma-memory-read14739;   

vma-memory-read14742:
  if (_trace) printf("vma-memory-read14742:\n");
  if ((t4 & 1) == 0)   
    goto vma-memory-read14741;
  t1 = (u32)t9;   		// Do the indirect thing 
  goto vma-memory-read14738;   

vma-memory-read14741:
  if (_trace) printf("vma-memory-read14741:\n");
  t5 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t4 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t4 = (t4 * 4) + t5;   		// Adjust for a longword load 
  t5 = *(s32 *)t4;   		// Get the memory action 

vma-memory-read14746:
  if (_trace) printf("vma-memory-read14746:\n");
  t4 = t5 & MemoryActionTransform;
  if (t4 == 0) 
    goto vma-memory-read14745;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto vma-memory-read14749;   

vma-memory-read14745:

vma-memory-read14744:
  /* Perform memory action */
  arg1 = t5;
  arg2 = 0;
  goto performmemoryaction;

DoFastAref1IM:
  goto doistageerror;

/* end DoFastAref1 */
  /* End of Halfword operand from stack instruction - DoFastAref1 */
/* start DoRplaca */

  /* Halfword operand from stack instruction - DoRplaca */

dorplaca:
  if (_trace) printf("dorplaca:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoRplacaIM:
  if (_trace) printf("DoRplacaIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment14763:
  if (_trace) printf("force-alignment14763:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindorplaca;   

DoRplacaSP:
  if (_trace) printf("DoRplacaSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto headdorplaca;
  arg1 = arg6;		// SP-pop mode, TOS->arg1 
  arg6 = *(u64 *)arg4;   		// Reload TOS 
  iSP = arg4;		// Adjust SP 
  goto begindorplaca;   

DoRplacaLP:
  if (_trace) printf("DoRplacaLP:\n");

DoRplacaFP:
  if (_trace) printf("DoRplacaFP:\n");

headdorplaca:
  if (_trace) printf("headdorplaca:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindorplaca:
  if (_trace) printf("begindorplaca:\n");
  /* arg1 has the operand, sign extended if immediate. */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t1 = (u32)(arg6 >> ((4&7)*8));   
  arg2 = (u32)arg6;   		// Read ARG1, the list 
  iSP = iSP - 8;   		// Pop Stack. 
  /* TagType. */
  t3 = t1 & 63;
  t4 = t3 - Type_List;   
  t4 = t4 & ~4L;
  if (t4 != 0)   
    goto rplacaexception;

rplacstore:
  if (_trace) printf("rplacstore:\n");
  t2 = arg1 >> 32;   		// Tag for t2 
  arg1 = (u32)arg1;   		// data for t2 
  /* Memory Read Internal */

vma-memory-read14750:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->datawrite_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14752;

vma-memory-read14751:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read14754;

vma-memory-read14760:
  /* Merge cdr-code */
  arg6 = t2 & 63;
  arg5 = arg5 & 192;
  arg5 = arg5 | arg6;
  t5 = arg2 + ivory;
  arg6 = (t5 * 4);   
  t7 = LDQ_U(t5);   
  t6 = arg2 - t11;   		// Stack cache offset 
  t8 = ((u64)t6 < (u64)t12) ? 1 : 0;   		// In range? 
  t6 = (arg5 & 0xff) << ((t5&7)*8);   
  t7 = t7 & ~(0xffL << (t5&7)*8);   

force-alignment14762:
  if (_trace) printf("force-alignment14762:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);   
  *(u32 *)arg6 = arg1;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write14761;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

vma-memory-write14761:
  if (_trace) printf("vma-memory-write14761:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t6 = arg2 - t11;   		// Stack cache offset 
  t5 = (t6 * 8) + t5;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t5 = arg1;
		/* write the stack cache */
  *(u32 *)(t5 + 4) = arg5;
  goto NEXTINSTRUCTION;   

vma-memory-read14754:
  if (_trace) printf("vma-memory-read14754:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14753;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14750;   

vma-memory-read14753:
  if (_trace) printf("vma-memory-read14753:\n");

vma-memory-read14752:
  if (_trace) printf("vma-memory-read14752:\n");
  r0 = (u64)&&return0484;
  goto memoryreadwritedecode;
return0484:
  goto vma-memory-read14760;   

/* end DoRplaca */
  /* End of Halfword operand from stack instruction - DoRplaca */
/* start MemoryReadWrite */


memoryreadwrite:
  if (_trace) printf("memoryreadwrite:\n");
  /* Memory Read Internal */

vma-memory-read14764:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->datawrite_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14766;

vma-memory-read14765:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14768;

vma-memory-read14773:
  goto *r0; /* ret */

memoryreadwritedecode:
  if (_trace) printf("memoryreadwritedecode:\n");
  if (t6 == 0) 
    goto vma-memory-read14767;

vma-memory-read14766:
  if (_trace) printf("vma-memory-read14766:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  arg6 = *(s32 *)t5;   
  arg5 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read14765;   

vma-memory-read14768:
  if (_trace) printf("vma-memory-read14768:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14767;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14764;   

vma-memory-read14767:
  if (_trace) printf("vma-memory-read14767:\n");
  t8 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg2;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read14770:

vma-memory-read14769:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 1;
  goto performmemoryaction;

/* end MemoryReadWrite */
/* start DoRplacd */

  /* Halfword operand from stack instruction - DoRplacd */

dorplacd:
  if (_trace) printf("dorplacd:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoRplacdIM:
  if (_trace) printf("DoRplacdIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment14784:
  if (_trace) printf("force-alignment14784:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindorplacd;   

DoRplacdSP:
  if (_trace) printf("DoRplacdSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto headdorplacd;
  arg1 = arg6;		// SP-pop mode, TOS->arg1 
  arg6 = *(u64 *)arg4;   		// Reload TOS 
  iSP = arg4;		// Adjust SP 
  goto begindorplacd;   

DoRplacdLP:
  if (_trace) printf("DoRplacdLP:\n");

DoRplacdFP:
  if (_trace) printf("DoRplacdFP:\n");

headdorplacd:
  if (_trace) printf("headdorplacd:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindorplacd:
  if (_trace) printf("begindorplacd:\n");
  /* arg1 has the operand, sign extended if immediate. */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t1 = (u32)(arg6 >> ((4&7)*8));   
  arg2 = (u32)arg6;   		// Read ARG1, the list 
  iSP = iSP - 8;   		// Pop Stack. 
  /* TagType. */
  t3 = t1 & 63;
  t4 = t3 - Type_Locative;   
  if (t4 == 0) 
    goto rplacstore;
  t4 = t3 - Type_List;   
  if (t4 != 0)   
    goto rplacdexception;
  /* Memory Read Internal */

vma-memory-read14774:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->cdr_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14776;

vma-memory-read14775:
  t7 = zero + 192;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read14778;

vma-memory-read14783:
  /* TagCdr. */
  arg5 = arg5 >> 6;   
  arg5 = arg5 - Cdr_Normal;   
  if (arg5 != 0)   		// J. if CDR coded 
    goto rplacdexception;
  arg2 = arg2 + 1;		// address of CDR 
  goto rplacstore;   

vma-memory-read14778:
  if (_trace) printf("vma-memory-read14778:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14777;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14774;   

vma-memory-read14777:
  if (_trace) printf("vma-memory-read14777:\n");

vma-memory-read14776:
  if (_trace) printf("vma-memory-read14776:\n");
  r0 = (u64)&&return0485;
  goto memoryreadcdrdecode;
return0485:
  goto vma-memory-read14783;   

/* end DoRplacd */
  /* End of Halfword operand from stack instruction - DoRplacd */
/* start DoBranchTrueAndExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueAndExtraPop */

dobranchtrueandextrapop:
  if (_trace) printf("dobranchtrueandextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchTrueAndExtraPopIM:
  if (_trace) printf("DoBranchTrueAndExtraPopIM:\n");

DoBranchTrueAndExtraPopSP:
  if (_trace) printf("DoBranchTrueAndExtraPopSP:\n");

DoBranchTrueAndExtraPopLP:
  if (_trace) printf("DoBranchTrueAndExtraPopLP:\n");

DoBranchTrueAndExtraPopFP:
  if (_trace) printf("DoBranchTrueAndExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 != 0)   
    goto dobrpopextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   
  goto cachevalid;   

dobrpopextrapop:
  if (_trace) printf("dobrpopextrapop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 16;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchTrueAndExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueAndExtraPop */
/* start DoBranchFalseAndExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseAndExtraPop */

dobranchfalseandextrapop:
  if (_trace) printf("dobranchfalseandextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchFalseAndExtraPopIM:
  if (_trace) printf("DoBranchFalseAndExtraPopIM:\n");

DoBranchFalseAndExtraPopSP:
  if (_trace) printf("DoBranchFalseAndExtraPopSP:\n");

DoBranchFalseAndExtraPopLP:
  if (_trace) printf("DoBranchFalseAndExtraPopLP:\n");

DoBranchFalseAndExtraPopFP:
  if (_trace) printf("DoBranchFalseAndExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 == 0) 
    goto dobrnpopextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   
  goto cachevalid;   

dobrnpopextrapop:
  if (_trace) printf("dobrnpopextrapop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 16;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchFalseAndExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseAndExtraPop */
/* start DoBranchTrueAndNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueAndNoPop */

dobranchtrueandnopop:
  if (_trace) printf("dobranchtrueandnopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchTrueAndNoPopIM:
  if (_trace) printf("DoBranchTrueAndNoPopIM:\n");

DoBranchTrueAndNoPopSP:
  if (_trace) printf("DoBranchTrueAndNoPopSP:\n");

DoBranchTrueAndNoPopLP:
  if (_trace) printf("DoBranchTrueAndNoPopLP:\n");

DoBranchTrueAndNoPopFP:
  if (_trace) printf("DoBranchTrueAndNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 != 0)   
    goto dobrelsepop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   
  goto cachevalid;   

dobrelsepop:
  if (_trace) printf("dobrelsepop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchTrueAndNoPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueAndNoPop */
/* start DoBranchFalseAndNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseAndNoPop */

dobranchfalseandnopop:
  if (_trace) printf("dobranchfalseandnopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchFalseAndNoPopIM:
  if (_trace) printf("DoBranchFalseAndNoPopIM:\n");

DoBranchFalseAndNoPopSP:
  if (_trace) printf("DoBranchFalseAndNoPopSP:\n");

DoBranchFalseAndNoPopLP:
  if (_trace) printf("DoBranchFalseAndNoPopLP:\n");

DoBranchFalseAndNoPopFP:
  if (_trace) printf("DoBranchFalseAndNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 == 0) 
    goto dobrnelsepop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   
  goto cachevalid;   

dobrnelsepop:
  if (_trace) printf("dobrnelsepop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchFalseAndNoPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseAndNoPop */
/* start DoBranchFalseElseNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseElseNoPop */

dobranchfalseelsenopop:
  if (_trace) printf("dobranchfalseelsenopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchFalseElseNoPopIM:
  if (_trace) printf("DoBranchFalseElseNoPopIM:\n");

DoBranchFalseElseNoPopSP:
  if (_trace) printf("DoBranchFalseElseNoPopSP:\n");

DoBranchFalseElseNoPopLP:
  if (_trace) printf("DoBranchFalseElseNoPopLP:\n");

DoBranchFalseElseNoPopFP:
  if (_trace) printf("DoBranchFalseElseNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 != 0)   
    goto NEXTINSTRUCTION;
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 8;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchFalseElseNoPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseElseNoPop */
/* start DoEqualNumber */

  /* Halfword operand from stack instruction - DoEqualNumber */
  /* arg2 has the preloaded 8 bit operand. */

doequalnumber:
  if (_trace) printf("doequalnumber:\n");

DoEqualNumberSP:
  if (_trace) printf("DoEqualNumberSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoequalnumber;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoEqualNumberLP:
  if (_trace) printf("DoEqualNumberLP:\n");

DoEqualNumberFP:
  if (_trace) printf("DoEqualNumberFP:\n");

begindoequalnumber:
  if (_trace) printf("begindoequalnumber:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->niladdress);   
  t7 = arg3 >> 12;   
  t12 = *(u64 *)&(processor->taddress);   
  arg3 = (u32)(arg6 >> ((4&7)*8));   		// Get ARG1 tag 
  t1 = *(s32 *)(arg1 + 4);   		// t1 is tag of arg2 
  LDS(1, f1, *(u32 *)iSP );   
  t7 = t7 & 1;
  arg2 = *(s32 *)arg1;   
  arg4 = (s32)arg6;
  LDS(2, f2, *(u32 *)arg1 );   
  t5 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_Fixnum) ? 1 : 0;   

force-alignment14802:
  if (_trace) printf("force-alignment14802:\n");
  if (t6 == 0) 
    goto basic-dispatch14790;
  /* Here if argument TypeFixnum */
  t3 = (t4 == Type_Fixnum) ? 1 : 0;   

force-alignment14794:
  if (_trace) printf("force-alignment14794:\n");
  if (t3 == 0) 
    goto binary-type-dispatch14785;
  /* Here if argument TypeFixnum */
  t2 = (s32)arg4 - (s32)arg2;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  		// Pop/No-pop 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t2 == 0)   		// T if the test succeeds 
    t11 = t12;
  *(u64 *)iSP = t11;   
  goto cachevalid;   

basic-dispatch14791:
  if (_trace) printf("basic-dispatch14791:\n");

basic-dispatch14790:
  if (_trace) printf("basic-dispatch14790:\n");
  t6 = (t5 == Type_SingleFloat) ? 1 : 0;   

force-alignment14803:
  if (_trace) printf("force-alignment14803:\n");
  if (t6 == 0) 
    goto basic-dispatch14795;
  /* Here if argument TypeSingleFloat */
  t3 = (t4 == Type_SingleFloat) ? 1 : 0;   

force-alignment14799:
  if (_trace) printf("force-alignment14799:\n");
  if (t3 == 0) 
    goto binary-type-dispatch14785;
  /* Here if argument TypeSingleFloat */

equalnumbermmexcfltflt:
  if (_trace) printf("equalnumbermmexcfltflt:\n");
  SETFLTT(3,f3, FLTU64(1,f1) == FLTU64(2,f2) ? 2.0:0);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)iSP = t12;   
  if (FLTU64(3, f3) != 0.0)   
    goto cachevalid;
  *(u64 *)iSP = t11;   		// Didn't branch, answer is NIL 
  goto cachevalid;   

basic-dispatch14796:
  if (_trace) printf("basic-dispatch14796:\n");

basic-dispatch14795:
  if (_trace) printf("basic-dispatch14795:\n");
  /* Here for all other cases */

binary-type-dispatch14785:
  if (_trace) printf("binary-type-dispatch14785:\n");
  goto equalnumbermmexc;   

basic-dispatch14789:
  if (_trace) printf("basic-dispatch14789:\n");

DoEqualNumberIM:
  if (_trace) printf("DoEqualNumberIM:\n");
  t11 = *(u64 *)&(processor->niladdress);   
  arg2 = arg2 << 56;   		// First half of sign extension 
  t12 = *(u64 *)&(processor->taddress);   
  t7 = arg3 >> 12;   
  arg3 = (u32)(arg6 >> ((4&7)*8));   
  arg4 = (s32)arg6;
  arg2 = (s64)arg2 >> 56;   		// Second half of sign extension 
  t7 = t7 & 1;
  t3 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = (t3 == Type_Fixnum) ? 1 : 0;   

force-alignment14808:
  if (_trace) printf("force-alignment14808:\n");
  if (t4 == 0) 
    goto basic-dispatch14805;
  /* Here if argument TypeFixnum */
  t2 = (s32)arg4 - (s32)arg2;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t2 == 0)   		// T if the test succeeds 
    t11 = t12;
  *(u64 *)iSP = t11;   
  goto cachevalid;   

basic-dispatch14805:
  if (_trace) printf("basic-dispatch14805:\n");
  /* Here for all other cases */
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

basic-dispatch14804:
  if (_trace) printf("basic-dispatch14804:\n");

/* end DoEqualNumber */
  /* End of Halfword operand from stack instruction - DoEqualNumber */
/* start DoSetToCdrPushCar */

  /* Halfword operand from stack instruction - DoSetToCdrPushCar */
  /* arg2 has the preloaded 8 bit operand. */

dosettocdrpushcar:
  if (_trace) printf("dosettocdrpushcar:\n");

DoSetToCdrPushCarSP:
  if (_trace) printf("DoSetToCdrPushCarSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoSetToCdrPushCarLP:
  if (_trace) printf("DoSetToCdrPushCarLP:\n");

DoSetToCdrPushCarFP:
  if (_trace) printf("DoSetToCdrPushCarFP:\n");

begindosettocdrpushcar:
  if (_trace) printf("begindosettocdrpushcar:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t2 = *(s32 *)arg1;   		// Get the operand from the stack. 
  t1 = *(s32 *)(arg1 + 4);   
  t2 = (u32)t2;   
  t3 = t1 & 192;		// Save the old CDR code 
  t5 = t1 - Type_Locative;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 == 0) 
    goto settocdrpushcarlocative;
  r0 = (u64)&&return0486;
  goto carcdrinternal;
return0486:
  /* TagType. */
  arg5 = arg5 & 63;
  arg5 = arg5 | t3;		// Put back the original CDR codes 
  *(u32 *)arg1 = arg6;
		/* write the stack cache */
  *(u32 *)(arg1 + 4) = arg5;
  t5 = t1 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

DoSetToCdrPushCarIM:
  goto doistageerror;

/* end DoSetToCdrPushCar */
  /* End of Halfword operand from stack instruction - DoSetToCdrPushCar */
/* start DoSub */

  /* Halfword operand from stack instruction - DoSub */
  /* arg2 has the preloaded 8 bit operand. */

dosub:
  if (_trace) printf("dosub:\n");

DoSubSP:
  if (_trace) printf("DoSubSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindosub;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoSubLP:
  if (_trace) printf("DoSubLP:\n");

DoSubFP:
  if (_trace) printf("DoSubFP:\n");

begindosub:
  if (_trace) printf("begindosub:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  /* NIL */
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment14848:
  if (_trace) printf("force-alignment14848:\n");
  if (t10 == 0) 
    goto basic-dispatch14819;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment14825:
  if (_trace) printf("force-alignment14825:\n");
  if (t12 == 0) 
    goto basic-dispatch14821;
  /* Here if argument TypeFixnum */
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t5 = (s64)((s32)t2 - (s64)(s32)t4); 		// compute 64-bit result 
  if (t5 >> 32)
    exception();  /* subl/v */ 
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t9;
  iPC = t6;
  *(u32 *)iSP = t5;
  iCP = t7;
  goto cachevalid;   

basic-dispatch14821:
  if (_trace) printf("basic-dispatch14821:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment14826:
  if (_trace) printf("force-alignment14826:\n");
  if (t12 == 0) 
    goto basic-dispatch14822;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple-binary-arithmetic-operation14809;   

basic-dispatch14822:
  if (_trace) printf("basic-dispatch14822:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment14827:
  if (_trace) printf("force-alignment14827:\n");
  if (t12 == 0) 
    goto binary-type-dispatch14816;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple-binary-arithmetic-operation14812;   

basic-dispatch14820:
  if (_trace) printf("basic-dispatch14820:\n");

basic-dispatch14819:
  if (_trace) printf("basic-dispatch14819:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment14849:
  if (_trace) printf("force-alignment14849:\n");
  if (t10 == 0) 
    goto basic-dispatch14828;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment14834:
  if (_trace) printf("force-alignment14834:\n");
  if (t12 == 0) 
    goto basic-dispatch14830;
  /* Here if argument TypeSingleFloat */

simple-binary-arithmetic-operation14809:
  if (_trace) printf("simple-binary-arithmetic-operation14809:\n");
  SUBS(0, f0, 1, f1, 2, f2); /* subs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto cachevalid;   

basic-dispatch14830:
  if (_trace) printf("basic-dispatch14830:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment14835:
  if (_trace) printf("force-alignment14835:\n");
  if (t12 == 0) 
    goto basic-dispatch14831;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple-binary-arithmetic-operation14809;   

basic-dispatch14831:
  if (_trace) printf("basic-dispatch14831:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment14836:
  if (_trace) printf("force-alignment14836:\n");
  if (t12 == 0) 
    goto binary-type-dispatch14816;
  /* Here if argument TypeDoubleFloat */

simple-binary-arithmetic-operation14812:
  if (_trace) printf("simple-binary-arithmetic-operation14812:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto simple-binary-arithmetic-operation14813;   

basic-dispatch14829:
  if (_trace) printf("basic-dispatch14829:\n");

basic-dispatch14828:
  if (_trace) printf("basic-dispatch14828:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

force-alignment14850:
  if (_trace) printf("force-alignment14850:\n");
  if (t10 == 0) 
    goto basic-dispatch14837;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment14843:
  if (_trace) printf("force-alignment14843:\n");
  if (t12 == 0) 
    goto basic-dispatch14839;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0487;
  goto fetchdoublefloat;
return0487:
  LDT(1, f1, processor->fp0);   

simple-binary-arithmetic-operation14813:
  if (_trace) printf("simple-binary-arithmetic-operation14813:\n");
  arg2 = (u32)t4;   
  r0 = (u64)&&return0488;
  goto fetchdoublefloat;
return0488:
  LDT(2, f2, processor->fp0);   

simple-binary-arithmetic-operation14810:
  if (_trace) printf("simple-binary-arithmetic-operation14810:\n");
  SUBT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0489;
  goto consdoublefloat;
return0489:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto cachevalid;   

basic-dispatch14839:
  if (_trace) printf("basic-dispatch14839:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment14844:
  if (_trace) printf("force-alignment14844:\n");
  if (t12 == 0) 
    goto basic-dispatch14840;
  /* Here if argument TypeSingleFloat */

simple-binary-arithmetic-operation14811:
  if (_trace) printf("simple-binary-arithmetic-operation14811:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0490;
  goto fetchdoublefloat;
return0490:
  LDT(1, f1, processor->fp0);   
  goto simple-binary-arithmetic-operation14810;   

basic-dispatch14840:
  if (_trace) printf("basic-dispatch14840:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment14845:
  if (_trace) printf("force-alignment14845:\n");
  if (t12 == 0) 
    goto binary-type-dispatch14816;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple-binary-arithmetic-operation14811;   

basic-dispatch14838:
  if (_trace) printf("basic-dispatch14838:\n");

basic-dispatch14837:
  if (_trace) printf("basic-dispatch14837:\n");
  /* Here for all other cases */

binary-type-dispatch14815:
  if (_trace) printf("binary-type-dispatch14815:\n");

dosubovfl:
  if (_trace) printf("dosubovfl:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch14817;   

binary-type-dispatch14816:
  if (_trace) printf("binary-type-dispatch14816:\n");
  t1 = t3;
  goto dosubovfl;   

binary-type-dispatch14817:
  if (_trace) printf("binary-type-dispatch14817:\n");

basic-dispatch14818:
  if (_trace) printf("basic-dispatch14818:\n");

DoSubIM:
  if (_trace) printf("DoSubIM:\n");
  t1 = (u32)(arg6 >> ((4&7)*8));   
  t2 = (s32)arg6;		// get ARG1 tag/data 
  t11 = t1 & 63;		// Strip off any CDR code bits. 
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment14855:
  if (_trace) printf("force-alignment14855:\n");
  if (t12 == 0) 
    goto basic-dispatch14852;
  /* Here if argument TypeFixnum */
  t3 = t2 - arg2;   		// compute 64-bit result 
  t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t10 = (s32)t3;		// compute 32-bit sign-extended result 
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t10 = (t3 == t10) ? 1 : 0;   		// is it the same as the 64-bit result? 
  if (t10 == 0) 		// if not, we overflowed 
    goto dosubovfl;
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t11;
  iPC = t4;
  *(u32 *)iSP = t3;
  iCP = t5;
  goto cachevalid;   

basic-dispatch14852:
  if (_trace) printf("basic-dispatch14852:\n");
  /* Here for all other cases */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;   
  arg2 = zero;
  goto begindosub;   

basic-dispatch14851:
  if (_trace) printf("basic-dispatch14851:\n");

/* end DoSub */
  /* End of Halfword operand from stack instruction - DoSub */
/* start DoTag */

  /* Halfword operand from stack instruction - DoTag */
  /* arg2 has the preloaded 8 bit operand. */

dotag:
  if (_trace) printf("dotag:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoTagIM:
  if (_trace) printf("DoTagIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;   
  arg2 = zero;
  goto begindotag;   

DoTagSP:
  if (_trace) printf("DoTagSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoTagLP:
  if (_trace) printf("DoTagLP:\n");

DoTagFP:
  if (_trace) printf("DoTagFP:\n");

begindotag:
  if (_trace) printf("begindotag:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  arg1 = *(s32 *)(arg1 + 4);   		// Get the tag of the operand 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t3 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  *(u32 *)(iSP + 8) = arg1;
  iSP = iSP + 8;
  goto cachevalid;   

/* end DoTag */
  /* End of Halfword operand from stack instruction - DoTag */
/* start DoEndp */

  /* Halfword operand from stack instruction - DoEndp */
  /* arg2 has the preloaded 8 bit operand. */

doendp:
  if (_trace) printf("doendp:\n");

DoEndpSP:
  if (_trace) printf("DoEndpSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoEndpLP:
  if (_trace) printf("DoEndpLP:\n");

DoEndpFP:
  if (_trace) printf("DoEndpFP:\n");

begindoendp:
  if (_trace) printf("begindoendp:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t1 = *(u64 *)&(processor->niladdress);   
  arg2 = *(s32 *)(arg1 + 4);   		// Get tag. 
  t2 = *(u64 *)&(processor->taddress);   
  /* TagType. */
  arg2 = arg2 & 63;
  t6 = arg2 - Type_NIL;   		// Compare 
  if (t6 != 0)   
    goto endpnotnil;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)(iSP + 8) = t2;   
  iSP = iSP + 8;
  goto cachevalid;   

endpnil:
  if (_trace) printf("endpnil:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)(iSP + 8) = t1;   
  iSP = iSP + 8;
  goto cachevalid;   

endpnotnil:
  if (_trace) printf("endpnotnil:\n");
  t6 = t6 - 1;   		// Now check for list 
  if (t6 == 0) 
    goto endpnil;
  t6 = arg2 - Type_ListInstance;   
  if (t6 == 0) 
    goto endpnil;

DoEndpIM:
  if (_trace) printf("DoEndpIM:\n");
  arg5 = 0;
  arg2 = 64;
  goto illegaloperand;

/* end DoEndp */
  /* End of Halfword operand from stack instruction - DoEndp */
/* start DoMinusp */

  /* Halfword operand from stack instruction - DoMinusp */
  /* arg2 has the preloaded 8 bit operand. */

dominusp:
  if (_trace) printf("dominusp:\n");

DoMinuspSP:
  if (_trace) printf("DoMinuspSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoMinuspLP:
  if (_trace) printf("DoMinuspLP:\n");

DoMinuspFP:
  if (_trace) printf("DoMinuspFP:\n");

begindominusp:
  if (_trace) printf("begindominusp:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->niladdress);   
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t1 = *(s32 *)(arg1 + 4);   
  t12 = *(u64 *)&(processor->taddress);   
  t2 = *(s32 *)arg1;   
  LDS(1, f1, *(u32 *)arg1 );   
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t5 = (t4 == Type_Fixnum) ? 1 : 0;   

force-alignment14861:
  if (_trace) printf("force-alignment14861:\n");
  if (t5 == 0) 
    goto basic-dispatch14857;
  /* Here if argument TypeFixnum */
  iPC = t6;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if ((s64)t2 < 0)   		// T if predicate succeeds 
    t11 = t12;
  *(u64 *)(iSP + 8) = t11;   
  iSP = iSP + 8;
  goto cachevalid;   

basic-dispatch14857:
  if (_trace) printf("basic-dispatch14857:\n");
  t5 = (t4 == Type_SingleFloat) ? 1 : 0;   

force-alignment14862:
  if (_trace) printf("force-alignment14862:\n");
  if (t5 == 0) 
    goto basic-dispatch14858;
  /* Here if argument TypeSingleFloat */
  iPC = t6;
  *(u64 *)(iSP + 8) = t12;   
  iSP = iSP + 8;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (FLTU64(1, f1) < 0.0)   
    goto cachevalid;
  *(u64 *)iSP = t11;   		// Didn't branch, answer is NIL 
  goto cachevalid;   

basic-dispatch14858:
  if (_trace) printf("basic-dispatch14858:\n");
  /* Here for all other cases */
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto unarynumericexception;

basic-dispatch14856:
  if (_trace) printf("basic-dispatch14856:\n");

DoMinuspIM:
  if (_trace) printf("DoMinuspIM:\n");
  t1 = *(u64 *)&(processor->niladdress);   
  arg2 = arg2 << 56;   		// Turned into a signed number 
  t2 = *(u64 *)&(processor->taddress);   
  iSP = iSP + 8;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if ((s64)arg2 < 0)   		// stall 2 then di 
    t1 = t2;
  *(u64 *)iSP = t1;   		// yes Virginia, we dual issue with above yahoo 
  goto cachevalid;   

/* end DoMinusp */
  /* End of Halfword operand from stack instruction - DoMinusp */
/* start DoPlusp */

  /* Halfword operand from stack instruction - DoPlusp */
  /* arg2 has the preloaded 8 bit operand. */

doplusp:
  if (_trace) printf("doplusp:\n");

DoPluspSP:
  if (_trace) printf("DoPluspSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPluspLP:
  if (_trace) printf("DoPluspLP:\n");

DoPluspFP:
  if (_trace) printf("DoPluspFP:\n");

begindoplusp:
  if (_trace) printf("begindoplusp:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->niladdress);   
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t1 = *(s32 *)(arg1 + 4);   
  t12 = *(u64 *)&(processor->taddress);   
  t2 = *(s32 *)arg1;   
  LDS(1, f1, *(u32 *)arg1 );   
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t5 = (t4 == Type_Fixnum) ? 1 : 0;   

force-alignment14868:
  if (_trace) printf("force-alignment14868:\n");
  if (t5 == 0) 
    goto basic-dispatch14864;
  /* Here if argument TypeFixnum */
  iPC = t6;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if ((s64)t2 > 0)   		// T if predicate succeeds 
    t11 = t12;
  *(u64 *)(iSP + 8) = t11;   
  iSP = iSP + 8;
  goto cachevalid;   

basic-dispatch14864:
  if (_trace) printf("basic-dispatch14864:\n");
  t5 = (t4 == Type_SingleFloat) ? 1 : 0;   

force-alignment14869:
  if (_trace) printf("force-alignment14869:\n");
  if (t5 == 0) 
    goto basic-dispatch14865;
  /* Here if argument TypeSingleFloat */
  iPC = t6;
  *(u64 *)(iSP + 8) = t12;   
  iSP = iSP + 8;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (FLTU64(1, f1) > 0.0)   
    goto cachevalid;
  *(u64 *)iSP = t11;   		// Didn't branch, answer is NIL 
  goto cachevalid;   

basic-dispatch14865:
  if (_trace) printf("basic-dispatch14865:\n");
  /* Here for all other cases */
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto unarynumericexception;

basic-dispatch14863:
  if (_trace) printf("basic-dispatch14863:\n");

DoPluspIM:
  if (_trace) printf("DoPluspIM:\n");
  t1 = *(u64 *)&(processor->niladdress);   
  arg2 = arg2 << 56;   		// Turned into a signed number 
  t2 = *(u64 *)&(processor->taddress);   
  iSP = iSP + 8;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if ((s64)arg2 > 0)   		// stall 2 then di 
    t1 = t2;
  *(u64 *)iSP = t1;   		// yes Virginia, we dual issue with above yahoo 
  goto cachevalid;   

/* end DoPlusp */
  /* End of Halfword operand from stack instruction - DoPlusp */
/* start DoLessp */

  /* Halfword operand from stack instruction - DoLessp */
  /* arg2 has the preloaded 8 bit operand. */

dolessp:
  if (_trace) printf("dolessp:\n");

DoLesspSP:
  if (_trace) printf("DoLesspSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindolessp;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoLesspLP:
  if (_trace) printf("DoLesspLP:\n");

DoLesspFP:
  if (_trace) printf("DoLesspFP:\n");

begindolessp:
  if (_trace) printf("begindolessp:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->niladdress);   
  t7 = arg3 >> 12;   
  t12 = *(u64 *)&(processor->taddress);   
  arg3 = (u32)(arg6 >> ((4&7)*8));   		// Get ARG1 tag 
  t1 = *(s32 *)(arg1 + 4);   		// t1 is tag of arg2 
  LDS(1, f1, *(u32 *)iSP );   
  t7 = t7 & 1;
  arg2 = *(s32 *)arg1;   
  arg4 = (s32)arg6;
  LDS(2, f2, *(u32 *)arg1 );   
  t5 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_Fixnum) ? 1 : 0;   

force-alignment14887:
  if (_trace) printf("force-alignment14887:\n");
  if (t6 == 0) 
    goto basic-dispatch14875;
  /* Here if argument TypeFixnum */
  t3 = (t4 == Type_Fixnum) ? 1 : 0;   

force-alignment14879:
  if (_trace) printf("force-alignment14879:\n");
  if (t3 == 0) 
    goto binary-type-dispatch14870;
  /* Here if argument TypeFixnum */
  t2 = arg4 - arg2;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  		// Pop/No-pop 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if ((s64)t2 < 0)   		// T if the test succeeds 
    t11 = t12;
  *(u64 *)iSP = t11;   
  goto cachevalid;   

basic-dispatch14876:
  if (_trace) printf("basic-dispatch14876:\n");

basic-dispatch14875:
  if (_trace) printf("basic-dispatch14875:\n");
  t6 = (t5 == Type_SingleFloat) ? 1 : 0;   

force-alignment14888:
  if (_trace) printf("force-alignment14888:\n");
  if (t6 == 0) 
    goto basic-dispatch14880;
  /* Here if argument TypeSingleFloat */
  t3 = (t4 == Type_SingleFloat) ? 1 : 0;   

force-alignment14884:
  if (_trace) printf("force-alignment14884:\n");
  if (t3 == 0) 
    goto binary-type-dispatch14870;
  /* Here if argument TypeSingleFloat */

lesspmmexcfltflt:
  if (_trace) printf("lesspmmexcfltflt:\n");
  SETFLTT(3,f3, FLTU64(1,f1) < FLTU64(2,f2) ? 2.0:0);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)iSP = t12;   
  if (FLTU64(3, f3) != 0.0)   
    goto cachevalid;
  *(u64 *)iSP = t11;   		// Didn't branch, answer is NIL 
  goto cachevalid;   

basic-dispatch14881:
  if (_trace) printf("basic-dispatch14881:\n");

basic-dispatch14880:
  if (_trace) printf("basic-dispatch14880:\n");
  /* Here for all other cases */

binary-type-dispatch14870:
  if (_trace) printf("binary-type-dispatch14870:\n");
  goto lesspmmexc;   

basic-dispatch14874:
  if (_trace) printf("basic-dispatch14874:\n");

DoLesspIM:
  if (_trace) printf("DoLesspIM:\n");
  t11 = *(u64 *)&(processor->niladdress);   
  arg2 = arg2 << 56;   		// First half of sign extension 
  t12 = *(u64 *)&(processor->taddress);   
  t7 = arg3 >> 12;   
  arg3 = (u32)(arg6 >> ((4&7)*8));   
  arg4 = (s32)arg6;
  arg2 = (s64)arg2 >> 56;   		// Second half of sign extension 
  t7 = t7 & 1;
  t3 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = (t3 == Type_Fixnum) ? 1 : 0;   

force-alignment14893:
  if (_trace) printf("force-alignment14893:\n");
  if (t4 == 0) 
    goto basic-dispatch14890;
  /* Here if argument TypeFixnum */
  t2 = arg4 - arg2;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if ((s64)t2 < 0)   		// T if the test succeeds 
    t11 = t12;
  *(u64 *)iSP = t11;   
  goto cachevalid;   

basic-dispatch14890:
  if (_trace) printf("basic-dispatch14890:\n");
  /* Here for all other cases */
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

basic-dispatch14889:
  if (_trace) printf("basic-dispatch14889:\n");

/* end DoLessp */
  /* End of Halfword operand from stack instruction - DoLessp */
/* start DoDecrement */

  /* Halfword operand from stack instruction - DoDecrement */
  /* arg2 has the preloaded 8 bit operand. */

dodecrement:
  if (_trace) printf("dodecrement:\n");

DoDecrementSP:
  if (_trace) printf("DoDecrementSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoDecrementLP:
  if (_trace) printf("DoDecrementLP:\n");

DoDecrementFP:
  if (_trace) printf("DoDecrementFP:\n");

begindodecrement:
  if (_trace) printf("begindodecrement:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg3 = *(s32 *)arg1;   		// read tag/data of arg1 
  arg2 = *(s32 *)(arg1 + 4);   
  arg3 = (u32)arg3;   
  t1 = arg2 & 63;		// Strip off any CDR code bits. 
  t2 = (t1 == Type_Fixnum) ? 1 : 0;   

force-alignment14899:
  if (_trace) printf("force-alignment14899:\n");
  if (t2 == 0) 
    goto basic-dispatch14895;
  /* Here if argument TypeFixnum */
  t2 = *(u64 *)&(processor->mostnegativefixnum);   
  t3 = arg3 - 1;   
  t2 = (arg3 == t2) ? 1 : 0;   
  if (t2 != 0)   
    goto decrementexception;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u32 *)arg1 = t3;
		/* write the stack cache */
  *(u32 *)(arg1 + 4) = arg2;
  goto cachevalid;   

basic-dispatch14895:
  if (_trace) printf("basic-dispatch14895:\n");
  t2 = (t1 == Type_SingleFloat) ? 1 : 0;   

force-alignment14900:
  if (_trace) printf("force-alignment14900:\n");
  if (t2 == 0) 
    goto basic-dispatch14896;
  /* Here if argument TypeSingleFloat */
  /* NIL */
  LDS(1, f1, *(u32 *)arg1 );   		// Get the floating data 
  LDS(2, f2, processor->sfp1);   		// constant 1.0 
  SUBS(0, f0, 1, f1, 2, f2); /* subs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  STS( (u32 *)arg1, 0, f0 );   		// Put the floating result 
  goto cachevalid;   

basic-dispatch14896:
  if (_trace) printf("basic-dispatch14896:\n");
  /* Here for all other cases */
  goto decrementexception;   

basic-dispatch14894:
  if (_trace) printf("basic-dispatch14894:\n");

DoDecrementIM:
  goto doistageerror;

/* end DoDecrement */
  /* End of Halfword operand from stack instruction - DoDecrement */
/* start DoMergeCdrNoPop */

  /* Halfword operand from stack instruction - DoMergeCdrNoPop */
  /* arg2 has the preloaded 8 bit operand. */

domergecdrnopop:
  if (_trace) printf("domergecdrnopop:\n");

DoMergeCdrNoPopSP:
  if (_trace) printf("DoMergeCdrNoPopSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomergecdrnopop;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoMergeCdrNoPopLP:
  if (_trace) printf("DoMergeCdrNoPopLP:\n");

DoMergeCdrNoPopFP:
  if (_trace) printf("DoMergeCdrNoPopFP:\n");

begindomergecdrnopop:
  if (_trace) printf("begindomergecdrnopop:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t1 = *(s32 *)(arg1 + 4);   		// Get the CDR CODE/TAG of arg2 
  t2 = (u32)(arg6 >> ((4&7)*8));   		// Get the CDR CODE/TAG of arg1 

force-alignment14901:
  if (_trace) printf("force-alignment14901:\n");
  t2 = t2 & 192;		// Get Just the CDR code in position 
  t1 = t1 & 63;		// Get the TAG of arg1 
  t3 = t1 | t2;		// Merge the tag of arg2 with the cdr code of arg1 
		/* Replace tag/cdr code no pop */
  *(u32 *)(arg1 + 4) = t3;
  goto cachevalid;   

DoMergeCdrNoPopIM:
  goto doistageerror;

/* end DoMergeCdrNoPop */
  /* End of Halfword operand from stack instruction - DoMergeCdrNoPop */
/* start DoEqImmediateHandler */


doeqimmediatehandler:
  if (_trace) printf("doeqimmediatehandler:\n");

DoEqIM:
  if (_trace) printf("DoEqIM:\n");
  arg2 = arg2 << 56;   
  t4 = *(s32 *)(iSP + 4);   		// t4=tag t3=data 
  t3 = *(s32 *)iSP;   
  arg3 = arg3 >> 12;   
  t11 = *(u64 *)&(processor->niladdress);   
  arg2 = (s64)arg2 >> 56;   		// Sign extension of arg2 is complete 
  /* TagType. */
  t4 = t4 & 63;
  t12 = *(u64 *)&(processor->taddress);   
  arg3 = arg3 & 1;		// 1 if no-pop, 0 if pop 
  arg2 = (s32)t3 - (s32)arg2;   
  t4 = t4 ^ Type_Fixnum;   
  iSP = (arg3 * 8) + iSP;  		// Either a stack-push or a stack-write 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t4 = arg2 | t4;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t4 == 0)   
    t11 = t12;
  *(u64 *)iSP = t11;   		// Yes Virginia, this does dual issue with above 
  goto cachevalid;   

/* end DoEqImmediateHandler */
/* start DoIncrement */

  /* Halfword operand from stack instruction - DoIncrement */
  /* arg2 has the preloaded 8 bit operand. */

doincrement:
  if (_trace) printf("doincrement:\n");

DoIncrementSP:
  if (_trace) printf("DoIncrementSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoIncrementLP:
  if (_trace) printf("DoIncrementLP:\n");

DoIncrementFP:
  if (_trace) printf("DoIncrementFP:\n");

begindoincrement:
  if (_trace) printf("begindoincrement:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg3 = *(s32 *)arg1;   		// read tag/data of arg1 
  arg2 = *(s32 *)(arg1 + 4);   
  arg3 = (u32)arg3;   
  t1 = arg2 & 63;		// Strip off any CDR code bits. 
  t2 = (t1 == Type_Fixnum) ? 1 : 0;   

force-alignment14907:
  if (_trace) printf("force-alignment14907:\n");
  if (t2 == 0) 
    goto basic-dispatch14903;
  /* Here if argument TypeFixnum */
  t2 = *(u64 *)&(processor->mostpositivefixnum);   
  t3 = arg3 + 1;
  t2 = (arg3 == t2) ? 1 : 0;   
  if (t2 != 0)   
    goto incrementexception;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u32 *)arg1 = t3;
		/* write the stack cache */
  *(u32 *)(arg1 + 4) = arg2;
  goto cachevalid;   

basic-dispatch14903:
  if (_trace) printf("basic-dispatch14903:\n");
  t2 = (t1 == Type_SingleFloat) ? 1 : 0;   

force-alignment14908:
  if (_trace) printf("force-alignment14908:\n");
  if (t2 == 0) 
    goto basic-dispatch14904;
  /* Here if argument TypeSingleFloat */
  /* NIL */
  LDS(1, f1, *(u32 *)arg1 );   		// Get the floating data 
  LDS(2, f2, processor->sfp1);   		// constant 1.0 
  ADDS(0, f0, 1, f1, 2, f2); /* adds */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  STS( (u32 *)arg1, 0, f0 );   		// Put the floating result 
  goto cachevalid;   

basic-dispatch14904:
  if (_trace) printf("basic-dispatch14904:\n");
  /* Here for all other cases */
  goto incrementexception;   

basic-dispatch14902:
  if (_trace) printf("basic-dispatch14902:\n");

DoIncrementIM:
  goto doistageerror;

/* end DoIncrement */
  /* End of Halfword operand from stack instruction - DoIncrement */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifuncom2.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifungene.as
 ************************************************************************/

  /* Generic dispatching an method lookup */
/* start DoMessageDispatch */

  /* Halfword operand from stack instruction - DoMessageDispatch */
  /* arg2 has the preloaded 8 bit operand. */

domessagedispatch:
  if (_trace) printf("domessagedispatch:\n");

DoMessageDispatchSP:
  if (_trace) printf("DoMessageDispatchSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoMessageDispatchLP:
  if (_trace) printf("DoMessageDispatchLP:\n");

DoMessageDispatchFP:
  if (_trace) printf("DoMessageDispatchFP:\n");

begindomessagedispatch:
  if (_trace) printf("begindomessagedispatch:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg2 = *(s32 *)&processor->control;   
  arg1 = *(s32 *)(iFP + 28);   		// get message tag and data 
  t1 = *(s32 *)(iFP + 24);   
  arg5 = arg2 & 255;		// get number of arguments 
  arg3 = *(s32 *)(iFP + 20);   		// get instance tag and data 
  arg4 = *(s32 *)(iFP + 16);   
  arg5 = arg5 - 4;   		// done if 2 or more arguments (plus 2 extra words) 
  if ((s64)arg5 < 0)   
    goto verifygenericarity;
  t1 = (u32)t1;   
  arg4 = (u32)arg4;   
  r0 = (u64)&&return0491;
  goto lookuphandler;
return0491:
  arg4 = *(u64 *)(iFP + 16);   		// clobbered by |LookupHandler| 
  t3 = t4 - Type_EvenPC;   
  t3 = t3 & 62;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto message-dispatch14911;
  t3 = t6 & 63;		// Strip CDR code 
  t3 = t3 - Type_NIL;   
  if (t3 == 0) 
    goto message-dispatch14909;
  *(u32 *)(iFP + 16) = t7;
		/* write the stack cache */
  *(u32 *)(iFP + 20) = t6;
  goto message-dispatch14910;   

message-dispatch14909:
  if (_trace) printf("message-dispatch14909:\n");
		/* swap message/instance in the frame */
  *(u32 *)(iFP + 16) = t1;
		/* write the stack cache */
  *(u32 *)(iFP + 20) = arg1;

message-dispatch14910:
  if (_trace) printf("message-dispatch14910:\n");
  *(u64 *)(iFP + 24) = arg4;   
  /* Convert real continuation to PC. */
  iPC = t4 & 1;
  iPC = t9 + iPC;
  iPC = t9 + iPC;
  goto interpretinstructionforjump;   

message-dispatch14911:
  if (_trace) printf("message-dispatch14911:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t3 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = iSP - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t3 = t2 + t3;		// reconstruct VMA 
  arg5 = t3;
  arg2 = 37;
  goto illegaloperand;

DoMessageDispatchIM:
  goto doistageerror;

/* end DoMessageDispatch */
  /* End of Halfword operand from stack instruction - DoMessageDispatch */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifungene.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunfcal.as
 ************************************************************************/

  /* Function calling. */
  /* Start call. */
  /* Finish call. */
/* start DoFinishCallTos */

  /* Halfword 10 bit immediate instruction - DoFinishCallTos */

dofinishcalltos:
  if (_trace) printf("dofinishcalltos:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoFinishCallTosIM:
  if (_trace) printf("DoFinishCallTosIM:\n");

DoFinishCallTosSP:
  if (_trace) printf("DoFinishCallTosSP:\n");

DoFinishCallTosLP:
  if (_trace) printf("DoFinishCallTosLP:\n");

DoFinishCallTosFP:
  if (_trace) printf("DoFinishCallTosFP:\n");
  /* arg1 has operand preloaded. */
  arg1 = (u8)(arg3 >> ((5&7)*8));   		// arg1 contains the disposition (two bits) 
  arg2 = *(s32 *)iSP;   		// Get the number of args 
  iSP = iSP - 8;   		// Pop stack 
  arg2 = (arg2 * 8) + 8;  		// Add 1 and convert to stacked word address 
  goto finishcallmerge;   

/* end DoFinishCallTos */
  /* End of Halfword operand from stack instruction - DoFinishCallTos */
  /* Function entry. */
/* start DoEntryRestAccepted */

  /* Field Extraction instruction - DoEntryRestAccepted */

doentryrestaccepted:
  if (_trace) printf("doentryrestaccepted:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoEntryRestAcceptedIM:
  if (_trace) printf("DoEntryRestAcceptedIM:\n");

DoEntryRestAcceptedSP:
  if (_trace) printf("DoEntryRestAcceptedSP:\n");

DoEntryRestAcceptedLP:
  if (_trace) printf("DoEntryRestAcceptedLP:\n");

DoEntryRestAcceptedFP:
  if (_trace) printf("DoEntryRestAcceptedFP:\n");
  arg5 = *(s32 *)&processor->control;   		// The control register 
  arg4 = arg3 >> 18;   		// Pull down the number of optionals 
  arg1 = (u8)(arg3 >> ((5&7)*8));   		// Extract the 'ptr' field while we are waiting 
  arg4 = arg4 & 255;
  /* arg1=ptr field, arg2=required, arg3=instn, arg4=optionals arg5=control-register */
  t2 = arg5 >> 27;   		// Get the cr.trace-pending bit 
  t1 = arg5 & 255;		// The supplied args 
  if (t2 & 1)   
    goto tracetrap;
  t3 = arg5 >> 17;   
  t4 = *(s32 *)(iSP + 4);   		// Get the tag of the stack top. 

force-alignment14914:
  if (_trace) printf("force-alignment14914:\n");
  if (t3 & 1)   		// J. if apply args 
    goto b-apply-argument-supplied14912;

b-apply-argument-supplied14913:
  t2 = t1 - arg2;   		// t2=supplied-minimum 
  if ((s64)t2 < 0)   		// B. if too few args. 
    goto retryeratoofew;
  arg1 = arg4 - t1;   		// maximum-supplied 
  if ((s64)arg1 < 0)   		// B. rest args. 
    goto retryerarest;
  /* Compute entry position and advance PC/CP accordingly. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   		// get the next PC 
  t3 = t2 << 1;   		// Adjust index to halfword 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t2 == 0) 		// J. if index zero, no adjustment. 
    goto INTERPRETINSTRUCTION;
  iPC = iPC + t3;		// Compute the new address 
  iPC = iPC & ~1L;		// Make it an DTP-EVEN-PC 
  goto interpretinstructionforjump;   

applysuppra:
  if (_trace) printf("applysuppra:\n");
  arg1 = arg4 - t1;   		// maximum-supplied 
  if ((s64)arg1 < 0)   		// B. rest args. 
    goto retryerarest;
  if ((s64)arg1 > 0)   		// try pulling from applied args. 
    goto pullapplyargs;
  t6 = *(s32 *)(iSP + 4);   		// get tag 
  t6 = t6 & 63;
  t6 = t6 | 64;
		/* set tag */
  *(u32 *)(iSP + 4) = t6;
  t2 = t1 - arg2;   		// t2=supplied-minimum 
  t2 = t2 + 1;
  /* Compute entry position and advance PC/CP accordingly. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   		// get the next PC 
  t3 = t2 << 1;   		// Adjust index to halfword 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t2 == 0) 		// J. if index zero, no adjustment. 
    goto INTERPRETINSTRUCTION;
  iPC = iPC + t3;		// Compute the new address 
  iPC = iPC & ~1L;		// Make it an DTP-EVEN-PC 
  goto interpretinstructionforjump;   

retryeratoofew:
  if (_trace) printf("retryeratoofew:\n");
  arg5 = 0;
  arg2 = 77;
  goto illegaloperand;

retryerarest:
  if (_trace) printf("retryerarest:\n");
  t1 = *(s32 *)(iSP + 4);   		// get tag 
  t1 = t1 & 63;
  t1 = t1 | 64;
		/* set tag */
  *(u32 *)(iSP + 4) = t1;
  t2 = arg5 >> 17;   
  t3 = *(s32 *)(iSP + 4);   		// Get the tag of the stack top. 

force-alignment14919:
  if (_trace) printf("force-alignment14919:\n");
  if (t2 & 1)   		// J. if apply args 
    goto b-apply-argument-supplied14917;

b-apply-argument-supplied14918:
  t1 = (arg4 * 8) + iFP;  
  /* Convert stack cache address to VMA */
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = t1 - t3;   		// stack cache base relative offset 
  t3 = t3 >> 3;   		// convert byte address to word address 
  t2 = t3 + t2;		// reconstruct VMA 
  t1 = Type_List;
  *(u32 *)(iSP + 8) = t2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto push-apply-args14916;   

push-apply-args14915:
  if (_trace) printf("push-apply-args14915:\n");
  t1 = iSP - 8;   
  t3 = *(s32 *)(t1 + 4);   		// get tag 
  t3 = t3 & 63;
  t3 = t3 | 128;
		/* set tag */
  *(u32 *)(t1 + 4) = t3;
  t1 = (arg4 * 8) + iFP;  
  /* Convert stack cache address to VMA */
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = t1 - t3;   		// stack cache base relative offset 
  t3 = t3 >> 3;   		// convert byte address to word address 
  t2 = t3 + t2;		// reconstruct VMA 
  t1 = Type_List;
  *(u32 *)(iSP + 8) = t2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  iLP = iLP + 8;
  arg5 = arg5 + 1;
  *(u32 *)&processor->control = arg5;

push-apply-args14916:
  if (_trace) printf("push-apply-args14916:\n");
  t1 = arg4 - arg2;   
  t1 = t1 + 1;
  /* Compute entry position and advance PC/CP accordingly. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   		// get the next PC 
  t2 = t1 << 1;   		// Adjust index to halfword 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t1 == 0) 		// J. if index zero, no adjustment. 
    goto INTERPRETINSTRUCTION;
  iPC = iPC + t2;		// Compute the new address 
  iPC = iPC & ~1L;		// Make it an DTP-EVEN-PC 
  goto interpretinstructionforjump;   

b-apply-argument-supplied14917:
  if (_trace) printf("b-apply-argument-supplied14917:\n");
  t3 = t3 & 63;
  t3 = t3 - Type_NIL;   
  if (t3 != 0)   		// J. if apply args supplied not nil. 
    goto push-apply-args14915;
  t2 = t2 & 1;		// keep just the apply bit! 
  t2 = t2 << 17;   		// reposition the apply bit 
  iSP = iSP - 8;   		// Pop off the null applied arg. 
  arg5 = arg5 & ~t2;		// Blast the apply arg bit away 
		/* Reset the stored cr bit */
  *(u32 *)&processor->control = arg5;
  goto b-apply-argument-supplied14918;   

b-apply-argument-supplied14912:
  if (_trace) printf("b-apply-argument-supplied14912:\n");
  t4 = t4 & 63;
  t4 = t4 - Type_NIL;   
  if (t4 != 0)   		// J. if apply args supplied not nil. 
    goto applysuppra;
  t3 = t3 & 1;		// keep just the apply bit! 
  t3 = t3 << 17;   		// reposition the apply bit 
  iSP = iSP - 8;   		// Pop off the null applied arg. 
  arg5 = arg5 & ~t3;		// Blast the apply arg bit away 
		/* Reset the stored cr bit */
  *(u32 *)&processor->control = arg5;
  goto b-apply-argument-supplied14913;   

/* end DoEntryRestAccepted */
  /* End of Halfword operand from stack instruction - DoEntryRestAccepted */
/* start CarCdrInternal */


carcdrinternal:
  if (_trace) printf("carcdrinternal:\n");
  sp = sp + -8;   
  arg2 = (u32)(t2 >> ((zero&7)*8));   
  t5 = t1 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_List) ? 1 : 0;   

force-alignment14967:
  if (_trace) printf("force-alignment14967:\n");
  if (t6 == 0) 
    goto basic-dispatch14924;
  /* Here if argument TypeList */
  /* Memory Read Internal */

vma-memory-read14925:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14927;

vma-memory-read14926:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14929;

vma-memory-read14936:
  t5 = (s32)arg2 - (s32)t2;   
  if (t5 != 0)   		// CAR forwarded, must CDR the hard way 
    goto carcdr-internal14920;
  t1 = arg5;
  t2 = arg6;

carcdr-internal14922:
  if (_trace) printf("carcdr-internal14922:\n");
  t5 = arg5 & 192;		// Extract CDR code. 
  if (t5 != 0)   
    goto basic-dispatch14938;
  /* Here if argument 0 */
  arg6 = arg2 + 1;		// Address of next position is CDR 
  arg5 = Type_List;

basic-dispatch14937:
  if (_trace) printf("basic-dispatch14937:\n");

basic-dispatch14923:
  if (_trace) printf("basic-dispatch14923:\n");

carcdr-internal14921:
  if (_trace) printf("carcdr-internal14921:\n");
  sp = sp + 8;   
  goto *r0; /* ret */

basic-dispatch14924:
  if (_trace) printf("basic-dispatch14924:\n");
  t6 = (t5 == Type_NIL) ? 1 : 0;   

force-alignment14968:
  if (_trace) printf("force-alignment14968:\n");
  if (t6 == 0) 
    goto basic-dispatch14954;
  /* Here if argument TypeNIL */
  arg6 = *(s32 *)&processor->niladdress;   
  arg5 = *((s32 *)(&processor->niladdress)+1);   
  arg6 = (u32)arg6;   
  goto basic-dispatch14923;   

basic-dispatch14954:
  if (_trace) printf("basic-dispatch14954:\n");
  /* Here for all other cases */
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto listexception;

carcdr-internal14920:
  if (_trace) printf("carcdr-internal14920:\n");
  arg2 = (u32)(t2 >> ((zero&7)*8));   
  t1 = arg5;
  t2 = arg6;
  /* Memory Read Internal */

vma-memory-read14956:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->cdr_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14958;

vma-memory-read14957:
  t7 = zero + 192;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read14960;

vma-memory-read14965:
  goto carcdr-internal14922;   

vma-memory-read14960:
  if (_trace) printf("vma-memory-read14960:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14959;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14956;   

vma-memory-read14959:
  if (_trace) printf("vma-memory-read14959:\n");

vma-memory-read14958:
  if (_trace) printf("vma-memory-read14958:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0492;
  goto memoryreadcdrdecode;
return0492:
  r0 = *(u64 *)sp;   
  goto vma-memory-read14965;   

basic-dispatch14938:
  if (_trace) printf("basic-dispatch14938:\n");
  t6 = (t5 == 128) ? 1 : 0;   

force-alignment14969:
  if (_trace) printf("force-alignment14969:\n");
  if (t6 == 0) 
    goto basic-dispatch14939;
  /* Here if argument 128 */
  arg2 = arg2 + 1;
  /* Memory Read Internal */

vma-memory-read14940:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read14942;

vma-memory-read14941:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t8 & 1)   
    goto vma-memory-read14944;
  goto carcdr-internal14921;   

basic-dispatch14939:
  if (_trace) printf("basic-dispatch14939:\n");
  t6 = (t5 == 64) ? 1 : 0;   

force-alignment14970:
  if (_trace) printf("force-alignment14970:\n");
  if (t6 == 0) 
    goto basic-dispatch14951;
  /* Here if argument 64 */
  arg6 = *(s32 *)&processor->niladdress;   
  arg5 = *((s32 *)(&processor->niladdress)+1);   
  arg6 = (u32)arg6;   
  goto carcdr-internal14921;   

basic-dispatch14951:
  if (_trace) printf("basic-dispatch14951:\n");
  /* Here for all other cases */
  arg5 = arg2;
  arg2 = 15;
  goto illegaloperand;

vma-memory-read14944:
  if (_trace) printf("vma-memory-read14944:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14943;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14940;   

vma-memory-read14943:
  if (_trace) printf("vma-memory-read14943:\n");

vma-memory-read14942:
  if (_trace) printf("vma-memory-read14942:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0493;
  goto memoryreaddatadecode;
return0493:
  r0 = *(u64 *)sp;   
  goto carcdr-internal14921;   

vma-memory-read14929:
  if (_trace) printf("vma-memory-read14929:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read14928;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14925;   

vma-memory-read14928:
  if (_trace) printf("vma-memory-read14928:\n");

vma-memory-read14927:
  if (_trace) printf("vma-memory-read14927:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0494;
  goto memoryreaddatadecode;
return0494:
  r0 = *(u64 *)sp;   
  goto vma-memory-read14936;   

/* end CarCdrInternal */
/* start PullApplyArgsSlowly */


pullapplyargsslowly:
  if (_trace) printf("pullapplyargsslowly:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg4 = *(s32 *)iSP;   		// Get the rest arg 
  arg3 = *(s32 *)(iSP + 4);   
  arg4 = (u32)arg4;   
  t2 = (u32)(arg4 >> ((zero&7)*8));   
  t3 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = (t3 == Type_List) ? 1 : 0;   

force-alignment15018:
  if (_trace) printf("force-alignment15018:\n");
  if (t4 == 0) 
    goto basic-dispatch14975;
  /* Here if argument TypeList */
  /* Memory Read Internal */

vma-memory-read14976:
  t5 = t2 + ivory;
  arg6 = (t5 * 4);   
  arg5 = LDQ_U(t5);   
  t3 = t2 - t11;   		// Stack cache offset 
  t6 = *(u64 *)&(processor->dataread_mask);   
  t4 = ((u64)t3 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t5&7)*8));   
  if (t4 != 0)   
    goto vma-memory-read14978;

vma-memory-read14977:
  t5 = zero + 240;   
  t6 = t6 >> (arg5 & 63);   
  t5 = t5 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t6 & 1)   
    goto vma-memory-read14980;

vma-memory-read14987:
  t3 = (s32)t2 - (s32)arg4;   
  if (t3 != 0)   		// CAR forwarded, must CDR the hard way 
    goto carcdr-internal14971;
  arg3 = arg5;
  arg4 = arg6;

carcdr-internal14973:
  if (_trace) printf("carcdr-internal14973:\n");
  t3 = arg5 & 192;		// Extract CDR code. 
  if (t3 != 0)   
    goto basic-dispatch14989;
  /* Here if argument 0 */
  arg6 = t2 + 1;		// Address of next position is CDR 
  arg5 = Type_List;

basic-dispatch14988:
  if (_trace) printf("basic-dispatch14988:\n");

basic-dispatch14974:
  if (_trace) printf("basic-dispatch14974:\n");

carcdr-internal14972:
  if (_trace) printf("carcdr-internal14972:\n");
		/* Push the pulled argument */
  *(u32 *)iSP = arg4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = arg3;
  t1 = arg5 & 63;		// set CDR-NEXT 
		/* Push the new rest arg */
  *(u32 *)(iSP + 8) = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  arg2 = *(s32 *)&processor->control;   
  t2 = arg2 & 255;		// Get current arg size. 
  arg2 = arg2 & ~255L;
  t2 = t2 + 1;
  arg2 = t2 + arg2;		// Update the arg size 
  *(u32 *)&processor->control = arg2;
  iLP = iLP + 8;
  goto INTERPRETINSTRUCTION;   

basic-dispatch14975:
  if (_trace) printf("basic-dispatch14975:\n");
  t4 = (t3 == Type_NIL) ? 1 : 0;   

force-alignment15019:
  if (_trace) printf("force-alignment15019:\n");
  if (t4 == 0) 
    goto basic-dispatch15005;
  /* Here if argument TypeNIL */
  arg6 = *(s32 *)&processor->niladdress;   
  arg5 = *((s32 *)(&processor->niladdress)+1);   
  arg6 = (u32)arg6;   
  goto basic-dispatch14974;   

basic-dispatch15005:
  if (_trace) printf("basic-dispatch15005:\n");
  /* Here for all other cases */
  arg1 = arg1;
  goto pullapplyargstrap;

carcdr-internal14971:
  if (_trace) printf("carcdr-internal14971:\n");
  t2 = (u32)(arg4 >> ((zero&7)*8));   
  arg3 = arg5;
  arg4 = arg6;
  /* Memory Read Internal */

vma-memory-read15007:
  t5 = t2 + ivory;
  arg6 = (t5 * 4);   
  arg5 = LDQ_U(t5);   
  t3 = t2 - t11;   		// Stack cache offset 
  t6 = *(u64 *)&(processor->cdr_mask);   
  t4 = ((u64)t3 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t5&7)*8));   
  if (t4 != 0)   
    goto vma-memory-read15009;

vma-memory-read15008:
  t5 = zero + 192;   
  t6 = t6 >> (arg5 & 63);   
  t5 = t5 >> (arg5 & 63);   
  if (t6 & 1)   
    goto vma-memory-read15011;

vma-memory-read15016:
  goto carcdr-internal14973;   

vma-memory-read15009:
  if (_trace) printf("vma-memory-read15009:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t3 = (t3 * 8) + t4;  		// reconstruct SCA 
  arg6 = *(s32 *)t3;   
  arg5 = *(s32 *)(t3 + 4);   		// Read from stack cache 
  goto vma-memory-read15008;   

vma-memory-read15011:
  if (_trace) printf("vma-memory-read15011:\n");
  if ((t5 & 1) == 0)   
    goto vma-memory-read15010;
  t2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read15007;   

vma-memory-read15010:
  if (_trace) printf("vma-memory-read15010:\n");
  t6 = *(u64 *)&(processor->cdr);   		// Load the memory action table for cycle 
  /* TagType. */
  t5 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t2;   		// stash the VMA for the (likely) trap 
  t5 = (t5 * 4) + t6;   		// Adjust for a longword load 
  t6 = *(s32 *)t5;   		// Get the memory action 

vma-memory-read15013:
  /* Perform memory action */
  arg1 = t6;
  arg2 = 9;
  goto performmemoryaction;

basic-dispatch14989:
  if (_trace) printf("basic-dispatch14989:\n");
  t4 = (t3 == 128) ? 1 : 0;   

force-alignment15020:
  if (_trace) printf("force-alignment15020:\n");
  if (t4 == 0) 
    goto basic-dispatch14990;
  /* Here if argument 128 */
  t2 = t2 + 1;
  /* Memory Read Internal */

vma-memory-read14991:
  t5 = t2 + ivory;
  arg6 = (t5 * 4);   
  arg5 = LDQ_U(t5);   
  t3 = t2 - t11;   		// Stack cache offset 
  t6 = *(u64 *)&(processor->dataread_mask);   
  t4 = ((u64)t3 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t5&7)*8));   
  if (t4 != 0)   
    goto vma-memory-read14993;

vma-memory-read14992:
  t5 = zero + 240;   
  t6 = t6 >> (arg5 & 63);   
  t5 = t5 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t6 & 1)   
    goto vma-memory-read14995;
  goto carcdr-internal14972;   

basic-dispatch14990:
  if (_trace) printf("basic-dispatch14990:\n");
  t4 = (t3 == 64) ? 1 : 0;   

force-alignment15021:
  if (_trace) printf("force-alignment15021:\n");
  if (t4 == 0) 
    goto basic-dispatch15002;
  /* Here if argument 64 */
  arg6 = *(s32 *)&processor->niladdress;   
  arg5 = *((s32 *)(&processor->niladdress)+1);   
  arg6 = (u32)arg6;   
  goto carcdr-internal14972;   

basic-dispatch15002:
  if (_trace) printf("basic-dispatch15002:\n");
  /* Here for all other cases */
  arg5 = t2;
  arg2 = 15;
  goto illegaloperand;

vma-memory-read14993:
  if (_trace) printf("vma-memory-read14993:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t3 = (t3 * 8) + t4;  		// reconstruct SCA 
  arg6 = *(s32 *)t3;   
  arg5 = *(s32 *)(t3 + 4);   		// Read from stack cache 
  goto vma-memory-read14992;   

vma-memory-read14995:
  if (_trace) printf("vma-memory-read14995:\n");
  if ((t5 & 1) == 0)   
    goto vma-memory-read14994;
  t2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14991;   

vma-memory-read14994:
  if (_trace) printf("vma-memory-read14994:\n");
  t6 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t5 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t2;   		// stash the VMA for the (likely) trap 
  t5 = (t5 * 4) + t6;   		// Adjust for a longword load 
  t6 = *(s32 *)t5;   		// Get the memory action 

vma-memory-read14999:
  if (_trace) printf("vma-memory-read14999:\n");
  t5 = t6 & MemoryActionTransform;
  if (t5 == 0) 
    goto vma-memory-read14998;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto carcdr-internal14972;   

vma-memory-read14998:

vma-memory-read14997:
  /* Perform memory action */
  arg1 = t6;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read14978:
  if (_trace) printf("vma-memory-read14978:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t3 = (t3 * 8) + t4;  		// reconstruct SCA 
  arg6 = *(s32 *)t3;   
  arg5 = *(s32 *)(t3 + 4);   		// Read from stack cache 
  goto vma-memory-read14977;   

vma-memory-read14980:
  if (_trace) printf("vma-memory-read14980:\n");
  if ((t5 & 1) == 0)   
    goto vma-memory-read14979;
  t2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read14976;   

vma-memory-read14979:
  if (_trace) printf("vma-memory-read14979:\n");
  t6 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t5 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t2;   		// stash the VMA for the (likely) trap 
  t5 = (t5 * 4) + t6;   		// Adjust for a longword load 
  t6 = *(s32 *)t5;   		// Get the memory action 

vma-memory-read14984:
  if (_trace) printf("vma-memory-read14984:\n");
  t5 = t6 & MemoryActionTransform;
  if (t5 == 0) 
    goto vma-memory-read14983;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto vma-memory-read14987;   

vma-memory-read14983:

vma-memory-read14982:
  /* Perform memory action */
  arg1 = t6;
  arg2 = 0;
  goto performmemoryaction;

/* end PullApplyArgsSlowly */
/* start DoLocateLocals */

  /* Halfword operand from stack instruction - DoLocateLocals */
  /* arg2 has the preloaded 8 bit operand. */

dolocatelocals:
  if (_trace) printf("dolocatelocals:\n");

DoLocateLocalsSP:
  if (_trace) printf("DoLocateLocalsSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoLocateLocalsLP:
  if (_trace) printf("DoLocateLocalsLP:\n");

DoLocateLocalsFP:
  if (_trace) printf("DoLocateLocalsFP:\n");

begindolocatelocals:
  if (_trace) printf("begindolocatelocals:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t1 = *(s32 *)&processor->control;   		// The control register 
  iLP = iSP;
  t3 = iLP - iFP;   		// arg size including the fudge 2 
  t3 = t3 >> 3;   		// adjust arg size to words 
  t2 = t1 & 255;		// argument size 
  t2 = t2 - 2;   		// corrected arg size 
  t1 = t1 & ~255L;
  t1 = t1 | t3;		// replace the arg size 
  t4 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  *(u32 *)&processor->control = t1;
  goto NEXTINSTRUCTION;   

DoLocateLocalsIM:
  goto doistageerror;

/* end DoLocateLocals */
  /* End of Halfword operand from stack instruction - DoLocateLocals */
  /* Returning. */
/* start DoReturnMultiple */

  /* Halfword operand from stack instruction - DoReturnMultiple */
  /* arg2 has the preloaded 8 bit operand. */

doreturnmultiple:
  if (_trace) printf("doreturnmultiple:\n");

DoReturnMultipleSP:
  if (_trace) printf("DoReturnMultipleSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoReturnMultipleLP:
  if (_trace) printf("DoReturnMultipleLP:\n");

DoReturnMultipleFP:
  if (_trace) printf("DoReturnMultipleFP:\n");

begindoreturnmultiple:
  if (_trace) printf("begindoreturnmultiple:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t1 = *(s32 *)(arg1 + 4);   		// Fetch the tag for type-check 
  arg1 = *(s32 *)arg1;   		// Fetch the data 
  t2 = t1 - Type_Fixnum;   
  t2 = t2 & 63;		// Strip CDR code 
  if (t2 != 0)   
    goto returnmultipleio;
  arg1 = (u32)arg1;   		// Discard dtp-fixnum tag word 

returnmultipletop:
  if (_trace) printf("returnmultipletop:\n");
  arg5 = *(s32 *)&processor->control;   
  t3 = (12) << 16;   
  t2 = iSP + 8;
  t1 = arg1 << 3;   		// Value bytes 
  t3 = t3 & arg5;		// Mask 
  t3 = t3 >> 18;   		// Shift disposition bits into place. 
  arg3 = t2 - t1;   		// Compute position of value(s) 
  arg6 = *(u64 *)&(processor->stackcachedata);   
  arg4 = t3 - 2;   		// arg4 -2=effect -1=value 0=return 1=multiple 
  if ((s64)arg4 < 0)   
    goto returnmultiplesingle;
  /* Restore machine state from frame header. */
  t3 = *(s32 *)iFP;   
  t1 = (1792) << 16;   
  t5 = *(s32 *)&processor->continuation;   
  t1 = arg5 & t1;		// Mask 
  t2 = *(s32 *)(iFP + 4);   
  t7 = iCP;
  if (t1 != 0)   		// Need to cleanup frame first 
    goto handleframecleanup;
  t3 = (u32)t3;   
  t4 = *((s32 *)(&processor->continuation)+1);   
  t5 = (u32)t5;   
#ifdef IVERIFY
  /* check for instruction verification suite end-of-test */
  t6 = (s32)t2 - (s32)Type_NIL;   		// check for end of run 
  if (t6 == 0) 
    goto abandon-frame-simple15022;
#endif
  t6 = *(s32 *)(iFP + 8);   		// Get saved control register 
  /* TagType. */
  t2 = t2 & 63;
  /* Restore the PC. */
  if (arg4 == 0) 
    goto abandon-frame-simple15023;
  iPC = t5 << 1;   		// Assume even PC 
  t1 = t4 & 1;
  t7 = *(u64 *)&(processor->continuationcp);   
  iPC = iPC + t1;

abandon-frame-simple15023:
  if (_trace) printf("abandon-frame-simple15023:\n");
  /* Restore the saved continuation */
  *((u32 *)(&processor->continuation)+1) = t2;
  t1 = arg5 >> 9;   		// Get the caller frame size into place 
  *(u32 *)&processor->continuation = t3;
  iSP = iFP - 8;   		// Restore the stack pointer. 
  *(u64 *)&processor->continuationcp = zero;   
  t1 = t1 & 255;		// Mask just the caller frame size. 
  t1 = (t1 * 8) + 0;  		// *8 
  t2 = (2048) << 16;   
  t2 = t2 & arg5;
  t3 = *(s32 *)&processor->interruptreg;   		// Get the preempt-pending bit 
  t6 = t2 | t6;		// Sticky trace pending bit. 
  t4 = *(u64 *)&(processor->please_stop);   		// Get the trap/suspend bits 
  iFP = iFP - t1;   		// Restore the frame pointer. 
		/* Restore the control register */
  *(u32 *)&processor->control = t6;
  t1 = t6 & 255;		// extract the argument size 
  t3 = t3 & 1;
  t3 = t4 | t3;
  *(u64 *)&processor->stop_interpreter = t3;   
  iLP = (t1 * 8) + iFP;  		// Restore the local pointer. 
  arg6 = ((u64)iFP < (u64)arg6) ? 1 : 0;   		// ARG6 = stack-cache underflow 
  t4 = iSP + 8;		// Compute destination of copy 
  t3 = arg1;		// Values 
  t1 = *(u64 *)&(processor->cdrcodemask);   		// mask for CDR codes 
  goto stack-block-copy15024;   

stack-block-copy15025:
  if (_trace) printf("stack-block-copy15025:\n");
  t3 = t3 - 1;   
  t2 = *(u64 *)arg3;   		// Get a word from source 
  arg3 = arg3 + 8;		// advance from position 
  t2 = t2 & ~t1;		// Strip off CDR code 
  *(u64 *)t4 = t2;   		// Put word in destination 
  t4 = t4 + 8;		// advance to position 

stack-block-copy15024:
  if ((s64)t3 > 0)   
    goto stack-block-copy15025;
  iSP = (arg1 * 8) + iSP;  		// Adjust iSP over returned values 
  /* arg4 -2=effect -1=value 0=return 1=multiple */
  if (arg4 == 0) 
    goto returnmultiplereturn;

returnmultiplemultiple:
  if (_trace) printf("returnmultiplemultiple:\n");
  t1 = Type_Fixnum;
		/* push the MV return count */
  *(u32 *)(iSP + 8) = arg1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;

returnmultipledone:
  if (_trace) printf("returnmultipledone:\n");
  if (arg6 != 0)   
    goto returnmultipleunderflow;
  arg2 = t7;
  if (t7 != 0)   
    goto interpretinstructionpredicted;
  if (arg4 != 0)   
    goto interpretinstructionforbranch;
  goto INTERPRETINSTRUCTION;   		// Return-multiple done 

returnmultipleunderflow:
  if (_trace) printf("returnmultipleunderflow:\n");
  goto stackcacheunderflowcheck;

returnmultiplesingle:
  if (_trace) printf("returnmultiplesingle:\n");
  arg3 = *(u64 *)arg3;   
  t1 = *(u64 *)&(processor->niladdress);   
  arg3 = arg3 << 26;   		// Clear cdr 
  arg3 = arg3 >> 26;   		// Clear cdr 
  if (arg1 == 0)   
    arg3 = t1;
  goto returncommontail;   

returnmultiplereturn:
  if (_trace) printf("returnmultiplereturn:\n");
  if (arg2 != 0)   
    goto returnmultipledone;
  t1 = Type_Fixnum;
  *(u32 *)(iSP + 8) = arg1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto returnmultipledone;   

DoReturnMultipleIM:
  if (_trace) printf("DoReturnMultipleIM:\n");
  arg1 = arg2;
  arg2 = zero + 1;   
  goto returnmultipletop;   

returnmultipleio:
  if (_trace) printf("returnmultipleio:\n");
  arg5 = 0;
  arg2 = 63;
  goto illegaloperand;

/* end DoReturnMultiple */
  /* End of Halfword operand from stack instruction - DoReturnMultiple */
/* start HANDLEFRAMECLEANUP */


handleframecleanup:
  if (_trace) printf("handleframecleanup:\n");
  iSP = *(u64 *)&(processor->restartsp);   		// Restore SP to instruction start 
  arg5 = *(s32 *)&processor->control;   		// Get control register 

cleanup-frame15028:
  if (_trace) printf("cleanup-frame15028:\n");
  t1 = (1024) << 16;   
  t4 = *(s32 *)&processor->catchblock;   
  t4 = (u32)t4;   
  t2 = t1 & arg5;
  if (t2 == 0) 		// J. if cr.cleanup-catch is 0 
    goto cleanup-frame15027;
  /* Convert VMA to stack cache address */
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = t4 - t2;   		// stack cache base relative offset 
  t3 = (t2 * 8) + t3;  		// reconstruct SCA 
  t6 = *(s32 *)(t3 + 16);   
  t5 = *(s32 *)(t3 + 20);   
  t6 = (u32)t6;   
  t2 = *(s32 *)(t3 + 8);   
  t1 = *(s32 *)(t3 + 12);   
  t2 = (u32)t2;   
  t12 = t1 & 64;
  if (t12 != 0)   		// J. if catch block is UWP variety. 
    goto handleunwindprotect;
  t3 = (1024) << 16;   
  t2 = t5 & 64;		// Extract the catchcleanup bit 
  t2 = t2 << 20;   		// Shift into place for CR 
  t3 = arg5 & ~t3;
  arg5 = t3 | t2;
  *(u32 *)&processor->control = arg5;
  /* TagType. */
  t5 = t5 & 63;
  t5 = t5 << 32;   
  t6 = t6 | t5;
  *(u64 *)&processor->catchblock = t6;   
  goto cleanup-frame15028;   

cleanup-frame15027:
  if (_trace) printf("cleanup-frame15027:\n");
  t1 = (512) << 16;   
  t2 = t1 & arg5;
  t1 = *(u64 *)&(processor->bindingstackpointer);   
  if (t2 == 0) 		// J. if cr.cleanup-bindings is 0. 
    goto cleanup-frame15026;

cleanup-frame15029:
  if (_trace) printf("cleanup-frame15029:\n");
  t1 = *(u64 *)&(processor->bindingstackpointer);   
  t4 = *(s32 *)&processor->control;   
  t1 = (u32)t1;   		// vma only 
  t2 = (512) << 16;   
  t5 = t1 - 1;   
  t3 = t4 & t2;
  t4 = t4 & ~t2;		// Turn off the bit 
  if (t3 != 0)   
    goto g15030;
  t4 = *(u64 *)&(processor->restartsp);   		// Get the SP, ->op2 
  arg5 = 0;
  arg2 = 20;
  goto illegaloperand;

g15030:
  if (_trace) printf("g15030:\n");
  /* Memory Read Internal */

vma-memory-read15031:
  t8 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t1 + ivory;
  t9 = *(s32 *)&processor->scovlimit;   
  t6 = (t10 * 4);   
  t7 = LDQ_U(t10);   
  t8 = t1 - t8;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->bindread_mask);   
  t9 = ((u64)t8 < (u64)t9) ? 1 : 0;   		// In range? 
  t6 = *(s32 *)t6;   
  t7 = (u8)(t7 >> ((t10&7)*8));   
  if (t9 != 0)   
    goto vma-memory-read15033;

vma-memory-read15032:
  t10 = zero + 224;   
  t11 = t11 >> (t7 & 63);   
  t10 = t10 >> (t7 & 63);   
  if (t11 & 1)   
    goto vma-memory-read15035;

vma-memory-read15040:
  /* Memory Read Internal */

vma-memory-read15041:
  t8 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t5 + ivory;
  t9 = *(s32 *)&processor->scovlimit;   
  t2 = (t10 * 4);   
  t3 = LDQ_U(t10);   
  t8 = t5 - t8;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->bindread_mask);   
  t9 = ((u64)t8 < (u64)t9) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t3 = (u8)(t3 >> ((t10&7)*8));   
  if (t9 != 0)   
    goto vma-memory-read15043;

vma-memory-read15042:
  t10 = zero + 224;   
  t11 = t11 >> (t3 & 63);   
  t10 = t10 >> (t3 & 63);   
  t2 = (u32)t2;   
  if (t11 & 1)   
    goto vma-memory-read15045;

vma-memory-read15050:
  /* Memory Read Internal */

vma-memory-read15051:
  t10 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t12 = t2 + ivory;
  t11 = *(s32 *)&processor->scovlimit;   
  t9 = (t12 * 4);   
  t8 = LDQ_U(t12);   
  t10 = t2 - t10;   		// Stack cache offset 
  t11 = ((u64)t10 < (u64)t11) ? 1 : 0;   		// In range? 
  t9 = *(s32 *)t9;   
  t8 = (u8)(t8 >> ((t12&7)*8));   
  if (t11 != 0)   
    goto vma-memory-read15053;

vma-memory-read15052:
  t10 = *(u64 *)&(processor->bindwrite_mask);   
  t12 = zero + 224;   
  t10 = t10 >> (t8 & 63);   
  t12 = t12 >> (t8 & 63);   
  if (t10 & 1)   
    goto vma-memory-read15055;

vma-memory-read15060:
  /* Merge cdr-code */
  t9 = t7 & 63;
  t8 = t8 & 192;
  t8 = t8 | t9;
  t10 = t2 + ivory;
  t9 = (t10 * 4);   
  t12 = LDQ_U(t10);   
  t11 = (t8 & 0xff) << ((t10&7)*8);   
  t12 = t12 & ~(0xffL << (t10&7)*8);   

force-alignment15063:
  if (_trace) printf("force-alignment15063:\n");
  t12 = t12 | t11;
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  STQ_U(t10, t12);   
  t10 = *(s32 *)&processor->scovlimit;   
  t11 = t2 - t11;   		// Stack cache offset 
  t10 = ((u64)t11 < (u64)t10) ? 1 : 0;   		// In range? 
  *(u32 *)t9 = t6;
  if (t10 != 0)   		// J. if in cache 
    goto vma-memory-write15062;

vma-memory-write15061:
  t3 = t3 & 64;		// Get the old cleanup-bindings bit 
  t3 = t3 << 19;   
  t1 = t1 - 2;   
		/* vma only */
  *(u32 *)&processor->bindingstackpointer = t1;
  t4 = t4 | t3;
  *(u32 *)&processor->control = t4;
  arg5 = *(s32 *)&processor->control;   
  t1 = (512) << 16;   
  t2 = t1 & arg5;
  if (t2 != 0)   		// J. if cr.cleanup-bindings is 0. 
    goto cleanup-frame15029;
  t2 = *(s32 *)&processor->interruptreg;   
  t3 = t2 & 2;
  t3 = (t3 == 2) ? 1 : 0;   
  t2 = t2 | t3;
  *(u32 *)&processor->interruptreg = t2;
  if (t2 == 0) 
    goto check-preempt-request15064;
  *(u64 *)&processor->stop_interpreter = t2;   

check-preempt-request15064:
  if (_trace) printf("check-preempt-request15064:\n");

cleanup-frame15026:
  if (_trace) printf("cleanup-frame15026:\n");
  t3 = (256) << 16;   
  t2 = t3 & arg5;
  if (t2 == 0) 
    goto INTERPRETINSTRUCTION;
  arg5 = zero;
  arg2 = 79;
  goto illegaloperand;
  goto INTERPRETINSTRUCTION;   		// Retry the instruction 

vma-memory-write15062:
  if (_trace) printf("vma-memory-write15062:\n");
  t10 = *(u64 *)&(processor->stackcachedata);   
  t10 = (t11 * 8) + t10;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t10 = t6;
		/* write the stack cache */
  *(u32 *)(t10 + 4) = t8;
  goto vma-memory-write15061;   

vma-memory-read15053:
  if (_trace) printf("vma-memory-read15053:\n");
  t11 = *(u64 *)&(processor->stackcachedata);   
  t10 = (t10 * 8) + t11;  		// reconstruct SCA 
  t9 = *(s32 *)t10;   
  t8 = *(s32 *)(t10 + 4);   		// Read from stack cache 
  goto vma-memory-read15052;   

vma-memory-read15055:
  if (_trace) printf("vma-memory-read15055:\n");
  if ((t12 & 1) == 0)   
    goto vma-memory-read15054;
  t2 = (u32)t9;   		// Do the indirect thing 
  goto vma-memory-read15051;   

vma-memory-read15054:
  if (_trace) printf("vma-memory-read15054:\n");
  t10 = *(u64 *)&(processor->bindwrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t12 = t8 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t2;   		// stash the VMA for the (likely) trap 
  t12 = (t12 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t12;   		// Get the memory action 

vma-memory-read15057:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 3;
  goto performmemoryaction;

vma-memory-read15043:
  if (_trace) printf("vma-memory-read15043:\n");
  t9 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + t9;  		// reconstruct SCA 
  t2 = *(s32 *)t8;   
  t3 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read15042;   

vma-memory-read15045:
  if (_trace) printf("vma-memory-read15045:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read15044;
  t5 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read15041;   

vma-memory-read15044:
  if (_trace) printf("vma-memory-read15044:\n");
  t11 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t3 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t5;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read15047:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 2;
  goto performmemoryaction;

vma-memory-read15033:
  if (_trace) printf("vma-memory-read15033:\n");
  t9 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + t9;  		// reconstruct SCA 
  t6 = *(s32 *)t8;   
  t7 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read15032;   

vma-memory-read15035:
  if (_trace) printf("vma-memory-read15035:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read15034;
  t1 = (u32)t6;   		// Do the indirect thing 
  goto vma-memory-read15031;   

vma-memory-read15034:
  if (_trace) printf("vma-memory-read15034:\n");
  t11 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t7 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read15037:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 2;
  goto performmemoryaction;

/* end HANDLEFRAMECLEANUP */
/* start StackCacheUnderflowCheck */


stackcacheunderflowcheck:
  if (_trace) printf("stackcacheunderflowcheck:\n");
  t1 = *(u64 *)&(processor->stackcachedata);   
  t4 = *(u64 *)&(processor->restartsp);   		// Preserve through instruction's original SP 
  t3 = t1 - iFP;   		// Number of words*8 to fill iff positive 
  if ((s64)t3 <= 0)  
    goto interpretinstructionforbranch;
  t3 = (s64)t3 >> 3;   		// Convert to a word count 
  t4 = t4 + 8;		// Account for the inclusive limit 
  if ((s64)t3 <= 0)  		// in case only low three bits nonzero 
    goto interpretinstructionforbranch;
  r0 = (u64)&&return0495;
  goto stackcacheunderflow;
return0495:
  goto interpretinstructionforbranch;   

/* end StackCacheUnderflowCheck */
/* start StackCacheUnderflow */


stackcacheunderflow:
  if (_trace) printf("stackcacheunderflow:\n");
  t2 = (t3 * 8) + t1;  		// Compute target address for shift 
  t5 = t4 - t1;   		// Compute number of elements to preserve 
  t5 = (s64)t5 >> 3;   		// Convert to word count 
  /* Shove everything up */
  t1 = (t5 * 8) + t1;  		// Adjust to end of source block 
  t2 = (t5 * 8) + t2;  		// Adjust to end of target block 
  goto stack-block-copy15065;   

stack-block-copy15066:
  if (_trace) printf("stack-block-copy15066:\n");
  t1 = t1 - 8;   		// advance from position 
  t5 = t5 - 1;   
  t7 = *(u64 *)t1;   		// Get a word from source 
  t2 = t2 - 8;   		// advance to position 
  *(u64 *)t2 = t7;   		// Put word in destination 

stack-block-copy15065:
  if ((s64)t5 > 0)   
    goto stack-block-copy15066;
  /* Adjust stack cache relative registers */
  iFP = (t3 * 8) + iFP;  
  t4 = *(u64 *)&(processor->restartsp);   
  iSP = (t3 * 8) + iSP;  
  iLP = (t3 * 8) + iLP;  
  t4 = (t3 * 8) + t4;  
  /* Fill freshly opened slots of stack cache from memory */
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = *(u64 *)&(processor->stackcachedata);   
  *(u64 *)&processor->restartsp = t4;   
  t1 = t1 - t3;   		// Compute new base address of stack cache 
  t4 = *(u64 *)&(processor->stackcachetopvma);   		// Top of cache 
  *(u64 *)&processor->stackcachebasevma = t1;   
  t4 = t4 - t3;   		// Adjust top of cache 
  *(u64 *)&processor->stackcachetopvma = t4;   
  t7 = t1 + ivory;
  t5 = (t7 * 4);   
  t4 = LDQ_U(t7);   
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t7&7)*8));   
  goto stack-fill15067;   

stack-fill15068:
  if (_trace) printf("stack-fill15068:\n");
  t7 = t1 + ivory;
  t5 = (t7 * 4);   
  t4 = LDQ_U(t7);   
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t7&7)*8));   
  t3 = t3 - 1;   
  t1 = t1 + 1;		// advance vma position 
  *(u32 *)t2 = t5;
		/* write the stack cache */
  *(u32 *)(t2 + 4) = t4;
  t2 = t2 + 8;		// advance sca position 

stack-fill15067:
  if ((s64)t3 > 0)   
    goto stack-fill15068;
  goto *r0; /* ret */

/* end StackCacheUnderflow */
/* start StackCacheOverflowHandler */


stackcacheoverflowhandler:
  if (_trace) printf("stackcacheoverflowhandler:\n");
  /* Stack cache overflow detected */
  t1 = zero + 256;   
  t1 = t1 + arg2;		// Account for what we're about to push 
  t1 = (t1 * 8) + iSP;  		// SCA of desired end of cache 
  iSP = *(u64 *)&(processor->restartsp);   
  t4 = *(u64 *)&(processor->stackcachedata);   		// Alpha base of stack cache 
  t4 = t1 - t4;   		// New limit*8 
  t4 = t4 >> 3;   
		/* Update stack cache limit */
  *(u32 *)&processor->scovlimit = t4;
  /* Check that the page underlying the end of the stack cache is accessible */
  /* Convert stack cache address to VMA */
  t4 = *(u64 *)&(processor->stackcachedata);   
  t3 = *(u64 *)&(processor->stackcachebasevma);   
  t4 = t1 - t4;   		// stack cache base relative offset 
  t4 = t4 >> 3;   		// convert byte address to word address 
  t3 = t4 + t3;		// reconstruct VMA 
  t5 = *(u64 *)&(processor->vmattributetable);   		// Per-page attributes table 
  t4 = t3 >> (MemoryPage_AddressShift & 63);   		// Index into the attributes table 
  t5 = t4 + t5;		// Address of the page's attributes 
  t4 = LDQ_U(t5);   		// Get the quadword with the page's attributes 
  *(u64 *)&processor->vma = t3;   		// Stash the VMA 
  t4 = (u8)(t4 >> ((t5&7)*8));   		// Extract the page's attributes 
  if (t4 == 0) 		// Non-existent page 
    goto pagenotresident;
  t5 = t4 & VMAttribute_AccessFault;
  if (t5 != 0)   		// Access fault 
    goto pagefaultrequesthandler;
  t5 = t4 & VMAttribute_WriteFault;
  if (t5 != 0)   		// Write fault 
    goto pagewritefault;
  /* Check if we must dump the cache */
  t4 = *(s32 *)&processor->scovlimit;   		// New stack cache limit (words) 
  t5 = *(u64 *)&(processor->stackcachesize);   		// Absolute size of the cache (words) 
  t5 = ((s64)t4 <= (s64)t5) ? 1 : 0;   
  if (t5 != 0)   		// We're done if new limit is less than absolute limit 
    goto INTERPRETINSTRUCTION;
  /* Dump the stack cache to make room */
  t1 = zero + 896;   
  t2 = *(u64 *)&(processor->stackcachebasevma);   		// Stack cache base VMA 
  t3 = *(u64 *)&(processor->stackcachedata);   		// Alpha base of stack cache 
		/* Will be destructively modified */
  *(u32 *)&processor->scovdumpcount = t1;
  t5 = t2 + ivory;		// Starting address of tags 
  t2 = (t5 * 4);   		// Starting address of data 
  /* Dump the data */
  goto stack-dump15069;   

stack-dump15070:
  if (_trace) printf("stack-dump15070:\n");
  t4 = *(s32 *)t3;   		// Get data word 
  t1 = t1 - 1;   
  t3 = t3 + 8;		// Advance SCA position 
		/* Save data word */
  *(u32 *)t2 = t4;
  t2 = t2 + 4;		// Advance VMA position 

stack-dump15069:
  if ((s64)t1 > 0)   
    goto stack-dump15070;
  /* Dump the tags */
  t1 = *(s32 *)&processor->scovdumpcount;   		// Restore the count 
  t2 = t5;		// Restore tag VMA 
  t4 = t1 << 3;   
  t3 = t3 - t4;   		// Restore orginal SCA 
  goto stack-dump15071;   

stack-dump15072:
  if (_trace) printf("stack-dump15072:\n");
  t1 = t1 - 1;   
  t4 = *(s32 *)(t3 + 4);   		// Get tag word 
  t3 = t3 + 8;		// Advance SCA position 
  t5 = LDQ_U(t2);   		// Get packed tags word 
  t4 = (t4 & 0xff) << ((t2&7)*8);   		// Position the new tag 
  t5 = t5 & ~(0xffL << (t2&7)*8);   		// Remove old tag 
  t5 = t4 | t5;		// Put in new byte 
  STQ_U(t2, t5);   		// Save packed tags word 
  t2 = t2 + 1;		// Advance VMA position 

stack-dump15071:
  if ((s64)t1 > 0)   
    goto stack-dump15072;
  t1 = zero + 896;   
  t2 = *(u64 *)&(processor->stackcachebasevma);   		// Stack cache base VMA 
  t4 = *(u64 *)&(processor->stackcachetopvma);   		// Top of cache 
  t5 = *(s32 *)&processor->scovlimit;   		// Cache limit in words 
  t2 = t2 + t1;		// Adjust cache base VMA 
  t4 = t4 + t1;		// Adjust top of cache 
  t5 = t5 - t1;   		// Adjust limit 
  *(u64 *)&processor->stackcachebasevma = t2;   		// Save update 
  *(u64 *)&processor->stackcachetopvma = t4;   
  *(u32 *)&processor->scovlimit = t5;
  /* Move the cache down */
  t3 = *(u64 *)&(processor->stackcachedata);   		// Alpha base of stack cache 
  t2 = (t1 * 8) + t3;  		// SCA of first word of new base 
  goto stack-block-copy15073;   

stack-block-copy15074:
  if (_trace) printf("stack-block-copy15074:\n");
  t1 = t1 - 1;   
  t5 = *(u64 *)t2;   		// Get a word from source 
  t2 = t2 + 8;		// advance from position 
  *(u64 *)t3 = t5;   		// Put word in destination 
  t3 = t3 + 8;		// advance to position 

stack-block-copy15073:
  if ((s64)t1 > 0)   
    goto stack-block-copy15074;
  /* Adjust stack cache relative registers */
  t1 = zero + 896;   
  t1 = t1 << 3;   		// Convert to SCA adjustment 
  iSP = iSP - t1;   
  iFP = iFP - t1;   
  iLP = iLP - t1;   
  *(u64 *)&processor->restartsp = iSP;   
  goto INTERPRETINSTRUCTION;   

/* end StackCacheOverflowHandler */
/* start DoReturnKludge */

  /* Halfword operand from stack instruction - DoReturnKludge */
  /* arg2 has the preloaded 8 bit operand. */

doreturnkludge:
  if (_trace) printf("doreturnkludge:\n");

DoReturnKludgeSP:
  if (_trace) printf("DoReturnKludgeSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoReturnKludgeLP:
  if (_trace) printf("DoReturnKludgeLP:\n");

DoReturnKludgeFP:
  if (_trace) printf("DoReturnKludgeFP:\n");

begindoreturnkludge:
  if (_trace) printf("begindoreturnkludge:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t1 = *(s32 *)(arg1 + 4);   
  arg2 = *(s32 *)arg1;   
  t2 = t1 - Type_Fixnum;   
  t2 = t2 & 63;		// Strip CDR code 
  if (t2 != 0)   
    goto returnkludgeio;
  arg2 = (u32)arg2;   

DoReturnKludgeIM:
  if (_trace) printf("DoReturnKludgeIM:\n");
  arg6 = *(u64 *)&(processor->stackcachedata);   
  t1 = (arg2 * 8) - 8;   
  t2 = *(s32 *)&processor->control;   
  t1 = iSP - t1;   		// t1 is the values block 
  /* Restore machine state from frame header. */
  t5 = *(s32 *)iFP;   
  t3 = (1792) << 16;   
  t7 = *(s32 *)&processor->continuation;   
  t3 = t2 & t3;		// Mask 
  t4 = *(s32 *)(iFP + 4);   
  t9 = iCP;
  if (t3 != 0)   		// Need to cleanup frame first 
    goto returnkludgecleanup;
  t5 = (u32)t5;   
  t6 = *((s32 *)(&processor->continuation)+1);   
  t7 = (u32)t7;   
#ifdef IVERIFY
  /* check for instruction verification suite end-of-test */
  t8 = (s32)t4 - (s32)Type_NIL;   		// check for end of run 
  if (t8 == 0) 
    goto abandon-frame-simple15075;
#endif
  t8 = *(s32 *)(iFP + 8);   		// Get saved control register 
  /* TagType. */
  t4 = t4 & 63;
  /* Restore the PC. */
  iPC = t7 << 1;   		// Assume even PC 
  t3 = t6 & 1;
  t9 = *(u64 *)&(processor->continuationcp);   
  iPC = iPC + t3;

abandon-frame-simple15076:
  if (_trace) printf("abandon-frame-simple15076:\n");
  /* Restore the saved continuation */
  *((u32 *)(&processor->continuation)+1) = t4;
  t3 = t2 >> 9;   		// Get the caller frame size into place 
  *(u32 *)&processor->continuation = t5;
  iSP = iFP - 8;   		// Restore the stack pointer. 
  *(u64 *)&processor->continuationcp = zero;   
  t3 = t3 & 255;		// Mask just the caller frame size. 
  t3 = (t3 * 8) + 0;  		// *8 
  t4 = (2048) << 16;   
  t4 = t4 & t2;
  t5 = *(s32 *)&processor->interruptreg;   		// Get the preempt-pending bit 
  t8 = t4 | t8;		// Sticky trace pending bit. 
  t6 = *(u64 *)&(processor->please_stop);   		// Get the trap/suspend bits 
  iFP = iFP - t3;   		// Restore the frame pointer. 
		/* Restore the control register */
  *(u32 *)&processor->control = t8;
  t3 = t8 & 255;		// extract the argument size 
  t5 = t5 & 1;
  t5 = t6 | t5;
  *(u64 *)&processor->stop_interpreter = t5;   
  iLP = (t3 * 8) + iFP;  		// Restore the local pointer. 
  arg6 = ((u64)iFP < (u64)arg6) ? 1 : 0;   		// ARG6 = stack-cache underflow 
  if (arg2 == 0) 
    goto rkloopdone;

rklooptop:
  if (_trace) printf("rklooptop:\n");
  t4 = *(u64 *)t1;   		// Read a 40 bit word from the values block 
  arg2 = arg2 - 1;   
  *(u64 *)(iSP + 8) = t4;   		// Push value onto stack cdr codes and all 
  t1 = t1 + 8;
  iSP = iSP + 8;
  if ((s64)arg2 > 0)   
    goto rklooptop;

rkloopdone:
  if (_trace) printf("rkloopdone:\n");
  if (arg6 != 0)   
    goto returnkludgeunderflow;
  if (t9 == 0) 		// No prediction, validate cache 
    goto interpretinstructionforbranch;
  iCP = t9;
  goto INTERPRETINSTRUCTION;   

returnkludgeio:
  if (_trace) printf("returnkludgeio:\n");
  arg5 = 0;
  arg2 = 63;
  goto illegaloperand;

returnkludgecleanup:
  if (_trace) printf("returnkludgecleanup:\n");
  goto handleframecleanup;

returnkludgeunderflow:
  if (_trace) printf("returnkludgeunderflow:\n");
  goto stackcacheunderflowcheck;

/* end DoReturnKludge */
  /* End of Halfword operand from stack instruction - DoReturnKludge */
/* start DoTakeValues */

  /* Halfword operand from stack instruction - DoTakeValues */
  /* arg2 has the preloaded 8 bit operand. */

dotakevalues:
  if (_trace) printf("dotakevalues:\n");

DoTakeValuesIM:
  if (_trace) printf("DoTakeValuesIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindotakevalues;   

DoTakeValuesSP:
  if (_trace) printf("DoTakeValuesSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoTakeValuesLP:
  if (_trace) printf("DoTakeValuesLP:\n");

DoTakeValuesFP:
  if (_trace) printf("DoTakeValuesFP:\n");

headdotakevalues:
  if (_trace) printf("headdotakevalues:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindotakevalues:
  if (_trace) printf("begindotakevalues:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg6 = *(u64 *)&(processor->niladdress);   
  arg1 = (u32)arg1;   		// Number of values expected 
  arg4 = *(s32 *)iSP;   		// Number of values provided 
  arg3 = *(s32 *)(iSP + 4);   		// Number of values provided 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  arg2 = arg1 - arg4;   
  if ((s64)arg2 < 0)   		// J. if too many args supplied 
    goto takevalueslose;
  if ((s64)arg2 > 0)   		// J. if too few values supplied 
    goto takevaluespad;
  goto NEXTINSTRUCTION;   

takevalueslose:
  if (_trace) printf("takevalueslose:\n");
  iSP = (arg2 * 8) + iSP;  		// Remove the unwanted values 
  goto NEXTINSTRUCTION;   

takevaluespad:
  if (_trace) printf("takevaluespad:\n");
  t4 = *(s32 *)&processor->scovlimit;   		// Current stack cache limit (words) 
  t1 = zero + 128;   
  t2 = *(u64 *)&(processor->stackcachedata);   		// Alpha base of stack cache 
  t1 = t1 + arg2;		// Account for what we're about to push 
  t1 = (t1 * 8) + iSP;  		// SCA of desired end of cache 
  t2 = (t4 * 8) + t2;  		// SCA of current end of cache 
  t4 = ((s64)t1 <= (s64)t2) ? 1 : 0;   
  if (t4 == 0) 		// We're done if new SCA is within bounds 
    goto stackcacheoverflowhandler;

takevaluespadloop:
  if (_trace) printf("takevaluespadloop:\n");
  *(u64 *)(iSP + 8) = arg6;   		// Push NIL 
  iSP = iSP + 8;
  arg2 = arg2 - 1;   
  if ((s64)arg2 > 0)   
    goto takevaluespadloop;
  goto NEXTINSTRUCTION;   

/* end DoTakeValues */
  /* End of Halfword operand from stack instruction - DoTakeValues */
  /* Catch Instructions */
/* start DoCatchOpen */

  /* Halfword 10 bit immediate instruction - DoCatchOpen */

docatchopen:
  if (_trace) printf("docatchopen:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoCatchOpenIM:
  if (_trace) printf("DoCatchOpenIM:\n");

DoCatchOpenSP:
  if (_trace) printf("DoCatchOpenSP:\n");

DoCatchOpenLP:
  if (_trace) printf("DoCatchOpenLP:\n");

DoCatchOpenFP:
  if (_trace) printf("DoCatchOpenFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  t10 = arg1 & 1;		// t10=1 if unwind-protect, t10=0 if catch 
  t3 = *((s32 *)(&processor->catchblock)+1);   		// tag 
  t10 = t10 << 38;   
  t4 = *(s32 *)&processor->catchblock;   		// data 
  t2 = *(u64 *)&(processor->bindingstackpointer);   
  /* Convert stack cache address to VMA */
  t1 = *(u64 *)&(processor->stackcachedata);   
  t9 = *(u64 *)&(processor->stackcachebasevma);   
  t1 = iSP - t1;   		// stack cache base relative offset 
  t1 = t1 >> 3;   		// convert byte address to word address 
  t9 = t1 + t9;		// reconstruct VMA 
  t1 = t10 | t2;
  *(u64 *)(iSP + 8) = t1;   
  iSP = iSP + 8;
  t11 = *(s32 *)&processor->control;   
  t2 = t11 >> 20;   		// Get old cleanup catch bit 
  t2 = t2 & 64;
  t1 = t11 >> 1;   		// Get old extra arg bit 
  t1 = t1 & 128;
  t1 = t1 | t2;
  /* TagType. */
  t2 = t3 & 63;
  t1 = t1 | t2;		// T1 now has new tag 
  *(u32 *)(iSP + 8) = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  if (t10 != 0)   
    goto catchopen2;
  t2 = *(s32 *)&processor->continuation;   
  t1 = *((s32 *)(&processor->continuation)+1);   
  t2 = (u32)t2;   
  /* TagType. */
  t1 = t1 & 63;
  t3 = arg1 & 192;		// T3 has the disposition bits in place 
  t1 = t1 | t3;
  *(u32 *)(iSP + 8) = t2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;

catchopen2:
  if (_trace) printf("catchopen2:\n");
  t1 = Type_Locative;
		/* tag */
  *((u32 *)(&processor->catchblock)+1) = t1;
		/* data */
  *(u32 *)&processor->catchblock = t9;
  t1 = (1024) << 16;   
  t1 = t1 | t11;		// set it 
  *(u32 *)&processor->control = t1;
  goto NEXTINSTRUCTION;   

/* end DoCatchOpen */
  /* End of Halfword operand from stack instruction - DoCatchOpen */
/* start DoCatchClose */

  /* Halfword operand from stack instruction - DoCatchClose */
  /* arg2 has the preloaded 8 bit operand. */

docatchclose:
  if (_trace) printf("docatchclose:\n");

DoCatchCloseSP:
  if (_trace) printf("DoCatchCloseSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoCatchCloseLP:
  if (_trace) printf("DoCatchCloseLP:\n");

DoCatchCloseFP:
  if (_trace) printf("DoCatchCloseFP:\n");

begindocatchclose:
  if (_trace) printf("begindocatchclose:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t1 = *(s32 *)&processor->catchblock;   		// data 
  t1 = (u32)t1;   
  /* Convert VMA to stack cache address */
  t3 = *(u64 *)&(processor->stackcachebasevma);   
  t10 = *(u64 *)&(processor->stackcachedata);   
  t3 = t1 - t3;   		// stack cache base relative offset 
  t10 = (t3 * 8) + t10;  		// reconstruct SCA 
  arg4 = *(s32 *)(t10 + 8);   		// bstag bsdata 
  arg3 = *(s32 *)(t10 + 12);   
  arg4 = (u32)arg4;   
  t4 = *(u64 *)&(processor->bindingstackpointer);   
  arg6 = *(s32 *)(t10 + 16);   		// prtag prdata 
  arg5 = *(s32 *)(t10 + 20);   
  arg6 = (u32)arg6;   
  t3 = t4 >> 32;   
  t5 = (s32)arg4 - (s32)t4;   
  if (t5 == 0) 
    goto catchcloseld;
  t1 = t3 - Type_Locative;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto catchclosedbt;

catchcloselt:
  if (_trace) printf("catchcloselt:\n");
  t1 = *(u64 *)&(processor->bindingstackpointer);   
  t4 = *(s32 *)&processor->control;   
  t1 = (u32)t1;   		// vma only 
  t2 = (512) << 16;   
  t5 = t1 - 1;   
  t3 = t4 & t2;
  t4 = t4 & ~t2;		// Turn off the bit 
  if (t3 != 0)   
    goto g15078;
  t4 = *(u64 *)&(processor->restartsp);   		// Get the SP, ->op2 
  arg5 = 0;
  arg2 = 20;
  goto illegaloperand;

g15078:
  if (_trace) printf("g15078:\n");
  /* Memory Read Internal */

vma-memory-read15079:
  t8 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  arg1 = t1 + ivory;
  t9 = *(s32 *)&processor->scovlimit;   
  t6 = (arg1 * 4);   
  t7 = LDQ_U(arg1);   
  t8 = t1 - t8;   		// Stack cache offset 
  arg2 = *(u64 *)&(processor->bindread_mask);   
  t9 = ((u64)t8 < (u64)t9) ? 1 : 0;   		// In range? 
  t6 = *(s32 *)t6;   
  t7 = (u8)(t7 >> ((arg1&7)*8));   
  if (t9 != 0)   
    goto vma-memory-read15081;

vma-memory-read15080:
  arg1 = zero + 224;   
  arg2 = arg2 >> (t7 & 63);   
  arg1 = arg1 >> (t7 & 63);   
  if (arg2 & 1)   
    goto vma-memory-read15083;

vma-memory-read15088:
  /* Memory Read Internal */

vma-memory-read15089:
  t8 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  arg1 = t5 + ivory;
  t9 = *(s32 *)&processor->scovlimit;   
  t2 = (arg1 * 4);   
  t3 = LDQ_U(arg1);   
  t8 = t5 - t8;   		// Stack cache offset 
  arg2 = *(u64 *)&(processor->bindread_mask);   
  t9 = ((u64)t8 < (u64)t9) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t3 = (u8)(t3 >> ((arg1&7)*8));   
  if (t9 != 0)   
    goto vma-memory-read15091;

vma-memory-read15090:
  arg1 = zero + 224;   
  arg2 = arg2 >> (t3 & 63);   
  arg1 = arg1 >> (t3 & 63);   
  t2 = (u32)t2;   
  if (arg2 & 1)   
    goto vma-memory-read15093;

vma-memory-read15098:
  /* Memory Read Internal */

vma-memory-read15099:
  arg1 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t11 = t2 + ivory;
  arg2 = *(s32 *)&processor->scovlimit;   
  t9 = (t11 * 4);   
  t8 = LDQ_U(t11);   
  arg1 = t2 - arg1;   		// Stack cache offset 
  arg2 = ((u64)arg1 < (u64)arg2) ? 1 : 0;   		// In range? 
  t9 = *(s32 *)t9;   
  t8 = (u8)(t8 >> ((t11&7)*8));   
  if (arg2 != 0)   
    goto vma-memory-read15101;

vma-memory-read15100:
  arg1 = *(u64 *)&(processor->bindwrite_mask);   
  t11 = zero + 224;   
  arg1 = arg1 >> (t8 & 63);   
  t11 = t11 >> (t8 & 63);   
  if (arg1 & 1)   
    goto vma-memory-read15103;

vma-memory-read15108:
  /* Merge cdr-code */
  t9 = t7 & 63;
  t8 = t8 & 192;
  t8 = t8 | t9;
  arg1 = t2 + ivory;
  t9 = (arg1 * 4);   
  t11 = LDQ_U(arg1);   
  arg2 = (t8 & 0xff) << ((arg1&7)*8);   
  t11 = t11 & ~(0xffL << (arg1&7)*8);   

force-alignment15111:
  if (_trace) printf("force-alignment15111:\n");
  t11 = t11 | arg2;
  arg2 = *(u64 *)&(processor->stackcachebasevma);   
  STQ_U(arg1, t11);   
  arg1 = *(s32 *)&processor->scovlimit;   
  arg2 = t2 - arg2;   		// Stack cache offset 
  arg1 = ((u64)arg2 < (u64)arg1) ? 1 : 0;   		// In range? 
  *(u32 *)t9 = t6;
  if (arg1 != 0)   		// J. if in cache 
    goto vma-memory-write15110;

vma-memory-write15109:
  t3 = t3 & 64;		// Get the old cleanup-bindings bit 
  t3 = t3 << 19;   
  t1 = t1 - 2;   
		/* vma only */
  *(u32 *)&processor->bindingstackpointer = t1;
  t4 = t4 | t3;
  *(u32 *)&processor->control = t4;
  t5 = (s32)arg4 - (s32)t1;   
  if (t5 != 0)   
    goto catchcloselt;
  t3 = *(s32 *)&processor->interruptreg;   
  t4 = t3 & 2;
  t4 = (t4 == 2) ? 1 : 0;   
  t3 = t3 | t4;
  *(u32 *)&processor->interruptreg = t3;
  if (t3 == 0) 
    goto check-preempt-request15112;
  *(u64 *)&processor->stop_interpreter = t3;   

check-preempt-request15112:
  if (_trace) printf("check-preempt-request15112:\n");

catchcloseld:
  if (_trace) printf("catchcloseld:\n");
  /* TagType. */
  t1 = arg5 & 63;
		/* tag */
  *((u32 *)(&processor->catchblock)+1) = t1;
  t2 = arg5 & 128;		// extra argument bit 
  t6 = *(u64 *)&(processor->extraandcatch);   		// mask for two bits 
  t2 = t2 << 1;   		// position in place for control register. 
		/* data */
  *(u32 *)&processor->catchblock = arg6;
  t3 = arg5 & 64;		// cleanup catch bit 
  t3 = t3 << 20;   		// position in place for cr 
  t4 = *(s32 *)&processor->control;   
  t5 = t2 | t3;		// coalesce the two bits 
  t4 = t4 & ~t6;		// Turn off extra-arg and cleanup-catch 
  t4 = t4 | t5;		// Maybe turn them back on 
  *(u32 *)&processor->control = t4;
  t6 = arg3 & 64;		// uwp bit 
  if (t6 == 0) 
    goto NEXTINSTRUCTION;
  /* Handle unwind-protect cleanup here */
  arg2 = *(s32 *)t10;   		// pctag pcdata 
  arg1 = *(s32 *)(t10 + 4);   
  arg2 = (u32)arg2;   
  t8 = t4 >> 17;   		// Cleanup in progress bit into cdr code pos 
  t7 = iPC + 1;		// Next PC 
  /* Convert PC to a real continuation. */
  t8 = t7 & 1;
  t10 = t7 >> 1;   		// convert PC to a real word address. 
  t8 = t8 + Type_EvenPC;   
  /* TagType. */
  t7 = t8 & 63;
  t8 = t8 & 64;
  t9 = (128) << 16;   
  t8 = t8 | 128;
  t7 = t7 | t8;
  *(u32 *)(iSP + 8) = t10;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  t4 = t4 | t9;		// set cr.cleanup-in-progress 
  *(u32 *)&processor->control = t4;
  /* Convert real continuation to PC. */
  iPC = arg1 & 1;
  iPC = arg2 + iPC;
  iPC = arg2 + iPC;
  goto interpretinstructionforjump;   

catchclosedbt:
  if (_trace) printf("catchclosedbt:\n");
  goto dbunwindcatchtrap;

vma-memory-write15110:
  if (_trace) printf("vma-memory-write15110:\n");
  arg1 = *(u64 *)&(processor->stackcachedata);   
  arg1 = (arg2 * 8) + arg1;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)arg1 = t6;
		/* write the stack cache */
  *(u32 *)(arg1 + 4) = t8;
  goto vma-memory-write15109;   

vma-memory-read15101:
  if (_trace) printf("vma-memory-read15101:\n");
  arg2 = *(u64 *)&(processor->stackcachedata);   
  arg1 = (arg1 * 8) + arg2;  		// reconstruct SCA 
  t9 = *(s32 *)arg1;   
  t8 = *(s32 *)(arg1 + 4);   		// Read from stack cache 
  goto vma-memory-read15100;   

vma-memory-read15103:
  if (_trace) printf("vma-memory-read15103:\n");
  if ((t11 & 1) == 0)   
    goto vma-memory-read15102;
  t2 = (u32)t9;   		// Do the indirect thing 
  goto vma-memory-read15099;   

vma-memory-read15102:
  if (_trace) printf("vma-memory-read15102:\n");
  arg1 = *(u64 *)&(processor->bindwrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t11 = t8 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t2;   		// stash the VMA for the (likely) trap 
  t11 = (t11 * 4) + arg1;   		// Adjust for a longword load 
  arg1 = *(s32 *)t11;   		// Get the memory action 

vma-memory-read15105:
  /* Perform memory action */
  arg1 = arg1;
  arg2 = 3;
  goto performmemoryaction;

vma-memory-read15091:
  if (_trace) printf("vma-memory-read15091:\n");
  t9 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + t9;  		// reconstruct SCA 
  t2 = *(s32 *)t8;   
  t3 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read15090;   

vma-memory-read15093:
  if (_trace) printf("vma-memory-read15093:\n");
  if ((arg1 & 1) == 0)   
    goto vma-memory-read15092;
  t5 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read15089;   

vma-memory-read15092:
  if (_trace) printf("vma-memory-read15092:\n");
  arg2 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  arg1 = t3 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t5;   		// stash the VMA for the (likely) trap 
  arg1 = (arg1 * 4) + arg2;   		// Adjust for a longword load 
  arg2 = *(s32 *)arg1;   		// Get the memory action 

vma-memory-read15095:
  /* Perform memory action */
  arg1 = arg2;
  arg2 = 2;
  goto performmemoryaction;

vma-memory-read15081:
  if (_trace) printf("vma-memory-read15081:\n");
  t9 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + t9;  		// reconstruct SCA 
  t6 = *(s32 *)t8;   
  t7 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read15080;   

vma-memory-read15083:
  if (_trace) printf("vma-memory-read15083:\n");
  if ((arg1 & 1) == 0)   
    goto vma-memory-read15082;
  t1 = (u32)t6;   		// Do the indirect thing 
  goto vma-memory-read15079;   

vma-memory-read15082:
  if (_trace) printf("vma-memory-read15082:\n");
  arg2 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  arg1 = t7 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  arg1 = (arg1 * 4) + arg2;   		// Adjust for a longword load 
  arg2 = *(s32 *)arg1;   		// Get the memory action 

vma-memory-read15085:
  /* Perform memory action */
  arg1 = arg2;
  arg2 = 2;
  goto performmemoryaction;

DoCatchCloseIM:
  goto doistageerror;

/* end DoCatchClose */
  /* End of Halfword operand from stack instruction - DoCatchClose */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunfcal.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunloop.as
 ************************************************************************/

  /* Branch and loop instructions. */
/* start DoBranchTrueElseNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueElseNoPop */

dobranchtrueelsenopop:
  if (_trace) printf("dobranchtrueelsenopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchTrueElseNoPopIM:
  if (_trace) printf("DoBranchTrueElseNoPopIM:\n");

DoBranchTrueElseNoPopSP:
  if (_trace) printf("DoBranchTrueElseNoPopSP:\n");

DoBranchTrueElseNoPopLP:
  if (_trace) printf("DoBranchTrueElseNoPopLP:\n");

DoBranchTrueElseNoPopFP:
  if (_trace) printf("DoBranchTrueElseNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 == 0) 
    goto NEXTINSTRUCTION;
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 8;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchTrueElseNoPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueElseNoPop */
/* start DoBranchTrueElseExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueElseExtraPop */

dobranchtrueelseextrapop:
  if (_trace) printf("dobranchtrueelseextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchTrueElseExtraPopIM:
  if (_trace) printf("DoBranchTrueElseExtraPopIM:\n");

DoBranchTrueElseExtraPopSP:
  if (_trace) printf("DoBranchTrueElseExtraPopSP:\n");

DoBranchTrueElseExtraPopLP:
  if (_trace) printf("DoBranchTrueElseExtraPopLP:\n");

DoBranchTrueElseExtraPopFP:
  if (_trace) printf("DoBranchTrueElseExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 != 0)   
    goto dobrelsepopextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 16;   
  goto cachevalid;   

dobrelsepopextrapop:
  if (_trace) printf("dobrelsepopextrapop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 8;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchTrueElseExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueElseExtraPop */
/* start DoBranchFalseElseExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseElseExtraPop */

dobranchfalseelseextrapop:
  if (_trace) printf("dobranchfalseelseextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchFalseElseExtraPopIM:
  if (_trace) printf("DoBranchFalseElseExtraPopIM:\n");

DoBranchFalseElseExtraPopSP:
  if (_trace) printf("DoBranchFalseElseExtraPopSP:\n");

DoBranchFalseElseExtraPopLP:
  if (_trace) printf("DoBranchFalseElseExtraPopLP:\n");

DoBranchFalseElseExtraPopFP:
  if (_trace) printf("DoBranchFalseElseExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 == 0) 
    goto dobrnelsepopextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 16;   
  goto cachevalid;   

dobrnelsepopextrapop:
  if (_trace) printf("dobrnelsepopextrapop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 8;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchFalseElseExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseElseExtraPop */
/* start DoBranchFalseExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseExtraPop */

dobranchfalseextrapop:
  if (_trace) printf("dobranchfalseextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchFalseExtraPopIM:
  if (_trace) printf("DoBranchFalseExtraPopIM:\n");

DoBranchFalseExtraPopSP:
  if (_trace) printf("DoBranchFalseExtraPopSP:\n");

DoBranchFalseExtraPopLP:
  if (_trace) printf("DoBranchFalseExtraPopLP:\n");

DoBranchFalseExtraPopFP:
  if (_trace) printf("DoBranchFalseExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 == 0) 
    goto dobrnpopelsepopextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 16;   
  goto cachevalid;   

dobrnpopelsepopextrapop:
  if (_trace) printf("dobrnpopelsepopextrapop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 16;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchFalseExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseExtraPop */
/* start DoLoopDecrementTos */

  /* Halfword 10 bit immediate instruction - DoLoopDecrementTos */

doloopdecrementtos:
  if (_trace) printf("doloopdecrementtos:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoLoopDecrementTosIM:
  if (_trace) printf("DoLoopDecrementTosIM:\n");

DoLoopDecrementTosSP:
  if (_trace) printf("DoLoopDecrementTosSP:\n");

DoLoopDecrementTosLP:
  if (_trace) printf("DoLoopDecrementTosLP:\n");

DoLoopDecrementTosFP:
  if (_trace) printf("DoLoopDecrementTosFP:\n");
  arg1 = (s64)arg3 >> 48;   
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  t2 = (u32)arg6;   
  t3 = t1 - Type_Fixnum;   
  t3 = t3 & 63;		// Strip CDR code 
  if (t3 != 0)   
    goto iloop-decrement-tos15113;
  t3 = (s32)t2 - (s32)1;   
  t4 = ((s64)t3 < (s64)t2) ? 1 : 0;   
  if (t4 == 0) 
    goto iloop-decrement-tos15115;
  t6 = Type_Fixnum;
  *(u32 *)iSP = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t6;
  if ((s64)t3 <= 0)  
    goto NEXTINSTRUCTION;
  /* Here if branch taken. */
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

iloop-decrement-tos15113:
  if (_trace) printf("iloop-decrement-tos15113:\n");
  t3 = t1 - Type_Fixnum;   
  t3 = t3 & 56;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto iloop-decrement-tos15114;

iloop-decrement-tos15115:
  if (_trace) printf("iloop-decrement-tos15115:\n");
  arg5 = iPC + arg1;		// Compute next-pc 
  arg3 = 1;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto loopexception;

iloop-decrement-tos15114:
  if (_trace) printf("iloop-decrement-tos15114:\n");
  arg5 = 0;
  arg2 = 81;
  goto illegaloperand;

/* end DoLoopDecrementTos */
  /* End of Halfword operand from stack instruction - DoLoopDecrementTos */
/* start DoLoopIncrementTosLessThan */

  /* Halfword 10 bit immediate instruction - DoLoopIncrementTosLessThan */

doloopincrementtoslessthan:
  if (_trace) printf("doloopincrementtoslessthan:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoLoopIncrementTosLessThanIM:
  if (_trace) printf("DoLoopIncrementTosLessThanIM:\n");

DoLoopIncrementTosLessThanSP:
  if (_trace) printf("DoLoopIncrementTosLessThanSP:\n");

DoLoopIncrementTosLessThanLP:
  if (_trace) printf("DoLoopIncrementTosLessThanLP:\n");

DoLoopIncrementTosLessThanFP:
  if (_trace) printf("DoLoopIncrementTosLessThanFP:\n");
  arg1 = (s64)arg3 >> 48;   
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  t2 = (u32)arg6;   
  t5 = t1 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto iloop-increment-tos-less-than15116;
  t4 = *(s32 *)(iSP + -8);   		// Get arg1. 
  t3 = *(s32 *)(iSP + -4);   
  t4 = (u32)t4;   
  t5 = t3 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto iloop-increment-tos-less-than15117;
  t5 = (s32)t2 + (s32)1;
  t6 = ((s64)t2 <= (s64)t5) ? 1 : 0;   
  if (t6 == 0) 
    goto iloop-increment-tos-less-than15118;
  t6 = Type_Fixnum;
  *(u32 *)iSP = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t6;
  t6 = ((s64)t5 <= (s64)t4) ? 1 : 0;   
  if (t6 == 0) 
    goto NEXTINSTRUCTION;
  /* Here if branch taken. */

force-alignment15120:
  if (_trace) printf("force-alignment15120:\n");
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

iloop-increment-tos-less-than15116:
  if (_trace) printf("iloop-increment-tos-less-than15116:\n");
  t5 = t1 - Type_Fixnum;   
  t5 = t5 & 56;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto iloop-increment-tos-less-than15119;

iloop-increment-tos-less-than15117:
  if (_trace) printf("iloop-increment-tos-less-than15117:\n");
  t5 = t3 - Type_Fixnum;   
  t5 = t5 & 56;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto iloop-increment-tos-less-than15119;

iloop-increment-tos-less-than15118:
  if (_trace) printf("iloop-increment-tos-less-than15118:\n");
  arg5 = iPC + arg1;		// Compute next-pc 
  arg3 = 1;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto loopexception;

iloop-increment-tos-less-than15119:
  if (_trace) printf("iloop-increment-tos-less-than15119:\n");
  arg5 = 0;
  arg2 = 16;
  goto illegaloperand;

/* end DoLoopIncrementTosLessThan */
  /* End of Halfword operand from stack instruction - DoLoopIncrementTosLessThan */
/* start DoBranchTrueExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueExtraPop */

dobranchtrueextrapop:
  if (_trace) printf("dobranchtrueextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchTrueExtraPopIM:
  if (_trace) printf("DoBranchTrueExtraPopIM:\n");

DoBranchTrueExtraPopSP:
  if (_trace) printf("DoBranchTrueExtraPopSP:\n");

DoBranchTrueExtraPopLP:
  if (_trace) printf("DoBranchTrueExtraPopLP:\n");

DoBranchTrueExtraPopFP:
  if (_trace) printf("DoBranchTrueExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 != 0)   
    goto dobrpopelsepopextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 16;   
  goto cachevalid;   

dobrpopelsepopextrapop:
  if (_trace) printf("dobrpopelsepopextrapop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 16;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchTrueExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueExtraPop */
/* start DoBranchTrueAndNoPopElseNoPopExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueAndNoPopElseNoPopExtraPop */

dobranchtrueandnopopelsenopopextrapop:
  if (_trace) printf("dobranchtrueandnopopelsenopopextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchTrueAndNoPopElseNoPopExtraPopIM:
  if (_trace) printf("DoBranchTrueAndNoPopElseNoPopExtraPopIM:\n");

DoBranchTrueAndNoPopElseNoPopExtraPopSP:
  if (_trace) printf("DoBranchTrueAndNoPopElseNoPopExtraPopSP:\n");

DoBranchTrueAndNoPopElseNoPopExtraPopLP:
  if (_trace) printf("DoBranchTrueAndNoPopElseNoPopExtraPopLP:\n");

DoBranchTrueAndNoPopElseNoPopExtraPopFP:
  if (_trace) printf("DoBranchTrueAndNoPopElseNoPopExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 != 0)   
    goto dobrextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   
  goto cachevalid;   

dobrextrapop:
  if (_trace) printf("dobrextrapop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 8;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchTrueAndNoPopElseNoPopExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueAndNoPopElseNoPopExtraPop */
/* start DoBranchFalseAndNoPopElseNoPopExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseAndNoPopElseNoPopExtraPop */

dobranchfalseandnopopelsenopopextrapop:
  if (_trace) printf("dobranchfalseandnopopelsenopopextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBranchFalseAndNoPopElseNoPopExtraPopIM:
  if (_trace) printf("DoBranchFalseAndNoPopElseNoPopExtraPopIM:\n");

DoBranchFalseAndNoPopElseNoPopExtraPopSP:
  if (_trace) printf("DoBranchFalseAndNoPopElseNoPopExtraPopSP:\n");

DoBranchFalseAndNoPopElseNoPopExtraPopLP:
  if (_trace) printf("DoBranchFalseAndNoPopElseNoPopExtraPopLP:\n");

DoBranchFalseAndNoPopElseNoPopExtraPopFP:
  if (_trace) printf("DoBranchFalseAndNoPopElseNoPopExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  t1 = (u32)(arg6 >> ((4&7)*8));   		// Check tag of word in TOS. 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  arg1 = (s64)arg3 >> 48;   		// Get signed 10-bit immediate arg 
  /* TagType. */
  t1 = t1 & 63;		// strip the cdr code off. 
  t1 = t1 - Type_NIL;   		// Compare to NIL 
  if (t1 == 0) 
    goto dobrnextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  iSP = iSP - 8;   
  goto cachevalid;   

dobrnextrapop:
  if (_trace) printf("dobrnextrapop:\n");
  if (arg1 == 0) 		// Can't branch to ourself 
    goto branchexception;
  iSP = iSP - 8;   
  iPC = iPC + arg1;		// Update the PC in halfwords 
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end DoBranchFalseAndNoPopElseNoPopExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseAndNoPopElseNoPopExtraPop */
/* start BranchException */


branchexception:
  if (_trace) printf("branchexception:\n");
  arg5 = 0;
  arg2 = 24;
  goto illegaloperand;

/* end BranchException */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunloop.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunlist.as
 ************************************************************************/

  /* List Operations. */
/* start DoSetToCar */

  /* Halfword operand from stack instruction - DoSetToCar */
  /* arg2 has the preloaded 8 bit operand. */

dosettocar:
  if (_trace) printf("dosettocar:\n");

DoSetToCarSP:
  if (_trace) printf("DoSetToCarSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoSetToCarLP:
  if (_trace) printf("DoSetToCarLP:\n");

DoSetToCarFP:
  if (_trace) printf("DoSetToCarFP:\n");

begindosettocar:
  if (_trace) printf("begindosettocar:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg5 = *(s32 *)(arg1 + 4);   		// Get the operand from the stack. 
  arg6 = *(s32 *)arg1;   
  t2 = arg5 & 192;		// Save the old CDR code 
  r0 = (u64)&&return0496;
  goto carinternal;
return0496:
  /* TagType. */
  arg5 = arg5 & 63;
  arg5 = arg5 | t2;		// Put back the original CDR codes 
  *(u32 *)arg1 = arg6;
		/* write the stack cache */
  *(u32 *)(arg1 + 4) = arg5;
  goto NEXTINSTRUCTION;   

DoSetToCarIM:
  goto doistageerror;

/* end DoSetToCar */
  /* End of Halfword operand from stack instruction - DoSetToCar */
/* start DoSetToCdr */

  /* Halfword operand from stack instruction - DoSetToCdr */
  /* arg2 has the preloaded 8 bit operand. */

dosettocdr:
  if (_trace) printf("dosettocdr:\n");

DoSetToCdrSP:
  if (_trace) printf("DoSetToCdrSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoSetToCdrLP:
  if (_trace) printf("DoSetToCdrLP:\n");

DoSetToCdrFP:
  if (_trace) printf("DoSetToCdrFP:\n");

begindosettocdr:
  if (_trace) printf("begindosettocdr:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg5 = *(s32 *)(arg1 + 4);   		// Get the operand from the stack. 
  arg6 = *(s32 *)arg1;   
  t2 = arg5 & 192;		// Save the old CDR code 
  r0 = (u64)&&return0497;
  goto cdrinternal;
return0497:
  /* TagType. */
  arg5 = arg5 & 63;
  arg5 = arg5 | t2;		// Put back the original CDR codes 
  *(u32 *)arg1 = arg6;
		/* write the stack cache */
  *(u32 *)(arg1 + 4) = arg5;
  goto NEXTINSTRUCTION;   

DoSetToCdrIM:
  goto doistageerror;

/* end DoSetToCdr */
  /* End of Halfword operand from stack instruction - DoSetToCdr */
/* start SetToCdrPushCarLocative */


SetToCdrPushCarLocative:
  if (_trace) printf("SetToCdrPushCarLocative:\n");

settocdrpushcarlocative:
  if (_trace) printf("settocdrpushcarlocative:\n");
  arg2 = t2;
  /* Memory Read Internal */

vma-memory-read15121:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read15123;

vma-memory-read15122:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read15125;

vma-memory-read15132:
  /* TagType. */
  t1 = t1 & 63;
  *(u32 *)(iSP + 8) = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = arg5;
  iSP = iSP + 8;
  t1 = t1 | t3;		// Put back the original CDR codes 
  *(u32 *)arg1 = arg6;
		/* write the stack cache */
  *(u32 *)(arg1 + 4) = arg5;
  goto NEXTINSTRUCTION;   

vma-memory-read15125:
  if (_trace) printf("vma-memory-read15125:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read15124;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read15121;   

vma-memory-read15124:
  if (_trace) printf("vma-memory-read15124:\n");

vma-memory-read15123:
  if (_trace) printf("vma-memory-read15123:\n");
  r0 = (u64)&&return0498;
  goto memoryreaddatadecode;
return0498:
  goto vma-memory-read15132;   

/* end SetToCdrPushCarLocative */
/* start DoAssoc */

  /* Halfword operand from stack instruction - DoAssoc */
  /* arg2 has the preloaded 8 bit operand. */

doassoc:
  if (_trace) printf("doassoc:\n");

DoAssocSP:
  if (_trace) printf("DoAssocSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoassoc;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoAssocLP:
  if (_trace) printf("DoAssocLP:\n");

DoAssocFP:
  if (_trace) printf("DoAssocFP:\n");

begindoassoc:
  if (_trace) printf("begindoassoc:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t5 = zero + -2048;   
  t5 = t5 + ((1) << 16);   
  arg3 = (u32)(arg6 >> ((4&7)*8));   
  arg4 = (u32)arg6;   
  t1 = *(s32 *)(arg1 + 4);   
  t2 = *(s32 *)arg1;   
  /* TagType. */
  arg3 = arg3 & 63;		// Get the object type bits 
  t5 = t5 >> (arg3 & 63);   		// Low bit will set iff EQ-NOT-EQL 
  /* TagType. */
  t1 = t1 & 63;		// Strip cdr code 
  t2 = (u32)t2;   		// Remove sign-extension 
  if (t5 & 1)   
    goto assocexc;
  t6 = zero;
  goto carcdrloop15134;   

assoccdr:
  if (_trace) printf("assoccdr:\n");
  t6 = *(u64 *)&(processor->stop_interpreter);   		// Have we been asked to stop or trap? 
  /* Move cdr to car for next carcdr-internal */
  /* TagType. */
  t1 = arg5 & 63;
  t2 = arg6;

carcdrloop15134:
  if (_trace) printf("carcdrloop15134:\n");
  t5 = t1 - Type_NIL;   
  if (t6 != 0)   		// Asked to stop, check for sequence break 
    goto carcdrloop15133;
  if (t5 == 0) 
    goto carcdrloop15135;
  r0 = (u64)&&return0499;
  goto carcdrinternal;
return0499:
  t7 = t1 & 63;		// Strip off any CDR code bits. 
  t8 = (t7 == Type_List) ? 1 : 0;   

force-alignment15153:
  if (_trace) printf("force-alignment15153:\n");
  if (t8 == 0) 
    goto basic-dispatch15137;
  /* Here if argument TypeList */
  arg2 = t2;
  t3 = arg5;
  arg1 = arg6;
  /* Memory Read Internal */

vma-memory-read15138:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read15140;

vma-memory-read15139:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read15142;

vma-memory-read15149:
  /* TagType. */
  t5 = arg5 & 63;
  arg5 = t3;
  t6 = (s32)arg4 - (s32)arg6;   		// t6=0 if data same 
  arg6 = arg1;
  if (t6 != 0)   		// J. if different 
    goto assoccdr;
  t5 = arg3 - t5;   		// t5 zero if same tag 
  if (t5 != 0)   		// J. if tags different 
    goto assoccdr;
  /* we found a match! */
  /* TagType. */
  t1 = t1 & 63;
  *(u32 *)iSP = t2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto NEXTINSTRUCTION;   

basic-dispatch15137:
  if (_trace) printf("basic-dispatch15137:\n");
  t8 = (t7 == Type_NIL) ? 1 : 0;   

force-alignment15154:
  if (_trace) printf("force-alignment15154:\n");
  if (t8 == 0) 
    goto basic-dispatch15150;
  /* Here if argument TypeNIL */
  goto assoccdr;   

basic-dispatch15150:
  if (_trace) printf("basic-dispatch15150:\n");
  /* Here for all other cases */
  /* SetTag. */
  t1 = arg4 << 32;   
  t1 = arg5 | t1;
  arg5 = t1;
  arg2 = 14;
  goto illegaloperand;

basic-dispatch15136:
  if (_trace) printf("basic-dispatch15136:\n");

carcdrloop15135:
  if (_trace) printf("carcdrloop15135:\n");
  t1 = *(u64 *)&(processor->niladdress);   		// Return NIL 
  *(u64 *)iSP = t1;   		// push the data 
  goto NEXTINSTRUCTION;   

assocexc:
  if (_trace) printf("assocexc:\n");
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

vma-memory-read15142:
  if (_trace) printf("vma-memory-read15142:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read15141;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read15138;   

vma-memory-read15141:
  if (_trace) printf("vma-memory-read15141:\n");

vma-memory-read15140:
  if (_trace) printf("vma-memory-read15140:\n");
  r0 = (u64)&&return0500;
  goto memoryreaddatadecode;
return0500:
  goto vma-memory-read15149;   

carcdrloop15133:
  if (_trace) printf("carcdrloop15133:\n");
  iSP = *(u64 *)&(processor->restartsp);   
  goto INTERPRETINSTRUCTION;   

DoAssocIM:
  goto doistageerror;

/* end DoAssoc */
  /* End of Halfword operand from stack instruction - DoAssoc */
/* start DoMember */

  /* Halfword operand from stack instruction - DoMember */
  /* arg2 has the preloaded 8 bit operand. */

domember:
  if (_trace) printf("domember:\n");

DoMemberSP:
  if (_trace) printf("DoMemberSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomember;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoMemberLP:
  if (_trace) printf("DoMemberLP:\n");

DoMemberFP:
  if (_trace) printf("DoMemberFP:\n");

begindomember:
  if (_trace) printf("begindomember:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t5 = zero + -2048;   
  t5 = t5 + ((1) << 16);   
  arg3 = (u32)(arg6 >> ((4&7)*8));   
  arg4 = (u32)arg6;   
  t1 = *(s32 *)(arg1 + 4);   
  t2 = *(s32 *)arg1;   
  /* TagType. */
  arg3 = arg3 & 63;		// Get the object type bits 
  t5 = t5 >> (arg3 & 63);   		// Low bit will set iff EQ-NOT-EQL 
  /* TagType. */
  t1 = t1 & 63;		// Strip cdr code 
  t2 = (u32)t2;   		// Remove sign-extension 
  if (t5 & 1)   
    goto memberexc;
  t6 = zero;
  goto carcdrloop15156;   

membercdr:
  if (_trace) printf("membercdr:\n");
  t6 = *(u64 *)&(processor->stop_interpreter);   		// Have we been asked to stop or trap? 
  /* Move cdr to car for next carcdr-internal */
  /* TagType. */
  t1 = arg5 & 63;
  t2 = arg6;

carcdrloop15156:
  if (_trace) printf("carcdrloop15156:\n");
  /* TagType. */
  t3 = t1 & 63;
  arg1 = t2;
  t5 = t1 - Type_NIL;   
  if (t6 != 0)   		// Asked to stop, check for sequence break 
    goto carcdrloop15155;
  if (t5 == 0) 
    goto carcdrloop15157;
  r0 = (u64)&&return0501;
  goto carcdrinternal;
return0501:
  /* TagType. */
  t5 = t1 & 63;
  t7 = arg4 - t2;   		// t7=0 if data same 
  if (t7 != 0)   		// J. if different 
    goto membercdr;
  t6 = arg3 - t5;   		// t6 zero if same tag 
  if (t6 != 0)   		// J. if tags different 
    goto membercdr;
  /* we found a match! */
  *(u32 *)iSP = arg1;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t3;
  goto NEXTINSTRUCTION;   

carcdrloop15157:
  if (_trace) printf("carcdrloop15157:\n");
  t1 = *(u64 *)&(processor->niladdress);   		// Return NIL 
  *(u64 *)iSP = t1;   		// push the data 
  goto NEXTINSTRUCTION;   

memberexc:
  if (_trace) printf("memberexc:\n");
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

carcdrloop15155:
  if (_trace) printf("carcdrloop15155:\n");
  iSP = *(u64 *)&(processor->restartsp);   
  goto INTERPRETINSTRUCTION;   

DoMemberIM:
  goto doistageerror;

/* end DoMember */
  /* End of Halfword operand from stack instruction - DoMember */
/* start DoRgetf */

  /* Halfword operand from stack instruction - DoRgetf */
  /* arg2 has the preloaded 8 bit operand. */

dorgetf:
  if (_trace) printf("dorgetf:\n");

DoRgetfSP:
  if (_trace) printf("DoRgetfSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindorgetf;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoRgetfLP:
  if (_trace) printf("DoRgetfLP:\n");

DoRgetfFP:
  if (_trace) printf("DoRgetfFP:\n");

begindorgetf:
  if (_trace) printf("begindorgetf:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t5 = zero + -2048;   
  t5 = t5 + ((1) << 16);   
  arg3 = (u32)(arg6 >> ((4&7)*8));   
  arg4 = (u32)arg6;   
  t1 = *(s32 *)(arg1 + 4);   
  t2 = *(s32 *)arg1;   
  /* TagType. */
  arg3 = arg3 & 63;		// Get the object type bits 
  t5 = t5 >> (arg3 & 63);   		// Low bit will set iff EQ-NOT-EQL 
  /* TagType. */
  t1 = t1 & 63;		// Strip cdr code 
  t2 = (u32)t2;   		// Remove sign-extension 
  if (t5 & 1)   
    goto rgetfexc;
  t6 = zero;
  goto carcdrloop15159;   

rgetfcdr:
  if (_trace) printf("rgetfcdr:\n");
  r0 = (u64)&&return0502;
  goto cdrinternal;
return0502:
  t6 = *(u64 *)&(processor->stop_interpreter);   		// Have we been asked to stop or trap? 
  /* Move cdr to car for next carcdr-internal */
  /* TagType. */
  t1 = arg5 & 63;
  t2 = arg6;

carcdrloop15159:
  if (_trace) printf("carcdrloop15159:\n");
  t5 = t1 - Type_NIL;   
  if (t6 != 0)   		// Asked to stop, check for sequence break 
    goto carcdrloop15158;
  if (t5 == 0) 
    goto carcdrloop15160;
  r0 = (u64)&&return0503;
  goto carcdrinternal;
return0503:
  /* TagType. */
  t5 = t1 & 63;
  t7 = arg4 - t2;   		// t7=0 if data same 
  if (t7 != 0)   		// J. if different 
    goto rgetfcdr;
  t6 = arg3 - t5;   		// t6 zero if same tag 
  if (t6 != 0)   		// J. if tags different 
    goto rgetfcdr;
  /* we found a match! */
  /* TagType. */
  t1 = arg5 & 63;		// Strip CDR code 
  t5 = t1 - Type_NIL;   		// t5=0 if end of list 
  if (t5 == 0) 		// after all this effort we lose! 
    goto rgetfexc;
  t2 = arg6;
  r0 = (u64)&&return0504;
  goto carinternal;
return0504:
  /* TagType. */
  arg5 = arg5 & 63;		// Strip the CDR code 
  *(u32 *)iSP = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = arg5;
  arg2 = t1 & 63;		// set CDR-NEXT 
		/* Push the second result */
  *(u32 *)(iSP + 8) = t2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = arg2;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

carcdrloop15160:
  if (_trace) printf("carcdrloop15160:\n");
  arg2 = *(u64 *)&(processor->niladdress);   		// Return NIL 
  *(u64 *)iSP = arg2;   
  *(u64 *)(iSP + 8) = arg2;   		// push the data 
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

rgetfexc:
  if (_trace) printf("rgetfexc:\n");
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

carcdrloop15158:
  if (_trace) printf("carcdrloop15158:\n");
  iSP = *(u64 *)&(processor->restartsp);   
  goto INTERPRETINSTRUCTION;   

DoRgetfIM:
  goto doistageerror;

/* end DoRgetf */
  /* End of Halfword operand from stack instruction - DoRgetf */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunlist.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifuninst.as
 ************************************************************************/

  /* Instance variable accessors.. */
/* start DoPopInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPopInstanceVariable */

dopopinstancevariable:
  if (_trace) printf("dopopinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoPopInstanceVariableIM:
  if (_trace) printf("DoPopInstanceVariableIM:\n");

DoPopInstanceVariableSP:
  if (_trace) printf("DoPopInstanceVariableSP:\n");

DoPopInstanceVariableLP:
  if (_trace) printf("DoPopInstanceVariableLP:\n");

DoPopInstanceVariableFP:
  if (_trace) printf("DoPopInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Instance Variable Mapped */
  arg1 = *(s32 *)(iFP + 16);   		// Map 
  t1 = *(s32 *)(iFP + 20);   
  arg1 = (u32)arg1;   
  t4 = t1 - Type_Array;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto ivbadmap;
  /* Memory Read Internal */

vma-memory-read15164:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->header_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15166;

vma-memory-read15165:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  if (t10 & 1)   
    goto vma-memory-read15168;

vma-memory-read15173:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;   
  if ((s64)t5 <= 0)  		// J. if mapping-table-index-out-of-bounds 
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

vma-memory-read15174:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15176;

vma-memory-read15175:
  t9 = zero + 240;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto vma-memory-read15178;

vma-memory-read15185:
  t3 = t2;
  t6 = t1 - Type_Fixnum;   
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto popiviex;
  arg1 = *(s32 *)(iFP + 24);   		// Self 
  t6 = *(s32 *)(iFP + 28);   
  arg1 = (u32)arg1;   
  t5 = t6 - Type_Instance;   
  t5 = t5 & 60;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto ivbadinst;
  t5 = t6 & 192;		// Unshifted cdr code 
  t5 = t5 - 64;   		// Check for CDR code 1 
  if (t5 != 0)   		// J. if CDR code is not 1 
    goto locate-instance0variable-mapped15163;

locate-instance0variable-mapped15162:
  if (_trace) printf("locate-instance0variable-mapped15162:\n");
  arg1 = arg1 + t3;

locate-instance0variable-mapped15161:
  if (_trace) printf("locate-instance0variable-mapped15161:\n");
  t1 = *(s32 *)iSP;   
  t2 = *(s32 *)(iSP + 4);   
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = (u32)t1;   
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read15186:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = arg1 - arg5;   		// Stack cache offset 
  t9 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read15188;

vma-memory-read15187:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t9 & 1)   
    goto vma-memory-read15190;

vma-memory-read15196:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment15198:
  if (_trace) printf("force-alignment15198:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t1;
  if (t9 != 0)   		// J. if in cache 
    goto vma-memory-write15197;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

popiviex:
  if (_trace) printf("popiviex:\n");
  t1 = zero + 8;   
  /* SetTag. */
  t1 = t1 << 32;   
  t1 = arg2 | t1;
  arg6 = t2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

vma-memory-write15197:
  if (_trace) printf("vma-memory-write15197:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = t1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

vma-memory-read15188:
  if (_trace) printf("vma-memory-read15188:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read15187;   

vma-memory-read15190:
  if (_trace) printf("vma-memory-read15190:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read15189;
  arg1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read15186;   

vma-memory-read15189:
  if (_trace) printf("vma-memory-read15189:\n");
  t9 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
  t9 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read15193:

vma-memory-read15192:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

vma-memory-read15176:
  if (_trace) printf("vma-memory-read15176:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15175;   

vma-memory-read15178:
  if (_trace) printf("vma-memory-read15178:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read15177;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read15174;   

vma-memory-read15177:
  if (_trace) printf("vma-memory-read15177:\n");
  t10 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read15182:
  if (_trace) printf("vma-memory-read15182:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0) 
    goto vma-memory-read15181;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto vma-memory-read15185;   

vma-memory-read15181:

vma-memory-read15180:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read15166:
  if (_trace) printf("vma-memory-read15166:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15165;   

vma-memory-read15168:
  if (_trace) printf("vma-memory-read15168:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read15167;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read15164;   

vma-memory-read15167:
  if (_trace) printf("vma-memory-read15167:\n");
  t10 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read15170:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

locate-instance0variable-mapped15163:
  if (_trace) printf("locate-instance0variable-mapped15163:\n");
  t5 = arg1;
  /* Memory Read Internal */

vma-memory-read15199:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->header_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15201;

vma-memory-read15200:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto vma-memory-read15203;

vma-memory-read15208:
  t5 = t5 - arg1;   
  if (t5 != 0)   
    goto locate-instance0variable-mapped15162;
  /* TagType. */
  t6 = t6 & 63;
  t6 = t6 | 64;		// Set CDR code to 1 
		/* Update self */
  *(u32 *)(iFP + 24) = arg1;
		/* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto locate-instance0variable-mapped15162;   

vma-memory-read15201:
  if (_trace) printf("vma-memory-read15201:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15200;   

vma-memory-read15203:
  if (_trace) printf("vma-memory-read15203:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read15202;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read15199;   

vma-memory-read15202:
  if (_trace) printf("vma-memory-read15202:\n");
  t10 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read15205:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoPopInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPopInstanceVariable */
/* start DoMovemInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoMovemInstanceVariable */

domoveminstancevariable:
  if (_trace) printf("domoveminstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoMovemInstanceVariableIM:
  if (_trace) printf("DoMovemInstanceVariableIM:\n");

DoMovemInstanceVariableSP:
  if (_trace) printf("DoMovemInstanceVariableSP:\n");

DoMovemInstanceVariableLP:
  if (_trace) printf("DoMovemInstanceVariableLP:\n");

DoMovemInstanceVariableFP:
  if (_trace) printf("DoMovemInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Instance Variable Mapped */
  arg1 = *(s32 *)(iFP + 16);   		// Map 
  t1 = *(s32 *)(iFP + 20);   
  arg1 = (u32)arg1;   
  t4 = t1 - Type_Array;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto ivbadmap;
  /* Memory Read Internal */

vma-memory-read15212:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->header_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15214;

vma-memory-read15213:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  if (t10 & 1)   
    goto vma-memory-read15216;

vma-memory-read15221:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;   
  if ((s64)t5 <= 0)  		// J. if mapping-table-index-out-of-bounds 
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

vma-memory-read15222:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15224;

vma-memory-read15223:
  t9 = zero + 240;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto vma-memory-read15226;

vma-memory-read15233:
  t3 = t2;
  t6 = t1 - Type_Fixnum;   
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto movemiviex;
  arg1 = *(s32 *)(iFP + 24);   		// Self 
  t6 = *(s32 *)(iFP + 28);   
  arg1 = (u32)arg1;   
  t5 = t6 - Type_Instance;   
  t5 = t5 & 60;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto ivbadinst;
  t5 = t6 & 192;		// Unshifted cdr code 
  t5 = t5 - 64;   		// Check for CDR code 1 
  if (t5 != 0)   		// J. if CDR code is not 1 
    goto locate-instance0variable-mapped15211;

locate-instance0variable-mapped15210:
  if (_trace) printf("locate-instance0variable-mapped15210:\n");
  arg1 = arg1 + t3;

locate-instance0variable-mapped15209:
  if (_trace) printf("locate-instance0variable-mapped15209:\n");
  t1 = *(s32 *)iSP;   
  t2 = *(s32 *)(iSP + 4);   
  t1 = (u32)t1;   
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read15234:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = arg1 - arg5;   		// Stack cache offset 
  t9 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read15236;

vma-memory-read15235:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t9 & 1)   
    goto vma-memory-read15238;

vma-memory-read15244:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment15246:
  if (_trace) printf("force-alignment15246:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t1;
  if (t9 != 0)   		// J. if in cache 
    goto vma-memory-write15245;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

movemiviex:
  if (_trace) printf("movemiviex:\n");
  t1 = zero + 8;   
  /* SetTag. */
  t1 = t1 << 32;   
  t1 = arg2 | t1;
  arg6 = t2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

vma-memory-write15245:
  if (_trace) printf("vma-memory-write15245:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = t1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

vma-memory-read15236:
  if (_trace) printf("vma-memory-read15236:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read15235;   

vma-memory-read15238:
  if (_trace) printf("vma-memory-read15238:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read15237;
  arg1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read15234;   

vma-memory-read15237:
  if (_trace) printf("vma-memory-read15237:\n");
  t9 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
  t9 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read15241:

vma-memory-read15240:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

vma-memory-read15224:
  if (_trace) printf("vma-memory-read15224:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15223;   

vma-memory-read15226:
  if (_trace) printf("vma-memory-read15226:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read15225;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read15222;   

vma-memory-read15225:
  if (_trace) printf("vma-memory-read15225:\n");
  t10 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read15230:
  if (_trace) printf("vma-memory-read15230:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0) 
    goto vma-memory-read15229;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto vma-memory-read15233;   

vma-memory-read15229:

vma-memory-read15228:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read15214:
  if (_trace) printf("vma-memory-read15214:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15213;   

vma-memory-read15216:
  if (_trace) printf("vma-memory-read15216:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read15215;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read15212;   

vma-memory-read15215:
  if (_trace) printf("vma-memory-read15215:\n");
  t10 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read15218:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

locate-instance0variable-mapped15211:
  if (_trace) printf("locate-instance0variable-mapped15211:\n");
  t5 = arg1;
  /* Memory Read Internal */

vma-memory-read15247:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->header_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15249;

vma-memory-read15248:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto vma-memory-read15251;

vma-memory-read15256:
  t5 = t5 - arg1;   
  if (t5 != 0)   
    goto locate-instance0variable-mapped15210;
  /* TagType. */
  t6 = t6 & 63;
  t6 = t6 | 64;		// Set CDR code to 1 
		/* Update self */
  *(u32 *)(iFP + 24) = arg1;
		/* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto locate-instance0variable-mapped15210;   

vma-memory-read15249:
  if (_trace) printf("vma-memory-read15249:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15248;   

vma-memory-read15251:
  if (_trace) printf("vma-memory-read15251:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read15250;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read15247;   

vma-memory-read15250:
  if (_trace) printf("vma-memory-read15250:\n");
  t10 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read15253:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoMovemInstanceVariable */
  /* End of Halfword operand from stack instruction - DoMovemInstanceVariable */
/* start DoPushAddressInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariable */

dopushaddressinstancevariable:
  if (_trace) printf("dopushaddressinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoPushAddressInstanceVariableIM:
  if (_trace) printf("DoPushAddressInstanceVariableIM:\n");

DoPushAddressInstanceVariableSP:
  if (_trace) printf("DoPushAddressInstanceVariableSP:\n");

DoPushAddressInstanceVariableLP:
  if (_trace) printf("DoPushAddressInstanceVariableLP:\n");

DoPushAddressInstanceVariableFP:
  if (_trace) printf("DoPushAddressInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Instance Variable Mapped */
  arg1 = *(s32 *)(iFP + 16);   		// Map 
  t1 = *(s32 *)(iFP + 20);   
  arg1 = (u32)arg1;   
  t4 = t1 - Type_Array;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto ivbadmap;
  /* Memory Read Internal */

vma-memory-read15260:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->header_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15262;

vma-memory-read15261:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  if (t10 & 1)   
    goto vma-memory-read15264;

vma-memory-read15269:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;   
  if ((s64)t5 <= 0)  		// J. if mapping-table-index-out-of-bounds 
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

vma-memory-read15270:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15272;

vma-memory-read15271:
  t9 = zero + 240;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto vma-memory-read15274;

vma-memory-read15281:
  t3 = t2;
  t6 = t1 - Type_Fixnum;   
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto pushadiviex;
  arg1 = *(s32 *)(iFP + 24);   		// Self 
  t6 = *(s32 *)(iFP + 28);   
  arg1 = (u32)arg1;   
  t5 = t6 - Type_Instance;   
  t5 = t5 & 60;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto ivbadinst;
  t5 = t6 & 192;		// Unshifted cdr code 
  t5 = t5 - 64;   		// Check for CDR code 1 
  if (t5 != 0)   		// J. if CDR code is not 1 
    goto locate-instance0variable-mapped15259;

locate-instance0variable-mapped15258:
  if (_trace) printf("locate-instance0variable-mapped15258:\n");
  arg1 = arg1 + t3;

locate-instance0variable-mapped15257:
  if (_trace) printf("locate-instance0variable-mapped15257:\n");
  t7 = Type_Locative;
  *(u32 *)(iSP + 8) = arg1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

pushadiviex:
  if (_trace) printf("pushadiviex:\n");
  t1 = zero + 8;   
  /* SetTag. */
  t1 = t1 << 32;   
  t1 = arg2 | t1;
  arg6 = t2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

vma-memory-read15272:
  if (_trace) printf("vma-memory-read15272:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15271;   

vma-memory-read15274:
  if (_trace) printf("vma-memory-read15274:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read15273;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read15270;   

vma-memory-read15273:
  if (_trace) printf("vma-memory-read15273:\n");
  t10 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read15278:
  if (_trace) printf("vma-memory-read15278:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0) 
    goto vma-memory-read15277;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto vma-memory-read15281;   

vma-memory-read15277:

vma-memory-read15276:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read15262:
  if (_trace) printf("vma-memory-read15262:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15261;   

vma-memory-read15264:
  if (_trace) printf("vma-memory-read15264:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read15263;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read15260;   

vma-memory-read15263:
  if (_trace) printf("vma-memory-read15263:\n");
  t10 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read15266:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

locate-instance0variable-mapped15259:
  if (_trace) printf("locate-instance0variable-mapped15259:\n");
  t5 = arg1;
  /* Memory Read Internal */

vma-memory-read15282:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->header_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15284;

vma-memory-read15283:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto vma-memory-read15286;

vma-memory-read15291:
  t5 = t5 - arg1;   
  if (t5 != 0)   
    goto locate-instance0variable-mapped15258;
  /* TagType. */
  t6 = t6 & 63;
  t6 = t6 | 64;		// Set CDR code to 1 
		/* Update self */
  *(u32 *)(iFP + 24) = arg1;
		/* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto locate-instance0variable-mapped15258;   

vma-memory-read15284:
  if (_trace) printf("vma-memory-read15284:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15283;   

vma-memory-read15286:
  if (_trace) printf("vma-memory-read15286:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read15285;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read15282;   

vma-memory-read15285:
  if (_trace) printf("vma-memory-read15285:\n");
  t10 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read15288:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoPushAddressInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPushAddressInstanceVariable */
/* start DoPushInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPushInstanceVariableOrdered */

dopushinstancevariableordered:
  if (_trace) printf("dopushinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoPushInstanceVariableOrderedIM:
  if (_trace) printf("DoPushInstanceVariableOrderedIM:\n");

DoPushInstanceVariableOrderedSP:
  if (_trace) printf("DoPushInstanceVariableOrderedSP:\n");

DoPushInstanceVariableOrderedLP:
  if (_trace) printf("DoPushInstanceVariableOrderedLP:\n");

DoPushInstanceVariableOrderedFP:
  if (_trace) printf("DoPushInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Instance Variable Unmapped */
  t2 = *(s32 *)(iFP + 24);   		// self 
  t1 = *(s32 *)(iFP + 28);   
  t2 = (u32)t2;   
  t3 = t1 - Type_Instance;   
  t3 = t3 & 60;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto ivbadinst;
  arg1 = t2 + arg2;
  /* Memory Read Internal */

vma-memory-read15292:
  t6 = arg1 + ivory;
  t1 = (t6 * 4);   
  t2 = LDQ_U(t6);   
  t4 = arg1 - arg5;   		// Stack cache offset 
  t7 = *(u64 *)&(processor->dataread_mask);   
  t5 = ((u64)t4 < (u64)arg6) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;   
  t2 = (u8)(t2 >> ((t6&7)*8));   
  if (t5 != 0)   
    goto vma-memory-read15294;

vma-memory-read15293:
  t6 = zero + 240;   
  t7 = t7 >> (t2 & 63);   
  t6 = t6 >> (t2 & 63);   
  if (t7 & 1)   
    goto vma-memory-read15296;

vma-memory-read15303:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t7 = t2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;   

vma-memory-read15294:
  if (_trace) printf("vma-memory-read15294:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t4 = (t4 * 8) + t5;  		// reconstruct SCA 
  t1 = *(s32 *)t4;   
  t2 = *(s32 *)(t4 + 4);   		// Read from stack cache 
  goto vma-memory-read15293;   

vma-memory-read15296:
  if (_trace) printf("vma-memory-read15296:\n");
  if ((t6 & 1) == 0)   
    goto vma-memory-read15295;
  arg1 = (u32)t1;   		// Do the indirect thing 
  goto vma-memory-read15292;   

vma-memory-read15295:
  if (_trace) printf("vma-memory-read15295:\n");
  t7 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t6 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t6 = (t6 * 4) + t7;   		// Adjust for a longword load 
  t7 = *(s32 *)t6;   		// Get the memory action 

vma-memory-read15300:
  if (_trace) printf("vma-memory-read15300:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0) 
    goto vma-memory-read15299;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto vma-memory-read15303;   

vma-memory-read15299:

vma-memory-read15298:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

/* end DoPushInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPushInstanceVariableOrdered */
/* start DoPopInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPopInstanceVariableOrdered */

dopopinstancevariableordered:
  if (_trace) printf("dopopinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoPopInstanceVariableOrderedIM:
  if (_trace) printf("DoPopInstanceVariableOrderedIM:\n");

DoPopInstanceVariableOrderedSP:
  if (_trace) printf("DoPopInstanceVariableOrderedSP:\n");

DoPopInstanceVariableOrderedLP:
  if (_trace) printf("DoPopInstanceVariableOrderedLP:\n");

DoPopInstanceVariableOrderedFP:
  if (_trace) printf("DoPopInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Instance Variable Unmapped */
  t2 = *(s32 *)(iFP + 24);   		// self 
  t1 = *(s32 *)(iFP + 28);   
  t2 = (u32)t2;   
  t3 = t1 - Type_Instance;   
  t3 = t3 & 60;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto ivbadinst;
  arg1 = t2 + arg2;
  t1 = *(s32 *)iSP;   
  t2 = *(s32 *)(iSP + 4);   
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = (u32)t1;   
  /* Memory Read Internal */

vma-memory-read15304:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = arg1 - arg5;   		// Stack cache offset 
  t9 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read15306;

vma-memory-read15305:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t9 & 1)   
    goto vma-memory-read15308;

vma-memory-read15314:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment15316:
  if (_trace) printf("force-alignment15316:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t1;
  if (t9 != 0)   		// J. if in cache 
    goto vma-memory-write15315;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

vma-memory-write15315:
  if (_trace) printf("vma-memory-write15315:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = t1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

vma-memory-read15306:
  if (_trace) printf("vma-memory-read15306:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read15305;   

vma-memory-read15308:
  if (_trace) printf("vma-memory-read15308:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read15307;
  arg1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read15304;   

vma-memory-read15307:
  if (_trace) printf("vma-memory-read15307:\n");
  t9 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
  t9 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read15311:

vma-memory-read15310:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoPopInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPopInstanceVariableOrdered */
/* start DoMovemInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoMovemInstanceVariableOrdered */

domoveminstancevariableordered:
  if (_trace) printf("domoveminstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoMovemInstanceVariableOrderedIM:
  if (_trace) printf("DoMovemInstanceVariableOrderedIM:\n");

DoMovemInstanceVariableOrderedSP:
  if (_trace) printf("DoMovemInstanceVariableOrderedSP:\n");

DoMovemInstanceVariableOrderedLP:
  if (_trace) printf("DoMovemInstanceVariableOrderedLP:\n");

DoMovemInstanceVariableOrderedFP:
  if (_trace) printf("DoMovemInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Instance Variable Unmapped */
  t2 = *(s32 *)(iFP + 24);   		// self 
  t1 = *(s32 *)(iFP + 28);   
  t2 = (u32)t2;   
  t3 = t1 - Type_Instance;   
  t3 = t3 & 60;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto ivbadinst;
  arg1 = t2 + arg2;
  t1 = *(s32 *)iSP;   
  t2 = *(s32 *)(iSP + 4);   
  t1 = (u32)t1;   
  /* Memory Read Internal */

vma-memory-read15317:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = arg1 - arg5;   		// Stack cache offset 
  t9 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read15319;

vma-memory-read15318:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t9 & 1)   
    goto vma-memory-read15321;

vma-memory-read15327:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment15329:
  if (_trace) printf("force-alignment15329:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t1;
  if (t9 != 0)   		// J. if in cache 
    goto vma-memory-write15328;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

vma-memory-write15328:
  if (_trace) printf("vma-memory-write15328:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = t1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

vma-memory-read15319:
  if (_trace) printf("vma-memory-read15319:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read15318;   

vma-memory-read15321:
  if (_trace) printf("vma-memory-read15321:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read15320;
  arg1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read15317;   

vma-memory-read15320:
  if (_trace) printf("vma-memory-read15320:\n");
  t9 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
  t9 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read15324:

vma-memory-read15323:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoMovemInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoMovemInstanceVariableOrdered */
/* start DoPushAddressInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariableOrdered */

dopushaddressinstancevariableordered:
  if (_trace) printf("dopushaddressinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoPushAddressInstanceVariableOrderedIM:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedIM:\n");

DoPushAddressInstanceVariableOrderedSP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedSP:\n");

DoPushAddressInstanceVariableOrderedLP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedLP:\n");

DoPushAddressInstanceVariableOrderedFP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  /* Locate Instance Variable Unmapped */
  t2 = *(s32 *)(iFP + 24);   		// self 
  t1 = *(s32 *)(iFP + 28);   
  t2 = (u32)t2;   
  t3 = t1 - Type_Instance;   
  t3 = t3 & 60;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto ivbadinst;
  arg1 = t2 + arg2;
  t7 = Type_Locative;
  *(u32 *)(iSP + 8) = arg1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

ivbadmap:
  if (_trace) printf("ivbadmap:\n");
  arg5 = 0;
  arg2 = 68;
  goto illegaloperand;

ivbadindex:
  if (_trace) printf("ivbadindex:\n");
  arg5 = 0;
  arg2 = 53;
  goto illegaloperand;

ivbadinst:
  if (_trace) printf("ivbadinst:\n");
  arg5 = 0;
  arg2 = 69;
  goto illegaloperand;

/* end DoPushAddressInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPushAddressInstanceVariableOrdered */
/* start DoInstanceRef */

  /* Halfword operand from stack instruction - DoInstanceRef */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceref:
  if (_trace) printf("doinstanceref:\n");

DoInstanceRefIM:
  if (_trace) printf("DoInstanceRefIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoinstanceref;   

DoInstanceRefSP:
  if (_trace) printf("DoInstanceRefSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoInstanceRefLP:
  if (_trace) printf("DoInstanceRefLP:\n");

DoInstanceRefFP:
  if (_trace) printf("DoInstanceRefFP:\n");

headdoinstanceref:
  if (_trace) printf("headdoinstanceref:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoinstanceref:
  if (_trace) printf("begindoinstanceref:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   
  arg3 = *(s32 *)(iSP + 4);   
  arg4 = (u32)arg4;   
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;   
  t1 = t1 & 60;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto ivrefbadinst;
  t1 = arg2 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto ivrefbadoffset;
  /* Memory Read Internal */

vma-memory-read15330:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);   
  t2 = LDQ_U(t7);   
  t5 = arg4 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;   
  t2 = (u8)(t2 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read15332;

vma-memory-read15331:
  t7 = zero + 64;   
  t8 = t8 >> (t2 & 63);   
  t7 = t7 >> (t2 & 63);   
  t1 = (u32)t1;   
  if (t8 & 1)   
    goto vma-memory-read15334;

vma-memory-read15339:
  t1 = t1 - 1;   
  /* Memory Read Internal */

vma-memory-read15340:
  t7 = t1 + ivory;
  t2 = (t7 * 4);   
  t4 = LDQ_U(t7);   
  t5 = t1 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read15342;

vma-memory-read15341:
  t7 = zero + 240;   
  t8 = t8 >> (t4 & 63);   
  t7 = t7 >> (t4 & 63);   
  if (t8 & 1)   
    goto vma-memory-read15344;

vma-memory-read15351:
  t5 = t4 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto ivrefbadoffset;
  if ((s64)arg1 < 0)   		// J. if offset <0 
    goto ivrefbadoffset;
  t4 = arg1 - t2;   
  if ((s64)t4 >= 0)   		// J. if offset out of bounds 
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  /* Memory Read Internal */

vma-memory-read15352:
  t4 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t6 = arg5 + ivory;
  t5 = *(s32 *)&processor->scovlimit;   
  t1 = (t6 * 4);   
  t2 = LDQ_U(t6);   
  t4 = arg5 - t4;   		// Stack cache offset 
  t7 = *(u64 *)&(processor->dataread_mask);   
  t5 = ((u64)t4 < (u64)t5) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;   
  t2 = (u8)(t2 >> ((t6&7)*8));   
  if (t5 != 0)   
    goto vma-memory-read15354;

vma-memory-read15353:
  t6 = zero + 240;   
  t7 = t7 >> (t2 & 63);   
  t6 = t6 >> (t2 & 63);   
  if (t7 & 1)   
    goto vma-memory-read15356;

vma-memory-read15363:
  t2 = t2 & 63;		// set CDR-NEXT 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u32 *)iSP = t1;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t2;
  goto cachevalid;   

vma-memory-read15354:
  if (_trace) printf("vma-memory-read15354:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t4 = (t4 * 8) + t5;  		// reconstruct SCA 
  t1 = *(s32 *)t4;   
  t2 = *(s32 *)(t4 + 4);   		// Read from stack cache 
  goto vma-memory-read15353;   

vma-memory-read15356:
  if (_trace) printf("vma-memory-read15356:\n");
  if ((t6 & 1) == 0)   
    goto vma-memory-read15355;
  arg5 = (u32)t1;   		// Do the indirect thing 
  goto vma-memory-read15352;   

vma-memory-read15355:
  if (_trace) printf("vma-memory-read15355:\n");
  t7 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t6 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg5;   		// stash the VMA for the (likely) trap 
  t6 = (t6 * 4) + t7;   		// Adjust for a longword load 
  t7 = *(s32 *)t6;   		// Get the memory action 

vma-memory-read15360:
  if (_trace) printf("vma-memory-read15360:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0) 
    goto vma-memory-read15359;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto vma-memory-read15363;   

vma-memory-read15359:

vma-memory-read15358:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read15342:
  if (_trace) printf("vma-memory-read15342:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t2 = *(s32 *)t5;   
  t4 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read15341;   

vma-memory-read15344:
  if (_trace) printf("vma-memory-read15344:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read15343;
  t1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read15340;   

vma-memory-read15343:
  if (_trace) printf("vma-memory-read15343:\n");
  t8 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read15348:
  if (_trace) printf("vma-memory-read15348:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0) 
    goto vma-memory-read15347;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto vma-memory-read15351;   

vma-memory-read15347:

vma-memory-read15346:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read15332:
  if (_trace) printf("vma-memory-read15332:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t1 = *(s32 *)t5;   
  t2 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read15331;   

vma-memory-read15334:
  if (_trace) printf("vma-memory-read15334:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read15333;
  arg4 = (u32)t1;   		// Do the indirect thing 
  goto vma-memory-read15330;   

vma-memory-read15333:
  if (_trace) printf("vma-memory-read15333:\n");
  t8 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read15336:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceRef */
  /* End of Halfword operand from stack instruction - DoInstanceRef */
/* start DoInstanceSet */

  /* Halfword operand from stack instruction - DoInstanceSet */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceset:
  if (_trace) printf("doinstanceset:\n");

DoInstanceSetIM:
  if (_trace) printf("DoInstanceSetIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoinstanceset;   

DoInstanceSetSP:
  if (_trace) printf("DoInstanceSetSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoInstanceSetLP:
  if (_trace) printf("DoInstanceSetLP:\n");

DoInstanceSetFP:
  if (_trace) printf("DoInstanceSetFP:\n");

headdoinstanceset:
  if (_trace) printf("headdoinstanceset:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoinstanceset:
  if (_trace) printf("begindoinstanceset:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   
  arg3 = *(s32 *)(iSP + 4);   
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;   
  t1 = t1 & 60;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto ivrefbadinst3;
  t1 = arg2 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto ivrefbadoffset;
  /* Memory Read Internal */

vma-memory-read15364:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);   
  t2 = LDQ_U(t7);   
  t5 = arg4 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;   
  t2 = (u8)(t2 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read15366;

vma-memory-read15365:
  t7 = zero + 64;   
  t8 = t8 >> (t2 & 63);   
  t7 = t7 >> (t2 & 63);   
  t1 = (u32)t1;   
  if (t8 & 1)   
    goto vma-memory-read15368;

vma-memory-read15373:
  t1 = t1 - 1;   
  /* Memory Read Internal */

vma-memory-read15374:
  t7 = t1 + ivory;
  t2 = (t7 * 4);   
  t4 = LDQ_U(t7);   
  t5 = t1 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read15376;

vma-memory-read15375:
  t7 = zero + 240;   
  t8 = t8 >> (t4 & 63);   
  t7 = t7 >> (t4 & 63);   
  if (t8 & 1)   
    goto vma-memory-read15378;

vma-memory-read15385:
  t5 = t4 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto ivrefbadoffset;
  if ((s64)arg1 < 0)   		// J. if offset <0 
    goto ivrefbadoffset;
  t4 = arg1 - t2;   
  if ((s64)t4 >= 0)   		// J. if offset out of bounds 
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  t1 = *(s32 *)iSP;   
  t2 = *(s32 *)(iSP + 4);   
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = (u32)t1;   
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read15386:
  t7 = arg5 + ivory;
  t4 = (t7 * 4);   
  t3 = LDQ_U(t7);   
  t5 = arg5 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->datawrite_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t4 = *(s32 *)t4;   
  t3 = (u8)(t3 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read15388;

vma-memory-read15387:
  t7 = zero + 240;   
  t8 = t8 >> (t3 & 63);   
  t7 = t7 >> (t3 & 63);   
  if (t8 & 1)   
    goto vma-memory-read15390;

vma-memory-read15396:
  /* Merge cdr-code */
  t4 = t2 & 63;
  t3 = t3 & 192;
  t3 = t3 | t4;
  t5 = arg5 + ivory;
  t4 = (t5 * 4);   
  t7 = LDQ_U(t5);   
  t6 = arg5 - t11;   		// Stack cache offset 
  t8 = ((u64)t6 < (u64)t12) ? 1 : 0;   		// In range? 
  t6 = (t3 & 0xff) << ((t5&7)*8);   
  t7 = t7 & ~(0xffL << (t5&7)*8);   

force-alignment15398:
  if (_trace) printf("force-alignment15398:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);   
  *(u32 *)t4 = t1;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write15397;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

ivrefbadinst3:
  if (_trace) printf("ivrefbadinst3:\n");
  arg5 = 0;
  arg2 = 4;
  goto illegaloperand;

vma-memory-write15397:
  if (_trace) printf("vma-memory-write15397:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t6 = arg5 - t11;   		// Stack cache offset 
  t5 = (t6 * 8) + t5;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t5 = t1;
		/* write the stack cache */
  *(u32 *)(t5 + 4) = t3;
  goto NEXTINSTRUCTION;   

vma-memory-read15388:
  if (_trace) printf("vma-memory-read15388:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t4 = *(s32 *)t5;   
  t3 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read15387;   

vma-memory-read15390:
  if (_trace) printf("vma-memory-read15390:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read15389;
  arg5 = (u32)t4;   		// Do the indirect thing 
  goto vma-memory-read15386;   

vma-memory-read15389:
  if (_trace) printf("vma-memory-read15389:\n");
  t8 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t3 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg5;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read15393:

vma-memory-read15392:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 1;
  goto performmemoryaction;

vma-memory-read15376:
  if (_trace) printf("vma-memory-read15376:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t2 = *(s32 *)t5;   
  t4 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read15375;   

vma-memory-read15378:
  if (_trace) printf("vma-memory-read15378:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read15377;
  t1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read15374;   

vma-memory-read15377:
  if (_trace) printf("vma-memory-read15377:\n");
  t8 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read15382:
  if (_trace) printf("vma-memory-read15382:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0) 
    goto vma-memory-read15381;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto vma-memory-read15385;   

vma-memory-read15381:

vma-memory-read15380:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read15366:
  if (_trace) printf("vma-memory-read15366:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t1 = *(s32 *)t5;   
  t2 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read15365;   

vma-memory-read15368:
  if (_trace) printf("vma-memory-read15368:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read15367;
  arg4 = (u32)t1;   		// Do the indirect thing 
  goto vma-memory-read15364;   

vma-memory-read15367:
  if (_trace) printf("vma-memory-read15367:\n");
  t8 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read15370:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceSet */
  /* End of Halfword operand from stack instruction - DoInstanceSet */
/* start DoInstanceLoc */

  /* Halfword operand from stack instruction - DoInstanceLoc */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceloc:
  if (_trace) printf("doinstanceloc:\n");

DoInstanceLocIM:
  if (_trace) printf("DoInstanceLocIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoinstanceloc;   

DoInstanceLocSP:
  if (_trace) printf("DoInstanceLocSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoInstanceLocLP:
  if (_trace) printf("DoInstanceLocLP:\n");

DoInstanceLocFP:
  if (_trace) printf("DoInstanceLocFP:\n");

headdoinstanceloc:
  if (_trace) printf("headdoinstanceloc:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoinstanceloc:
  if (_trace) printf("begindoinstanceloc:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   
  arg3 = *(s32 *)(iSP + 4);   
  arg4 = (u32)arg4;   
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;   
  t1 = t1 & 60;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto ivrefbadinst;
  t1 = arg2 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto ivrefbadoffset;
  /* Memory Read Internal */

vma-memory-read15399:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);   
  t2 = LDQ_U(t7);   
  t5 = arg4 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;   
  t2 = (u8)(t2 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read15401;

vma-memory-read15400:
  t7 = zero + 64;   
  t8 = t8 >> (t2 & 63);   
  t7 = t7 >> (t2 & 63);   
  t1 = (u32)t1;   
  if (t8 & 1)   
    goto vma-memory-read15403;

vma-memory-read15408:
  t1 = t1 - 1;   
  /* Memory Read Internal */

vma-memory-read15409:
  t7 = t1 + ivory;
  t2 = (t7 * 4);   
  t4 = LDQ_U(t7);   
  t5 = t1 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read15411;

vma-memory-read15410:
  t7 = zero + 240;   
  t8 = t8 >> (t4 & 63);   
  t7 = t7 >> (t4 & 63);   
  if (t8 & 1)   
    goto vma-memory-read15413;

vma-memory-read15420:
  t5 = t4 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto ivrefbadoffset;
  if ((s64)arg1 < 0)   		// J. if offset <0 
    goto ivrefbadoffset;
  t4 = arg1 - t2;   
  if ((s64)t4 >= 0)   		// J. if offset out of bounds 
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  t7 = Type_Locative;
  *(u32 *)iSP = arg5;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t7;
  goto NEXTINSTRUCTION;   

ivrefbadinst:
  if (_trace) printf("ivrefbadinst:\n");
  arg5 = 0;
  arg2 = 3;
  goto illegaloperand;

ivrefbadoffset:
  if (_trace) printf("ivrefbadoffset:\n");
  arg5 = 0;
  arg2 = 49;
  goto illegaloperand;

vma-memory-read15411:
  if (_trace) printf("vma-memory-read15411:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t2 = *(s32 *)t5;   
  t4 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read15410;   

vma-memory-read15413:
  if (_trace) printf("vma-memory-read15413:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read15412;
  t1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read15409;   

vma-memory-read15412:
  if (_trace) printf("vma-memory-read15412:\n");
  t8 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read15417:
  if (_trace) printf("vma-memory-read15417:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0) 
    goto vma-memory-read15416;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto vma-memory-read15420;   

vma-memory-read15416:

vma-memory-read15415:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read15401:
  if (_trace) printf("vma-memory-read15401:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t1 = *(s32 *)t5;   
  t2 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read15400;   

vma-memory-read15403:
  if (_trace) printf("vma-memory-read15403:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read15402;
  arg4 = (u32)t1;   		// Do the indirect thing 
  goto vma-memory-read15399;   

vma-memory-read15402:
  if (_trace) printf("vma-memory-read15402:\n");
  t8 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read15405:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceLoc */
  /* End of Halfword operand from stack instruction - DoInstanceLoc */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifuninst.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunmath.as
 ************************************************************************/

  /* Arithmetic. */
/* start DoUnaryMinus */

  /* Halfword operand from stack instruction - DoUnaryMinus */
  /* arg2 has the preloaded 8 bit operand. */

dounaryminus:
  if (_trace) printf("dounaryminus:\n");

DoUnaryMinusSP:
  if (_trace) printf("DoUnaryMinusSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoUnaryMinusLP:
  if (_trace) printf("DoUnaryMinusLP:\n");

DoUnaryMinusFP:
  if (_trace) printf("DoUnaryMinusFP:\n");

begindounaryminus:
  if (_trace) printf("begindounaryminus:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  arg5 = *(s32 *)(arg1 + 4);   		// tag of ARG2 
  arg6 = *(s32 *)arg1;   
  t2 = *(u64 *)&(processor->mostnegativefixnum);   
  LDS(1, f1, *(u32 *)arg1 );   
  t5 = arg5 & 63;		// Strip off any CDR code bits. 
  t4 = (t5 == Type_Fixnum) ? 1 : 0;   

force-alignment15426:
  if (_trace) printf("force-alignment15426:\n");
  if (t4 == 0) 
    goto basic-dispatch15422;
  /* Here if argument TypeFixnum */
  t2 = (s32)arg6 - (s32)t2;   
  arg2 = (s32)zero - (s32)arg6;   
  if (t2 == 0) 
    goto unaryminusexc;
  iPC = t6;
		/* Semi-cheat, we know t5 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
		/* Push the data */
  *(u32 *)(iSP + 8) = arg2;
  iSP = iSP + 8;
  goto cachevalid;   

basic-dispatch15422:
  if (_trace) printf("basic-dispatch15422:\n");
  t4 = (t5 == Type_SingleFloat) ? 1 : 0;   

force-alignment15427:
  if (_trace) printf("force-alignment15427:\n");
  if (t4 == 0) 
    goto basic-dispatch15423;
  /* Here if argument TypeSingleFloat */
  /* NIL */
  SUBS(0, f0, 3, f31, 1, f1); /* subs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = t6;
		/* Semi-cheat, we know t5 has CDRNext/TypeSingleFloat */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
  STS( (u32 *)(iSP + 8), 0, f0 );   		// Push the data 
  iSP = iSP + 8;
  goto cachevalid;   

basic-dispatch15423:
  if (_trace) printf("basic-dispatch15423:\n");
  /* Here for all other cases */

unaryminusexc:
  if (_trace) printf("unaryminusexc:\n");
  arg6 = arg5;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto unarynumericexception;

basic-dispatch15421:
  if (_trace) printf("basic-dispatch15421:\n");

DoUnaryMinusIM:
  if (_trace) printf("DoUnaryMinusIM:\n");
  arg2 = (s32)zero - (s32)arg2;   		// Negate the 8 bit immediate operand 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t7 = Type_Fixnum;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;   

/* end DoUnaryMinus */
  /* End of Halfword operand from stack instruction - DoUnaryMinus */
/* start DoMultiply */

  /* Halfword operand from stack instruction - DoMultiply */
  /* arg2 has the preloaded 8 bit operand. */

domultiply:
  if (_trace) printf("domultiply:\n");

DoMultiplySP:
  if (_trace) printf("DoMultiplySP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomultiply;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoMultiplyLP:
  if (_trace) printf("DoMultiplyLP:\n");

DoMultiplyFP:
  if (_trace) printf("DoMultiplyFP:\n");

begindomultiply:
  if (_trace) printf("begindomultiply:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  /* NIL */
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment15467:
  if (_trace) printf("force-alignment15467:\n");
  if (t10 == 0) 
    goto basic-dispatch15438;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment15444:
  if (_trace) printf("force-alignment15444:\n");
  if (t12 == 0) 
    goto basic-dispatch15440;
  /* Here if argument TypeFixnum */
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t5 = (s64)((s32)t2 * (s64)(s32)t4); /* mull/v */   		// compute 64-bit result 
  if (t5 >> 32)
    exception();  // WARNING !!! THIS IS ADJUSTED BY THE DIFF FILE
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t9;
  iPC = t6;
  *(u32 *)iSP = t5;
  iCP = t7;
  goto cachevalid;   

basic-dispatch15440:
  if (_trace) printf("basic-dispatch15440:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment15445:
  if (_trace) printf("force-alignment15445:\n");
  if (t12 == 0) 
    goto basic-dispatch15441;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple-binary-arithmetic-operation15428;   

basic-dispatch15441:
  if (_trace) printf("basic-dispatch15441:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment15446:
  if (_trace) printf("force-alignment15446:\n");
  if (t12 == 0) 
    goto binary-type-dispatch15435;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple-binary-arithmetic-operation15431;   

basic-dispatch15439:
  if (_trace) printf("basic-dispatch15439:\n");

basic-dispatch15438:
  if (_trace) printf("basic-dispatch15438:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment15468:
  if (_trace) printf("force-alignment15468:\n");
  if (t10 == 0) 
    goto basic-dispatch15447;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment15453:
  if (_trace) printf("force-alignment15453:\n");
  if (t12 == 0) 
    goto basic-dispatch15449;
  /* Here if argument TypeSingleFloat */

simple-binary-arithmetic-operation15428:
  if (_trace) printf("simple-binary-arithmetic-operation15428:\n");
  MULS(0, f0, 1, f1, 2, f2); /* muls */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto cachevalid;   

basic-dispatch15449:
  if (_trace) printf("basic-dispatch15449:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment15454:
  if (_trace) printf("force-alignment15454:\n");
  if (t12 == 0) 
    goto basic-dispatch15450;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple-binary-arithmetic-operation15428;   

basic-dispatch15450:
  if (_trace) printf("basic-dispatch15450:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment15455:
  if (_trace) printf("force-alignment15455:\n");
  if (t12 == 0) 
    goto binary-type-dispatch15435;
  /* Here if argument TypeDoubleFloat */

simple-binary-arithmetic-operation15431:
  if (_trace) printf("simple-binary-arithmetic-operation15431:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto simple-binary-arithmetic-operation15432;   

basic-dispatch15448:
  if (_trace) printf("basic-dispatch15448:\n");

basic-dispatch15447:
  if (_trace) printf("basic-dispatch15447:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

force-alignment15469:
  if (_trace) printf("force-alignment15469:\n");
  if (t10 == 0) 
    goto basic-dispatch15456;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment15462:
  if (_trace) printf("force-alignment15462:\n");
  if (t12 == 0) 
    goto basic-dispatch15458;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0505;
  goto fetchdoublefloat;
return0505:
  LDT(1, f1, processor->fp0);   

simple-binary-arithmetic-operation15432:
  if (_trace) printf("simple-binary-arithmetic-operation15432:\n");
  arg2 = (u32)t4;   
  r0 = (u64)&&return0506;
  goto fetchdoublefloat;
return0506:
  LDT(2, f2, processor->fp0);   

simple-binary-arithmetic-operation15429:
  if (_trace) printf("simple-binary-arithmetic-operation15429:\n");
  MULT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0507;
  goto consdoublefloat;
return0507:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto cachevalid;   

basic-dispatch15458:
  if (_trace) printf("basic-dispatch15458:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment15463:
  if (_trace) printf("force-alignment15463:\n");
  if (t12 == 0) 
    goto basic-dispatch15459;
  /* Here if argument TypeSingleFloat */

simple-binary-arithmetic-operation15430:
  if (_trace) printf("simple-binary-arithmetic-operation15430:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0508;
  goto fetchdoublefloat;
return0508:
  LDT(1, f1, processor->fp0);   
  goto simple-binary-arithmetic-operation15429;   

basic-dispatch15459:
  if (_trace) printf("basic-dispatch15459:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment15464:
  if (_trace) printf("force-alignment15464:\n");
  if (t12 == 0) 
    goto binary-type-dispatch15435;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple-binary-arithmetic-operation15430;   

basic-dispatch15457:
  if (_trace) printf("basic-dispatch15457:\n");

basic-dispatch15456:
  if (_trace) printf("basic-dispatch15456:\n");
  /* Here for all other cases */

binary-type-dispatch15434:
  if (_trace) printf("binary-type-dispatch15434:\n");

domulovfl:
  if (_trace) printf("domulovfl:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch15436;   

binary-type-dispatch15435:
  if (_trace) printf("binary-type-dispatch15435:\n");
  t1 = t3;
  goto domulovfl;   

binary-type-dispatch15436:
  if (_trace) printf("binary-type-dispatch15436:\n");

basic-dispatch15437:
  if (_trace) printf("basic-dispatch15437:\n");

DoMultiplyIM:
  if (_trace) printf("DoMultiplyIM:\n");
  arg2 = arg2 << 56;   
  t1 = (u32)(arg6 >> ((4&7)*8));   
  t2 = (s32)arg6;		// get ARG1 tag/data 
  arg2 = (s64)arg2 >> 56;   
  t11 = t1 & 63;		// Strip off any CDR code bits. 
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment15474:
  if (_trace) printf("force-alignment15474:\n");
  if (t12 == 0) 
    goto basic-dispatch15471;
  /* Here if argument TypeFixnum */
  t3 = t2 * arg2;   		// compute 64-bit result 
  t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t10 = (s32)t3;		// compute 32-bit sign-extended result 
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t10 = (t3 == t10) ? 1 : 0;   		// is it the same as the 64-bit result? 
  if (t10 == 0) 		// if not, we overflowed 
    goto domulovfl;
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t11;
  iPC = t4;
  *(u32 *)iSP = t3;
  iCP = t5;
  goto cachevalid;   

basic-dispatch15471:
  if (_trace) printf("basic-dispatch15471:\n");
  /* Here for all other cases */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;   
  arg2 = zero;
  goto begindomultiply;   

basic-dispatch15470:
  if (_trace) printf("basic-dispatch15470:\n");

/* end DoMultiply */
  /* End of Halfword operand from stack instruction - DoMultiply */
/* start BinaryArithmeticDivisionPrelude */


binaryarithmeticdivisionprelude:
  if (_trace) printf("binaryarithmeticdivisionprelude:\n");
  sp = sp + -8;   
  LDS(1, f1, *(u32 *)iSP );   
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment15512:
  if (_trace) printf("force-alignment15512:\n");
  if (t10 == 0) 
    goto basic-dispatch15485;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment15491:
  if (_trace) printf("force-alignment15491:\n");
  if (t12 == 0) 
    goto basic-dispatch15487;
  /* Here if argument TypeFixnum */
  CVTLQ(1, f1, f31, 1, f1);
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(1, f1, f31, 1, f1);
  CVTQT(2, f2, f31, 2, f2);

basic-dispatch15486:
  if (_trace) printf("basic-dispatch15486:\n");

basic-dispatch15484:
  if (_trace) printf("basic-dispatch15484:\n");

binary-arithmetic-division-prelude15475:
  if (_trace) printf("binary-arithmetic-division-prelude15475:\n");
  sp = sp + 8;   
  goto *r0; /* ret */

basic-dispatch15485:
  if (_trace) printf("basic-dispatch15485:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment15513:
  if (_trace) printf("force-alignment15513:\n");
  if (t10 == 0) 
    goto basic-dispatch15492;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment15498:
  if (_trace) printf("force-alignment15498:\n");
  if (t12 != 0)   
    goto binary-arithmetic-division-prelude15475;

basic-dispatch15494:
  if (_trace) printf("basic-dispatch15494:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment15499:
  if (_trace) printf("force-alignment15499:\n");
  if (t12 == 0) 
    goto basic-dispatch15495;
  /* Here if argument TypeFixnum */
  t3 = t1;		// contagion 
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto binary-arithmetic-division-prelude15475;   

basic-dispatch15495:
  if (_trace) printf("basic-dispatch15495:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment15500:
  if (_trace) printf("force-alignment15500:\n");
  if (t12 == 0) 
    goto binary-type-dispatch15482;
  /* Here if argument TypeDoubleFloat */

binary-arithmetic-division-prelude15477:
  if (_trace) printf("binary-arithmetic-division-prelude15477:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto binary-arithmetic-division-prelude15478;   

basic-dispatch15493:
  if (_trace) printf("basic-dispatch15493:\n");

basic-dispatch15492:
  if (_trace) printf("basic-dispatch15492:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

force-alignment15514:
  if (_trace) printf("force-alignment15514:\n");
  if (t10 == 0) 
    goto basic-dispatch15501;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment15507:
  if (_trace) printf("force-alignment15507:\n");
  if (t12 == 0) 
    goto basic-dispatch15503;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0509;
  goto fetchdoublefloat;
return0509:
  r0 = *(u64 *)sp;   
  LDT(1, f1, processor->fp0);   

binary-arithmetic-division-prelude15478:
  if (_trace) printf("binary-arithmetic-division-prelude15478:\n");
  arg2 = (u32)t4;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0510;
  goto fetchdoublefloat;
return0510:
  r0 = *(u64 *)sp;   
  LDT(2, f2, processor->fp0);   
  goto binary-arithmetic-division-prelude15475;   

basic-dispatch15503:
  if (_trace) printf("basic-dispatch15503:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment15508:
  if (_trace) printf("force-alignment15508:\n");
  if (t12 == 0) 
    goto basic-dispatch15504;
  /* Here if argument TypeSingleFloat */

binary-arithmetic-division-prelude15476:
  if (_trace) printf("binary-arithmetic-division-prelude15476:\n");
  t3 = t1;		// contagion 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0511;
  goto fetchdoublefloat;
return0511:
  r0 = *(u64 *)sp;   
  LDT(1, f1, processor->fp0);   
  goto binary-arithmetic-division-prelude15475;   

basic-dispatch15504:
  if (_trace) printf("basic-dispatch15504:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment15509:
  if (_trace) printf("force-alignment15509:\n");
  if (t12 == 0) 
    goto binary-type-dispatch15482;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto binary-arithmetic-division-prelude15476;   

basic-dispatch15502:
  if (_trace) printf("basic-dispatch15502:\n");

basic-dispatch15501:
  if (_trace) printf("basic-dispatch15501:\n");
  /* Here for all other cases */

binary-type-dispatch15481:
  if (_trace) printf("binary-type-dispatch15481:\n");

binary-arithmetic-division-prelude15479:
  if (_trace) printf("binary-arithmetic-division-prelude15479:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch15483;   

binary-type-dispatch15482:
  if (_trace) printf("binary-type-dispatch15482:\n");
  t1 = t3;
  goto binary-arithmetic-division-prelude15479;   

binary-type-dispatch15483:
  if (_trace) printf("binary-type-dispatch15483:\n");

basic-dispatch15487:
  if (_trace) printf("basic-dispatch15487:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment15515:
  if (_trace) printf("force-alignment15515:\n");
  if (t12 == 0) 
    goto basic-dispatch15488;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto binary-arithmetic-division-prelude15475;   

basic-dispatch15488:
  if (_trace) printf("basic-dispatch15488:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment15516:
  if (_trace) printf("force-alignment15516:\n");
  if (t12 == 0) 
    goto binary-type-dispatch15482;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto binary-arithmetic-division-prelude15477;   

/* end BinaryArithmeticDivisionPrelude */
/* start DoQuotient */

  /* Halfword operand from stack instruction - DoQuotient */
  /* arg2 has the preloaded 8 bit operand. */

doquotient:
  if (_trace) printf("doquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoQuotientIM:
  if (_trace) printf("DoQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoquotient;   

DoQuotientSP:
  if (_trace) printf("DoQuotientSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoquotient;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoQuotientLP:
  if (_trace) printf("DoQuotientLP:\n");

DoQuotientFP:
  if (_trace) printf("DoQuotientFP:\n");

begindoquotient:
  if (_trace) printf("begindoquotient:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0512;
  goto binaryarithmeticdivisionprelude;
return0512:
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment15522:
  if (_trace) printf("force-alignment15522:\n");
  if (t9 == 0) 
    goto basic-dispatch15518;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   

basic-dispatch15517:
  if (_trace) printf("basic-dispatch15517:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch15518:
  if (_trace) printf("basic-dispatch15518:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment15523:
  if (_trace) printf("force-alignment15523:\n");
  if (t9 == 0) 
    goto basic-dispatch15519;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto basic-dispatch15517;   

basic-dispatch15519:
  if (_trace) printf("basic-dispatch15519:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment15524:
  if (_trace) printf("force-alignment15524:\n");
  if (t9 == 0) 
    goto basic-dispatch15517;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0513;
  goto consdoublefloat;
return0513:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto basic-dispatch15517;   

/* end DoQuotient */
  /* End of Halfword operand from stack instruction - DoQuotient */
/* start DoRationalQuotient */

  /* Halfword operand from stack instruction - DoRationalQuotient */
  /* arg2 has the preloaded 8 bit operand. */

dorationalquotient:
  if (_trace) printf("dorationalquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoRationalQuotientIM:
  if (_trace) printf("DoRationalQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindorationalquotient;   

DoRationalQuotientSP:
  if (_trace) printf("DoRationalQuotientSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindorationalquotient;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoRationalQuotientLP:
  if (_trace) printf("DoRationalQuotientLP:\n");

DoRationalQuotientFP:
  if (_trace) printf("DoRationalQuotientFP:\n");

begindorationalquotient:
  if (_trace) printf("begindorationalquotient:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0514;
  goto binaryarithmeticdivisionprelude;
return0514:
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment15530:
  if (_trace) printf("force-alignment15530:\n");
  if (t9 == 0) 
    goto basic-dispatch15526;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQSVI(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   

basic-dispatch15525:
  if (_trace) printf("basic-dispatch15525:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch15526:
  if (_trace) printf("basic-dispatch15526:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment15531:
  if (_trace) printf("force-alignment15531:\n");
  if (t9 == 0) 
    goto basic-dispatch15527;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto basic-dispatch15525;   

basic-dispatch15527:
  if (_trace) printf("basic-dispatch15527:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment15532:
  if (_trace) printf("force-alignment15532:\n");
  if (t9 == 0) 
    goto basic-dispatch15525;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0515;
  goto consdoublefloat;
return0515:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto basic-dispatch15525;   

/* end DoRationalQuotient */
  /* End of Halfword operand from stack instruction - DoRationalQuotient */
/* start DoFloor */

  /* Halfword operand from stack instruction - DoFloor */
  /* arg2 has the preloaded 8 bit operand. */

dofloor:
  if (_trace) printf("dofloor:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoFloorIM:
  if (_trace) printf("DoFloorIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindofloor;   

DoFloorSP:
  if (_trace) printf("DoFloorSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindofloor;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoFloorLP:
  if (_trace) printf("DoFloorLP:\n");

DoFloorFP:
  if (_trace) printf("DoFloorFP:\n");

begindofloor:
  if (_trace) printf("begindofloor:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0516;
  goto binaryarithmeticdivisionprelude;
return0516:
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment15538:
  if (_trace) printf("force-alignment15538:\n");
  if (t9 == 0) 
    goto basic-dispatch15534;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic-dispatch15533:
  if (_trace) printf("basic-dispatch15533:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch15534:
  if (_trace) printf("basic-dispatch15534:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment15539:
  if (_trace) printf("force-alignment15539:\n");
  if (t9 == 0) 
    goto basic-dispatch15535;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic-dispatch15533;   

basic-dispatch15535:
  if (_trace) printf("basic-dispatch15535:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment15540:
  if (_trace) printf("force-alignment15540:\n");
  if (t9 == 0) 
    goto basic-dispatch15533;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0517;
  goto consdoublefloat;
return0517:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic-dispatch15533;   

/* end DoFloor */
  /* End of Halfword operand from stack instruction - DoFloor */
/* start DoCeiling */

  /* Halfword operand from stack instruction - DoCeiling */
  /* arg2 has the preloaded 8 bit operand. */

doceiling:
  if (_trace) printf("doceiling:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoCeilingIM:
  if (_trace) printf("DoCeilingIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoceiling;   

DoCeilingSP:
  if (_trace) printf("DoCeilingSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoceiling;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoCeilingLP:
  if (_trace) printf("DoCeilingLP:\n");

DoCeilingFP:
  if (_trace) printf("DoCeilingFP:\n");

begindoceiling:
  if (_trace) printf("begindoceiling:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0518;
  goto binaryarithmeticdivisionprelude;
return0518:
  CPYSN(2, f2, 2, f2, 2, f2);   
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  CPYSN(0, f0, 3, f3, 3, f3);   
  CVTTQ(0, f0, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment15546:
  if (_trace) printf("force-alignment15546:\n");
  if (t9 == 0) 
    goto basic-dispatch15542;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic-dispatch15541:
  if (_trace) printf("basic-dispatch15541:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch15542:
  if (_trace) printf("basic-dispatch15542:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment15547:
  if (_trace) printf("force-alignment15547:\n");
  if (t9 == 0) 
    goto basic-dispatch15543;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic-dispatch15541;   

basic-dispatch15543:
  if (_trace) printf("basic-dispatch15543:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment15548:
  if (_trace) printf("force-alignment15548:\n");
  if (t9 == 0) 
    goto basic-dispatch15541;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0519;
  goto consdoublefloat;
return0519:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic-dispatch15541;   

/* end DoCeiling */
  /* End of Halfword operand from stack instruction - DoCeiling */
/* start DoTruncate */

  /* Halfword operand from stack instruction - DoTruncate */
  /* arg2 has the preloaded 8 bit operand. */

dotruncate:
  if (_trace) printf("dotruncate:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoTruncateIM:
  if (_trace) printf("DoTruncateIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindotruncate;   

DoTruncateSP:
  if (_trace) printf("DoTruncateSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindotruncate;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoTruncateLP:
  if (_trace) printf("DoTruncateLP:\n");

DoTruncateFP:
  if (_trace) printf("DoTruncateFP:\n");

begindotruncate:
  if (_trace) printf("begindotruncate:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0520;
  goto binaryarithmeticdivisionprelude;
return0520:
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment15554:
  if (_trace) printf("force-alignment15554:\n");
  if (t9 == 0) 
    goto basic-dispatch15550;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic-dispatch15549:
  if (_trace) printf("basic-dispatch15549:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch15550:
  if (_trace) printf("basic-dispatch15550:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment15555:
  if (_trace) printf("force-alignment15555:\n");
  if (t9 == 0) 
    goto basic-dispatch15551;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic-dispatch15549;   

basic-dispatch15551:
  if (_trace) printf("basic-dispatch15551:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment15556:
  if (_trace) printf("force-alignment15556:\n");
  if (t9 == 0) 
    goto basic-dispatch15549;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0521;
  goto consdoublefloat;
return0521:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic-dispatch15549;   

/* end DoTruncate */
  /* End of Halfword operand from stack instruction - DoTruncate */
/* start DoRound */

  /* Halfword operand from stack instruction - DoRound */
  /* arg2 has the preloaded 8 bit operand. */

doround:
  if (_trace) printf("doround:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoRoundIM:
  if (_trace) printf("DoRoundIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoround;   

DoRoundSP:
  if (_trace) printf("DoRoundSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoround;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoRoundLP:
  if (_trace) printf("DoRoundLP:\n");

DoRoundFP:
  if (_trace) printf("DoRoundFP:\n");

begindoround:
  if (_trace) printf("begindoround:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0522;
  goto binaryarithmeticdivisionprelude;
return0522:
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQV(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment15562:
  if (_trace) printf("force-alignment15562:\n");
  if (t9 == 0) 
    goto basic-dispatch15558;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic-dispatch15557:
  if (_trace) printf("basic-dispatch15557:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch15558:
  if (_trace) printf("basic-dispatch15558:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment15563:
  if (_trace) printf("force-alignment15563:\n");
  if (t9 == 0) 
    goto basic-dispatch15559;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic-dispatch15557;   

basic-dispatch15559:
  if (_trace) printf("basic-dispatch15559:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment15564:
  if (_trace) printf("force-alignment15564:\n");
  if (t9 == 0) 
    goto basic-dispatch15557;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0523;
  goto consdoublefloat;
return0523:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic-dispatch15557;   

/* end DoRound */
  /* End of Halfword operand from stack instruction - DoRound */
  /* Other arithmetic. */
/* start DoMax */

  /* Halfword operand from stack instruction - DoMax */
  /* arg2 has the preloaded 8 bit operand. */

domax:
  if (_trace) printf("domax:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoMaxIM:
  if (_trace) printf("DoMaxIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindomax;   

DoMaxSP:
  if (_trace) printf("DoMaxSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomax;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoMaxLP:
  if (_trace) printf("DoMaxLP:\n");

DoMaxFP:
  if (_trace) printf("DoMaxFP:\n");

begindomax:
  if (_trace) printf("begindomax:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment15588:
  if (_trace) printf("force-alignment15588:\n");
  if (t10 == 0) 
    goto basic-dispatch15572;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment15577:
  if (_trace) printf("force-alignment15577:\n");
  if (t12 == 0) 
    goto basic-dispatch15574;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if ((s64)t5 > 0)   
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
		/* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;   

basic-dispatch15574:
  if (_trace) printf("basic-dispatch15574:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment15578:
  if (_trace) printf("force-alignment15578:\n");
  if (t12 == 0) 
    goto binary-type-dispatch15569;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto simple-binary-minmax15566;   

basic-dispatch15573:
  if (_trace) printf("basic-dispatch15573:\n");

basic-dispatch15572:
  if (_trace) printf("basic-dispatch15572:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment15589:
  if (_trace) printf("force-alignment15589:\n");
  if (t10 == 0) 
    goto basic-dispatch15579;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment15584:
  if (_trace) printf("force-alignment15584:\n");
  if (t12 == 0) 
    goto basic-dispatch15581;
  /* Here if argument TypeSingleFloat */

simple-binary-minmax15566:
  if (_trace) printf("simple-binary-minmax15566:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if (FLTU64(0, f0) > 0.0)   
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );   
  goto cachevalid;   

basic-dispatch15581:
  if (_trace) printf("basic-dispatch15581:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment15585:
  if (_trace) printf("force-alignment15585:\n");
  if (t12 == 0) 
    goto binary-type-dispatch15569;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto simple-binary-minmax15566;   

basic-dispatch15580:
  if (_trace) printf("basic-dispatch15580:\n");

basic-dispatch15579:
  if (_trace) printf("basic-dispatch15579:\n");
  /* Here for all other cases */

binary-type-dispatch15568:
  if (_trace) printf("binary-type-dispatch15568:\n");

simple-binary-minmax15565:
  if (_trace) printf("simple-binary-minmax15565:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch15570;   

binary-type-dispatch15569:
  if (_trace) printf("binary-type-dispatch15569:\n");
  t1 = t3;
  goto simple-binary-minmax15565;   

binary-type-dispatch15570:
  if (_trace) printf("binary-type-dispatch15570:\n");

basic-dispatch15571:
  if (_trace) printf("basic-dispatch15571:\n");

/* end DoMax */
  /* End of Halfword operand from stack instruction - DoMax */
/* start DoMin */

  /* Halfword operand from stack instruction - DoMin */
  /* arg2 has the preloaded 8 bit operand. */

domin:
  if (_trace) printf("domin:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoMinIM:
  if (_trace) printf("DoMinIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindomin;   

DoMinSP:
  if (_trace) printf("DoMinSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomin;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoMinLP:
  if (_trace) printf("DoMinLP:\n");

DoMinFP:
  if (_trace) printf("DoMinFP:\n");

begindomin:
  if (_trace) printf("begindomin:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment15613:
  if (_trace) printf("force-alignment15613:\n");
  if (t10 == 0) 
    goto basic-dispatch15597;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment15602:
  if (_trace) printf("force-alignment15602:\n");
  if (t12 == 0) 
    goto basic-dispatch15599;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if ((s64)t5 < 0)   
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
		/* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;   

basic-dispatch15599:
  if (_trace) printf("basic-dispatch15599:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment15603:
  if (_trace) printf("force-alignment15603:\n");
  if (t12 == 0) 
    goto binary-type-dispatch15594;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto simple-binary-minmax15591;   

basic-dispatch15598:
  if (_trace) printf("basic-dispatch15598:\n");

basic-dispatch15597:
  if (_trace) printf("basic-dispatch15597:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment15614:
  if (_trace) printf("force-alignment15614:\n");
  if (t10 == 0) 
    goto basic-dispatch15604;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment15609:
  if (_trace) printf("force-alignment15609:\n");
  if (t12 == 0) 
    goto basic-dispatch15606;
  /* Here if argument TypeSingleFloat */

simple-binary-minmax15591:
  if (_trace) printf("simple-binary-minmax15591:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if (FLTU64(0, f0) < 0.0)   
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );   
  goto cachevalid;   

basic-dispatch15606:
  if (_trace) printf("basic-dispatch15606:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment15610:
  if (_trace) printf("force-alignment15610:\n");
  if (t12 == 0) 
    goto binary-type-dispatch15594;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto simple-binary-minmax15591;   

basic-dispatch15605:
  if (_trace) printf("basic-dispatch15605:\n");

basic-dispatch15604:
  if (_trace) printf("basic-dispatch15604:\n");
  /* Here for all other cases */

binary-type-dispatch15593:
  if (_trace) printf("binary-type-dispatch15593:\n");

simple-binary-minmax15590:
  if (_trace) printf("simple-binary-minmax15590:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch15595;   

binary-type-dispatch15594:
  if (_trace) printf("binary-type-dispatch15594:\n");
  t1 = t3;
  goto simple-binary-minmax15590;   

binary-type-dispatch15595:
  if (_trace) printf("binary-type-dispatch15595:\n");

basic-dispatch15596:
  if (_trace) printf("basic-dispatch15596:\n");

/* end DoMin */
  /* End of Halfword operand from stack instruction - DoMin */
/* start DoMultiplyDouble */

  /* Halfword operand from stack instruction - DoMultiplyDouble */

domultiplydouble:
  if (_trace) printf("domultiplydouble:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoMultiplyDoubleIM:
  if (_trace) printf("DoMultiplyDoubleIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment15615:
  if (_trace) printf("force-alignment15615:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindomultiplydouble;   

DoMultiplyDoubleSP:
  if (_trace) printf("DoMultiplyDoubleSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoMultiplyDoubleLP:
  if (_trace) printf("DoMultiplyDoubleLP:\n");

DoMultiplyDoubleFP:
  if (_trace) printf("DoMultiplyDoubleFP:\n");

headdomultiplydouble:
  if (_trace) printf("headdomultiplydouble:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindomultiplydouble:
  if (_trace) printf("begindomultiplydouble:\n");
  /* arg1 has the operand, sign extended if immediate. */
  t2 = arg1 >> 32;   		// ARG2 tag 
  t3 = *(s32 *)iSP;   		// ARG1 data, sign extended 
  t4 = (s32)arg1 + (s32)0;		// ARG2 data, sign extended 
  t1 = *(s32 *)(iSP + 4);   		// ARG1 tag 
  /* TagType. */
  t1 = t1 & 63;		// Strip CDR code if any. 
  t1 = t1 - Type_Fixnum;   
  /* TagType. */
  t2 = t2 & 63;		// Strip CDR code if any. 
  t5 = t3 * t4;   		// Perform the 63 bit multiply. 
  t2 = t2 - Type_Fixnum;   
  if (t1 != 0)   
    goto muldexc;
  if (t2 != 0)   
    goto muldexc;
  t6 = (u32)t5;   		// Get the low 32 bit half. 
  t5 = (u32)(t5 >> ((4&7)*8));   		// Get the high 32 bit half. 
		/* Put the result back on the stack */
  *(u32 *)iSP = t6;
  t1 = Type_Fixnum;
		/* Push high order half */
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

muldexc:
  if (_trace) printf("muldexc:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end DoMultiplyDouble */
  /* End of Halfword operand from stack instruction - DoMultiplyDouble */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunmath.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunarra.as
 ************************************************************************/

  /* Array operations. */
/* start Aref1Regset */


aref1regset:
  if (_trace) printf("aref1regset:\n");
  t12 = arg4;
  /* Memory Read Internal */

vma-memory-read15616:
  t1 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;   
  arg6 = (t3 * 4);   
  arg5 = LDQ_U(t3);   
  t1 = arg4 - t1;   		// Stack cache offset 
  t4 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read15618;

vma-memory-read15617:
  t3 = zero + 64;   
  t4 = t4 >> (arg5 & 63);   
  t3 = t3 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t4 & 1)   
    goto vma-memory-read15620;

vma-memory-read15625:
  /* TagType. */
  t1 = arg5 & 63;
  t2 = arg6 >> (Array_LongPrefixBitPos & 63);   
  t1 = t1 - Type_HeaderI;   
  if (t1 != 0)   
    goto aref1illegal;
  if (t2 & 1)   
    goto aref1exception;
		/* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t12;
  t2 = zero + Array_LengthMask;   
  t1 = arg6 & t2;
  t2 = ((u64)arg2 < (u64)t1) ? 1 : 0;   
  if (t2 == 0) 
    goto aref1bounds;
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;   		// store the array length [implicit fixnum] 
  t10 = arg6 >> (Array_RegisterBytePackingPos & 63);   
  t8 = *(u64 *)&(processor->areventcount);   
  t10 = t10 << (Array_RegisterBytePackingPos & 63);   
  t9 = arg4 + 1;
  t10 = t10 + t8;		// Construct the array register word 
		/* store the array register word [implicit fixnum] */
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t10;
  *(u64 *)&((ARRAYCACHEP)t7)->locat = t9;   		// store the storage [implicit locative] 
  arg5 = arg6 >> (Array_BytePackingPos & 63);   		// get BP into arg5 
  arg6 = arg6 >> (Array_ElementTypePos & 63);   		// get element type into arg6 
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = zero;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aref1restart;   

vma-memory-read15618:
  if (_trace) printf("vma-memory-read15618:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = (t1 * 8) + t2;  		// reconstruct SCA 
  arg6 = *(s32 *)t1;   
  arg5 = *(s32 *)(t1 + 4);   		// Read from stack cache 
  goto vma-memory-read15617;   

vma-memory-read15620:
  if (_trace) printf("vma-memory-read15620:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read15619;
  arg4 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read15616;   

vma-memory-read15619:
  if (_trace) printf("vma-memory-read15619:\n");
  t4 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
  t4 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read15622:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end Aref1Regset */
/* start Aref1RecomputeArrayRegister */


aref1recomputearrayregister:
  if (_trace) printf("aref1recomputearrayregister:\n");
  t5 = *(s32 *)(arg1 + -8);   
  t4 = *(s32 *)(arg1 + -4);   
  t5 = (u32)t5;   
  t6 = t4 - Type_Array;   
  t6 = t6 & 62;		// Strip CDR code, low bits 
  if (t6 != 0)   
    goto recompute-array-register15627;
  /* Memory Read Internal */

vma-memory-read15629:
  t8 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t3 = t5 + ivory;
  t2 = *(s32 *)&processor->scovlimit;   
  t6 = (t3 * 4);   
  t7 = LDQ_U(t3);   
  t8 = t5 - t8;   		// Stack cache offset 
  t1 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t8 < (u64)t2) ? 1 : 0;   		// In range? 
  t6 = *(s32 *)t6;   
  t7 = (u8)(t7 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read15631;

vma-memory-read15630:
  t3 = zero + 64;   
  t1 = t1 >> (t7 & 63);   
  t3 = t3 >> (t7 & 63);   
  t6 = (u32)t6;   
  if (t1 & 1)   
    goto vma-memory-read15633;

vma-memory-read15638:
  /* TagType. */
  t8 = t7 & 63;
  t2 = t6 >> (Array_LongPrefixBitPos & 63);   
  t8 = t8 - Type_HeaderI;   
  if (t8 != 0)   
    goto recompute-array-register15626;
  if (t2 & 1)   
    goto recompute-array-register15628;
  t1 = t6 >> (Array_BytePackingPos & 63);   
  t4 = *(u64 *)&(processor->areventcount);   
  t1 = t1 << (Array_RegisterBytePackingPos & 63);   
  t2 = t5 + 1;
  t1 = t1 + t4;		// Construct the array register word 
  *(u32 *)(arg1 + 8) = t2;
  t3 = zero + Array_LengthMask;   
  t3 = t6 & t3;
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaref1retry;   

recompute-array-register15628:
  if (_trace) printf("recompute-array-register15628:\n");
  *(u64 *)&processor->asrf5 = arg1;   		// Just a place to save these values 
  *(u64 *)&processor->asrf4 = t10;   		// Just a place to save these values 
  *(u64 *)&processor->asrf3 = t11;   		// Just a place to save these values 
  *(u64 *)&processor->asrf6 = arg1;   		// Just a place to save these values 
  *(u64 *)&processor->asrf7 = arg2;   		// Just a place to save these values 
  *(u64 *)&processor->asrf8 = arg3;   		// Just a place to save these values 
  *(u64 *)&processor->asrf9 = arg4;   		// Just a place to save these values 
  t9 = *(s32 *)(arg1 + -8);   
  arg2 = *(s32 *)(arg1 + -4);   
  t9 = (u32)t9;   
  arg1 = t5;
  t4 = t7;
  t3 = t6;
  t2 = 1;
  iSP = iSP + 24;
  r0 = (u64)&&return0524;
  goto setup1dlongarray;
return0524:
  t4 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t4 != 0)   
    goto recompute-array-register15627;
  arg1 = *(u64 *)&(processor->asrf5);   		// Just a place to save these values 
  t10 = *(u64 *)&(processor->asrf4);   		// Just a place to save these values 
  t11 = *(u64 *)&(processor->asrf3);   		// Just a place to save these values 
  arg1 = *(u64 *)&(processor->asrf6);   		// Just a place to save these values 
  arg2 = *(u64 *)&(processor->asrf7);   		// Just a place to save these values 
  arg3 = *(u64 *)&(processor->asrf8);   		// Just a place to save these values 
  arg4 = *(u64 *)&(processor->asrf9);   		// Just a place to save these values 
  t3 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  t2 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  t4 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  iSP = iSP - 24;   
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 8) = t2;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaref1retry;   

recompute-array-register15627:
  if (_trace) printf("recompute-array-register15627:\n");
  arg6 = t4;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 12;
  goto arrayexception;

recompute-array-register15626:
  if (_trace) printf("recompute-array-register15626:\n");
  arg5 = 0;
  arg2 = 12;
  goto illegaloperand;

vma-memory-read15631:
  if (_trace) printf("vma-memory-read15631:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + t2;  		// reconstruct SCA 
  t6 = *(s32 *)t8;   
  t7 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read15630;   

vma-memory-read15633:
  if (_trace) printf("vma-memory-read15633:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read15632;
  t5 = (u32)t6;   		// Do the indirect thing 
  goto vma-memory-read15629;   

vma-memory-read15632:
  if (_trace) printf("vma-memory-read15632:\n");
  t1 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = t7 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t5;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t1;   		// Adjust for a longword load 
  t1 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read15635:
  /* Perform memory action */
  arg1 = t1;
  arg2 = 6;
  goto performmemoryaction;

/* end Aref1RecomputeArrayRegister */
/* start Aref1Exception */


aref1exception:
  if (_trace) printf("aref1exception:\n");
  *(u64 *)&processor->asrf4 = arg2;   		// Just a place to save these values 
  *(u64 *)&processor->asrf5 = t7;   		// Just a place to save these values 
  t9 = t12;
  arg2 = arg3;
  arg1 = arg4;
  t4 = arg5;
  t3 = arg6;
  t2 = zero;
  iSP = iSP + 24;
  r0 = (u64)&&return0525;
  goto setup1dlongarray;
return0525:
  arg2 = *(s32 *)&processor->asrf4;   		// Just a place to save these values 
  t7 = *(u64 *)&(processor->asrf5);   		// Just a place to save these values 
  t1 = *(s32 *)iSP;   		// Length 
  t5 = *(s32 *)(iSP + 4);   		// Length 
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = (u32)t1;   
  t5 = *(u64 *)iSP;   		// base 
  iSP = iSP - 8;   		// Pop Stack. 
  t3 = *(u64 *)iSP;   		// control 
  iSP = iSP - 8;   		// Pop Stack. 
  t9 = *(s32 *)iSP;   		// The original array 
  arg3 = *(s32 *)(iSP + 4);   		// The original array 
  iSP = iSP - 8;   		// Pop Stack. 
  t9 = (u32)t9;   
  iSP = iSP - 24;   
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;   
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t3;
  *(u32 *)&((ARRAYCACHEP)t7)->locat = t5;
		/* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t9;
  t9 = (u32)t5;   
  t2 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t2 != 0)   
    goto reallyaref1exc;
  t5 = ((u64)arg2 < (u64)t1) ? 1 : 0;   
  if (t5 == 0) 
    goto aref1bounds;
  arg5 = t3 >> (Array_BytePackingPos & 63);   		// get BP into arg5 
  arg6 = t3 >> (Array_ElementTypePos & 63);   		// get element type into arg6 
  arg4 = t3 >> (Array_RegisterByteOffsetPos & 63);   
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = arg4 & Array_RegisterByteOffsetMask;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aref1restart;   

reallyaref1exc:
  if (_trace) printf("reallyaref1exc:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;   
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 8;
  goto arrayexception;

aref1illegal:
  if (_trace) printf("aref1illegal:\n");
  arg5 = 0;
  arg2 = 8;
  goto illegaloperand;

aref1bounds:
  if (_trace) printf("aref1bounds:\n");
  *(u64 *)&((ARRAYCACHEP)t7)->array = zero;   
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;

/* end Aref1Exception */
/* start Aset1Regset */


aset1regset:
  if (_trace) printf("aset1regset:\n");
  t12 = arg4;
  /* Memory Read Internal */

vma-memory-read15639:
  t1 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;   
  arg6 = (t3 * 4);   
  arg5 = LDQ_U(t3);   
  t1 = arg4 - t1;   		// Stack cache offset 
  t4 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read15641;

vma-memory-read15640:
  t3 = zero + 64;   
  t4 = t4 >> (arg5 & 63);   
  t3 = t3 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t4 & 1)   
    goto vma-memory-read15643;

vma-memory-read15648:
  /* TagType. */
  t1 = arg5 & 63;
  t2 = arg6 >> (Array_LongPrefixBitPos & 63);   
  t1 = t1 - Type_HeaderI;   
  if (t1 != 0)   
    goto aset1illegal;
  if (t2 & 1)   
    goto aset1exception;
		/* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t12;
  t2 = zero + Array_LengthMask;   
  t1 = arg6 & t2;
  t2 = ((u64)arg2 < (u64)t1) ? 1 : 0;   
  if (t2 == 0) 
    goto aset1bounds;
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;   		// store the array length [implicit fixnum] 
  t10 = arg6 >> (Array_RegisterBytePackingPos & 63);   
  t8 = *(u64 *)&(processor->areventcount);   
  t10 = t10 << (Array_RegisterBytePackingPos & 63);   
  t9 = arg4 + 1;
  t10 = t10 + t8;		// Construct the array register word 
		/* store the array register word [implicit fixnum] */
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t10;
  *(u64 *)&((ARRAYCACHEP)t7)->locat = t9;   		// store the storage [implicit locative] 
  arg5 = arg6 >> (Array_BytePackingPos & 63);   		// get BP into arg5 
  arg6 = arg6 >> (Array_ElementTypePos & 63);   		// get element type into arg6 
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = zero;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aset1restart;   

vma-memory-read15641:
  if (_trace) printf("vma-memory-read15641:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = (t1 * 8) + t2;  		// reconstruct SCA 
  arg6 = *(s32 *)t1;   
  arg5 = *(s32 *)(t1 + 4);   		// Read from stack cache 
  goto vma-memory-read15640;   

vma-memory-read15643:
  if (_trace) printf("vma-memory-read15643:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read15642;
  arg4 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read15639;   

vma-memory-read15642:
  if (_trace) printf("vma-memory-read15642:\n");
  t4 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
  t4 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read15645:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end Aset1Regset */
/* start Aset1RecomputeArrayRegister */


aset1recomputearrayregister:
  if (_trace) printf("aset1recomputearrayregister:\n");
  t5 = *(s32 *)(arg1 + -8);   
  t4 = *(s32 *)(arg1 + -4);   
  t5 = (u32)t5;   
  t6 = t4 - Type_Array;   
  t6 = t6 & 62;		// Strip CDR code, low bits 
  if (t6 != 0)   
    goto recompute-array-register15650;
  /* Memory Read Internal */

vma-memory-read15652:
  t8 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t3 = t5 + ivory;
  t2 = *(s32 *)&processor->scovlimit;   
  t6 = (t3 * 4);   
  t7 = LDQ_U(t3);   
  t8 = t5 - t8;   		// Stack cache offset 
  t1 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t8 < (u64)t2) ? 1 : 0;   		// In range? 
  t6 = *(s32 *)t6;   
  t7 = (u8)(t7 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read15654;

vma-memory-read15653:
  t3 = zero + 64;   
  t1 = t1 >> (t7 & 63);   
  t3 = t3 >> (t7 & 63);   
  t6 = (u32)t6;   
  if (t1 & 1)   
    goto vma-memory-read15656;

vma-memory-read15661:
  /* TagType. */
  t8 = t7 & 63;
  t2 = t6 >> (Array_LongPrefixBitPos & 63);   
  t8 = t8 - Type_HeaderI;   
  if (t8 != 0)   
    goto recompute-array-register15649;
  if (t2 & 1)   
    goto recompute-array-register15651;
  t1 = t6 >> (Array_BytePackingPos & 63);   
  t4 = *(u64 *)&(processor->areventcount);   
  t1 = t1 << (Array_RegisterBytePackingPos & 63);   
  t2 = t5 + 1;
  t1 = t1 + t4;		// Construct the array register word 
  *(u32 *)(arg1 + 8) = t2;
  t3 = zero + Array_LengthMask;   
  t3 = t6 & t3;
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaset1retry;   

recompute-array-register15651:
  if (_trace) printf("recompute-array-register15651:\n");
  *(u64 *)&processor->asrf5 = arg1;   		// Just a place to save these values 
  *(u64 *)&processor->asrf4 = t10;   		// Just a place to save these values 
  *(u64 *)&processor->asrf3 = t11;   		// Just a place to save these values 
  *(u64 *)&processor->asrf6 = arg1;   		// Just a place to save these values 
  *(u64 *)&processor->asrf7 = arg2;   		// Just a place to save these values 
  *(u64 *)&processor->asrf8 = arg3;   		// Just a place to save these values 
  *(u64 *)&processor->asrf9 = arg4;   		// Just a place to save these values 
  t9 = *(s32 *)(arg1 + -8);   
  arg2 = *(s32 *)(arg1 + -4);   
  t9 = (u32)t9;   
  arg1 = t5;
  t4 = t7;
  t3 = t6;
  t2 = 1;
  iSP = iSP + 24;
  r0 = (u64)&&return0526;
  goto setup1dlongarray;
return0526:
  t4 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t4 != 0)   
    goto recompute-array-register15650;
  arg1 = *(u64 *)&(processor->asrf5);   		// Just a place to save these values 
  t10 = *(u64 *)&(processor->asrf4);   		// Just a place to save these values 
  t11 = *(u64 *)&(processor->asrf3);   		// Just a place to save these values 
  arg1 = *(u64 *)&(processor->asrf6);   		// Just a place to save these values 
  arg2 = *(u64 *)&(processor->asrf7);   		// Just a place to save these values 
  arg3 = *(u64 *)&(processor->asrf8);   		// Just a place to save these values 
  arg4 = *(u64 *)&(processor->asrf9);   		// Just a place to save these values 
  t3 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  t2 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  t4 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  iSP = iSP - 24;   
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 8) = t2;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaset1retry;   

recompute-array-register15650:
  if (_trace) printf("recompute-array-register15650:\n");
  arg6 = t4;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 3;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 12;
  goto arrayexception;

recompute-array-register15649:
  if (_trace) printf("recompute-array-register15649:\n");
  arg5 = 0;
  arg2 = 12;
  goto illegaloperand;

vma-memory-read15654:
  if (_trace) printf("vma-memory-read15654:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + t2;  		// reconstruct SCA 
  t6 = *(s32 *)t8;   
  t7 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read15653;   

vma-memory-read15656:
  if (_trace) printf("vma-memory-read15656:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read15655;
  t5 = (u32)t6;   		// Do the indirect thing 
  goto vma-memory-read15652;   

vma-memory-read15655:
  if (_trace) printf("vma-memory-read15655:\n");
  t1 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = t7 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t5;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t1;   		// Adjust for a longword load 
  t1 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read15658:
  /* Perform memory action */
  arg1 = t1;
  arg2 = 6;
  goto performmemoryaction;

/* end Aset1RecomputeArrayRegister */
/* start Aset1Exception */


aset1exception:
  if (_trace) printf("aset1exception:\n");
  *(u64 *)&processor->asrf4 = arg2;   		// Just a place to save these values 
  *(u64 *)&processor->asrf3 = t5;   		// Just a place to save these values 
  *(u64 *)&processor->asrf6 = t6;   		// Just a place to save these values 
  *(u64 *)&processor->asrf5 = t7;   		// Just a place to save these values 
  t9 = t12;
  arg2 = arg3;
  arg1 = arg4;
  t4 = arg5;
  t3 = arg6;
  t2 = zero;
  iSP = iSP + 24;
  r0 = (u64)&&return0527;
  goto setup1dlongarray;
return0527:
  t1 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t1 != 0)   
    goto reallyaset1exc;
  arg2 = *(s32 *)&processor->asrf4;   		// Just a place to save these values 
  t5 = *(u64 *)&(processor->asrf3);   		// Just a place to save these values 
  t6 = *(u64 *)&(processor->asrf6);   		// Just a place to save these values 
  t7 = *(u64 *)&(processor->asrf5);   		// Just a place to save these values 
  t1 = *(s32 *)iSP;   		// Length 
  t2 = *(s32 *)(iSP + 4);   		// Length 
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = (u32)t1;   
  t2 = *(u64 *)iSP;   		// base 
  iSP = iSP - 8;   		// Pop Stack. 
  t3 = *(u64 *)iSP;   		// control 
  iSP = iSP - 8;   		// Pop Stack. 
  t9 = *(s32 *)iSP;   		// The original array 
  arg3 = *(s32 *)(iSP + 4);   		// The original array 
  iSP = iSP - 8;   		// Pop Stack. 
  t9 = (u32)t9;   
  iSP = iSP - 24;   
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;   
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t3;
  *(u32 *)&((ARRAYCACHEP)t7)->locat = t2;
		/* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t9;
  t9 = (u32)t2;   
  t2 = ((u64)arg2 < (u64)t1) ? 1 : 0;   
  if (t2 == 0) 
    goto aset1bounds;
  arg5 = t3 >> (Array_BytePackingPos & 63);   		// get BP into arg5 
  arg6 = t3 >> (Array_ElementTypePos & 63);   		// get element type into arg6 
  arg4 = t3 >> (Array_RegisterByteOffsetPos & 63);   
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = arg4 & Array_RegisterByteOffsetMask;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aset1restart;   

reallyaset1exc:
  if (_trace) printf("reallyaset1exc:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;   
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 3;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 9;
  goto arrayexception;

aset1illegal:
  if (_trace) printf("aset1illegal:\n");
  arg5 = 0;
  arg2 = 9;
  goto illegaloperand;

aset1bounds:
  if (_trace) printf("aset1bounds:\n");
  *(u64 *)&((ARRAYCACHEP)t7)->array = zero;   
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;

/* end Aset1Exception */
/* start DoAloc1 */

  /* Halfword operand from stack instruction - DoAloc1 */
  /* arg2 has the preloaded 8 bit operand. */

doaloc1:
  if (_trace) printf("doaloc1:\n");

DoAloc1SP:
  if (_trace) printf("DoAloc1SP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoAloc1LP:
  if (_trace) printf("DoAloc1LP:\n");

DoAloc1FP:
  if (_trace) printf("DoAloc1FP:\n");

headdoaloc1:
  if (_trace) printf("headdoaloc1:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoaloc1:
  if (_trace) printf("begindoaloc1:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   		// Get the array tag/data 
  arg3 = *(s32 *)(iSP + 4);   		// Get the array tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  arg2 = (u32)arg1;   		// Index Data 
  arg1 = arg1 >> 32;   		// Index Tag 
  t1 = arg1 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto aloc1illegal;

aloc1merge:
  if (_trace) printf("aloc1merge:\n");
  t1 = arg3 - Type_Array;   
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto aloc1exception;
  /* Memory Read Internal */

vma-memory-read15662:
  t1 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;   
  arg6 = (t3 * 4);   
  arg5 = LDQ_U(t3);   
  t1 = arg4 - t1;   		// Stack cache offset 
  t4 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read15664;

vma-memory-read15663:
  t3 = zero + 64;   
  t4 = t4 >> (arg5 & 63);   
  t3 = t3 >> (arg5 & 63);   
  if (t4 & 1)   
    goto vma-memory-read15666;

vma-memory-read15671:
  /* TagType. */
  t1 = arg5 & 63;
  t2 = arg6 >> (Array_LongPrefixBitPos & 63);   
  t1 = t1 - Type_HeaderI;   
  if (t1 != 0)   
    goto aloc1illegal;
  if (t2 & 1)   
    goto aloc1exception;
  t2 = zero + Array_LengthMask;   
  t1 = arg6 & t2;
  t3 = ((u64)arg2 < (u64)t1) ? 1 : 0;   
  if (t3 == 0) 
    goto aloc1illegal;
  arg6 = arg6 >> (Array_ElementTypePos & 63);   		// get element type into arg6 
  arg4 = arg4 + 1;
  arg4 = arg4 + arg2;
  arg6 = arg6 & Array_ElementTypeMask;
  arg6 = arg6 - Array_ElementTypeObject;   
  if (arg6 != 0)   
    goto aloc1notobject;
  t1 = Type_Locative;
  *(u32 *)(iSP + 8) = arg4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

aloc1exception:
  if (_trace) printf("aloc1exception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;   
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 8;
  goto arrayexception;

aloc1illegal:
  if (_trace) printf("aloc1illegal:\n");
  arg5 = 0;
  arg2 = 8;
  goto illegaloperand;

aloc1bounds:
  if (_trace) printf("aloc1bounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;

aloc1notobject:
  if (_trace) printf("aloc1notobject:\n");
  arg5 = 0;
  arg2 = 7;
  goto illegaloperand;

DoAloc1IM:
  if (_trace) printf("DoAloc1IM:\n");
  arg4 = *(s32 *)iSP;   		// Get the array tag/data 
  arg3 = *(s32 *)(iSP + 4);   		// Get the array tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  goto aloc1merge;   

vma-memory-read15664:
  if (_trace) printf("vma-memory-read15664:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = (t1 * 8) + t2;  		// reconstruct SCA 
  arg6 = *(s32 *)t1;   
  arg5 = *(s32 *)(t1 + 4);   		// Read from stack cache 
  goto vma-memory-read15663;   

vma-memory-read15666:
  if (_trace) printf("vma-memory-read15666:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read15665;
  arg4 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read15662;   

vma-memory-read15665:
  if (_trace) printf("vma-memory-read15665:\n");
  t4 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
  t4 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read15668:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoAloc1 */
  /* End of Halfword operand from stack instruction - DoAloc1 */
  /* Array register operations. */
/* start DoSetup1DArray */

  /* Halfword operand from stack instruction - DoSetup1DArray */

dosetup1darray:
  if (_trace) printf("dosetup1darray:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoSetup1DArrayIM:
  if (_trace) printf("DoSetup1DArrayIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment15685:
  if (_trace) printf("force-alignment15685:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindosetup1darray;   

DoSetup1DArraySP:
  if (_trace) printf("DoSetup1DArraySP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoSetup1DArrayLP:
  if (_trace) printf("DoSetup1DArrayLP:\n");

DoSetup1DArrayFP:
  if (_trace) printf("DoSetup1DArrayFP:\n");

headdosetup1darray:
  if (_trace) printf("headdosetup1darray:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindosetup1darray:
  if (_trace) printf("begindosetup1darray:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg2 = arg1 >> 32;   		// Get the tag 
  arg1 = (u32)arg1;   		// and the data 
  t2 = 0;		// Indicate not forcing 1d 
  t9 = arg1;
  t3 = arg2 - Type_Array;   
  t3 = t3 & 62;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto setup-array-register15673;
  /* Memory Read Internal */

vma-memory-read15675:
  t5 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t7 = arg1 + ivory;
  t6 = *(s32 *)&processor->scovlimit;   
  t3 = (t7 * 4);   
  t4 = LDQ_U(t7);   
  t5 = arg1 - t5;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t6) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read15677;

vma-memory-read15676:
  t7 = zero + 64;   
  t8 = t8 >> (t4 & 63);   
  t7 = t7 >> (t4 & 63);   
  t3 = (u32)t3;   
  if (t8 & 1)   
    goto vma-memory-read15679;

vma-memory-read15684:
  /* TagType. */
  t5 = t4 & 63;
  t6 = t3 >> (Array_LongPrefixBitPos & 63);   
  t5 = t5 - Type_HeaderI;   
  if (t5 != 0)   
    goto setup-array-register15672;
  if (t6 & 1)   
    goto setup-array-register15674;
  t5 = arg2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  t8 = t3 >> (Array_RegisterBytePackingPos & 63);   
  t7 = Type_Fixnum;
  t1 = *(u64 *)&(processor->areventcount);   
  t8 = t8 << (Array_RegisterBytePackingPos & 63);   
  t5 = arg1 + 1;
  t8 = t8 + t1;		// Construct the array register word 
  t6 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  t6 = zero + Array_LengthMask;   
  t6 = t3 & t6;
  t8 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

setup-array-register15673:
  if (_trace) printf("setup-array-register15673:\n");
  /* SetTag. */
  t6 = arg2 << 32;   
  t6 = t9 | t6;
  arg6 = arg2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 71;
  goto arrayexception;

setup-array-register15672:
  if (_trace) printf("setup-array-register15672:\n");
  arg5 = 0;
  arg2 = 71;
  goto illegaloperand;

setup-array-register15674:
  if (_trace) printf("setup-array-register15674:\n");
  r0 = (u64)&&return0528;
  goto setup1dlongarray;
return0528:
  t1 = (t2 == ReturnValue_Normal) ? 1 : 0;   
  if (t1 != 0)   
    goto NEXTINSTRUCTION;
  t1 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t1 != 0)   
    goto setup-array-register15673;
  t1 = (t2 == ReturnValue_IllegalOperand) ? 1 : 0;   
  if (t1 != 0)   
    goto setup-array-register15672;
  goto NEXTINSTRUCTION;   

vma-memory-read15677:
  if (_trace) printf("vma-memory-read15677:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t3 = *(s32 *)t5;   
  t4 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read15676;   

vma-memory-read15679:
  if (_trace) printf("vma-memory-read15679:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read15678;
  arg1 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read15675;   

vma-memory-read15678:
  if (_trace) printf("vma-memory-read15678:\n");
  t8 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read15681:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoSetup1DArray */
  /* End of Halfword operand from stack instruction - DoSetup1DArray */
/* start DoSetupForce1DArray */

  /* Halfword operand from stack instruction - DoSetupForce1DArray */

dosetupforce1darray:
  if (_trace) printf("dosetupforce1darray:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoSetupForce1DArrayIM:
  if (_trace) printf("DoSetupForce1DArrayIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment15699:
  if (_trace) printf("force-alignment15699:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindosetupforce1darray;   

DoSetupForce1DArraySP:
  if (_trace) printf("DoSetupForce1DArraySP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoSetupForce1DArrayLP:
  if (_trace) printf("DoSetupForce1DArrayLP:\n");

DoSetupForce1DArrayFP:
  if (_trace) printf("DoSetupForce1DArrayFP:\n");

headdosetupforce1darray:
  if (_trace) printf("headdosetupforce1darray:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindosetupforce1darray:
  if (_trace) printf("begindosetupforce1darray:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg2 = arg1 >> 32;   		// Get the tag 
  arg1 = (u32)arg1;   		// and the data 
  t2 = 1;		// Indicate forcing 1d 
  t9 = arg1;
  t3 = arg2 - Type_Array;   
  t3 = t3 & 62;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto setup-array-register15687;
  /* Memory Read Internal */

vma-memory-read15689:
  t5 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t7 = arg1 + ivory;
  t6 = *(s32 *)&processor->scovlimit;   
  t3 = (t7 * 4);   
  t4 = LDQ_U(t7);   
  t5 = arg1 - t5;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t6) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read15691;

vma-memory-read15690:
  t7 = zero + 64;   
  t8 = t8 >> (t4 & 63);   
  t7 = t7 >> (t4 & 63);   
  t3 = (u32)t3;   
  if (t8 & 1)   
    goto vma-memory-read15693;

vma-memory-read15698:
  /* TagType. */
  t5 = t4 & 63;
  t6 = t3 >> (Array_LongPrefixBitPos & 63);   
  t5 = t5 - Type_HeaderI;   
  if (t5 != 0)   
    goto setup-array-register15686;
  if (t6 & 1)   
    goto setup-array-register15688;
  t5 = arg2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  t8 = t3 >> (Array_RegisterBytePackingPos & 63);   
  t7 = Type_Fixnum;
  t1 = *(u64 *)&(processor->areventcount);   
  t8 = t8 << (Array_RegisterBytePackingPos & 63);   
  t5 = arg1 + 1;
  t8 = t8 + t1;		// Construct the array register word 
  t6 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  t6 = zero + Array_LengthMask;   
  t6 = t3 & t6;
  t8 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

setup-array-register15687:
  if (_trace) printf("setup-array-register15687:\n");
  /* SetTag. */
  t6 = arg2 << 32;   
  t6 = t9 | t6;
  arg6 = arg2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 71;
  goto arrayexception;

setup-array-register15686:
  if (_trace) printf("setup-array-register15686:\n");
  arg5 = 0;
  arg2 = 71;
  goto illegaloperand;

setup-array-register15688:
  if (_trace) printf("setup-array-register15688:\n");
  r0 = (u64)&&return0529;
  goto setup1dlongarray;
return0529:
  t1 = (t2 == ReturnValue_Normal) ? 1 : 0;   
  if (t1 != 0)   
    goto NEXTINSTRUCTION;
  t1 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t1 != 0)   
    goto setup-array-register15687;
  t1 = (t2 == ReturnValue_IllegalOperand) ? 1 : 0;   
  if (t1 != 0)   
    goto setup-array-register15686;
  goto NEXTINSTRUCTION;   

vma-memory-read15691:
  if (_trace) printf("vma-memory-read15691:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t3 = *(s32 *)t5;   
  t4 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read15690;   

vma-memory-read15693:
  if (_trace) printf("vma-memory-read15693:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read15692;
  arg1 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read15689;   

vma-memory-read15692:
  if (_trace) printf("vma-memory-read15692:\n");
  t8 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read15695:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoSetupForce1DArray */
  /* End of Halfword operand from stack instruction - DoSetupForce1DArray */
/* start Setup1DLongArray */


setup1dlongarray:
  if (_trace) printf("setup1dlongarray:\n");
  /* Read data from the header: alength offset indirect lengths&mults */
  t1 = arg1 + 1;   		// length=array+1 
  /* Memory Read Internal */

vma-memory-read15709:
  t7 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  arg4 = (t10 * 4);   
  t6 = LDQ_U(t10);   
  t7 = t1 - t7;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  arg4 = *(s32 *)arg4;   
  t6 = (u8)(t6 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15711;

vma-memory-read15710:
  t10 = zero + 240;   
  t11 = t11 >> (t6 & 63);   
  t10 = t10 >> (t6 & 63);   
  arg4 = (u32)arg4;   
  if (t11 & 1)   
    goto vma-memory-read15713;

vma-memory-read15720:
  t8 = t6 - Type_Fixnum;   
  t8 = t8 & 63;		// Strip CDR code 
  if (t8 != 0)   
    goto setup-long-array-register15700;
  t1 = t1 + 1;   		// Offset is adata+2 
  /* Memory Read Internal */

vma-memory-read15721:
  t7 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  arg3 = (t10 * 4);   
  t6 = LDQ_U(t10);   
  t7 = t1 - t7;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  arg3 = *(s32 *)arg3;   
  t6 = (u8)(t6 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15723;

vma-memory-read15722:
  t10 = zero + 240;   
  t11 = t11 >> (t6 & 63);   
  t10 = t10 >> (t6 & 63);   
  arg3 = (u32)arg3;   
  if (t11 & 1)   
    goto vma-memory-read15725;

vma-memory-read15732:
  t8 = t6 - Type_Fixnum;   
  t8 = t8 & 63;		// Strip CDR code 
  if (t8 != 0)   
    goto setup-long-array-register15700;
  t1 = t1 + 1;   		// Indirect is adata+3 
  /* Memory Read Internal */

vma-memory-read15733:
  t7 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t5 = (t10 * 4);   
  t6 = LDQ_U(t10);   
  t7 = t1 - t7;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t6 = (u8)(t6 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15735;

vma-memory-read15734:
  t10 = zero + 240;   
  t11 = t11 >> (t6 & 63);   
  t10 = t10 >> (t6 & 63);   
  t5 = (u32)t5;   
  if (t11 & 1)   
    goto vma-memory-read15737;

vma-memory-read15744:
  t10 = t6 & 63;		// Strip off any CDR code bits. 
  t11 = (t10 == Type_Locative) ? 1 : 0;   

force-alignment15809:
  if (_trace) printf("force-alignment15809:\n");
  if (t11 == 0) 
    goto basic-dispatch15746;
  /* Here if argument TypeLocative */

setup-long-array-register15703:
  if (_trace) printf("setup-long-array-register15703:\n");
  t10 = arg2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t10;
  iSP = iSP + 8;
  t8 = t3 >> (Array_BytePackingPos & 63);   
  t7 = Type_Fixnum;
  t1 = *(u64 *)&(processor->areventcount);   
  t8 = t8 << (Array_RegisterBytePackingPos & 63);   
  t8 = t8 + t1;		// Construct the array register word 
  t6 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  t8 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto setup-long-array-register15708;   

basic-dispatch15746:
  if (_trace) printf("basic-dispatch15746:\n");
  t11 = (t10 == Type_Fixnum) ? 1 : 0;   

force-alignment15810:
  if (_trace) printf("force-alignment15810:\n");
  if (t11 == 0) 
    goto basic-dispatch15747;
  /* Here if argument TypeFixnum */
  goto setup-long-array-register15703;   

basic-dispatch15747:
  if (_trace) printf("basic-dispatch15747:\n");
  t11 = (t10 == Type_Array) ? 1 : 0;   

force-alignment15811:
  if (_trace) printf("force-alignment15811:\n");
  if (t11 == 0) 
    goto basic-dispatch15748;
  /* Here if argument TypeArray */

setup-long-array-register15707:
  if (_trace) printf("setup-long-array-register15707:\n");
  t1 = t3 & 7;
  t1 = (t1 == 1) ? 1 : 0;   
  t1 = t1 | t2;		// Force true if FORCE 
  if (t1 == 0) 
    goto setup-long-array-register15700;
  t12 = t3 >> (Array_BytePackingPos & 63);   
  t12 = t12 & Array_BytePackingMask;
  t2 = arg3;

setup-long-array-register15702:
  if (_trace) printf("setup-long-array-register15702:\n");
  /* Memory Read Internal */

vma-memory-read15749:
  t7 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t5 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t4 = (t10 * 4);   
  t6 = LDQ_U(t10);   
  t7 = t5 - t7;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->header_mask);   
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  t4 = *(s32 *)t4;   
  t6 = (u8)(t6 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15751;

vma-memory-read15750:
  t10 = zero + 64;   
  t11 = t11 >> (t6 & 63);   
  t10 = t10 >> (t6 & 63);   
  t4 = (u32)t4;   
  if (t11 & 1)   
    goto vma-memory-read15753;

vma-memory-read15758:
  t10 = t4 >> (Array_BytePackingPos & 63);   
  t10 = t10 & Array_BytePackingMask;
  arg1 = t12 - t10;   
  t7 = t4 >> (Array_LongPrefixBitPos & 63);   
  if (t7 & 1)   
    goto setup-long-array-register15704;
  t5 = t5 + 1;		// increment beyond header 
  t8 = zero + 32767;   
  t8 = t4 & t8;
  t10 = zero - arg1;   
  t10 = t8 >> (t10 & 63);   
  t8 = t8 << (arg1 & 63);   
  if ((s64)arg1 <= 0)   
    t8 = t10;
  t10 = arg4 + arg3;
  t7 = t10 - t8;   
  if ((s64)t7 <= 0)   
    t8 = t10;
  arg4 = t8;

setup-long-array-register15701:
  if (_trace) printf("setup-long-array-register15701:\n");
  arg4 = arg4 - t2;   
  t10 = arg2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t10;
  iSP = iSP + 8;
  t7 = Type_Fixnum;
  t8 = t3 >> (Array_RegisterBytePackingPos & 63);   
  t1 = *(u64 *)&(processor->areventcount);   
  t8 = t8 << (Array_RegisterBytePackingPos & 63);   
  t11 = zero - 1;   		// -1 
  t11 = t11 << (t12 & 63);   		// (LSH -1 byte-packing) 
  t11 = t2 & ~t11;
  t11 = t11 << (Array_RegisterByteOffsetPos & 63);   
  t8 = t8 + t1;		// Construct the array register word 
  t8 = t11 + t8;		// Add in the byte offset 
  t6 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  if ((s64)arg4 <= 0)   
    arg4 = zero;
  if (arg4 == 0) 
    goto setup-long-array-register15705;
  t1 = zero - t12;   
  t1 = t2 << (t1 & 63);   
  t2 = t2 >> (t12 & 63);   
  if ((s64)t12 <= 0)   
    t2 = t1;
  t5 = t2 + t5;

setup-long-array-register15705:
  if (_trace) printf("setup-long-array-register15705:\n");
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  t8 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto setup-long-array-register15708;   

setup-long-array-register15704:
  if (_trace) printf("setup-long-array-register15704:\n");
  t1 = t5 + 1;		// length=array+1 
  /* Memory Read Internal */

vma-memory-read15759:
  t7 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  arg6 = (t10 * 4);   
  t4 = LDQ_U(t10);   
  t7 = t1 - t7;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  t4 = (u8)(t4 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15761;

vma-memory-read15760:
  t10 = zero + 240;   
  t11 = t11 >> (t4 & 63);   
  t10 = t10 >> (t4 & 63);   
  arg6 = (u32)arg6;   
  if (t11 & 1)   
    goto vma-memory-read15763;

vma-memory-read15770:
  t1 = t4 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto setup-long-array-register15700;
  t1 = t5 + 2;		// offset=array+2 
  /* Memory Read Internal */

vma-memory-read15771:
  t7 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  arg5 = (t10 * 4);   
  t4 = LDQ_U(t10);   
  t7 = t1 - t7;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  arg5 = *(s32 *)arg5;   
  t4 = (u8)(t4 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15773;

vma-memory-read15772:
  t10 = zero + 240;   
  t11 = t11 >> (t4 & 63);   
  t10 = t10 >> (t4 & 63);   
  arg5 = (u32)arg5;   
  if (t11 & 1)   
    goto vma-memory-read15775;

vma-memory-read15782:
  t1 = t4 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto setup-long-array-register15700;
  t1 = t5 + 3;		// next=array+3 
  /* Memory Read Internal */

vma-memory-read15783:
  t7 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t5 = (t10 * 4);   
  t4 = LDQ_U(t10);   
  t7 = t1 - t7;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read15785;

vma-memory-read15784:
  t10 = zero + 240;   
  t11 = t11 >> (t4 & 63);   
  t10 = t10 >> (t4 & 63);   
  t5 = (u32)t5;   
  if (t11 & 1)   
    goto vma-memory-read15787;

vma-memory-read15794:
  t8 = zero - arg1;   
  t8 = arg6 >> (t8 & 63);   
  t10 = arg6 << (arg1 & 63);   
  if ((s64)arg1 <= 0)   
    t10 = t8;
  t8 = arg4 + arg3;
  if ((s64)t10 <= 0)   
    t10 = t8;
  t7 = t10 - t8;   
  if ((s64)t7 <= 0)   
    t8 = t10;
  arg4 = t8;
  t8 = t4 & 63;		// Strip off any CDR code bits. 
  t10 = (t8 == Type_Locative) ? 1 : 0;   

force-alignment15802:
  if (_trace) printf("force-alignment15802:\n");
  if (t10 == 0) 
    goto basic-dispatch15796;
  /* Here if argument TypeLocative */
  goto setup-long-array-register15701;   

basic-dispatch15796:
  if (_trace) printf("basic-dispatch15796:\n");
  t10 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment15803:
  if (_trace) printf("force-alignment15803:\n");
  if (t10 == 0) 
    goto basic-dispatch15797;
  /* Here if argument TypeFixnum */
  goto setup-long-array-register15701;   

basic-dispatch15797:
  if (_trace) printf("basic-dispatch15797:\n");
  t10 = (t8 == Type_Array) ? 1 : 0;   

force-alignment15804:
  if (_trace) printf("force-alignment15804:\n");
  if (t10 == 0) 
    goto basic-dispatch15798;
  /* Here if argument TypeArray */

setup-long-array-register15706:
  if (_trace) printf("setup-long-array-register15706:\n");
  t7 = zero - arg1;   
  t7 = arg5 >> (t7 & 63);   
  arg3 = arg5 << (arg1 & 63);   
  if ((s64)arg1 <= 0)   
    arg3 = t7;
  t2 = t2 + arg3;
  goto setup-long-array-register15702;   

basic-dispatch15798:
  if (_trace) printf("basic-dispatch15798:\n");
  t10 = (t8 == Type_String) ? 1 : 0;   

force-alignment15805:
  if (_trace) printf("force-alignment15805:\n");
  if (t10 == 0) 
    goto basic-dispatch15799;
  /* Here if argument TypeString */
  goto setup-long-array-register15706;   

basic-dispatch15799:
  if (_trace) printf("basic-dispatch15799:\n");
  /* Here for all other cases */
  goto setup-long-array-register15700;   

basic-dispatch15795:
  if (_trace) printf("basic-dispatch15795:\n");

basic-dispatch15748:
  if (_trace) printf("basic-dispatch15748:\n");
  t11 = (t10 == Type_String) ? 1 : 0;   

force-alignment15812:
  if (_trace) printf("force-alignment15812:\n");
  if (t11 == 0) 
    goto basic-dispatch15806;
  /* Here if argument TypeString */
  goto setup-long-array-register15707;   

basic-dispatch15806:
  if (_trace) printf("basic-dispatch15806:\n");
  /* Here for all other cases */
  goto setup-long-array-register15700;   

basic-dispatch15745:
  if (_trace) printf("basic-dispatch15745:\n");

setup-long-array-register15700:
  if (_trace) printf("setup-long-array-register15700:\n");
  t2 = ReturnValue_Exception;
  goto *r0; /* ret */

setup-long-array-register15708:
  if (_trace) printf("setup-long-array-register15708:\n");
  t2 = ReturnValue_Normal;
  goto *r0; /* ret */

vma-memory-read15785:
  if (_trace) printf("vma-memory-read15785:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t5 = *(s32 *)t7;   
  t4 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15784;   

vma-memory-read15787:
  if (_trace) printf("vma-memory-read15787:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read15786;
  t1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read15783;   

vma-memory-read15786:
  if (_trace) printf("vma-memory-read15786:\n");
  t11 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read15791:
  if (_trace) printf("vma-memory-read15791:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto vma-memory-read15790;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto vma-memory-read15794;   

vma-memory-read15790:

vma-memory-read15789:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read15773:
  if (_trace) printf("vma-memory-read15773:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  arg5 = *(s32 *)t7;   
  t4 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15772;   

vma-memory-read15775:
  if (_trace) printf("vma-memory-read15775:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read15774;
  t1 = (u32)arg5;   		// Do the indirect thing 
  goto vma-memory-read15771;   

vma-memory-read15774:
  if (_trace) printf("vma-memory-read15774:\n");
  t11 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read15779:
  if (_trace) printf("vma-memory-read15779:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto vma-memory-read15778;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto vma-memory-read15782;   

vma-memory-read15778:

vma-memory-read15777:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read15761:
  if (_trace) printf("vma-memory-read15761:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  arg6 = *(s32 *)t7;   
  t4 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15760;   

vma-memory-read15763:
  if (_trace) printf("vma-memory-read15763:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read15762;
  t1 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read15759;   

vma-memory-read15762:
  if (_trace) printf("vma-memory-read15762:\n");
  t11 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read15767:
  if (_trace) printf("vma-memory-read15767:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto vma-memory-read15766;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto vma-memory-read15770;   

vma-memory-read15766:

vma-memory-read15765:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read15751:
  if (_trace) printf("vma-memory-read15751:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t4 = *(s32 *)t7;   
  t6 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15750;   

vma-memory-read15753:
  if (_trace) printf("vma-memory-read15753:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read15752;
  t5 = (u32)t4;   		// Do the indirect thing 
  goto vma-memory-read15749;   

vma-memory-read15752:
  if (_trace) printf("vma-memory-read15752:\n");
  t11 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t5;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read15755:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 6;
  goto performmemoryaction;

vma-memory-read15735:
  if (_trace) printf("vma-memory-read15735:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t5 = *(s32 *)t7;   
  t6 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15734;   

vma-memory-read15737:
  if (_trace) printf("vma-memory-read15737:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read15736;
  t1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read15733;   

vma-memory-read15736:
  if (_trace) printf("vma-memory-read15736:\n");
  t11 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read15741:
  if (_trace) printf("vma-memory-read15741:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto vma-memory-read15740;
  t6 = t6 & ~63L;
  t6 = t6 | Type_ExternalValueCellPointer;
  goto vma-memory-read15744;   

vma-memory-read15740:

vma-memory-read15739:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read15723:
  if (_trace) printf("vma-memory-read15723:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  arg3 = *(s32 *)t7;   
  t6 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15722;   

vma-memory-read15725:
  if (_trace) printf("vma-memory-read15725:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read15724;
  t1 = (u32)arg3;   		// Do the indirect thing 
  goto vma-memory-read15721;   

vma-memory-read15724:
  if (_trace) printf("vma-memory-read15724:\n");
  t11 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read15729:
  if (_trace) printf("vma-memory-read15729:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto vma-memory-read15728;
  t6 = t6 & ~63L;
  t6 = t6 | Type_ExternalValueCellPointer;
  goto vma-memory-read15732;   

vma-memory-read15728:

vma-memory-read15727:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read15711:
  if (_trace) printf("vma-memory-read15711:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  arg4 = *(s32 *)t7;   
  t6 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read15710;   

vma-memory-read15713:
  if (_trace) printf("vma-memory-read15713:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read15712;
  t1 = (u32)arg4;   		// Do the indirect thing 
  goto vma-memory-read15709;   

vma-memory-read15712:
  if (_trace) printf("vma-memory-read15712:\n");
  t11 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read15717:
  if (_trace) printf("vma-memory-read15717:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto vma-memory-read15716;
  t6 = t6 & ~63L;
  t6 = t6 | Type_ExternalValueCellPointer;
  goto vma-memory-read15720;   

vma-memory-read15716:

vma-memory-read15715:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

/* end Setup1DLongArray */
/* start DoFastAset1 */

  /* Halfword operand from stack instruction - DoFastAset1 */
  /* arg2 has the preloaded 8 bit operand. */

dofastaset1:
  if (_trace) printf("dofastaset1:\n");

DoFastAset1SP:
  if (_trace) printf("DoFastAset1SP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoFastAset1LP:
  if (_trace) printf("DoFastAset1LP:\n");

DoFastAset1FP:
  if (_trace) printf("DoFastAset1FP:\n");

begindofastaset1:
  if (_trace) printf("begindofastaset1:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg4 = *(s32 *)iSP;   		// Index 
  arg3 = *(s32 *)(iSP + 4);   		// Index 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  t11 = *(s32 *)iSP;   		// value 
  t10 = *(s32 *)(iSP + 4);   		// value 
  iSP = iSP - 8;   		// Pop Stack. 
  t11 = (u32)t11;   
  t1 = arg3 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto fastaset1iop;

fastaset1retry:
  if (_trace) printf("fastaset1retry:\n");
  arg6 = *(s32 *)arg1;   
  t9 = *(s32 *)(arg1 + 8);   
  t3 = *(s32 *)(arg1 + 16);   
  arg6 = (u32)arg6;   
  t9 = (u32)t9;   
  t5 = arg6 << 42;   
  t3 = (u32)t3;   
  t4 = *(u64 *)&(processor->areventcount);   
  t5 = t5 >> 42;   
  t2 = ((u64)arg4 < (u64)t3) ? 1 : 0;   
  if (t2 == 0) 
    goto fastaset1bounds;
  t6 = t4 - t5;   
  if (t6 != 0)   
    goto aset1recomputearrayregister;
  t6 = arg6 >> (Array_RegisterBytePackingPos & 63);   
  t7 = arg6 >> (Array_RegisterByteOffsetPos & 63);   
  t8 = arg6 >> (Array_RegisterElementTypePos & 63);   
  t6 = t6 & Array_RegisterBytePackingMask;
  t7 = t7 & Array_RegisterByteOffsetMask;
  t8 = t8 & Array_RegisterElementTypeMask;
  /* Element checking and foreplay. */
  /* TagType. */
  t1 = t10 & 63;
  t12 = (t8 == Array_ElementTypeCharacter) ? 1 : 0;   

force-alignment15823:
  if (_trace) printf("force-alignment15823:\n");
  if (t12 == 0) 
    goto basic-dispatch15819;
  /* Here if argument ArrayElementTypeCharacter */
  t2 = t1 - Type_Character;   
  if (t2 == 0) 
    goto aset-1-internal15814;
  arg5 = 0;
  arg2 = 29;
  goto illegaloperand;

aset-1-internal15814:
  if (_trace) printf("aset-1-internal15814:\n");
  if (t6 == 0) 		// Certainly will fit if not packed! 
    goto aset-1-internal15813;
  t2 = 32;
  t2 = t2 >> (t6 & 63);   		// Compute size of byte 
  t1 = ~zero;   
  t1 = t1 << (t2 & 63);   
  t1 = ~t1;   		// Compute mask for byte 
  t1 = t11 & t1;
  t1 = t11 - t1;   
  if (t1 == 0) 		// J. if character fits. 
    goto aset-1-internal15813;
  arg5 = 0;
  arg2 = 62;
  goto illegaloperand;

basic-dispatch15819:
  if (_trace) printf("basic-dispatch15819:\n");
  t12 = (t8 == Array_ElementTypeFixnum) ? 1 : 0;   

force-alignment15824:
  if (_trace) printf("force-alignment15824:\n");
  if (t12 == 0) 
    goto basic-dispatch15820;
  /* Here if argument ArrayElementTypeFixnum */
  t2 = t1 - Type_Fixnum;   
  if (t2 == 0) 
    goto aset-1-internal15813;
  arg5 = 0;
  arg2 = 33;
  goto illegaloperand;

basic-dispatch15820:
  if (_trace) printf("basic-dispatch15820:\n");
  t12 = (t8 == Array_ElementTypeBoolean) ? 1 : 0;   

force-alignment15825:
  if (_trace) printf("force-alignment15825:\n");
  if (t12 == 0) 
    goto basic-dispatch15818;
  /* Here if argument ArrayElementTypeBoolean */
  t11 = 1;
  t1 = t1 - Type_NIL;   
  if (t1 != 0)   		// J. if True 
    goto aset-1-internal15813;
  t11 = zero;
  goto aset-1-internal15813;   		// J. if False 

basic-dispatch15818:
  if (_trace) printf("basic-dispatch15818:\n");
  /* Shove it in. */

aset-1-internal15813:
  if (_trace) printf("aset-1-internal15813:\n");
  if (t6 != 0)   		// J. if packed 
    goto aset-1-internal15815;
  t1 = t8 - Array_ElementTypeObject;   
  if (t1 != 0)   
    goto aset-1-internal15815;
  /* Here for the simple non packed case */
  t1 = t9 + arg4;
  /* Memory Read Internal */

vma-memory-read15826:
  t4 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t12 = t1 + ivory;
  t5 = *(s32 *)&processor->scovlimit;   
  t3 = (t12 * 4);   
  t2 = LDQ_U(t12);   
  t4 = t1 - t4;   		// Stack cache offset 
  arg3 = *(u64 *)&(processor->datawrite_mask);   
  t5 = ((u64)t4 < (u64)t5) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t2 = (u8)(t2 >> ((t12&7)*8));   
  if (t5 != 0)   
    goto vma-memory-read15828;

vma-memory-read15827:
  t12 = zero + 240;   
  arg3 = arg3 >> (t2 & 63);   
  t12 = t12 >> (t2 & 63);   
  if (arg3 & 1)   
    goto vma-memory-read15830;

vma-memory-read15836:
  /* Merge cdr-code */
  t3 = t10 & 63;
  t2 = t2 & 192;
  t2 = t2 | t3;
  t5 = *(u64 *)&(processor->stackcachebasevma);   
  t4 = t1 + ivory;
  arg3 = *(s32 *)&processor->scovlimit;   
  t3 = (t4 * 4);   
  t12 = LDQ_U(t4);   
  t5 = t1 - t5;   		// Stack cache offset 
  arg3 = ((u64)t5 < (u64)arg3) ? 1 : 0;   		// In range? 
  t5 = (t2 & 0xff) << ((t4&7)*8);   
  t12 = t12 & ~(0xffL << (t4&7)*8);   

force-alignment15838:
  if (_trace) printf("force-alignment15838:\n");
  t12 = t12 | t5;
  STQ_U(t4, t12);   
  *(u32 *)t3 = t11;
  if (arg3 != 0)   		// J. if in cache 
    goto vma-memory-write15837;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   
  /* Here for the slow packed version */

aset-1-internal15815:
  if (_trace) printf("aset-1-internal15815:\n");
  arg4 = t7 + arg4;
  t1 = arg4 >> (t6 & 63);   		// Convert byte index to word index 
  t1 = t1 + t9;		// Address of word containing byte 
  /* Memory Read Internal */

vma-memory-read15839:
  t2 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t4 = t1 + ivory;
  t3 = *(s32 *)&processor->scovlimit;   
  t9 = (t4 * 4);   
  arg5 = LDQ_U(t4);   
  t2 = t1 - t2;   		// Stack cache offset 
  t5 = *(u64 *)&(processor->dataread_mask);   
  t3 = ((u64)t2 < (u64)t3) ? 1 : 0;   		// In range? 
  t9 = *(s32 *)t9;   
  arg5 = (u8)(arg5 >> ((t4&7)*8));   
  if (t3 != 0)   
    goto vma-memory-read15841;

vma-memory-read15840:
  t4 = zero + 240;   
  t5 = t5 >> (arg5 & 63);   
  t4 = t4 >> (arg5 & 63);   
  t9 = (u32)t9;   
  if (t5 & 1)   
    goto vma-memory-read15843;

vma-memory-read15850:
  /* Check fixnum element type */
  /* TagType. */
  t2 = arg5 & 63;
  t2 = t2 - Type_Fixnum;   
  if (t2 != 0)   		// J. if element type not fixnum. 
    goto aset-1-internal15816;
  if (t6 == 0) 		// J. if unpacked fixnum element type. 
    goto aset-1-internal15817;
  t12 = ~zero;   
  t12 = t12 << (t6 & 63);   
  t2 = zero - t6;   
  t12 = arg4 & ~t12;		// Compute subword index 
  t2 = t2 + 5;
  t2 = t12 << (t2 & 63);   		// Compute shift to get byte 
  t12 = 32;
  t12 = t12 >> (t6 & 63);   		// Compute size of byte 
  t3 = ~zero;   
  t3 = t3 << (t12 & 63);   
  t4 = ~t3;   		// Compute mask for byte 
  if (t2 == 0) 		// inserting into the low byte is easy 
    goto array-element-dpb15851;
  /* Inserting the byte into any byte other than the low byte */
  t5 = 64;
  t12 = t5 - t2;   		// = the left shift rotate amount 
  t5 = t9 >> (t2 & 63);   		// shift selected byte into low end of word. 
  t9 = t9 << (t12 & 63);   		// rotate low bits into high end of word. 
  t5 = t3 & t5;		// Remove unwanted bits 
  t9 = t9 >> (t12 & 63);   		// rotate low bits back into place. 
  t12 = t11 & t4;		// Strip any extra bits from element 
  t5 = t12 | t5;		// Insert new bits. 
  t5 = t5 << (t2 & 63);   		// reposition bits 
  t9 = t9 | t5;		// Replace low order bits 
  goto array-element-dpb15852;   

array-element-dpb15851:
  if (_trace) printf("array-element-dpb15851:\n");
  /* Inserting the byte into the low byte */
  t9 = t9 & t3;		// Remove the old low byte 
  t12 = t11 & t4;		// Remove unwanted bits from the new byte 
  t9 = t9 | t12;		// Insert the new byte in place of the old byte 

array-element-dpb15852:
  if (_trace) printf("array-element-dpb15852:\n");
  t11 = t9;

aset-1-internal15817:
  if (_trace) printf("aset-1-internal15817:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = t1 + ivory;
  t12 = *(s32 *)&processor->scovlimit;   
  t5 = (t2 * 4);   
  t4 = LDQ_U(t2);   
  t3 = t1 - t3;   		// Stack cache offset 
  t12 = ((u64)t3 < (u64)t12) ? 1 : 0;   		// In range? 
  t3 = (arg5 & 0xff) << ((t2&7)*8);   
  t4 = t4 & ~(0xffL << (t2&7)*8);   

force-alignment15854:
  if (_trace) printf("force-alignment15854:\n");
  t4 = t4 | t3;
  STQ_U(t2, t4);   
  *(u32 *)t5 = t11;
  if (t12 != 0)   		// J. if in cache 
    goto vma-memory-write15853;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

aset-1-internal15816:
  if (_trace) printf("aset-1-internal15816:\n");
  arg5 = t1;
  arg2 = 25;
  goto illegaloperand;

fastaset1iop:
  if (_trace) printf("fastaset1iop:\n");
  arg5 = 0;
  arg2 = 32;
  goto illegaloperand;

fastaset1bounds:
  if (_trace) printf("fastaset1bounds:\n");
  arg5 = 0;
  arg2 = 13;
  goto illegaloperand;

vma-memory-write15853:
  if (_trace) printf("vma-memory-write15853:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment15855:
  if (_trace) printf("force-alignment15855:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t3 = t1 - t3;   		// Stack cache offset 
  t2 = (t3 * 8) + t2;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t2 = t11;
		/* write the stack cache */
  *(u32 *)(t2 + 4) = arg5;
  goto NEXTINSTRUCTION;   

vma-memory-read15841:
  if (_trace) printf("vma-memory-read15841:\n");
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = (t2 * 8) + t3;  		// reconstruct SCA 
  t9 = *(s32 *)t2;   
  arg5 = *(s32 *)(t2 + 4);   		// Read from stack cache 
  goto vma-memory-read15840;   

vma-memory-read15843:
  if (_trace) printf("vma-memory-read15843:\n");
  if ((t4 & 1) == 0)   
    goto vma-memory-read15842;
  t1 = (u32)t9;   		// Do the indirect thing 
  goto vma-memory-read15839;   

vma-memory-read15842:
  if (_trace) printf("vma-memory-read15842:\n");
  t5 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t4 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t4 = (t4 * 4) + t5;   		// Adjust for a longword load 
  t5 = *(s32 *)t4;   		// Get the memory action 

vma-memory-read15847:
  if (_trace) printf("vma-memory-read15847:\n");
  t4 = t5 & MemoryActionTransform;
  if (t4 == 0) 
    goto vma-memory-read15846;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto vma-memory-read15850;   

vma-memory-read15846:

vma-memory-read15845:
  /* Perform memory action */
  arg1 = t5;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-write15837:
  if (_trace) printf("vma-memory-write15837:\n");
  t5 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment15856:
  if (_trace) printf("force-alignment15856:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t5 = t1 - t5;   		// Stack cache offset 
  t4 = (t5 * 8) + t4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t4 = t11;
		/* write the stack cache */
  *(u32 *)(t4 + 4) = t2;
  goto NEXTINSTRUCTION;   

vma-memory-read15828:
  if (_trace) printf("vma-memory-read15828:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t4 = (t4 * 8) + t5;  		// reconstruct SCA 
  t3 = *(s32 *)t4;   
  t2 = *(s32 *)(t4 + 4);   		// Read from stack cache 
  goto vma-memory-read15827;   

vma-memory-read15830:
  if (_trace) printf("vma-memory-read15830:\n");
  if ((t12 & 1) == 0)   
    goto vma-memory-read15829;
  t1 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read15826;   

vma-memory-read15829:
  if (_trace) printf("vma-memory-read15829:\n");
  arg3 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t12 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t12 = (t12 * 4) + arg3;   		// Adjust for a longword load 
  arg3 = *(s32 *)t12;   		// Get the memory action 

vma-memory-read15833:

vma-memory-read15832:
  /* Perform memory action */
  arg1 = arg3;
  arg2 = 1;
  goto performmemoryaction;

DoFastAset1IM:
  goto doistageerror;

/* end DoFastAset1 */
  /* End of Halfword operand from stack instruction - DoFastAset1 */
  /* Array leaders. */
/* start DoArrayLeader */

  /* Halfword operand from stack instruction - DoArrayLeader */
  /* arg2 has the preloaded 8 bit operand. */

doarrayleader:
  if (_trace) printf("doarrayleader:\n");

DoArrayLeaderSP:
  if (_trace) printf("DoArrayLeaderSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoArrayLeaderLP:
  if (_trace) printf("DoArrayLeaderLP:\n");

DoArrayLeaderFP:
  if (_trace) printf("DoArrayLeaderFP:\n");

headdoarrayleader:
  if (_trace) printf("headdoarrayleader:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoarrayleader:
  if (_trace) printf("begindoarrayleader:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   		// arg3=arraytag, arg4=arraydata 
  arg3 = *(s32 *)(iSP + 4);   		// arg3=arraytag, arg4=arraydata 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  arg2 = (u32)arg1;   		// index data 
  arg1 = arg1 >> 32;   		// index tag 
  t1 = arg1 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto arrayleaderiop;

arrayleadermerge:
  if (_trace) printf("arrayleadermerge:\n");
  t1 = arg3 - Type_Array;   
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto arrayleaderexception;
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read15857:
  t3 = arg4 + ivory;
  arg5 = (t3 * 4);   
  arg6 = LDQ_U(t3);   
  t1 = arg4 - t11;   		// Stack cache offset 
  t4 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t1 < (u64)t12) ? 1 : 0;   		// In range? 
  arg5 = *(s32 *)arg5;   
  arg6 = (u8)(arg6 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read15859;

vma-memory-read15858:
  t3 = zero + 64;   
  t4 = t4 >> (arg6 & 63);   
  t3 = t3 >> (arg6 & 63);   
  if (t4 & 1)   
    goto vma-memory-read15861;

vma-memory-read15866:
  /* TagType. */
  t1 = arg6 & 63;
  t1 = t1 - Type_HeaderI;   
  if (t1 != 0)   
    goto arrayleaderiop;
  t8 = arg5 >> (Array_LeaderLengthFieldPos & 63);   
  t8 = t8 & Array_LeaderLengthFieldMask;
  t1 = ((u64)arg2 < (u64)t8) ? 1 : 0;   
  if (t1 == 0) 
    goto arrayleaderbounds;
  arg2 = arg4 - arg2;   
  arg2 = arg2 - 1;   
  /* Memory Read Internal */

vma-memory-read15867:
  t3 = arg2 + ivory;
  arg5 = (t3 * 4);   
  arg6 = LDQ_U(t3);   
  t1 = arg2 - t11;   		// Stack cache offset 
  t4 = *(u64 *)&(processor->dataread_mask);   
  t2 = ((u64)t1 < (u64)t12) ? 1 : 0;   		// In range? 
  arg5 = *(s32 *)arg5;   
  arg6 = (u8)(arg6 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read15869;

vma-memory-read15868:
  t3 = zero + 240;   
  t4 = t4 >> (arg6 & 63);   
  t3 = t3 >> (arg6 & 63);   
  if (t4 & 1)   
    goto vma-memory-read15871;

vma-memory-read15878:
  t1 = arg6 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

arrayleaderexception:
  if (_trace) printf("arrayleaderexception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;   
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 10;
  goto arrayexception;

arrayleaderiop:
  if (_trace) printf("arrayleaderiop:\n");
  arg5 = 0;
  arg2 = 10;
  goto illegaloperand;

arrayleaderbounds:
  if (_trace) printf("arrayleaderbounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;

DoArrayLeaderIM:
  if (_trace) printf("DoArrayLeaderIM:\n");
  arg4 = *(s32 *)iSP;   		// arg3=arraytag, arg4=arraydata 
  arg3 = *(s32 *)(iSP + 4);   		// arg3=arraytag, arg4=arraydata 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  goto arrayleadermerge;   

vma-memory-read15869:
  if (_trace) printf("vma-memory-read15869:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = (t1 * 8) + t2;  		// reconstruct SCA 
  arg5 = *(s32 *)t1;   
  arg6 = *(s32 *)(t1 + 4);   		// Read from stack cache 
  goto vma-memory-read15868;   

vma-memory-read15871:
  if (_trace) printf("vma-memory-read15871:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read15870;
  arg2 = (u32)arg5;   		// Do the indirect thing 
  goto vma-memory-read15867;   

vma-memory-read15870:
  if (_trace) printf("vma-memory-read15870:\n");
  t4 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = arg6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg2;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
  t4 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read15875:
  if (_trace) printf("vma-memory-read15875:\n");
  t3 = t4 & MemoryActionTransform;
  if (t3 == 0) 
    goto vma-memory-read15874;
  arg6 = arg6 & ~63L;
  arg6 = arg6 | Type_ExternalValueCellPointer;
  goto vma-memory-read15878;   

vma-memory-read15874:

vma-memory-read15873:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read15859:
  if (_trace) printf("vma-memory-read15859:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = (t1 * 8) + t2;  		// reconstruct SCA 
  arg5 = *(s32 *)t1;   
  arg6 = *(s32 *)(t1 + 4);   		// Read from stack cache 
  goto vma-memory-read15858;   

vma-memory-read15861:
  if (_trace) printf("vma-memory-read15861:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read15860;
  arg4 = (u32)arg5;   		// Do the indirect thing 
  goto vma-memory-read15857;   

vma-memory-read15860:
  if (_trace) printf("vma-memory-read15860:\n");
  t4 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = arg6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
  t4 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read15863:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoArrayLeader */
  /* End of Halfword operand from stack instruction - DoArrayLeader */
/* start DoStoreArrayLeader */

  /* Halfword operand from stack instruction - DoStoreArrayLeader */
  /* arg2 has the preloaded 8 bit operand. */

dostorearrayleader:
  if (_trace) printf("dostorearrayleader:\n");

DoStoreArrayLeaderSP:
  if (_trace) printf("DoStoreArrayLeaderSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoStoreArrayLeaderLP:
  if (_trace) printf("DoStoreArrayLeaderLP:\n");

DoStoreArrayLeaderFP:
  if (_trace) printf("DoStoreArrayLeaderFP:\n");

headdostorearrayleader:
  if (_trace) printf("headdostorearrayleader:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindostorearrayleader:
  if (_trace) printf("begindostorearrayleader:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   		// arg3=arraytag, arg4=arraydata 
  arg3 = *(s32 *)(iSP + 4);   		// arg3=arraytag, arg4=arraydata 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  t7 = *(s32 *)iSP;   		// t6=valuetag, t7=valuedata 
  t6 = *(s32 *)(iSP + 4);   		// t6=valuetag, t7=valuedata 
  iSP = iSP - 8;   		// Pop Stack. 
  t7 = (u32)t7;   
  arg2 = (u32)arg1;   		// index data 
  arg1 = arg1 >> 32;   		// index tag 
  t1 = arg1 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto storearrayleaderiop;

storearrayleadermerge:
  if (_trace) printf("storearrayleadermerge:\n");
  t1 = arg3 - Type_Array;   
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto storearrayleaderexception;
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read15879:
  t3 = arg4 + ivory;
  arg5 = (t3 * 4);   
  arg6 = LDQ_U(t3);   
  t1 = arg4 - t11;   		// Stack cache offset 
  t4 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t1 < (u64)t12) ? 1 : 0;   		// In range? 
  arg5 = *(s32 *)arg5;   
  arg6 = (u8)(arg6 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read15881;

vma-memory-read15880:
  t3 = zero + 64;   
  t4 = t4 >> (arg6 & 63);   
  t3 = t3 >> (arg6 & 63);   
  if (t4 & 1)   
    goto vma-memory-read15883;

vma-memory-read15888:
  /* TagType. */
  t1 = arg6 & 63;
  t1 = t1 - Type_HeaderI;   
  if (t1 != 0)   
    goto storearrayleaderiop;
  t2 = arg5 >> (Array_LeaderLengthFieldPos & 63);   
  t2 = t2 & Array_LeaderLengthFieldMask;
  t1 = ((u64)arg2 < (u64)t2) ? 1 : 0;   
  if (t1 == 0) 
    goto storearrayleaderbounds;
  arg2 = arg4 - arg2;   
  arg2 = arg2 - 1;   
  /* Memory Read Internal */

vma-memory-read15889:
  t5 = arg2 + ivory;
  t2 = (t5 * 4);   
  t1 = LDQ_U(t5);   
  t3 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->datawrite_mask);   
  t4 = ((u64)t3 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t5&7)*8));   
  if (t4 != 0)   
    goto vma-memory-read15891;

vma-memory-read15890:
  t5 = zero + 240;   
  t8 = t8 >> (t1 & 63);   
  t5 = t5 >> (t1 & 63);   
  if (t8 & 1)   
    goto vma-memory-read15893;

vma-memory-read15899:
  /* Merge cdr-code */
  t2 = t6 & 63;
  t1 = t1 & 192;
  t1 = t1 | t2;
  t3 = arg2 + ivory;
  t2 = (t3 * 4);   
  t5 = LDQ_U(t3);   
  t4 = arg2 - t11;   		// Stack cache offset 
  t8 = ((u64)t4 < (u64)t12) ? 1 : 0;   		// In range? 
  t4 = (t1 & 0xff) << ((t3&7)*8);   
  t5 = t5 & ~(0xffL << (t3&7)*8);   

force-alignment15901:
  if (_trace) printf("force-alignment15901:\n");
  t5 = t5 | t4;
  STQ_U(t3, t5);   
  *(u32 *)t2 = t7;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write15900;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

storearrayleaderexception:
  if (_trace) printf("storearrayleaderexception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;   
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 3;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 11;
  goto arrayexception;

storearrayleaderiop:
  if (_trace) printf("storearrayleaderiop:\n");
  arg5 = 0;
  arg2 = 11;
  goto illegaloperand;

storearrayleaderbounds:
  if (_trace) printf("storearrayleaderbounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;

DoStoreArrayLeaderIM:
  if (_trace) printf("DoStoreArrayLeaderIM:\n");
  arg4 = *(s32 *)iSP;   		// arg3=arraytag, arg4=arraydata 
  arg3 = *(s32 *)(iSP + 4);   		// arg3=arraytag, arg4=arraydata 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  t7 = *(s32 *)iSP;   		// t6=valuetag, t7=valuedata 
  t6 = *(s32 *)(iSP + 4);   		// t6=valuetag, t7=valuedata 
  iSP = iSP - 8;   		// Pop Stack. 
  t7 = (u32)t7;   
  goto storearrayleadermerge;   

vma-memory-write15900:
  if (_trace) printf("vma-memory-write15900:\n");
  t3 = *(u64 *)&(processor->stackcachedata);   
  t4 = arg2 - t11;   		// Stack cache offset 
  t3 = (t4 * 8) + t3;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t3 = t7;
		/* write the stack cache */
  *(u32 *)(t3 + 4) = t1;
  goto NEXTINSTRUCTION;   

vma-memory-read15891:
  if (_trace) printf("vma-memory-read15891:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t3 = (t3 * 8) + t4;  		// reconstruct SCA 
  t2 = *(s32 *)t3;   
  t1 = *(s32 *)(t3 + 4);   		// Read from stack cache 
  goto vma-memory-read15890;   

vma-memory-read15893:
  if (_trace) printf("vma-memory-read15893:\n");
  if ((t5 & 1) == 0)   
    goto vma-memory-read15892;
  arg2 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read15889;   

vma-memory-read15892:
  if (_trace) printf("vma-memory-read15892:\n");
  t8 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t5 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg2;   		// stash the VMA for the (likely) trap 
  t5 = (t5 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t5;   		// Get the memory action 

vma-memory-read15896:

vma-memory-read15895:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 1;
  goto performmemoryaction;

vma-memory-read15881:
  if (_trace) printf("vma-memory-read15881:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = (t1 * 8) + t2;  		// reconstruct SCA 
  arg5 = *(s32 *)t1;   
  arg6 = *(s32 *)(t1 + 4);   		// Read from stack cache 
  goto vma-memory-read15880;   

vma-memory-read15883:
  if (_trace) printf("vma-memory-read15883:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read15882;
  arg4 = (u32)arg5;   		// Do the indirect thing 
  goto vma-memory-read15879;   

vma-memory-read15882:
  if (_trace) printf("vma-memory-read15882:\n");
  t4 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = arg6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
  t4 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read15885:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoStoreArrayLeader */
  /* End of Halfword operand from stack instruction - DoStoreArrayLeader */
/* start DoAlocLeader */

  /* Halfword operand from stack instruction - DoAlocLeader */
  /* arg2 has the preloaded 8 bit operand. */

doalocleader:
  if (_trace) printf("doalocleader:\n");

DoAlocLeaderSP:
  if (_trace) printf("DoAlocLeaderSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoAlocLeaderLP:
  if (_trace) printf("DoAlocLeaderLP:\n");

DoAlocLeaderFP:
  if (_trace) printf("DoAlocLeaderFP:\n");

headdoalocleader:
  if (_trace) printf("headdoalocleader:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoalocleader:
  if (_trace) printf("begindoalocleader:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   		// arg3=arraytag, arg4=arraydata 
  arg3 = *(s32 *)(iSP + 4);   		// arg3=arraytag, arg4=arraydata 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  arg2 = (u32)arg1;   		// index data 
  arg1 = arg1 >> 32;   		// index tag 
  t1 = arg1 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto alocleaderiop;

alocleadermerge:
  if (_trace) printf("alocleadermerge:\n");
  t1 = arg3 - Type_Array;   
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto alocleaderexception;
  /* Memory Read Internal */

vma-memory-read15902:
  t1 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;   
  arg5 = (t3 * 4);   
  arg6 = LDQ_U(t3);   
  t1 = arg4 - t1;   		// Stack cache offset 
  t4 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;   		// In range? 
  arg5 = *(s32 *)arg5;   
  arg6 = (u8)(arg6 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read15904;

vma-memory-read15903:
  t3 = zero + 64;   
  t4 = t4 >> (arg6 & 63);   
  t3 = t3 >> (arg6 & 63);   
  if (t4 & 1)   
    goto vma-memory-read15906;

vma-memory-read15911:
  /* TagType. */
  t1 = arg6 & 63;
  t1 = t1 - Type_HeaderI;   
  if (t1 != 0)   
    goto alocleaderiop;
  t9 = arg5 >> (Array_LeaderLengthFieldPos & 63);   
  t9 = t9 & Array_LeaderLengthFieldMask;
  t1 = ((u64)arg2 < (u64)t9) ? 1 : 0;   
  if (t1 == 0) 
    goto alocleaderbounds;
  arg2 = arg4 - arg2;   
  arg2 = arg2 - 1;   
  t1 = Type_Locative;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

alocleaderexception:
  if (_trace) printf("alocleaderexception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;   
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 10;
  goto arrayexception;

alocleaderiop:
  if (_trace) printf("alocleaderiop:\n");
  arg5 = 0;
  arg2 = 10;
  goto illegaloperand;

alocleaderbounds:
  if (_trace) printf("alocleaderbounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;

DoAlocLeaderIM:
  if (_trace) printf("DoAlocLeaderIM:\n");
  arg4 = *(s32 *)iSP;   		// arg3=arraytag, arg4=arraydata 
  arg3 = *(s32 *)(iSP + 4);   		// arg3=arraytag, arg4=arraydata 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  goto alocleadermerge;   

vma-memory-read15904:
  if (_trace) printf("vma-memory-read15904:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = (t1 * 8) + t2;  		// reconstruct SCA 
  arg5 = *(s32 *)t1;   
  arg6 = *(s32 *)(t1 + 4);   		// Read from stack cache 
  goto vma-memory-read15903;   

vma-memory-read15906:
  if (_trace) printf("vma-memory-read15906:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read15905;
  arg4 = (u32)arg5;   		// Do the indirect thing 
  goto vma-memory-read15902;   

vma-memory-read15905:
  if (_trace) printf("vma-memory-read15905:\n");
  t4 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = arg6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
  t4 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read15908:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoAlocLeader */
  /* End of Halfword operand from stack instruction - DoAlocLeader */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunarra.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunmove.as
 ************************************************************************/

  /* Data movement. */
/* start DoPushNNils */

  /* Halfword operand from stack instruction - DoPushNNils */
  /* arg2 has the preloaded 8 bit operand. */

dopushnnils:
  if (_trace) printf("dopushnnils:\n");

DoPushNNilsSP:
  if (_trace) printf("DoPushNNilsSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPushNNilsLP:
  if (_trace) printf("DoPushNNilsLP:\n");

DoPushNNilsFP:
  if (_trace) printf("DoPushNNilsFP:\n");

headdopushnnils:
  if (_trace) printf("headdopushnnils:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindopushnnils:
  if (_trace) printf("begindopushnnils:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg2 = (u32)arg1;   		// Get the data 
  t1 = arg1 >> 32;   		// and the tag 
  t5 = t1 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto pushnnbadop;

DoPushNNilsIM:
  if (_trace) printf("DoPushNNilsIM:\n");
  t4 = *(s32 *)&processor->scovlimit;   		// Current stack cache limit (words) 
  t1 = zero + 128;   
  t2 = *(u64 *)&(processor->stackcachedata);   		// Alpha base of stack cache 
  t1 = t1 + arg2;		// Account for what we're about to push 
  t1 = (t1 * 8) + iSP;  		// SCA of desired end of cache 
  t2 = (t4 * 8) + t2;  		// SCA of current end of cache 
  t4 = ((s64)t1 <= (s64)t2) ? 1 : 0;   
  if (t4 == 0) 		// We're done if new SCA is within bounds 
    goto stackcacheoverflowhandler;
  arg6 = *(u64 *)&(processor->niladdress);   
  goto pushnnilsl2;   

pushnnilsl1:
  if (_trace) printf("pushnnilsl1:\n");
  *(u64 *)(iSP + 8) = arg6;   		// Push NIL 
  iSP = iSP + 8;
  arg2 = arg2 - 1;   

pushnnilsl2:
  if ((s64)arg2 > 0)   
    goto pushnnilsl1;
  goto NEXTINSTRUCTION;   

pushnnbadop:
  if (_trace) printf("pushnnbadop:\n");
  arg5 = 0;
  arg2 = 63;
  goto illegaloperand;

/* end DoPushNNils */
  /* End of Halfword operand from stack instruction - DoPushNNils */
/* start DoPushAddressSpRelative */

  /* Halfword operand from stack instruction - DoPushAddressSpRelative */
  /* arg2 has the preloaded 8 bit operand. */

dopushaddresssprelative:
  if (_trace) printf("dopushaddresssprelative:\n");

DoPushAddressSpRelativeIM:
  if (_trace) printf("DoPushAddressSpRelativeIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindopushaddresssprelative;   

DoPushAddressSpRelativeSP:
  if (_trace) printf("DoPushAddressSpRelativeSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPushAddressSpRelativeLP:
  if (_trace) printf("DoPushAddressSpRelativeLP:\n");

DoPushAddressSpRelativeFP:
  if (_trace) printf("DoPushAddressSpRelativeFP:\n");

headdopushaddresssprelative:
  if (_trace) printf("headdopushaddresssprelative:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindopushaddresssprelative:
  if (_trace) printf("begindopushaddresssprelative:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  t4 = *(u64 *)&(processor->restartsp);   		// SP before any popping 
  t1 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t6 = *(u64 *)&(processor->stackcachebasevma);   		// Base of the stack cache 
  t7 = *(u64 *)&(processor->stackcachedata);   		// THe stack cache data block 
  t2 = t1 & 63;		// Strip off any CDR code bits. 
  t3 = (t2 == Type_Fixnum) ? 1 : 0;   

force-alignment15917:
  if (_trace) printf("force-alignment15917:\n");
  if (t3 == 0) 
    goto basic-dispatch15914;
  /* Here if argument TypeFixnum */
  arg1 = (arg1 * 8) + 8;  
  t5 = t4 - arg1;   		// Compute stack relative pointer 
  t5 = t5 - t7;   		// Index into stack data 
  t5 = t5 >> 3;   		// Convert to word index 
  t5 = t6 + t5;		// Convert to an ivory word address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t6 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  goto cachevalid;   

basic-dispatch15914:
  if (_trace) printf("basic-dispatch15914:\n");
  /* Here for all other cases */
  arg5 = 0;
  arg2 = 63;
  goto illegaloperand;

basic-dispatch15913:
  if (_trace) printf("basic-dispatch15913:\n");

/* end DoPushAddressSpRelative */
  /* End of Halfword operand from stack instruction - DoPushAddressSpRelative */
/* start DoStackBlt */

  /* Halfword operand from stack instruction - DoStackBlt */
  /* arg2 has the preloaded 8 bit operand. */

dostackblt:
  if (_trace) printf("dostackblt:\n");

DoStackBltIM:
  if (_trace) printf("DoStackBltIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindostackblt;   

DoStackBltSP:
  if (_trace) printf("DoStackBltSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoStackBltLP:
  if (_trace) printf("DoStackBltLP:\n");

DoStackBltFP:
  if (_trace) printf("DoStackBltFP:\n");

headdostackblt:
  if (_trace) printf("headdostackblt:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindostackblt:
  if (_trace) printf("begindostackblt:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  t3 = *(s32 *)iSP;   		// Destination locative 
  t2 = *(s32 *)(iSP + 4);   		// Destination locative 
  iSP = iSP - 8;   		// Pop Stack. 
  t3 = (u32)t3;   
  t1 = (u32)arg1;   
  /* Convert VMA to stack cache address */
  t4 = *(u64 *)&(processor->stackcachebasevma);   
  arg1 = *(u64 *)&(processor->stackcachedata);   
  t4 = t1 - t4;   		// stack cache base relative offset 
  arg1 = (t4 * 8) + arg1;  		// reconstruct SCA 
  t4 = *(u64 *)&(processor->stackcachebasevma);   		// Base of the stack cache 
  t5 = *(u64 *)&(processor->stackcachetopvma);   		// End ofthe stack cache 
  t1 = *(u64 *)&(processor->stackcachedata);   		// THe stack cache data block 
  t6 = t3 - t4;   		// BAse of Stack Cache. 
  t7 = t3 - t5;   		// Top of Stack Cache. 
  if ((s64)t6 < 0)   		// J. if vma below stack cache 
    goto stkbltexc;
  if ((s64)t7 >= 0)   		// J. if vma above stack cache 
    goto stkbltexc;
  t6 = (t6 * 8) + t1;  		// Compute the stackcache address 
  goto stkbltloopend;   

stkbltloop:
  if (_trace) printf("stkbltloop:\n");
  arg1 = arg1 + 8;		// Advance Source 
  t6 = t6 + 8;		// Advance destination 

stkbltloopend:
  t1 = *(u64 *)arg1;   		// Read a word from the source 
  t4 = arg1 - iSP;   
  *(u64 *)t6 = t1;   		// copy the word 
  if (t4 != 0)   		// J. if sourse not stack top 
    goto stkbltloop;
  iSP = t6;		// Update the SP to point at the last written location 
  goto NEXTINSTRUCTION;   

stkbltexc:
  if (_trace) printf("stkbltexc:\n");
  arg5 = 0;
  arg2 = 73;
  goto illegaloperand;

/* end DoStackBlt */
  /* End of Halfword operand from stack instruction - DoStackBlt */
/* start DoStackBltAddress */

  /* Halfword operand from stack instruction - DoStackBltAddress */
  /* arg2 has the preloaded 8 bit operand. */

dostackbltaddress:
  if (_trace) printf("dostackbltaddress:\n");

DoStackBltAddressSP:
  if (_trace) printf("DoStackBltAddressSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoStackBltAddressLP:
  if (_trace) printf("DoStackBltAddressLP:\n");

DoStackBltAddressFP:
  if (_trace) printf("DoStackBltAddressFP:\n");

begindostackbltaddress:
  if (_trace) printf("begindostackbltaddress:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t3 = *(s32 *)iSP;   		// Destination locative 
  t2 = *(s32 *)(iSP + 4);   		// Destination locative 
  iSP = iSP - 8;   		// Pop Stack. 
  t3 = (u32)t3;   
  t4 = *(u64 *)&(processor->stackcachebasevma);   		// Base of the stack cache 
  t5 = *(u64 *)&(processor->stackcachetopvma);   		// End ofthe stack cache 
  t1 = *(u64 *)&(processor->stackcachedata);   		// THe stack cache data block 
  t6 = t3 - t4;   		// Base of Stack Cache. 
  t7 = t3 - t5;   		// Top of Stack Cache. 
  if ((s64)t6 < 0)   		// J. if vma below stack cache 
    goto stkbltadrexc;
  if ((s64)t7 >= 0)   		// J. if vma above stack cache 
    goto stkbltadrexc;
  t6 = (t6 * 8) + t1;  		// Compute the stackcache address 
  goto stkbltaddloopend;   

stkbltaddloop:
  if (_trace) printf("stkbltaddloop:\n");
  arg1 = arg1 + 8;		// Advance Source 
  t6 = t6 + 8;		// Advance destination 

stkbltaddloopend:
  t1 = *(u64 *)arg1;   		// Read a word from the source 
  t4 = arg1 - iSP;   
  *(u64 *)t6 = t1;   		// copy the word 
  if (t4 != 0)   		// J. if sourse not stack top 
    goto stkbltaddloop;
  iSP = t6;		// Update the SP to point at the last written location 
  goto NEXTINSTRUCTION;   

stkbltadrexc:
  if (_trace) printf("stkbltadrexc:\n");
  arg5 = 0;
  arg2 = 73;
  goto illegaloperand;

DoStackBltAddressIM:
  goto doistageerror;

/* end DoStackBltAddress */
  /* End of Halfword operand from stack instruction - DoStackBltAddress */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunmove.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunpred.as
 ************************************************************************/

  /* Predicates. */
/* start DoEql */

  /* Halfword operand from stack instruction - DoEql */
  /* arg2 has the preloaded 8 bit operand. */

doeql:
  if (_trace) printf("doeql:\n");

DoEqlSP:
  if (_trace) printf("DoEqlSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoEqlLP:
  if (_trace) printf("DoEqlLP:\n");

DoEqlFP:
  if (_trace) printf("DoEqlFP:\n");

headdoeql:
  if (_trace) printf("headdoeql:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoeql:
  if (_trace) printf("begindoeql:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg6 = arg3 >> 12;   
  t3 = *(u64 *)iSP;   		// Load arg1 into t3 
  t4 = zero + -2048;   		// Low part of EQ-NOT-EQL mask 
  t11 = *(u64 *)&(processor->niladdress);   
  t4 = t4 + ((1) << 16);   		// High part of EQ-NOT-EQL mask 
  t12 = *(u64 *)&(processor->taddress);   		// Assume result will be T 
  t5 = arg1 ^ t3;   
  t5 = t5 << 26;   		// Shift left to lose CDRCODE. 
  arg6 = arg6 & 1;		// 1 if no-pop, 0 if pop 
  if (t5 == 0) 
    goto eqldone;
  /* They are not EQ, if types different or not numeric return nil */
  t5 = t5 >> 58;   		// Get the tag alone 
  t12 = t11;		// Now assume result will be NIL 
  if (t5 != 0)   		// Return NIL if tags different 
    goto eqldone;
  t3 = t3 >> 32;   		// Get tag, check for numeric 
  /* TagType. */
  t3 = t3 & 63;
  t4 = t4 >> (t3 & 63);   		// Type is now a bit mask 
  if (t4 & 1)   		// If funny numeric type, exception 
    goto eqlexc;

eqldone:
  if (_trace) printf("eqldone:\n");
  iSP = (arg6 * 8) + iSP;  		// Either a stack-push or a stack-write 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)iSP = t12;   
  goto cachevalid;   

DoEqlIM:
  if (_trace) printf("DoEqlIM:\n");
  arg2 = arg2 << 56;   
  t4 = *(s32 *)(iSP + 4);   		// t4=tag t3=data 
  t3 = *(s32 *)iSP;   
  arg6 = arg3 >> 12;   
  arg2 = (s64)arg2 >> 56;   		// Sign extension of arg2 is complete 
  t3 = (u32)t3;   
  t11 = *(u64 *)&(processor->niladdress);   
  /* TagType. */
  t4 = t4 & 63;
  t12 = *(u64 *)&(processor->taddress);   
  arg2 = (s32)t3 - (s32)arg2;   
  t4 = t4 ^ Type_Fixnum;   
  arg6 = arg6 & 1;		// 1 if no-pop, 0 if pop 
  t4 = arg2 | t4;
  iSP = (arg6 * 8) + iSP;  		// Either a stack-push or a stack-write 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t4 == 0)   
    t11 = t12;
  *(u64 *)iSP = t11;   		// Yes Virginia, this does dual issue with above 
  goto cachevalid;   

eqlexc:
  if (_trace) printf("eqlexc:\n");
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto exception;

/* end DoEql */
  /* End of Halfword operand from stack instruction - DoEql */
/* start DoGreaterp */

  /* Halfword operand from stack instruction - DoGreaterp */
  /* arg2 has the preloaded 8 bit operand. */

dogreaterp:
  if (_trace) printf("dogreaterp:\n");

DoGreaterpSP:
  if (_trace) printf("DoGreaterpSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindogreaterp;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoGreaterpLP:
  if (_trace) printf("DoGreaterpLP:\n");

DoGreaterpFP:
  if (_trace) printf("DoGreaterpFP:\n");

begindogreaterp:
  if (_trace) printf("begindogreaterp:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->niladdress);   
  t7 = arg3 >> 12;   
  t12 = *(u64 *)&(processor->taddress);   
  arg3 = (u32)(arg6 >> ((4&7)*8));   		// Get ARG1 tag 
  t1 = *(s32 *)(arg1 + 4);   		// t1 is tag of arg2 
  LDS(1, f1, *(u32 *)iSP );   
  t7 = t7 & 1;
  arg2 = *(s32 *)arg1;   
  arg4 = (s32)arg6;
  LDS(2, f2, *(u32 *)arg1 );   
  t5 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_Fixnum) ? 1 : 0;   

force-alignment15935:
  if (_trace) printf("force-alignment15935:\n");
  if (t6 == 0) 
    goto basic-dispatch15923;
  /* Here if argument TypeFixnum */
  t3 = (t4 == Type_Fixnum) ? 1 : 0;   

force-alignment15927:
  if (_trace) printf("force-alignment15927:\n");
  if (t3 == 0) 
    goto binary-type-dispatch15918;
  /* Here if argument TypeFixnum */
  t2 = arg4 - arg2;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  		// Pop/No-pop 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if ((s64)t2 > 0)   		// T if the test succeeds 
    t11 = t12;
  *(u64 *)iSP = t11;   
  goto cachevalid;   

basic-dispatch15924:
  if (_trace) printf("basic-dispatch15924:\n");

basic-dispatch15923:
  if (_trace) printf("basic-dispatch15923:\n");
  t6 = (t5 == Type_SingleFloat) ? 1 : 0;   

force-alignment15936:
  if (_trace) printf("force-alignment15936:\n");
  if (t6 == 0) 
    goto basic-dispatch15928;
  /* Here if argument TypeSingleFloat */
  t3 = (t4 == Type_SingleFloat) ? 1 : 0;   

force-alignment15932:
  if (_trace) printf("force-alignment15932:\n");
  if (t3 == 0) 
    goto binary-type-dispatch15918;
  /* Here if argument TypeSingleFloat */

greaterpmmexcfltflt:
  if (_trace) printf("greaterpmmexcfltflt:\n");
  SETFLTT(3,f3, FLTU64(1,f1) <= FLTU64(2,f2) ? 2.0:0);  
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)iSP = t12;   
  if (FLTU64(3, f3) == 0.0)   
    goto cachevalid;
  *(u64 *)iSP = t11;   		// Didn't branch, answer is NIL 
  goto cachevalid;   

basic-dispatch15929:
  if (_trace) printf("basic-dispatch15929:\n");

basic-dispatch15928:
  if (_trace) printf("basic-dispatch15928:\n");
  /* Here for all other cases */

binary-type-dispatch15918:
  if (_trace) printf("binary-type-dispatch15918:\n");
  goto greaterpmmexc;   

basic-dispatch15922:
  if (_trace) printf("basic-dispatch15922:\n");

DoGreaterpIM:
  if (_trace) printf("DoGreaterpIM:\n");
  t11 = *(u64 *)&(processor->niladdress);   
  arg2 = arg2 << 56;   		// First half of sign extension 
  t12 = *(u64 *)&(processor->taddress);   
  t7 = arg3 >> 12;   
  arg3 = (u32)(arg6 >> ((4&7)*8));   
  arg4 = (s32)arg6;
  arg2 = (s64)arg2 >> 56;   		// Second half of sign extension 
  t7 = t7 & 1;
  t3 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = (t3 == Type_Fixnum) ? 1 : 0;   

force-alignment15941:
  if (_trace) printf("force-alignment15941:\n");
  if (t4 == 0) 
    goto basic-dispatch15938;
  /* Here if argument TypeFixnum */
  t2 = arg4 - arg2;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if ((s64)t2 > 0)   		// T if the test succeeds 
    t11 = t12;
  *(u64 *)iSP = t11;   
  goto cachevalid;   

basic-dispatch15938:
  if (_trace) printf("basic-dispatch15938:\n");
  /* Here for all other cases */
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

basic-dispatch15937:
  if (_trace) printf("basic-dispatch15937:\n");

/* end DoGreaterp */
  /* End of Halfword operand from stack instruction - DoGreaterp */
/* start DoLogtest */

  /* Halfword operand from stack instruction - DoLogtest */
  /* arg2 has the preloaded 8 bit operand. */

dologtest:
  if (_trace) printf("dologtest:\n");

DoLogtestSP:
  if (_trace) printf("DoLogtestSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindologtest;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoLogtestLP:
  if (_trace) printf("DoLogtestLP:\n");

DoLogtestFP:
  if (_trace) printf("DoLogtestFP:\n");

begindologtest:
  if (_trace) printf("begindologtest:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t11 = *(u64 *)&(processor->niladdress);   
  t7 = arg3 >> 12;   
  t12 = *(u64 *)&(processor->taddress);   
  arg3 = (u32)(arg6 >> ((4&7)*8));   		// Get ARG1 tag 
  arg2 = *(s32 *)arg1;   
  LDS(1, f1, *(u32 *)iSP );   
  t7 = t7 & 1;
  t1 = *(s32 *)(arg1 + 4);   		// t1 is tag of arg2 
  arg4 = (u32)arg6;   
  arg2 = (u32)arg2;   
  LDS(2, f2, *(u32 *)arg1 );   
  t5 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_Fixnum) ? 1 : 0;   

force-alignment15954:
  if (_trace) printf("force-alignment15954:\n");
  if (t6 == 0) 
    goto basic-dispatch15947;
  /* Here if argument TypeFixnum */
  t3 = (t4 == Type_Fixnum) ? 1 : 0;   

force-alignment15951:
  if (_trace) printf("force-alignment15951:\n");
  if (t3 == 0) 
    goto binary-type-dispatch15944;
  /* Here if argument TypeFixnum */
  t2 = arg4 & arg2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  		// Pop/No-pop 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t2)   		// T if the test succeeds 
    t11 = t12;
  *(u64 *)iSP = t11;   
  goto cachevalid;   

basic-dispatch15948:
  if (_trace) printf("basic-dispatch15948:\n");

basic-dispatch15947:
  if (_trace) printf("basic-dispatch15947:\n");
  /* Here for all other cases */

binary-type-dispatch15943:
  if (_trace) printf("binary-type-dispatch15943:\n");
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch15945;   

binary-type-dispatch15944:
  if (_trace) printf("binary-type-dispatch15944:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

binary-type-dispatch15945:
  if (_trace) printf("binary-type-dispatch15945:\n");

basic-dispatch15946:
  if (_trace) printf("basic-dispatch15946:\n");

DoLogtestIM:
  if (_trace) printf("DoLogtestIM:\n");
  t11 = *(u64 *)&(processor->niladdress);   
  arg2 = arg2 << 56;   		// First half of sign extension 
  t12 = *(u64 *)&(processor->taddress);   
  t7 = arg3 >> 12;   
  arg3 = (u32)(arg6 >> ((4&7)*8));   
  arg4 = (s32)arg6;
  arg2 = (s64)arg2 >> 56;   		// Second half of sign extension 
  t7 = t7 & 1;
  t3 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = (t3 == Type_Fixnum) ? 1 : 0;   

force-alignment15959:
  if (_trace) printf("force-alignment15959:\n");
  if (t4 == 0) 
    goto basic-dispatch15956;
  /* Here if argument TypeFixnum */
  t2 = arg4 & arg2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iSP = (t7 * 8) + iSP;  
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (t2)   		// T if the test succeeds 
    t11 = t12;
  *(u64 *)iSP = t11;   
  goto cachevalid;   

basic-dispatch15956:
  if (_trace) printf("basic-dispatch15956:\n");
  /* Here for all other cases */
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

basic-dispatch15955:
  if (_trace) printf("basic-dispatch15955:\n");

/* end DoLogtest */
  /* End of Halfword operand from stack instruction - DoLogtest */
/* start EqualNumberMMExc */


equalnumbermmexc:
  if (_trace) printf("equalnumbermmexc:\n");
  t5 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_Fixnum) ? 1 : 0;   

force-alignment15977:
  if (_trace) printf("force-alignment15977:\n");
  if (t6 == 0) 
    goto basic-dispatch15965;
  /* Here if argument TypeFixnum */
  t3 = (t4 == Type_SingleFloat) ? 1 : 0;   

force-alignment15969:
  if (_trace) printf("force-alignment15969:\n");
  if (t3 == 0) 
    goto binary-type-dispatch15962;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto equalnumbermmexcfltflt;   

basic-dispatch15966:
  if (_trace) printf("basic-dispatch15966:\n");

basic-dispatch15965:
  if (_trace) printf("basic-dispatch15965:\n");
  t6 = (t5 == Type_SingleFloat) ? 1 : 0;   

force-alignment15978:
  if (_trace) printf("force-alignment15978:\n");
  if (t6 == 0) 
    goto basic-dispatch15970;
  /* Here if argument TypeSingleFloat */
  t3 = (t4 == Type_Fixnum) ? 1 : 0;   

force-alignment15974:
  if (_trace) printf("force-alignment15974:\n");
  if (t3 == 0) 
    goto binary-type-dispatch15962;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto equalnumbermmexcfltflt;   

basic-dispatch15971:
  if (_trace) printf("basic-dispatch15971:\n");

basic-dispatch15970:
  if (_trace) printf("basic-dispatch15970:\n");
  /* Here for all other cases */

binary-type-dispatch15961:
  if (_trace) printf("binary-type-dispatch15961:\n");
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch15963;   

binary-type-dispatch15962:
  if (_trace) printf("binary-type-dispatch15962:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

binary-type-dispatch15963:
  if (_trace) printf("binary-type-dispatch15963:\n");

basic-dispatch15964:
  if (_trace) printf("basic-dispatch15964:\n");

/* end EqualNumberMMExc */
/* start LesspMMExc */


lesspmmexc:
  if (_trace) printf("lesspmmexc:\n");
  t5 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_Fixnum) ? 1 : 0;   

force-alignment15996:
  if (_trace) printf("force-alignment15996:\n");
  if (t6 == 0) 
    goto basic-dispatch15984;
  /* Here if argument TypeFixnum */
  t3 = (t4 == Type_SingleFloat) ? 1 : 0;   

force-alignment15988:
  if (_trace) printf("force-alignment15988:\n");
  if (t3 == 0) 
    goto binary-type-dispatch15981;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto lesspmmexcfltflt;   

basic-dispatch15985:
  if (_trace) printf("basic-dispatch15985:\n");

basic-dispatch15984:
  if (_trace) printf("basic-dispatch15984:\n");
  t6 = (t5 == Type_SingleFloat) ? 1 : 0;   

force-alignment15997:
  if (_trace) printf("force-alignment15997:\n");
  if (t6 == 0) 
    goto basic-dispatch15989;
  /* Here if argument TypeSingleFloat */
  t3 = (t4 == Type_Fixnum) ? 1 : 0;   

force-alignment15993:
  if (_trace) printf("force-alignment15993:\n");
  if (t3 == 0) 
    goto binary-type-dispatch15981;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto lesspmmexcfltflt;   

basic-dispatch15990:
  if (_trace) printf("basic-dispatch15990:\n");

basic-dispatch15989:
  if (_trace) printf("basic-dispatch15989:\n");
  /* Here for all other cases */

binary-type-dispatch15980:
  if (_trace) printf("binary-type-dispatch15980:\n");
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch15982;   

binary-type-dispatch15981:
  if (_trace) printf("binary-type-dispatch15981:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

binary-type-dispatch15982:
  if (_trace) printf("binary-type-dispatch15982:\n");

basic-dispatch15983:
  if (_trace) printf("basic-dispatch15983:\n");

/* end LesspMMExc */
/* start GreaterpMMExc */


greaterpmmexc:
  if (_trace) printf("greaterpmmexc:\n");
  t5 = arg3 & 63;		// Strip off any CDR code bits. 
  t4 = t1 & 63;		// Strip off any CDR code bits. 
  t6 = (t5 == Type_Fixnum) ? 1 : 0;   

force-alignment16015:
  if (_trace) printf("force-alignment16015:\n");
  if (t6 == 0) 
    goto basic-dispatch16003;
  /* Here if argument TypeFixnum */
  t3 = (t4 == Type_SingleFloat) ? 1 : 0;   

force-alignment16007:
  if (_trace) printf("force-alignment16007:\n");
  if (t3 == 0) 
    goto binary-type-dispatch16000;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto greaterpmmexcfltflt;   

basic-dispatch16004:
  if (_trace) printf("basic-dispatch16004:\n");

basic-dispatch16003:
  if (_trace) printf("basic-dispatch16003:\n");
  t6 = (t5 == Type_SingleFloat) ? 1 : 0;   

force-alignment16016:
  if (_trace) printf("force-alignment16016:\n");
  if (t6 == 0) 
    goto basic-dispatch16008;
  /* Here if argument TypeSingleFloat */
  t3 = (t4 == Type_Fixnum) ? 1 : 0;   

force-alignment16012:
  if (_trace) printf("force-alignment16012:\n");
  if (t3 == 0) 
    goto binary-type-dispatch16000;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto greaterpmmexcfltflt;   

basic-dispatch16009:
  if (_trace) printf("basic-dispatch16009:\n");

basic-dispatch16008:
  if (_trace) printf("basic-dispatch16008:\n");
  /* Here for all other cases */

binary-type-dispatch15999:
  if (_trace) printf("binary-type-dispatch15999:\n");
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch16001;   

binary-type-dispatch16000:
  if (_trace) printf("binary-type-dispatch16000:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

binary-type-dispatch16001:
  if (_trace) printf("binary-type-dispatch16001:\n");

basic-dispatch16002:
  if (_trace) printf("basic-dispatch16002:\n");

/* end GreaterpMMExc */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunpred.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunsubp.as
 ************************************************************************/

  /* Subprimitives. */
/* start DoEphemeralp */

  /* Halfword operand from stack instruction - DoEphemeralp */

doephemeralp:
  if (_trace) printf("doephemeralp:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoEphemeralpIM:
  if (_trace) printf("DoEphemeralpIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment16017:
  if (_trace) printf("force-alignment16017:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoephemeralp;   

DoEphemeralpSP:
  if (_trace) printf("DoEphemeralpSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoEphemeralpLP:
  if (_trace) printf("DoEphemeralpLP:\n");

DoEphemeralpFP:
  if (_trace) printf("DoEphemeralpFP:\n");

headdoephemeralp:
  if (_trace) printf("headdoephemeralp:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoephemeralp:
  if (_trace) printf("begindoephemeralp:\n");
  /* arg1 has the operand, sign extended if immediate. */
  t1 = *(u64 *)&(processor->ptrtype);   		// ptr type array 
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  /* TagType. */
  arg2 = arg2 & 63;
  t2 = (arg2 * 4) + t1;   
  arg1 = arg1 >> 27;   
  t3 = *(s32 *)t2;   		// =0 if not a pointer 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (arg1 != 0)   		// J. if zone not ephemeral 
    goto nonephem;
  if (t3 == 0) 		// J. if not a pointer 
    goto nonephem;
  t6 = *(u64 *)&(processor->taddress);   
  *(u64 *)(iSP + 8) = t6;   		// push the data 
  iSP = iSP + 8;
  goto cachevalid;   

nonephem:
  if (_trace) printf("nonephem:\n");
  t6 = *(u64 *)&(processor->niladdress);   
  *(u64 *)(iSP + 8) = t6;   		// push the data 
  iSP = iSP + 8;
  goto cachevalid;   

/* end DoEphemeralp */
  /* End of Halfword operand from stack instruction - DoEphemeralp */
/* start DoUnsignedLessp */

  /* Halfword operand from stack instruction - DoUnsignedLessp */
  /* arg2 has the preloaded 8 bit operand. */

dounsignedlessp:
  if (_trace) printf("dounsignedlessp:\n");

DoUnsignedLesspSP:
  if (_trace) printf("DoUnsignedLesspSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoUnsignedLesspLP:
  if (_trace) printf("DoUnsignedLesspLP:\n");

DoUnsignedLesspFP:
  if (_trace) printf("DoUnsignedLesspFP:\n");

headdounsignedlessp:
  if (_trace) printf("headdounsignedlessp:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindounsignedlessp:
  if (_trace) printf("begindounsignedlessp:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  t2 = *(s32 *)iSP;   		// Get data from arg1 
  arg3 = arg3 >> 12;   
  t11 = *(u64 *)&(processor->niladdress);   
  t4 = (u32)arg1;   		// Get unsigned data from arg2 
  t12 = *(u64 *)&(processor->taddress);   
  arg3 = arg3 & 1;		// 1 if no-pop, 0 if pop 
  t2 = (u32)t2;   		// Unsigned arg1 
  iSP = (arg3 * 8) + iSP;  		// Either a stack-push or a stack-write 
  t6 = t4 - t2;   		// t6:=arg2-arg1 unsigned 
  if ((s64)t6 > 0)   
    t11 = t12;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)iSP = t11;   
  goto cachevalid;   

DoUnsignedLesspIM:
  if (_trace) printf("DoUnsignedLesspIM:\n");
  t2 = *(s32 *)iSP;   		// Get data from arg1 
  arg3 = arg3 >> 12;   
  t11 = *(u64 *)&(processor->niladdress);   
  t2 = (u32)t2;   		// ... 
  t12 = *(u64 *)&(processor->taddress);   
  arg3 = arg3 & 1;		// 1 if no-pop, 0 if pop 
  t6 = arg2 - t2;   		// t6:=arg2-arg1 unsigned 
  iSP = (arg3 * 8) + iSP;  		// Either a stack-push or a stack-write 
  if ((s64)t6 > 0)   
    t11 = t12;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u64 *)iSP = t11;   
  goto cachevalid;   

/* end DoUnsignedLessp */
  /* End of Halfword operand from stack instruction - DoUnsignedLessp */
/* start DoAllocateListBlock */

  /* Halfword operand from stack instruction - DoAllocateListBlock */
  /* arg2 has the preloaded 8 bit operand. */

doallocatelistblock:
  if (_trace) printf("doallocatelistblock:\n");

DoAllocateListBlockIM:
  if (_trace) printf("DoAllocateListBlockIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoallocatelistblock;   

DoAllocateListBlockSP:
  if (_trace) printf("DoAllocateListBlockSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoAllocateListBlockLP:
  if (_trace) printf("DoAllocateListBlockLP:\n");

DoAllocateListBlockFP:
  if (_trace) printf("DoAllocateListBlockFP:\n");

headdoallocatelistblock:
  if (_trace) printf("headdoallocatelistblock:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoallocatelistblock:
  if (_trace) printf("begindoallocatelistblock:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  t1 = *(u64 *)&(processor->lcarea);   
  arg3 = *(u64 *)iSP;   
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t5 = arg2 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto i%allocate-block16018;
  t4 = *(s32 *)&processor->lclength;   
  t2 = (arg3 == t1) ? 1 : 0;   
  if (t2 == 0) 		// Wrong area 
    goto i%allocate-block16019;
  t2 = t4 - arg1;   		// Effectively an unsigned 32-bit compare 
  if ((s64)t2 < 0)   		// Insufficient cache 
    goto i%allocate-block16019;
  t1 = *(u64 *)&(processor->lcaddress);   		// Fetch address 
  t3 = (-16384) << 16;   
  t3 = (u32)t3;   
		/* Store remaining length */
  *(u32 *)&processor->lclength = t2;
  *(u64 *)iSP = t1;   		// Cache address/tag -> TOS 
		/* Cache address -> BAR1 */
  *(u32 *)&processor->bar1 = t1;
  t1 = (u32)t1;   
  t4 = *(s32 *)&processor->control;   		// Verify trap mode 
  t1 = t1 + arg1;		// Increment address 
		/* Store updated address */
  *(u32 *)&processor->lcaddress = t1;
  t3 = t3 & t4;
  if (t3 != 0)   		// Already above emulator mode 
    goto NEXTINSTRUCTION;
  t3 = (16384) << 16;   
  t4 = t4 | t3;
  *(u32 *)&processor->control = t4;
  goto NEXTINSTRUCTION;   

i%allocate-block16018:
  if (_trace) printf("i%allocate-block16018:\n");
  arg5 = 0;
  arg2 = 1;
  goto illegaloperand;

i%allocate-block16019:
  if (_trace) printf("i%allocate-block16019:\n");
  /* SetTag. */
  t1 = arg2 << 32;   
  t1 = arg1 | t1;
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

/* end DoAllocateListBlock */
  /* End of Halfword operand from stack instruction - DoAllocateListBlock */
/* start DoAllocateStructureBlock */

  /* Halfword operand from stack instruction - DoAllocateStructureBlock */
  /* arg2 has the preloaded 8 bit operand. */

doallocatestructureblock:
  if (_trace) printf("doallocatestructureblock:\n");

DoAllocateStructureBlockIM:
  if (_trace) printf("DoAllocateStructureBlockIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoallocatestructureblock;   

DoAllocateStructureBlockSP:
  if (_trace) printf("DoAllocateStructureBlockSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoAllocateStructureBlockLP:
  if (_trace) printf("DoAllocateStructureBlockLP:\n");

DoAllocateStructureBlockFP:
  if (_trace) printf("DoAllocateStructureBlockFP:\n");

headdoallocatestructureblock:
  if (_trace) printf("headdoallocatestructureblock:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoallocatestructureblock:
  if (_trace) printf("begindoallocatestructureblock:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  t1 = *(u64 *)&(processor->scarea);   
  arg3 = *(u64 *)iSP;   
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t5 = arg2 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto i%allocate-block16020;
  t4 = *(s32 *)&processor->sclength;   
  t2 = (arg3 == t1) ? 1 : 0;   
  if (t2 == 0) 		// Wrong area 
    goto i%allocate-block16021;
  t2 = t4 - arg1;   		// Effectively an unsigned 32-bit compare 
  if ((s64)t2 < 0)   		// Insufficient cache 
    goto i%allocate-block16021;
  t1 = *(u64 *)&(processor->scaddress);   		// Fetch address 
  t3 = (-16384) << 16;   
  t3 = (u32)t3;   
		/* Store remaining length */
  *(u32 *)&processor->sclength = t2;
  *(u64 *)iSP = t1;   		// Cache address/tag -> TOS 
		/* Cache address -> BAR1 */
  *(u32 *)&processor->bar1 = t1;
  t1 = (u32)t1;   
  t4 = *(s32 *)&processor->control;   		// Verify trap mode 
  t1 = t1 + arg1;		// Increment address 
		/* Store updated address */
  *(u32 *)&processor->scaddress = t1;
  t3 = t3 & t4;
  if (t3 != 0)   		// Already above emulator mode 
    goto NEXTINSTRUCTION;
  t3 = (16384) << 16;   
  t4 = t4 | t3;
  *(u32 *)&processor->control = t4;
  goto NEXTINSTRUCTION;   

i%allocate-block16020:
  if (_trace) printf("i%allocate-block16020:\n");
  arg5 = 0;
  arg2 = 1;
  goto illegaloperand;

i%allocate-block16021:
  if (_trace) printf("i%allocate-block16021:\n");
  /* SetTag. */
  t1 = arg2 << 32;   
  t1 = arg1 | t1;
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

/* end DoAllocateStructureBlock */
  /* End of Halfword operand from stack instruction - DoAllocateStructureBlock */
/* start DoPointerDifference */

  /* Halfword operand from stack instruction - DoPointerDifference */
  /* arg2 has the preloaded 8 bit operand. */

dopointerdifference:
  if (_trace) printf("dopointerdifference:\n");

DoPointerDifferenceSP:
  if (_trace) printf("DoPointerDifferenceSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPointerDifferenceLP:
  if (_trace) printf("DoPointerDifferenceLP:\n");

DoPointerDifferenceFP:
  if (_trace) printf("DoPointerDifferenceFP:\n");

headdopointerdifference:
  if (_trace) printf("headdopointerdifference:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindopointerdifference:
  if (_trace) printf("begindopointerdifference:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  t1 = *(s32 *)iSP;   		// Get the data of ARG1 
  t2 = (u32)arg1;   		// Get the data of ARG2 
  t3 = (s32)t1 - (s32)t2;   		// (%32-bit-difference (data arg1) (data arg2)) 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t4 = Type_Fixnum;
		/* Save result and coerce to a FIXNUM */
  *(u32 *)iSP = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;   

DoPointerDifferenceIM:
  if (_trace) printf("DoPointerDifferenceIM:\n");
  t2 = arg2 << 56;   
  t1 = *(s32 *)iSP;   		// Get the data of arg1 
  t2 = (s64)t2 >> 56;   
  t3 = (s32)t1 - (s32)t2;   		// (%32-bit-difference (data arg1) (data arg2)) 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t4 = Type_Fixnum;
		/* Save result and coerce to a FIXNUM */
  *(u32 *)iSP = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;   

/* end DoPointerDifference */
  /* End of Halfword operand from stack instruction - DoPointerDifference */
/* start DoPointerIncrement */

  /* Halfword operand from stack instruction - DoPointerIncrement */
  /* arg2 has the preloaded 8 bit operand. */

dopointerincrement:
  if (_trace) printf("dopointerincrement:\n");

DoPointerIncrementSP:
  if (_trace) printf("DoPointerIncrementSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPointerIncrementLP:
  if (_trace) printf("DoPointerIncrementLP:\n");

DoPointerIncrementFP:
  if (_trace) printf("DoPointerIncrementFP:\n");

begindopointerincrement:
  if (_trace) printf("begindopointerincrement:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t2 = *(s32 *)arg1;   		// Get the data of arg2 
  t3 = (s32)t2 + (s32)1;		// (%32-bit-plus (data arg1) 1) 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
		/* Put result back */
  *(u32 *)arg1 = t3;
  goto cachevalid;   

DoPointerIncrementIM:
  goto doistageerror;

/* end DoPointerIncrement */
  /* End of Halfword operand from stack instruction - DoPointerIncrement */
/* start DoStoreConditional */

  /* Halfword operand from stack instruction - DoStoreConditional */

dostoreconditional:
  if (_trace) printf("dostoreconditional:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoStoreConditionalIM:
  if (_trace) printf("DoStoreConditionalIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment16038:
  if (_trace) printf("force-alignment16038:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindostoreconditional;   

DoStoreConditionalSP:
  if (_trace) printf("DoStoreConditionalSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoStoreConditionalLP:
  if (_trace) printf("DoStoreConditionalLP:\n");

DoStoreConditionalFP:
  if (_trace) printf("DoStoreConditionalFP:\n");

headdostoreconditional:
  if (_trace) printf("headdostoreconditional:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindostoreconditional:
  if (_trace) printf("begindostoreconditional:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg2 = arg1 >> 32;   
  arg4 = *(s32 *)iSP;   		// old tag and data 
  arg3 = *(s32 *)(iSP + 4);   		// old tag and data 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  arg1 = (u32)arg1;   
  arg6 = *(s32 *)iSP;   		// address tag and data 
  arg5 = *(s32 *)(iSP + 4);   		// address tag and data 
  iSP = iSP - 8;   		// Pop Stack. 
  arg6 = (u32)arg6;   
  /* TagType. */
  t1 = arg5 & 63;
  t2 = t1 - Type_Locative;   
  t2 = t2 & 63;		// Strip CDR code 
  if (t2 != 0)   
    goto storecondiop;
  /* Read the location, checking write access */
  /* Memory Read Internal */

vma-memory-read16022:
  t1 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t3 = arg6 + ivory;
  t2 = *(s32 *)&processor->scovlimit;   
  t5 = (t3 * 4);   
  t4 = LDQ_U(t3);   
  t1 = arg6 - t1;   		// Stack cache offset 
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read16024;

vma-memory-read16023:
  t1 = *(u64 *)&(processor->dataread_mask);   
  t3 = zero + 240;   
  t1 = t1 >> (t4 & 63);   
  t3 = t3 >> (t4 & 63);   
  if (t1 & 1)   
    goto vma-memory-read16026;

vma-memory-read16033:
  t1 = (s32)arg4 - (s32)t5;   		// Check for data match - NOT 
  t2 = arg3 ^ t4;   		// Zero if tags match 
  if (t1 != 0)   		// Jump if data didn't match 
    goto storecondnil;
  /* TagType. */
  t2 = t2 & 63;		// Stip result of comparing CDR-CODEs 
  if (t2 != 0)   		// Jump if tags don't match 
    goto storecondnil;
  t1 = arg2 & 63;		// Strip CDR-CODE 
  t4 = t4 & 192;		// Retain CDR-CODE 
  t4 = t1 | t4;		// Merge new tag with old CDR-CODE 
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  t1 = arg6 + ivory;
  t6 = *(s32 *)&processor->scovlimit;   
  t5 = (t1 * 4);   
  t3 = LDQ_U(t1);   
  t2 = arg6 - t2;   		// Stack cache offset 
  t6 = ((u64)t2 < (u64)t6) ? 1 : 0;   		// In range? 
  t2 = (t4 & 0xff) << ((t1&7)*8);   
  t3 = t3 & ~(0xffL << (t1&7)*8);   

force-alignment16036:
  if (_trace) printf("force-alignment16036:\n");
  t3 = t3 | t2;
  STQ_U(t1, t3);   
  *(u32 *)t5 = arg1;
  if (t6 != 0)   		// J. if in cache 
    goto vma-memory-write16035;

vma-memory-write16034:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t6 = *(u64 *)&(processor->taddress);   
  *(u64 *)(iSP + 8) = t6;   		// push the data 
  iSP = iSP + 8;
  goto cachevalid;   

storecondnil:
  if (_trace) printf("storecondnil:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t6 = *(u64 *)&(processor->niladdress);   
  *(u64 *)(iSP + 8) = t6;   		// push the data 
  iSP = iSP + 8;
  goto cachevalid;   

storecondiop:
  if (_trace) printf("storecondiop:\n");
  arg5 = 0;
  arg2 = 65;
  goto illegaloperand;

vma-memory-write16035:
  if (_trace) printf("vma-memory-write16035:\n");
  t2 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment16037:
  if (_trace) printf("force-alignment16037:\n");
  t1 = *(u64 *)&(processor->stackcachedata);   
  t2 = arg6 - t2;   		// Stack cache offset 
  t1 = (t2 * 8) + t1;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t1 = arg1;
		/* write the stack cache */
  *(u32 *)(t1 + 4) = t4;
  goto vma-memory-write16034;   

vma-memory-read16024:
  if (_trace) printf("vma-memory-read16024:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = (t1 * 8) + t2;  		// reconstruct SCA 
  t5 = *(s32 *)t1;   
  t4 = *(s32 *)(t1 + 4);   		// Read from stack cache 
  goto vma-memory-read16023;   

vma-memory-read16026:
  if (_trace) printf("vma-memory-read16026:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read16025;
  arg6 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read16022;   

vma-memory-read16025:
  if (_trace) printf("vma-memory-read16025:\n");
  t1 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg6;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t1;   		// Adjust for a longword load 
  t1 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read16030:
  if (_trace) printf("vma-memory-read16030:\n");
  t3 = t1 & MemoryActionTransform;
  if (t3 == 0) 
    goto vma-memory-read16029;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto vma-memory-read16033;   

vma-memory-read16029:

vma-memory-read16028:
  /* Perform memory action */
  arg1 = t1;
  arg2 = 0;
  goto performmemoryaction;

/* end DoStoreConditional */
  /* End of Halfword operand from stack instruction - DoStoreConditional */
/* start DoMemoryWrite */

  /* Halfword operand from stack instruction - DoMemoryWrite */

domemorywrite:
  if (_trace) printf("domemorywrite:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoMemoryWriteIM:
  if (_trace) printf("DoMemoryWriteIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment16042:
  if (_trace) printf("force-alignment16042:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindomemorywrite;   

DoMemoryWriteSP:
  if (_trace) printf("DoMemoryWriteSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoMemoryWriteLP:
  if (_trace) printf("DoMemoryWriteLP:\n");

DoMemoryWriteFP:
  if (_trace) printf("DoMemoryWriteFP:\n");

headdomemorywrite:
  if (_trace) printf("headdomemorywrite:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindomemorywrite:
  if (_trace) printf("begindomemorywrite:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg4 = *(s32 *)iSP;   
  arg3 = *(s32 *)(iSP + 4);   
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  t1 = arg4 + ivory;
  t5 = *(s32 *)&processor->scovlimit;   
  t4 = (t1 * 4);   
  t3 = LDQ_U(t1);   
  t2 = arg4 - t2;   		// Stack cache offset 
  t5 = ((u64)t2 < (u64)t5) ? 1 : 0;   		// In range? 
  t2 = (arg2 & 0xff) << ((t1&7)*8);   
  t3 = t3 & ~(0xffL << (t1&7)*8);   

force-alignment16040:
  if (_trace) printf("force-alignment16040:\n");
  t3 = t3 | t2;
  STQ_U(t1, t3);   
  *(u32 *)t4 = arg1;
  if (t5 != 0)   		// J. if in cache 
    goto vma-memory-write16039;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

vma-memory-write16039:
  if (_trace) printf("vma-memory-write16039:\n");
  t2 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment16041:
  if (_trace) printf("force-alignment16041:\n");
  t1 = *(u64 *)&(processor->stackcachedata);   
  t2 = arg4 - t2;   		// Stack cache offset 
  t1 = (t2 * 8) + t1;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t1 = arg1;
		/* write the stack cache */
  *(u32 *)(t1 + 4) = arg2;
  goto NEXTINSTRUCTION;   

/* end DoMemoryWrite */
  /* End of Halfword operand from stack instruction - DoMemoryWrite */
/* start DoPStoreContents */

  /* Halfword operand from stack instruction - DoPStoreContents */

dopstorecontents:
  if (_trace) printf("dopstorecontents:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoPStoreContentsIM:
  if (_trace) printf("DoPStoreContentsIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment16055:
  if (_trace) printf("force-alignment16055:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindopstorecontents;   

DoPStoreContentsSP:
  if (_trace) printf("DoPStoreContentsSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPStoreContentsLP:
  if (_trace) printf("DoPStoreContentsLP:\n");

DoPStoreContentsFP:
  if (_trace) printf("DoPStoreContentsFP:\n");

headdopstorecontents:
  if (_trace) printf("headdopstorecontents:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindopstorecontents:
  if (_trace) printf("begindopstorecontents:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg4 = *(s32 *)iSP;   		// address tag and data 
  arg3 = *(s32 *)(iSP + 4);   		// address tag and data 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  /* Memory Read Internal */

vma-memory-read16043:
  t6 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t8 = arg4 + ivory;
  t7 = *(s32 *)&processor->scovlimit;   
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = arg4 - t6;   		// Stack cache offset 
  t7 = ((u64)t6 < (u64)t7) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read16045;

vma-memory-read16044:

vma-memory-read16051:
  /* Merge cdr-code */
  t5 = arg2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t7 = *(u64 *)&(processor->stackcachebasevma);   
  t6 = arg4 + ivory;
  t9 = *(s32 *)&processor->scovlimit;   
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = arg4 - t7;   		// Stack cache offset 
  t9 = ((u64)t7 < (u64)t9) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment16053:
  if (_trace) printf("force-alignment16053:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = arg1;
  if (t9 != 0)   		// J. if in cache 
    goto vma-memory-write16052;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

vma-memory-write16052:
  if (_trace) printf("vma-memory-write16052:\n");
  t7 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment16054:
  if (_trace) printf("force-alignment16054:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = arg4 - t7;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = arg1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

vma-memory-read16045:
  if (_trace) printf("vma-memory-read16045:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read16044;   

/* end DoPStoreContents */
  /* End of Halfword operand from stack instruction - DoPStoreContents */
/* start DoSetCdrCode1 */

  /* Halfword operand from stack instruction - DoSetCdrCode1 */
  /* arg2 has the preloaded 8 bit operand. */

dosetcdrcode1:
  if (_trace) printf("dosetcdrcode1:\n");

DoSetCdrCode1SP:
  if (_trace) printf("DoSetCdrCode1SP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoSetCdrCode1LP:
  if (_trace) printf("DoSetCdrCode1LP:\n");

DoSetCdrCode1FP:
  if (_trace) printf("DoSetCdrCode1FP:\n");

begindosetcdrcode1:
  if (_trace) printf("begindosetcdrcode1:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t1 = *(s32 *)(arg1 + 4);   		// Get CDR CODE/TAG of operand 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t1 = t1 & 63;		// Strip off any existing CDR code bits 
  t1 = t1 | 64;		// OR in the CDR 
		/* Replace the CDE CODE/TAG */
  *(u32 *)(arg1 + 4) = t1;
  goto cachevalid;   

DoSetCdrCode1IM:
  goto doistageerror;

/* end DoSetCdrCode1 */
  /* End of Halfword operand from stack instruction - DoSetCdrCode1 */
/* start DoSetCdrCode2 */

  /* Halfword operand from stack instruction - DoSetCdrCode2 */
  /* arg2 has the preloaded 8 bit operand. */

dosetcdrcode2:
  if (_trace) printf("dosetcdrcode2:\n");

DoSetCdrCode2SP:
  if (_trace) printf("DoSetCdrCode2SP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoSetCdrCode2LP:
  if (_trace) printf("DoSetCdrCode2LP:\n");

DoSetCdrCode2FP:
  if (_trace) printf("DoSetCdrCode2FP:\n");

begindosetcdrcode2:
  if (_trace) printf("begindosetcdrcode2:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t1 = *(s32 *)(arg1 + 4);   		// Get CDR CODE/TAG of operand 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t1 = t1 & 63;		// Strip off any existing CDR code bits 
  t1 = t1 | 128;		// OR in the CDR 
		/* Replace the CDE CODE/TAG */
  *(u32 *)(arg1 + 4) = t1;
  goto cachevalid;   

DoSetCdrCode2IM:
  goto doistageerror;

/* end DoSetCdrCode2 */
  /* End of Halfword operand from stack instruction - DoSetCdrCode2 */
/* start DoJump */

  /* Halfword operand from stack instruction - DoJump */
  /* arg2 has the preloaded 8 bit operand. */

dojump:
  if (_trace) printf("dojump:\n");

DoJumpSP:
  if (_trace) printf("DoJumpSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoJumpLP:
  if (_trace) printf("DoJumpLP:\n");

DoJumpFP:
  if (_trace) printf("DoJumpFP:\n");

begindojump:
  if (_trace) printf("begindojump:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t4 = *(s32 *)arg1;   		// Read address and even/odd PC tag. 
  t3 = *(s32 *)(arg1 + 4);   
  t4 = (u32)t4;   
  t5 = t3 - Type_EvenPC;   
  t5 = t5 & 62;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto jexc;
  t4 = t4 << 1;   
  iPC = t3 & 1;
  iPC = iPC + t4;
  t5 = t3 & 128;
  if (t5 == 0) 
    goto interpretinstructionforjump;
  /* Bit 39=1 indicates we need to update control reg */
  t6 = t3 & 64;		// Get the cleanup bit 
  t5 = *(u64 *)&(processor->control);   		// Processor control register. 
  t6 = t6 << 17;   		// shift into cleanup-in-progress place 
  t7 = (128) << 16;   
  t5 = t5 & ~t7;		// Mask 
  t5 = t5 | t6;		// Set 
  *(u64 *)&processor->control = t5;   
  goto interpretinstructionforjump;   

jexc:
  if (_trace) printf("jexc:\n");
  arg3 = 1;		// arg3 = stackp 
  arg1 = 0;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

DoJumpIM:
  goto doistageerror;

/* end DoJump */
  /* End of Halfword operand from stack instruction - DoJump */
/* start DoCheckPreemptRequest */

  /* Halfword 10 bit immediate instruction - DoCheckPreemptRequest */

docheckpreemptrequest:
  if (_trace) printf("docheckpreemptrequest:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoCheckPreemptRequestIM:
  if (_trace) printf("DoCheckPreemptRequestIM:\n");

DoCheckPreemptRequestSP:
  if (_trace) printf("DoCheckPreemptRequestSP:\n");

DoCheckPreemptRequestLP:
  if (_trace) printf("DoCheckPreemptRequestLP:\n");

DoCheckPreemptRequestFP:
  if (_trace) printf("DoCheckPreemptRequestFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  t1 = *(s32 *)&processor->interruptreg;   
  t2 = t1 & 2;
  t2 = (t2 == 2) ? 1 : 0;   
  t1 = t1 | t2;
  *(u32 *)&processor->interruptreg = t1;
  if (t1 == 0) 
    goto NEXTINSTRUCTION;
  *(u64 *)&processor->stop_interpreter = t1;   
  goto NEXTINSTRUCTION;   

/* end DoCheckPreemptRequest */
  /* End of Halfword operand from stack instruction - DoCheckPreemptRequest */
/* start DoHalt */

  /* Halfword 10 bit immediate instruction - DoHalt */

dohalt:
  if (_trace) printf("dohalt:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoHaltIM:
  if (_trace) printf("DoHaltIM:\n");

DoHaltSP:
  if (_trace) printf("DoHaltSP:\n");

DoHaltLP:
  if (_trace) printf("DoHaltLP:\n");

DoHaltFP:
  if (_trace) printf("DoHaltFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  t1 = *(s32 *)&processor->control;   
  t1 = t1 >> 30;   		// Isolate current trap mode (FEP mode = -1) 
  t1 = (s32)t1 + (s32)1;		// t1 is zero iff we're in trap mode FEP 
  if (t1 != 0)   
    goto haltexc;
  goto haltmachine;

haltexc:
  if (_trace) printf("haltexc:\n");
  arg3 = 1;		// arg3 = stackp 
  arg1 = 0;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

/* end DoHalt */
  /* End of Halfword operand from stack instruction - DoHalt */
/* start DoNoOp */

  /* Halfword 10 bit immediate instruction - DoNoOp */

donoop:
  if (_trace) printf("donoop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoNoOpIM:
  if (_trace) printf("DoNoOpIM:\n");

DoNoOpSP:
  if (_trace) printf("DoNoOpSP:\n");

DoNoOpLP:
  if (_trace) printf("DoNoOpLP:\n");

DoNoOpFP:
  if (_trace) printf("DoNoOpFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  goto NEXTINSTRUCTION;   

/* end DoNoOp */
  /* End of Halfword operand from stack instruction - DoNoOp */
/* start DoAlu */

  /* Halfword operand from stack instruction - DoAlu */

doalu:
  if (_trace) printf("doalu:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoAluIM:
  if (_trace) printf("DoAluIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment16126:
  if (_trace) printf("force-alignment16126:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoalu;   

DoAluSP:
  if (_trace) printf("DoAluSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoAluLP:
  if (_trace) printf("DoAluLP:\n");

DoAluFP:
  if (_trace) printf("DoAluFP:\n");

headdoalu:
  if (_trace) printf("headdoalu:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoalu:
  if (_trace) printf("begindoalu:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg2 = arg1 >> 32;   		// Get tag of ARG2 
  arg1 = (u32)arg1;   		// Get data of ARG2 
  arg4 = *(s32 *)iSP;   		// Get ARG1 
  arg3 = *(s32 *)(iSP + 4);   
  arg4 = (u32)arg4;   
  t1 = arg2 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto aluexc;
  t1 = arg3 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto aluexc;
  arg5 = *(u64 *)&(processor->aluop);   
  *(u64 *)&processor->aluoverflow = zero;   
  arg6 = *(u64 *)&(processor->aluandrotatecontrol);   
  t1 = (arg5 == ALUFunction_Boolean) ? 1 : 0;   

force-alignment16116:
  if (_trace) printf("force-alignment16116:\n");
  if (t1 == 0) 
    goto basic-dispatch16057;
  /* Here if argument ALUFunctionBoolean */
  t10 = arg6 >> 10;   
  t10 = t10 & 15;		// Extract the ALU boolean function 
  t1 = (t10 == Boole_Clear) ? 1 : 0;   

force-alignment16076:
  if (_trace) printf("force-alignment16076:\n");
  if (t1 != 0)   
    goto basic-dispatch16058;

basic-dispatch16059:
  if (_trace) printf("basic-dispatch16059:\n");
  t1 = (t10 == Boole_And) ? 1 : 0;   

force-alignment16077:
  if (_trace) printf("force-alignment16077:\n");
  if (t1 == 0) 
    goto basic-dispatch16060;
  /* Here if argument BooleAnd */
  t10 = arg4 & arg1;
  goto basic-dispatch16058;   

basic-dispatch16060:
  if (_trace) printf("basic-dispatch16060:\n");
  t1 = (t10 == Boole_AndC1) ? 1 : 0;   

force-alignment16078:
  if (_trace) printf("force-alignment16078:\n");
  if (t1 == 0) 
    goto basic-dispatch16061;
  /* Here if argument BooleAndC1 */
  t10 = arg1 & ~arg4;
  goto basic-dispatch16058;   

basic-dispatch16061:
  if (_trace) printf("basic-dispatch16061:\n");
  t1 = (t10 == Boole_2) ? 1 : 0;   

force-alignment16079:
  if (_trace) printf("force-alignment16079:\n");
  if (t1 == 0) 
    goto basic-dispatch16062;
  /* Here if argument Boole2 */
  t10 = arg1;
  goto basic-dispatch16058;   

basic-dispatch16062:
  if (_trace) printf("basic-dispatch16062:\n");
  t1 = (t10 == Boole_AndC2) ? 1 : 0;   

force-alignment16080:
  if (_trace) printf("force-alignment16080:\n");
  if (t1 == 0) 
    goto basic-dispatch16063;
  /* Here if argument BooleAndC2 */
  t10 = arg4 & ~arg1;
  goto basic-dispatch16058;   

basic-dispatch16063:
  if (_trace) printf("basic-dispatch16063:\n");
  t1 = (t10 == Boole_1) ? 1 : 0;   

force-alignment16081:
  if (_trace) printf("force-alignment16081:\n");
  if (t1 == 0) 
    goto basic-dispatch16064;
  /* Here if argument Boole1 */
  t10 = arg4;
  goto basic-dispatch16058;   

basic-dispatch16064:
  if (_trace) printf("basic-dispatch16064:\n");
  t1 = (t10 == Boole_Xor) ? 1 : 0;   

force-alignment16082:
  if (_trace) printf("force-alignment16082:\n");
  if (t1 == 0) 
    goto basic-dispatch16065;
  /* Here if argument BooleXor */
  t10 = arg4 ^ arg1;   
  goto basic-dispatch16058;   

basic-dispatch16065:
  if (_trace) printf("basic-dispatch16065:\n");
  t1 = (t10 == Boole_Ior) ? 1 : 0;   

force-alignment16083:
  if (_trace) printf("force-alignment16083:\n");
  if (t1 == 0) 
    goto basic-dispatch16066;
  /* Here if argument BooleIor */
  t10 = arg4 | arg1;
  goto basic-dispatch16058;   

basic-dispatch16066:
  if (_trace) printf("basic-dispatch16066:\n");
  t1 = (t10 == Boole_Nor) ? 1 : 0;   

force-alignment16084:
  if (_trace) printf("force-alignment16084:\n");
  if (t1 == 0) 
    goto basic-dispatch16067;
  /* Here if argument BooleNor */
  t10 = arg4 | arg1;
  t10 = ~t10;   
  goto basic-dispatch16058;   

basic-dispatch16067:
  if (_trace) printf("basic-dispatch16067:\n");
  t1 = (t10 == Boole_Equiv) ? 1 : 0;   

force-alignment16085:
  if (_trace) printf("force-alignment16085:\n");
  if (t1 == 0) 
    goto basic-dispatch16068;
  /* Here if argument BooleEquiv */
  t10 = arg4 ^ arg1;   
  t10 = ~t10;   
  goto basic-dispatch16058;   

basic-dispatch16068:
  if (_trace) printf("basic-dispatch16068:\n");
  t1 = (t10 == Boole_C1) ? 1 : 0;   

force-alignment16086:
  if (_trace) printf("force-alignment16086:\n");
  if (t1 == 0) 
    goto basic-dispatch16069;
  /* Here if argument BooleC1 */
  t10 = ~arg4;   
  goto basic-dispatch16058;   

basic-dispatch16069:
  if (_trace) printf("basic-dispatch16069:\n");
  t1 = (t10 == Boole_OrC1) ? 1 : 0;   

force-alignment16087:
  if (_trace) printf("force-alignment16087:\n");
  if (t1 == 0) 
    goto basic-dispatch16070;
  /* Here if argument BooleOrC1 */
  t10 = arg1 | ~(arg4);   
  goto basic-dispatch16058;   

basic-dispatch16070:
  if (_trace) printf("basic-dispatch16070:\n");
  t1 = (t10 == Boole_C2) ? 1 : 0;   

force-alignment16088:
  if (_trace) printf("force-alignment16088:\n");
  if (t1 == 0) 
    goto basic-dispatch16071;
  /* Here if argument BooleC2 */
  t10 = ~arg1;   
  goto basic-dispatch16058;   

basic-dispatch16071:
  if (_trace) printf("basic-dispatch16071:\n");
  t1 = (t10 == Boole_OrC2) ? 1 : 0;   

force-alignment16089:
  if (_trace) printf("force-alignment16089:\n");
  if (t1 == 0) 
    goto basic-dispatch16072;
  /* Here if argument BooleOrC2 */
  t10 = arg4 & ~arg1;
  goto basic-dispatch16058;   

basic-dispatch16072:
  if (_trace) printf("basic-dispatch16072:\n");
  t1 = (t10 == Boole_Nand) ? 1 : 0;   

force-alignment16090:
  if (_trace) printf("force-alignment16090:\n");
  if (t1 == 0) 
    goto basic-dispatch16073;
  /* Here if argument BooleNand */
  t10 = arg4 & arg1;
  goto basic-dispatch16058;   

basic-dispatch16073:
  if (_trace) printf("basic-dispatch16073:\n");
  t1 = (t10 == Boole_Set) ? 1 : 0;   

force-alignment16091:
  if (_trace) printf("force-alignment16091:\n");
  if (t1 == 0) 
    goto basic-dispatch16058;
  /* Here if argument BooleSet */
  t10 = ~zero;   

basic-dispatch16058:
  if (_trace) printf("basic-dispatch16058:\n");
  *(u32 *)iSP = t10;
  goto NEXTINSTRUCTION;   

basic-dispatch16057:
  if (_trace) printf("basic-dispatch16057:\n");
  t1 = (arg5 == ALUFunction_Byte) ? 1 : 0;   

force-alignment16117:
  if (_trace) printf("force-alignment16117:\n");
  if (t1 == 0) 
    goto basic-dispatch16092;
  /* Here if argument ALUFunctionByte */
  t2 = *(u64 *)&(processor->byterotate);   		// Get rotate 
  t3 = *(u64 *)&(processor->bytesize);   		// Get bytesize 
  /* Get background */
  t1 = arg6 >> 10;   
  t1 = t1 & 3;		// Extract the byte background 
  t4 = (t1 == ALUByteBackground_Op1) ? 1 : 0;   

force-alignment16099:
  if (_trace) printf("force-alignment16099:\n");
  if (t4 == 0) 
    goto basic-dispatch16095;
  /* Here if argument ALUByteBackgroundOp1 */
  t1 = arg4;

basic-dispatch16094:
  if (_trace) printf("basic-dispatch16094:\n");
  t5 = arg6 >> 12;   
  t5 = t5 & 1;		// Extractthe byte rotate latch 
  t10 = arg1 << (t2 & 63);   
  t4 = (u32)(t10 >> ((4&7)*8));   
  t10 = (u32)t10;   
  t10 = t10 | t4;		// OP2 rotated 
  if (t5 == 0) 		// Don't update rotate latch if not requested 
    goto alu-function-byte16093;
  *(u64 *)&processor->rotatelatch = t10;   

alu-function-byte16093:
  if (_trace) printf("alu-function-byte16093:\n");
  t5 = zero + -2;   
  t5 = t5 << (t3 & 63);   
  t5 = ~t5;   		// Compute mask 
  /* Get byte function */
  t4 = arg6 >> 13;   
  t4 = t4 & 1;
  t3 = (t4 == ALUByteFunction_Dpb) ? 1 : 0;   

force-alignment16104:
  if (_trace) printf("force-alignment16104:\n");
  if (t3 == 0) 
    goto basic-dispatch16101;
  /* Here if argument ALUByteFunctionDpb */
  t5 = t5 << (t2 & 63);   		// Position mask 

basic-dispatch16100:
  if (_trace) printf("basic-dispatch16100:\n");
  t10 = t10 & t5;		// rotated&mask 
  t1 = t1 & ~t5;		// background&~mask 
  t10 = t10 | t1;
  *(u32 *)iSP = t10;
  goto NEXTINSTRUCTION;   

basic-dispatch16092:
  if (_trace) printf("basic-dispatch16092:\n");
  t1 = (arg5 == ALUFunction_Adder) ? 1 : 0;   

force-alignment16118:
  if (_trace) printf("force-alignment16118:\n");
  if (t1 == 0) 
    goto basic-dispatch16105;
  /* Here if argument ALUFunctionAdder */
  t3 = arg6 >> 11;   
  t3 = t3 & 3;		// Extract the op2 
  t2 = arg6 >> 10;   
  t2 = t2 & 1;		// Extract the adder carry in 
  t4 = (t3 == ALUAdderOp2_Op2) ? 1 : 0;   

force-alignment16113:
  if (_trace) printf("force-alignment16113:\n");
  if (t4 == 0) 
    goto basic-dispatch16108;
  /* Here if argument ALUAdderOp2Op2 */
  t1 = arg1;

basic-dispatch16107:
  if (_trace) printf("basic-dispatch16107:\n");
  t10 = arg4 + t1;
  t10 = t10 + t2;
  t3 = t10 >> 31;   		// Sign bit 
  t4 = t10 >> 32;   		// Next bit 
  t3 = t3 ^ t4;   		// Low bit is now overflow indicator 
  t4 = arg6 >> 24;   		// Get the load-carry-in bit 
  *(u64 *)&processor->aluoverflow = t3;   
  if ((t4 & 1) == 0)   
    goto alu-function-adder16106;
  t3 = (u32)(t10 >> ((4&7)*8));   		// Get the carry 
  t4 = zero + 1024;   
  arg6 = arg6 & ~t4;
  t4 = t3 & 1;
  t4 = t4 << 10;   
  arg6 = arg6 | t4;		// Set the adder carry in 
  *(u64 *)&processor->aluandrotatecontrol = arg6;   

alu-function-adder16106:
  if (_trace) printf("alu-function-adder16106:\n");
  t3 = ((s64)arg4 < (s64)t1) ? 1 : 0;   
  *(u64 *)&processor->aluborrow = t3;   
  arg4 = (s32)arg4;
  arg1 = (s32)arg1;
  t3 = ((s64)arg4 < (s64)t1) ? 1 : 0;   
  *(u64 *)&processor->alulessthan = t3;   
  *(u32 *)iSP = t10;
  goto NEXTINSTRUCTION;   

basic-dispatch16105:
  if (_trace) printf("basic-dispatch16105:\n");
  t1 = (arg5 == ALUFunction_MultiplyDivide) ? 1 : 0;   

force-alignment16119:
  if (_trace) printf("force-alignment16119:\n");
  if (t1 == 0) 
    goto basic-dispatch16056;
  /* Here if argument ALUFunctionMultiplyDivide */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;
  *(u32 *)iSP = t10;
  goto NEXTINSTRUCTION;   

basic-dispatch16056:
  if (_trace) printf("basic-dispatch16056:\n");

aluexc:
  if (_trace) printf("aluexc:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

basic-dispatch16108:
  if (_trace) printf("basic-dispatch16108:\n");
  t4 = (t3 == ALUAdderOp2_Zero) ? 1 : 0;   

force-alignment16120:
  if (_trace) printf("force-alignment16120:\n");
  if (t4 == 0) 
    goto basic-dispatch16109;
  /* Here if argument ALUAdderOp2Zero */
  t1 = zero;
  goto basic-dispatch16107;   

basic-dispatch16109:
  if (_trace) printf("basic-dispatch16109:\n");
  t4 = (t3 == ALUAdderOp2_Invert) ? 1 : 0;   

force-alignment16121:
  if (_trace) printf("force-alignment16121:\n");
  if (t4 == 0) 
    goto basic-dispatch16110;
  /* Here if argument ALUAdderOp2Invert */
  t1 = (s32)arg1;
  t1 = zero - t1;   
  t1 = (u32)t1;   
  goto basic-dispatch16107;   

basic-dispatch16110:
  if (_trace) printf("basic-dispatch16110:\n");
  t4 = (t3 == ALUAdderOp2_MinusOne) ? 1 : 0;   

force-alignment16122:
  if (_trace) printf("force-alignment16122:\n");
  if (t4 == 0) 
    goto basic-dispatch16107;
  /* Here if argument ALUAdderOp2MinusOne */
  t1 = ~zero;   
  t1 = (u32)t1;   
  goto basic-dispatch16107;   

basic-dispatch16101:
  if (_trace) printf("basic-dispatch16101:\n");
  t3 = (t4 == ALUByteFunction_Ldb) ? 1 : 0;   

force-alignment16123:
  if (_trace) printf("force-alignment16123:\n");
  if (t3 != 0)   
    goto basic-dispatch16100;
  goto basic-dispatch16100;   

basic-dispatch16095:
  if (_trace) printf("basic-dispatch16095:\n");
  t4 = (t1 == ALUByteBackground_RotateLatch) ? 1 : 0;   

force-alignment16124:
  if (_trace) printf("force-alignment16124:\n");
  if (t4 == 0) 
    goto basic-dispatch16096;
  /* Here if argument ALUByteBackgroundRotateLatch */
  t1 = *(u64 *)&(processor->rotatelatch);   
  goto basic-dispatch16094;   

basic-dispatch16096:
  if (_trace) printf("basic-dispatch16096:\n");
  t4 = (t1 == ALUByteBackground_Zero) ? 1 : 0;   

force-alignment16125:
  if (_trace) printf("force-alignment16125:\n");
  if (t4 == 0) 
    goto basic-dispatch16094;
  /* Here if argument ALUByteBackgroundZero */
  t1 = zero;
  goto basic-dispatch16094;   

/* end DoAlu */
  /* End of Halfword operand from stack instruction - DoAlu */
/* start DoSpareOp */

  /* Halfword 10 bit immediate instruction - DoSpareOp */

dospareop:
  if (_trace) printf("dospareop:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoSpareOpIM:
  if (_trace) printf("DoSpareOpIM:\n");

DoSpareOpSP:
  if (_trace) printf("DoSpareOpSP:\n");

DoSpareOpLP:
  if (_trace) printf("DoSpareOpLP:\n");

DoSpareOpFP:
  if (_trace) printf("DoSpareOpFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  t1 = *(u64 *)&(((CACHELINEP)iCP)->instruction);   		// Get the instruction 
  t1 = t1 >> 10;   		// Position the opcode 
  t1 = t1 & 255;		// Extract it 
  arg1 = 0;		// arg1 = instruction arity 
  arg2 = t1;		// arg2 = instruction opcode 
  arg3 = 1;		// arg3 = stackp 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;		// when not stackp arg5=the arg 
  arg6 = 0;		// arg6=tag to dispatch on 
  goto exception;
  goto NEXTINSTRUCTION;   

/* end DoSpareOp */
  /* End of Halfword operand from stack instruction - DoSpareOp */
  /* Reading and writing internal registers */
/* start ReadRegisterFP */


ReadRegisterFP:
  if (_trace) printf("ReadRegisterFP:\n");
  /* Convert stack cache address to VMA */
  t5 = *(u64 *)&(processor->stackcachedata);   
  t4 = *(u64 *)&(processor->stackcachebasevma);   
  t5 = iFP - t5;   		// stack cache base relative offset 
  t5 = t5 >> 3;   		// convert byte address to word address 
  t4 = t5 + t4;		// reconstruct VMA 
  t5 = Type_Locative;
  *(u32 *)(iSP + 8) = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterFP */
/* start ReadRegisterLP */


ReadRegisterLP:
  if (_trace) printf("ReadRegisterLP:\n");
  /* Convert stack cache address to VMA */
  t5 = *(u64 *)&(processor->stackcachedata);   
  t4 = *(u64 *)&(processor->stackcachebasevma);   
  t5 = iLP - t5;   		// stack cache base relative offset 
  t5 = t5 >> 3;   		// convert byte address to word address 
  t4 = t5 + t4;		// reconstruct VMA 
  t5 = Type_Locative;
  *(u32 *)(iSP + 8) = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterLP */
/* start ReadRegisterSP */


ReadRegisterSP:
  if (_trace) printf("ReadRegisterSP:\n");
  /* Convert stack cache address to VMA */
  t5 = *(u64 *)&(processor->stackcachedata);   
  t4 = *(u64 *)&(processor->stackcachebasevma);   
  t5 = iSP - t5;   		// stack cache base relative offset 
  t5 = t5 >> 3;   		// convert byte address to word address 
  t4 = t5 + t4;		// reconstruct VMA 
  t5 = Type_Locative;
  *(u32 *)(iSP + 8) = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterSP */
/* start ReadRegisterStackCacheLowerBound */


ReadRegisterStackCacheLowerBound:
  if (_trace) printf("ReadRegisterStackCacheLowerBound:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);   
  t5 = Type_Locative;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterStackCacheLowerBound */
/* start ReadRegisterBARx */


ReadRegisterBARx:
  if (_trace) printf("ReadRegisterBARx:\n");
  t2 = arg1 >> 7;   		// BAR number into T2 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t1 = (u64)&processor->bar0;   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t1 = (t2 * 8) + t1;  		// Now T1 points to the BAR 
  t3 = *(u64 *)t1;   
  t4 = Type_Locative;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  goto cachevalid;   

/* end ReadRegisterBARx */
/* start ReadRegisterContinuation */


ReadRegisterContinuation:
  if (_trace) printf("ReadRegisterContinuation:\n");
  t3 = *(u64 *)&(processor->continuation);   
  iSP = iSP + 8;
  t5 = t3 << 26;   
  t5 = t5 >> 26;   
  *(u64 *)iSP = t5;   
  goto NEXTINSTRUCTION;   

/* end ReadRegisterContinuation */
/* start ReadRegisterAluAndRotateControl */


ReadRegisterAluAndRotateControl:
  if (_trace) printf("ReadRegisterAluAndRotateControl:\n");
  t3 = *(u64 *)&(processor->aluandrotatecontrol);   
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterAluAndRotateControl */
/* start ReadRegisterControlRegister */


ReadRegisterControlRegister:
  if (_trace) printf("ReadRegisterControlRegister:\n");
  t3 = *(s32 *)&processor->control;   
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterControlRegister */
/* start ReadRegisterCRArgumentSize */


ReadRegisterCRArgumentSize:
  if (_trace) printf("ReadRegisterCRArgumentSize:\n");
  t3 = *(s32 *)&processor->control;   
  t3 = t3 & 255;		// Get the argument size field 
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterCRArgumentSize */
/* start ReadRegisterEphemeralOldspaceRegister */


ReadRegisterEphemeralOldspaceRegister:
  if (_trace) printf("ReadRegisterEphemeralOldspaceRegister:\n");
  t3 = *(s32 *)&processor->ephemeraloldspace;   
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterEphemeralOldspaceRegister */
/* start ReadRegisterZoneOldspaceRegister */


ReadRegisterZoneOldspaceRegister:
  if (_trace) printf("ReadRegisterZoneOldspaceRegister:\n");
  t3 = *(s32 *)&processor->zoneoldspace;   
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterZoneOldspaceRegister */
/* start ReadRegisterChipRevision */


ReadRegisterChipRevision:
  if (_trace) printf("ReadRegisterChipRevision:\n");
  t3 = 5;
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterChipRevision */
/* start ReadRegisterFPCoprocessorPresent */


ReadRegisterFPCoprocessorPresent:
  if (_trace) printf("ReadRegisterFPCoprocessorPresent:\n");
  t4 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterFPCoprocessorPresent */
/* start ReadRegisterPreemptRegister */


ReadRegisterPreemptRegister:
  if (_trace) printf("ReadRegisterPreemptRegister:\n");
  t3 = *(s32 *)&processor->interruptreg;   
  t3 = t3 & 3;
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterPreemptRegister */
/* start ReadRegisterIcacheControl */


ReadRegisterIcacheControl:
  if (_trace) printf("ReadRegisterIcacheControl:\n");
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterIcacheControl */
/* start ReadRegisterPrefetcherControl */


ReadRegisterPrefetcherControl:
  if (_trace) printf("ReadRegisterPrefetcherControl:\n");
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterPrefetcherControl */
/* start ReadRegisterMapCacheControl */


ReadRegisterMapCacheControl:
  if (_trace) printf("ReadRegisterMapCacheControl:\n");
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterMapCacheControl */
/* start ReadRegisterMemoryControl */


ReadRegisterMemoryControl:
  if (_trace) printf("ReadRegisterMemoryControl:\n");
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterMemoryControl */
/* start ReadRegisterStackCacheOverflowLimit */


ReadRegisterStackCacheOverflowLimit:
  if (_trace) printf("ReadRegisterStackCacheOverflowLimit:\n");
  t3 = *(s32 *)&processor->scovlimit;   
  t4 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = t3 + t4;
  t4 = Type_Locative;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterStackCacheOverflowLimit */
/* start ReadRegisterMicrosecondClock */


ReadRegisterMicrosecondClock:
  if (_trace) printf("ReadRegisterMicrosecondClock:\n");
  t1 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterMicrosecondClock */
/* start ReadRegisterTOS */


ReadRegisterTOS:
  if (_trace) printf("ReadRegisterTOS:\n");
  t1 = *(u64 *)iSP;   
  iSP = iSP + 8;
  t2 = t1 << 26;   
  t2 = t2 >> 26;   
  *(u64 *)iSP = t2;   		// Push CDR-NEXT TOS 
  goto NEXTINSTRUCTION;   

/* end ReadRegisterTOS */
/* start ReadRegisterEventCount */


ReadRegisterEventCount:
  if (_trace) printf("ReadRegisterEventCount:\n");
  t3 = *(u64 *)&(processor->areventcount);   
  t4 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterEventCount */
/* start ReadRegisterBindingStackPointer */


ReadRegisterBindingStackPointer:
  if (_trace) printf("ReadRegisterBindingStackPointer:\n");
  t3 = *(u64 *)&(processor->bindingstackpointer);   
  iSP = iSP + 8;
  t5 = t3 << 26;   
  t5 = t5 >> 26;   
  *(u64 *)iSP = t5;   
  goto NEXTINSTRUCTION;   

/* end ReadRegisterBindingStackPointer */
/* start ReadRegisterCatchBlockList */


ReadRegisterCatchBlockList:
  if (_trace) printf("ReadRegisterCatchBlockList:\n");
  t3 = *(u64 *)&(processor->catchblock);   
  iSP = iSP + 8;
  t5 = t3 << 26;   
  t5 = t5 >> 26;   
  *(u64 *)iSP = t5;   
  goto NEXTINSTRUCTION;   

/* end ReadRegisterCatchBlockList */
/* start ReadRegisterControlStackLimit */


ReadRegisterControlStackLimit:
  if (_trace) printf("ReadRegisterControlStackLimit:\n");
  t3 = *(s32 *)&processor->cslimit;   
  t5 = Type_Locative;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterControlStackLimit */
/* start ReadRegisterControlStackExtraLimit */


ReadRegisterControlStackExtraLimit:
  if (_trace) printf("ReadRegisterControlStackExtraLimit:\n");
  t3 = *(s32 *)&processor->csextralimit;   
  t5 = Type_Locative;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterControlStackExtraLimit */
/* start ReadRegisterBindingStackLimit */


ReadRegisterBindingStackLimit:
  if (_trace) printf("ReadRegisterBindingStackLimit:\n");
  t3 = *(u64 *)&(processor->bindingstacklimit);   
  iSP = iSP + 8;
  t5 = t3 << 26;   
  t5 = t5 >> 26;   
  *(u64 *)iSP = t5;   
  goto NEXTINSTRUCTION;   

/* end ReadRegisterBindingStackLimit */
/* start ReadRegisterPHTBase */


ReadRegisterPHTBase:
  if (_trace) printf("ReadRegisterPHTBase:\n");
  t5 = Type_Locative;
  *(u32 *)(iSP + 8) = zero;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterPHTBase */
/* start ReadRegisterPHTMask */


ReadRegisterPHTMask:
  if (_trace) printf("ReadRegisterPHTMask:\n");
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterPHTMask */
/* start ReadRegisterCountMapReloads */


ReadRegisterCountMapReloads:
  if (_trace) printf("ReadRegisterCountMapReloads:\n");
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = zero;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterCountMapReloads */
/* start ReadRegisterListCacheArea */


ReadRegisterListCacheArea:
  if (_trace) printf("ReadRegisterListCacheArea:\n");
  t3 = *(u64 *)&(processor->lcarea);   
  iSP = iSP + 8;
  t5 = t3 << 26;   
  t5 = t5 >> 26;   
  *(u64 *)iSP = t5;   
  goto NEXTINSTRUCTION;   

/* end ReadRegisterListCacheArea */
/* start ReadRegisterListCacheAddress */


ReadRegisterListCacheAddress:
  if (_trace) printf("ReadRegisterListCacheAddress:\n");
  t3 = *(u64 *)&(processor->lcaddress);   
  iSP = iSP + 8;
  t5 = t3 << 26;   
  t5 = t5 >> 26;   
  *(u64 *)iSP = t5;   
  goto NEXTINSTRUCTION;   

/* end ReadRegisterListCacheAddress */
/* start ReadRegisterListCacheLength */


ReadRegisterListCacheLength:
  if (_trace) printf("ReadRegisterListCacheLength:\n");
  t3 = *(s32 *)&processor->lclength;   
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterListCacheLength */
/* start ReadRegisterStructureCacheArea */


ReadRegisterStructureCacheArea:
  if (_trace) printf("ReadRegisterStructureCacheArea:\n");
  t3 = *(u64 *)&(processor->scarea);   
  iSP = iSP + 8;
  t5 = t3 << 26;   
  t5 = t5 >> 26;   
  *(u64 *)iSP = t5;   
  goto NEXTINSTRUCTION;   

/* end ReadRegisterStructureCacheArea */
/* start ReadRegisterStructureCacheAddress */


ReadRegisterStructureCacheAddress:
  if (_trace) printf("ReadRegisterStructureCacheAddress:\n");
  t3 = *(u64 *)&(processor->scaddress);   
  iSP = iSP + 8;
  t5 = t3 << 26;   
  t5 = t5 >> 26;   
  *(u64 *)iSP = t5;   
  goto NEXTINSTRUCTION;   

/* end ReadRegisterStructureCacheAddress */
/* start ReadRegisterStructureCacheLength */


ReadRegisterStructureCacheLength:
  if (_trace) printf("ReadRegisterStructureCacheLength:\n");
  t3 = *(s32 *)&processor->sclength;   
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterStructureCacheLength */
/* start ReadRegisterDynamicBindingCacheBase */


ReadRegisterDynamicBindingCacheBase:
  if (_trace) printf("ReadRegisterDynamicBindingCacheBase:\n");
  t3 = *(u64 *)&(processor->dbcbase);   
  iSP = iSP + 8;
  t5 = t3 << 26;   
  t5 = t5 >> 26;   
  *(u64 *)iSP = t5;   
  goto NEXTINSTRUCTION;   

/* end ReadRegisterDynamicBindingCacheBase */
/* start ReadRegisterDynamicBindingCacheMask */


ReadRegisterDynamicBindingCacheMask:
  if (_trace) printf("ReadRegisterDynamicBindingCacheMask:\n");
  t3 = *(u64 *)&(processor->dbcmask);   
  iSP = iSP + 8;
  t5 = t3 << 26;   
  t5 = t5 >> 26;   
  *(u64 *)iSP = t5;   
  goto NEXTINSTRUCTION;   

/* end ReadRegisterDynamicBindingCacheMask */
/* start ReadRegisterChoicePointer */


ReadRegisterChoicePointer:
  if (_trace) printf("ReadRegisterChoicePointer:\n");
  t3 = *(s32 *)&processor->choiceptr;   
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterChoicePointer */
/* start ReadRegisterStructureStackChoicePointer */


ReadRegisterStructureStackChoicePointer:
  if (_trace) printf("ReadRegisterStructureStackChoicePointer:\n");
  t3 = *(s32 *)&processor->sstkchoiceptr;   
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterStructureStackChoicePointer */
/* start ReadRegisterFEPModeTrapVectorAddress */


ReadRegisterFEPModeTrapVectorAddress:
  if (_trace) printf("ReadRegisterFEPModeTrapVectorAddress:\n");
  t3 = *(u64 *)&(processor->fepmodetrapvecaddress);   
  goto NEXTINSTRUCTION;   

/* end ReadRegisterFEPModeTrapVectorAddress */
/* start ReadRegisterStackFrameMaximumSize */


ReadRegisterStackFrameMaximumSize:
  if (_trace) printf("ReadRegisterStackFrameMaximumSize:\n");
  t3 = zero + 128;   
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterStackFrameMaximumSize */
/* start ReadRegisterStackCacheDumpQuantum */


ReadRegisterStackCacheDumpQuantum:
  if (_trace) printf("ReadRegisterStackCacheDumpQuantum:\n");
  t3 = zero + 896;   
  t5 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterStackCacheDumpQuantum */
/* start ReadRegisterConstantNIL */


ReadRegisterConstantNIL:
  if (_trace) printf("ReadRegisterConstantNIL:\n");
  t5 = *(u64 *)&(processor->taddress);   
  *(u64 *)(iSP + 8) = t5;   		// push the data 
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterConstantNIL */
/* start ReadRegisterConstantT */


ReadRegisterConstantT:
  if (_trace) printf("ReadRegisterConstantT:\n");
  t5 = *(u64 *)&(processor->niladdress);   
  *(u64 *)(iSP + 8) = t5;   		// push the data 
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

/* end ReadRegisterConstantT */
/* start ReadRegisterError */


ReadRegisterError:
  if (_trace) printf("ReadRegisterError:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

/* end ReadRegisterError */
/* start WriteRegisterFP */


WriteRegisterFP:
  if (_trace) printf("WriteRegisterFP:\n");
#ifdef IVERIFY
  t2 = *(u64 *)&(processor->stackcachebasevma);   		// Base of the stack cache 
  t1 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t2 = arg3 - t2;   		// Stack cache offset 
  t3 = ((u64)t2 < (u64)t1) ? 1 : 0;   		// In range? 
  t1 = *(u64 *)&(processor->stackcachedata);   
  if (t3 == 0) 		// J. if not in cache 
    goto badregister;
  t1 = (t2 * 8) + t1;  		// reconstruct SCA 
  iFP = t1;
  goto NEXTINSTRUCTION;   
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;
#endif

/* end WriteRegisterFP */
/* start WriteRegisterLP */


WriteRegisterLP:
  if (_trace) printf("WriteRegisterLP:\n");
#ifdef IVERIFY
  t2 = *(u64 *)&(processor->stackcachebasevma);   		// Base of the stack cache 
  t1 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t2 = arg3 - t2;   		// Stack cache offset 
  t3 = ((u64)t2 < (u64)t1) ? 1 : 0;   		// In range? 
  t1 = *(u64 *)&(processor->stackcachedata);   
  if (t3 == 0) 		// J. if not in cache 
    goto badregister;
  t1 = (t2 * 8) + t1;  		// reconstruct SCA 
  iLP = t1;
  goto NEXTINSTRUCTION;   
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;
#endif

/* end WriteRegisterLP */
/* start WriteRegisterSP */


WriteRegisterSP:
  if (_trace) printf("WriteRegisterSP:\n");
#ifdef IVERIFY
  t2 = *(u64 *)&(processor->stackcachebasevma);   		// Base of the stack cache 
  t1 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t2 = arg3 - t2;   		// Stack cache offset 
  t3 = ((u64)t2 < (u64)t1) ? 1 : 0;   		// In range? 
  t1 = *(u64 *)&(processor->stackcachedata);   
  if (t3 == 0) 		// J. if not in cache 
    goto badregister;
  t1 = (t2 * 8) + t1;  		// reconstruct SCA 
  iSP = t1;
  goto NEXTINSTRUCTION;   
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;
#endif

/* end WriteRegisterSP */
/* start WriteRegisterStackCacheLowerBound */


WriteRegisterStackCacheLowerBound:
  if (_trace) printf("WriteRegisterStackCacheLowerBound:\n");
#ifdef IVERIFY
  *(u64 *)&processor->stackcachebasevma = arg3;   
  t1 = *(u64 *)&(processor->stackcachesize);   
  t1 = arg3 + t1;
  *(u64 *)&processor->stackcachetopvma = t1;   
  goto NEXTINSTRUCTION;   
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;
#endif

/* end WriteRegisterStackCacheLowerBound */
/* start WriteRegisterContinuation */


WriteRegisterContinuation:
  if (_trace) printf("WriteRegisterContinuation:\n");
  arg4 = arg2 << 32;   
  arg4 = arg4 | arg3;		// construct the combined word 
  *(u64 *)&processor->continuation = arg4;   
  goto NEXTINSTRUCTION;   

/* end WriteRegisterContinuation */
/* start WriteRegisterAluAndRotateControl */


WriteRegisterAluAndRotateControl:
  if (_trace) printf("WriteRegisterAluAndRotateControl:\n");
  t1 = arg3 >> 14;   
  t1 = t1 & 3;		// Extract the function class bits 
  *(u64 *)&processor->aluandrotatecontrol = arg3;   
  t2 = arg3 >> 5;   
  t2 = t2 & 31;		// Extract the byte size 
  *(u64 *)&processor->aluop = t1;   
  t3 = arg3 & 31;		// Extract the Byte Rotate 
  *(u64 *)&processor->bytesize = t2;   
  *(u64 *)&processor->byterotate = t3;   
  goto NEXTINSTRUCTION;   

/* end WriteRegisterAluAndRotateControl */
/* start WriteRegisterControlRegister */


WriteRegisterControlRegister:
  if (_trace) printf("WriteRegisterControlRegister:\n");
  *(u32 *)&processor->control = arg3;
  goto NEXTINSTRUCTION;   

/* end WriteRegisterControlRegister */
/* start WriteRegisterEphemeralOldspaceRegister */


WriteRegisterEphemeralOldspaceRegister:
  if (_trace) printf("WriteRegisterEphemeralOldspaceRegister:\n");
  *(u64 *)&processor->ac0array = zero;   
  *(u64 *)&processor->ac1array = zero;   
  *(u64 *)&processor->ac2array = zero;   
  *(u64 *)&processor->ac3array = zero;   
  *(u64 *)&processor->ac4array = zero;   
  *(u64 *)&processor->ac5array = zero;   
  *(u64 *)&processor->ac6array = zero;   
  *(u64 *)&processor->ac7array = zero;   
  *(u32 *)&processor->ephemeraloldspace = arg3;
  goto NEXTINSTRUCTION;   

/* end WriteRegisterEphemeralOldspaceRegister */
/* start WriteRegisterZoneOldspaceRegister */


WriteRegisterZoneOldspaceRegister:
  if (_trace) printf("WriteRegisterZoneOldspaceRegister:\n");
  *(u32 *)&processor->zoneoldspace = arg3;
  goto NEXTINSTRUCTION;   

/* end WriteRegisterZoneOldspaceRegister */
/* start WriteRegisterFPCoprocessorPresent */


WriteRegisterFPCoprocessorPresent:
  if (_trace) printf("WriteRegisterFPCoprocessorPresent:\n");
  goto NEXTINSTRUCTION;   

/* end WriteRegisterFPCoprocessorPresent */
/* start WriteRegisterPreemptRegister */


WriteRegisterPreemptRegister:
  if (_trace) printf("WriteRegisterPreemptRegister:\n");
  t3 = *(s32 *)&processor->interruptreg;   
  t3 = t3 & ~3L;
  arg3 = arg3 & 3;
  t3 = t3 | arg3;
  *(u32 *)&processor->interruptreg = t3;
  if ((t3 & 1) == 0)   
    goto NEXTINSTRUCTION;
  *(u64 *)&processor->stop_interpreter = t3;   
  goto NEXTINSTRUCTION;   

/* end WriteRegisterPreemptRegister */
/* start WriteRegisterStackCacheOverflowLimit */


WriteRegisterStackCacheOverflowLimit:
  if (_trace) printf("WriteRegisterStackCacheOverflowLimit:\n");
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t1 = (u32)t1;   
  t1 = arg3 - t1;   
  *(u32 *)&processor->scovlimit = t1;
  goto NEXTINSTRUCTION;   

/* end WriteRegisterStackCacheOverflowLimit */
/* start WriteRegisterTOS */


WriteRegisterTOS:
  if (_trace) printf("WriteRegisterTOS:\n");
  goto NEXTINSTRUCTION;   

/* end WriteRegisterTOS */
/* start WriteRegisterEventCount */


WriteRegisterEventCount:
  if (_trace) printf("WriteRegisterEventCount:\n");
  *(u64 *)&processor->areventcount = arg3;   
  goto NEXTINSTRUCTION;   

/* end WriteRegisterEventCount */
/* start WriteRegisterBindingStackPointer */


WriteRegisterBindingStackPointer:
  if (_trace) printf("WriteRegisterBindingStackPointer:\n");
  arg4 = arg2 << 32;   
  arg4 = arg4 | arg3;		// construct the combined word 
  *(u64 *)&processor->bindingstackpointer = arg4;   
  goto NEXTINSTRUCTION;   

/* end WriteRegisterBindingStackPointer */
/* start WriteRegisterCatchBlockList */


WriteRegisterCatchBlockList:
  if (_trace) printf("WriteRegisterCatchBlockList:\n");
  arg4 = arg2 << 32;   
  arg4 = arg4 | arg3;		// construct the combined word 
  *(u64 *)&processor->catchblock = arg4;   
  goto NEXTINSTRUCTION;   

/* end WriteRegisterCatchBlockList */
/* start WriteRegisterControlStackLimit */


WriteRegisterControlStackLimit:
  if (_trace) printf("WriteRegisterControlStackLimit:\n");
  *(u32 *)&processor->cslimit = arg3;
  goto NEXTINSTRUCTION;   

/* end WriteRegisterControlStackLimit */
/* start WriteRegisterControlStackExtraLimit */


WriteRegisterControlStackExtraLimit:
  if (_trace) printf("WriteRegisterControlStackExtraLimit:\n");
  *(u32 *)&processor->csextralimit = arg3;
  goto NEXTINSTRUCTION;   

/* end WriteRegisterControlStackExtraLimit */
/* start WriteRegisterBindingStackLimit */


WriteRegisterBindingStackLimit:
  if (_trace) printf("WriteRegisterBindingStackLimit:\n");
  arg4 = arg2 << 32;   
  arg4 = arg4 | arg3;		// construct the combined word 
  *(u64 *)&processor->bindingstacklimit = arg4;   
  goto NEXTINSTRUCTION;   

/* end WriteRegisterBindingStackLimit */
/* start WriteRegisterListCacheArea */


WriteRegisterListCacheArea:
  if (_trace) printf("WriteRegisterListCacheArea:\n");
  arg4 = arg2 << 32;   
  arg4 = arg4 | arg3;		// construct the combined word 
  *(u64 *)&processor->lcarea = arg4;   
  goto NEXTINSTRUCTION;   

/* end WriteRegisterListCacheArea */
/* start WriteRegisterListCacheAddress */


WriteRegisterListCacheAddress:
  if (_trace) printf("WriteRegisterListCacheAddress:\n");
  arg4 = arg2 << 32;   
  arg4 = arg4 | arg3;		// construct the combined word 
  *(u64 *)&processor->lcaddress = arg4;   
  goto NEXTINSTRUCTION;   

/* end WriteRegisterListCacheAddress */
/* start WriteRegisterListCacheLength */


WriteRegisterListCacheLength:
  if (_trace) printf("WriteRegisterListCacheLength:\n");
  *(u32 *)&processor->lclength = arg3;
  goto NEXTINSTRUCTION;   

/* end WriteRegisterListCacheLength */
/* start WriteRegisterStructureCacheArea */


WriteRegisterStructureCacheArea:
  if (_trace) printf("WriteRegisterStructureCacheArea:\n");
  arg4 = arg2 << 32;   
  arg4 = arg4 | arg3;		// construct the combined word 
  *(u64 *)&processor->scarea = arg4;   
  goto NEXTINSTRUCTION;   

/* end WriteRegisterStructureCacheArea */
/* start WriteRegisterStructureCacheAddress */


WriteRegisterStructureCacheAddress:
  if (_trace) printf("WriteRegisterStructureCacheAddress:\n");
  arg4 = arg2 << 32;   
  arg4 = arg4 | arg3;		// construct the combined word 
  *(u64 *)&processor->scaddress = arg4;   
  goto NEXTINSTRUCTION;   

/* end WriteRegisterStructureCacheAddress */
/* start WriteRegisterStructureCacheLength */


WriteRegisterStructureCacheLength:
  if (_trace) printf("WriteRegisterStructureCacheLength:\n");
  *(u32 *)&processor->sclength = arg3;
  goto NEXTINSTRUCTION;   

/* end WriteRegisterStructureCacheLength */
/* start WriteRegisterDynamicBindingCacheBase */


WriteRegisterDynamicBindingCacheBase:
  if (_trace) printf("WriteRegisterDynamicBindingCacheBase:\n");
  arg4 = arg2 << 32;   
  arg4 = arg4 | arg3;		// construct the combined word 
  *(u64 *)&processor->dbcbase = arg4;   
  goto NEXTINSTRUCTION;   

/* end WriteRegisterDynamicBindingCacheBase */
/* start WriteRegisterDynamicBindingCacheMask */


WriteRegisterDynamicBindingCacheMask:
  if (_trace) printf("WriteRegisterDynamicBindingCacheMask:\n");
  arg4 = arg2 << 32;   
  arg4 = arg4 | arg3;		// construct the combined word 
  *(u64 *)&processor->dbcmask = arg4;   
  goto NEXTINSTRUCTION;   

/* end WriteRegisterDynamicBindingCacheMask */
/* start WriteRegisterChoicePointer */


WriteRegisterChoicePointer:
  if (_trace) printf("WriteRegisterChoicePointer:\n");
  *(u32 *)&processor->choiceptr = arg3;
  goto NEXTINSTRUCTION;   

/* end WriteRegisterChoicePointer */
/* start WriteRegisterStructureStackChoicePointer */


WriteRegisterStructureStackChoicePointer:
  if (_trace) printf("WriteRegisterStructureStackChoicePointer:\n");
  *(u32 *)&processor->sstkchoiceptr = arg3;
  goto NEXTINSTRUCTION;   

/* end WriteRegisterStructureStackChoicePointer */
/* start WriteRegisterFEPModeTrapVectorAddress */


WriteRegisterFEPModeTrapVectorAddress:
  if (_trace) printf("WriteRegisterFEPModeTrapVectorAddress:\n");
  *(u32 *)&processor->fepmodetrapvecaddress = arg3;
  goto NEXTINSTRUCTION;   

/* end WriteRegisterFEPModeTrapVectorAddress */
/* start WriteRegisterMappingTableCache */


WriteRegisterMappingTableCache:
  if (_trace) printf("WriteRegisterMappingTableCache:\n");
  goto NEXTINSTRUCTION;   

/* end WriteRegisterMappingTableCache */
/* start WriteRegisterError */


WriteRegisterError:
  if (_trace) printf("WriteRegisterError:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

/* end WriteRegisterError */
  /* Coprocessor read and write are implemented in C in order to */
  /* encourage creativity!  The hooks are in aicoproc.c */
/* start DoCoprocessorRead */

  /* Halfword 10 bit immediate instruction - DoCoprocessorRead */

docoprocessorread:
  if (_trace) printf("docoprocessorread:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoCoprocessorReadIM:
  if (_trace) printf("DoCoprocessorReadIM:\n");

DoCoprocessorReadSP:
  if (_trace) printf("DoCoprocessorReadSP:\n");

DoCoprocessorReadLP:
  if (_trace) printf("DoCoprocessorReadLP:\n");

DoCoprocessorReadFP:
  if (_trace) printf("DoCoprocessorReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  r0 = *(u64 *)&(processor->coprocessorreadhook);   
  *(u64 *)&processor->cp = iCP;   
  *(u64 *)&processor->epc = iPC;   
  *(u64 *)&processor->sp = iSP;   
  *(u64 *)&processor->fp = iFP;   
  *(u64 *)&processor->lp = iLP;   
  r9 = *(u64 *)&(processor->asrr9);   
  r10 = *(u64 *)&(processor->asrr10);   
  r11 = *(u64 *)&(processor->asrr11);   
  r12 = *(u64 *)&(processor->asrr12);   
  r13 = *(u64 *)&(processor->asrr13);   
  r15 = *(u64 *)&(processor->asrr15);   
  r27 = *(u64 *)&(processor->asrr27);   
  r29 = *(u64 *)&(processor->asrr29);   
  pv = r0;
    r0 = (*( u64 (*)(u64, u64) )r0)(arg1, arg2); /* jsr */  
  r9 = *(u64 *)&(processor->asrr9);   
  r10 = *(u64 *)&(processor->asrr10);   
  r11 = *(u64 *)&(processor->asrr11);   
  r12 = *(u64 *)&(processor->asrr12);   
  r13 = *(u64 *)&(processor->asrr13);   
  r15 = *(u64 *)&(processor->asrr15);   
  r27 = *(u64 *)&(processor->asrr27);   
  r29 = *(u64 *)&(processor->asrr29);   
  iCP = *(u64 *)&(processor->cp);   
  iPC = *(u64 *)&(processor->epc);   
  iSP = *(u64 *)&(processor->sp);   
  iFP = *(u64 *)&(processor->fp);   
  iLP = *(u64 *)&(processor->lp);   
  /* Long -1 is never a valid LISP value */
  t1 = zero + -1;   
  t1 = (r0 == t1) ? 1 : 0;   
  if (t1 != 0)   		// J. if CoprocessorRead exception return 
    goto cpreadexc;
  iSP = iSP + 8;
  t1 = r0 << 26;   
  t1 = t1 >> 26;   
  *(u64 *)iSP = t1;   		// Push the result of coprocessor read! 
  goto NEXTINSTRUCTION;   

cpreadexc:
  if (_trace) printf("cpreadexc:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

/* end DoCoprocessorRead */
  /* End of Halfword operand from stack instruction - DoCoprocessorRead */
/* start DoCoprocessorWrite */

  /* Halfword 10 bit immediate instruction - DoCoprocessorWrite */

docoprocessorwrite:
  if (_trace) printf("docoprocessorwrite:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoCoprocessorWriteIM:
  if (_trace) printf("DoCoprocessorWriteIM:\n");

DoCoprocessorWriteSP:
  if (_trace) printf("DoCoprocessorWriteSP:\n");

DoCoprocessorWriteLP:
  if (_trace) printf("DoCoprocessorWriteLP:\n");

DoCoprocessorWriteFP:
  if (_trace) printf("DoCoprocessorWriteFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg2 = *(u64 *)iSP;   		// The value to be written 
  iSP = iSP - 8;   		// Pop Stack. 
  t2 = zero + CoprocessorRegister_UnwindStackForRestartOrApply;   
  t2 = arg1 - t2;   
  if (t2 != 0)   
    goto mondo-dispatch16128;
  /* Here if argument CoprocessorRegisterUnwindStackForRestartOrApply */
  t1 = *(s32 *)iSP;   		// peek at new continuation to look at tag 
  t2 = *(s32 *)(iSP + 4);   
  t1 = (u32)t1;   
  t3 = t2 - Type_EvenPC;   
  t3 = t3 & 62;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto unwindillegalcontinuation;
  t1 = *(u64 *)iSP;   		// Get new continuation 
  iSP = iSP - 8;   		// Pop Stack. 
  *(u64 *)&processor->continuation = t1;   		// Update continuation register 
  *(u64 *)&processor->continuationcp = zero;   
  t1 = *(s32 *)iSP;   		// Get new FP 
  t2 = *(s32 *)(iSP + 4);   		// Get new FP 
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = (u32)t1;   
  t3 = t2 - Type_Locative;   
  t3 = t3 & 63;		// Strip CDR code 
  if (t3 != 0)   
    goto unwindillegalfp;
  /* Convert VMA to stack cache address */
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  iFP = *(u64 *)&(processor->stackcachedata);   
  t2 = t1 - t2;   		// stack cache base relative offset 
  iFP = (t2 * 8) + iFP;  		// reconstruct SCA 
  t1 = *(s32 *)iSP;   		// Get new LP 
  t2 = *(s32 *)(iSP + 4);   		// Get new LP 
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = (u32)t1;   
  t3 = t2 - Type_Locative;   
  t3 = t3 & 63;		// Strip CDR code 
  if (t3 != 0)   
    goto unwindillegallp;
  /* Convert VMA to stack cache address */
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  iLP = *(u64 *)&(processor->stackcachedata);   
  t2 = t1 - t2;   		// stack cache base relative offset 
  iLP = (t2 * 8) + iLP;  		// reconstruct SCA 
  /* Update CDR-CODEs to make it a legitimate frame */
  t1 = *(s32 *)(iFP + 4);   		// Tag of saved continuation register 
  t2 = *(s32 *)(iFP + 12);   		// Tag of saved control register 
  t1 = t1 | 192;		// Set CDR-CODE to 3 
		/* Put it back */
  *(u32 *)(iFP + 4) = t1;
  t2 = t2 | 192;		// Set CDR-CODE to 3 
		/* Put it back */
  *(u32 *)(iFP + 12) = t2;
  /* Copy the current trap-on-exit bit into the saved control register */
  t1 = *(s32 *)&processor->control;   		// Get control register 
  t2 = *(s32 *)(iFP + 8);   		// Get saved control register 
  t2 = (u32)t2;   
  t3 = (256) << 16;   
  t2 = t2 & ~t3;		// Remove saved control register's trap-on-exit bit 
  t1 = t1 & t3;		// Extract control register's trap-on-exit bit 
  t2 = t2 | t1;		// Copy it into saved control register 
		/* Update saved control register */
  *(u32 *)(iFP + 8) = t2;
  /* Restore the new control register with proper trap mode */
  t1 = *(s32 *)iSP;   		// peek at new control register to look at tag 
  t2 = *(s32 *)(iSP + 4);   
  t1 = (u32)t1;   
  t3 = t2 - Type_Fixnum;   
  t3 = t3 & 63;		// Strip CDR code 
  if (t3 != 0)   
    goto unwindillegalcontrol;
  t1 = *(s32 *)iSP;   		// Get new control register 
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = (u32)t1;   
  *(u32 *)&processor->control = t1;
  goto mondo-dispatch16127;   

mondo-dispatch16128:
  if (_trace) printf("mondo-dispatch16128:\n");
  t2 = zero + CoprocessorRegister_FlushIDCaches;   
  t2 = arg1 - t2;   
  if (t2 != 0)   
    goto mondo-dispatch16129;
  /* Here if argument CoprocessorRegisterFlushIDCaches */
  /* We're about to flush the instruction cache so we can't rely */
  /* on ContinueToNextInstruction working.  Instead, we must load */
  /* the next PC now and explicitly fill the cache. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t1 = *(u64 *)&(processor->flushcaches_hook);   
  *(u64 *)&processor->cp = iCP;   
  *(u64 *)&processor->epc = iPC;   
  *(u64 *)&processor->sp = iSP;   
  *(u64 *)&processor->fp = iFP;   
  *(u64 *)&processor->lp = iLP;   
  r9 = *(u64 *)&(processor->asrr9);   
  r10 = *(u64 *)&(processor->asrr10);   
  r11 = *(u64 *)&(processor->asrr11);   
  r12 = *(u64 *)&(processor->asrr12);   
  r13 = *(u64 *)&(processor->asrr13);   
  r15 = *(u64 *)&(processor->asrr15);   
  r27 = *(u64 *)&(processor->asrr27);   
  r29 = *(u64 *)&(processor->asrr29);   
  pv = t1;
    r0 = (*( u64 (*)(u64, u64) )t1)(arg1, arg2); /* jsr */  
  r9 = *(u64 *)&(processor->asrr9);   
  r10 = *(u64 *)&(processor->asrr10);   
  r11 = *(u64 *)&(processor->asrr11);   
  r12 = *(u64 *)&(processor->asrr12);   
  r13 = *(u64 *)&(processor->asrr13);   
  r15 = *(u64 *)&(processor->asrr15);   
  r27 = *(u64 *)&(processor->asrr27);   
  r29 = *(u64 *)&(processor->asrr29);   
  iCP = *(u64 *)&(processor->cp);   
  iPC = *(u64 *)&(processor->epc);   
  iSP = *(u64 *)&(processor->sp);   
  iFP = *(u64 *)&(processor->fp);   
  iLP = *(u64 *)&(processor->lp);   
  /* Compute proper iCP after FlushCaches resets it. */
  goto ICACHEMISS;
  goto mondo-dispatch16127;   

mondo-dispatch16129:
  if (_trace) printf("mondo-dispatch16129:\n");
  t2 = zero + CoprocessorRegister_FlushCachesForVMA;   
  t2 = arg1 - t2;   
  if (t2 != 0)   
    goto mondo-dispatch16130;
  /* Here if argument CoprocessorRegisterFlushCachesForVMA */
  arg2 = (u32)arg2;   		// Extract the VMA 
  t1 = arg2 << 1;   		// convert continuation to an even pc 
  /* Convert a halfword address into a CP pointer. */
  t2 = t1 >> (CacheLine_RShift & 63);   		// Get third byte into bottom 
  t4 = *(u64 *)&(processor->icachebase);   		// get the base of the icache 
  t3 = zero + -1;   
  t3 = t3 + ((4) << 16);   
  t2 = t2 << (CacheLine_LShift & 63);   		// Now third byte is zero-shifted 
  t2 = t1 + t2;
  t2 = t2 & t3;
  t3 = t2 << 5;   		// temp=cpos*32 
  t2 = t2 << 4;   		// cpos=cpos*16 
  t4 = t4 + t3;		// temp2=base+cpos*32 
  t2 = t4 + t2;		// cpos=base+cpos*48 
  t3 = *(u64 *)&(((CACHELINEP)t2)->pcdata);   
  t3 = (t1 == t3) ? 1 : 0;   		// Is this VMA in the cache? 
  if (t3 == 0) 		// No. 
    goto dcwnotincache;
  *(u64 *)&((CACHELINEP)t2)->pcdata = zero;   		// Yes, flush it 
  *((u64 *)(&((CACHELINEP)t2)->pcdata)+CACHELINESIZE/8) = zero;   

dcwnotincache:
  if (_trace) printf("dcwnotincache:\n");
  goto mondo-dispatch16127;   

mondo-dispatch16130:
  if (_trace) printf("mondo-dispatch16130:\n");
  t2 = zero + CoprocessorRegister_FlushHiddenArrayRegisters;   
  t2 = arg1 - t2;   
  if (t2 != 0)   
    goto mondo-dispatch16131;
  /* Here if argument CoprocessorRegisterFlushHiddenArrayRegisters */
  arg2 = (u32)arg2;   		// Get the VMA of the new stack array 
  t8 = zero + AutoArrayRegMask;   
  t8 = arg2 & t8;
  t7 = (u64)&processor->ac0array;   
  t7 = t7 + t8;		// Here is our array register block 
  t8 = *(u64 *)&(((ARRAYCACHEP)t7)->array);   		// And here is the cached array 
  t8 = (arg2 == t8) ? 1 : 0;   		// t8==1 iff cached array is ours 
  if (t8 == 0) 
    goto arraynotincache;
  *(u64 *)&((ARRAYCACHEP)t7)->array = zero;   		// Flush it 

arraynotincache:
  if (_trace) printf("arraynotincache:\n");
  goto mondo-dispatch16127;   

mondo-dispatch16131:
  if (_trace) printf("mondo-dispatch16131:\n");
  /* Here for all other cases */
  /* Standard coprocessor register processing */
  r0 = *(u64 *)&(processor->coprocessorwritehook);   
  *(u64 *)&processor->cp = iCP;   
  *(u64 *)&processor->epc = iPC;   
  *(u64 *)&processor->sp = iSP;   
  *(u64 *)&processor->fp = iFP;   
  *(u64 *)&processor->lp = iLP;   
  r9 = *(u64 *)&(processor->asrr9);   
  r10 = *(u64 *)&(processor->asrr10);   
  r11 = *(u64 *)&(processor->asrr11);   
  r12 = *(u64 *)&(processor->asrr12);   
  r13 = *(u64 *)&(processor->asrr13);   
  r15 = *(u64 *)&(processor->asrr15);   
  r27 = *(u64 *)&(processor->asrr27);   
  r29 = *(u64 *)&(processor->asrr29);   
  pv = r0;
    r0 = (*( u64 (*)(u64, u64) )r0)(arg1, arg2); /* jsr */  
  r9 = *(u64 *)&(processor->asrr9);   
  r10 = *(u64 *)&(processor->asrr10);   
  r11 = *(u64 *)&(processor->asrr11);   
  r12 = *(u64 *)&(processor->asrr12);   
  r13 = *(u64 *)&(processor->asrr13);   
  r15 = *(u64 *)&(processor->asrr15);   
  r27 = *(u64 *)&(processor->asrr27);   
  r29 = *(u64 *)&(processor->asrr29);   
  iCP = *(u64 *)&(processor->cp);   
  iPC = *(u64 *)&(processor->epc);   
  iSP = *(u64 *)&(processor->sp);   
  iFP = *(u64 *)&(processor->fp);   
  iLP = *(u64 *)&(processor->lp);   
  if (r0 == 0) 		// J. if CoprocessorWrite exception return 
    goto cpreadexc;
  goto mondo-dispatch16127;   

mondo-dispatch16132:
  if (_trace) printf("mondo-dispatch16132:\n");

mondo-dispatch16127:
  if (_trace) printf("mondo-dispatch16127:\n");
  goto NEXTINSTRUCTION;   

unwindillegalcontinuation:
  if (_trace) printf("unwindillegalcontinuation:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

unwindillegalcontrol:
  if (_trace) printf("unwindillegalcontrol:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

unwindillegalfp:
  if (_trace) printf("unwindillegalfp:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

unwindillegallp:
  if (_trace) printf("unwindillegallp:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

cpwriteexc:
  if (_trace) printf("cpwriteexc:\n");
  arg5 = 0;
  arg2 = 84;
  goto illegaloperand;

/* end DoCoprocessorWrite */
  /* End of Halfword operand from stack instruction - DoCoprocessorWrite */
/* start GetRPCC */


getrpcc:
  if (_trace) printf("getrpcc:\n");
  r0 = RPCC();
  arg1 = r0 << 32;   
  arg1 = r0 + arg1;
  r0 = arg1 >> 32;   
  goto *ra; /* ret */

/* end GetRPCC */
/* start SpinWheels */


spinwheels:
  if (_trace) printf("spinwheels:\n");
  arg1 = 1;
  arg1 = arg1 << 25;   

spinwheelaxis:
  if (_trace) printf("spinwheelaxis:\n");
  arg1 = arg1 + -1;
  if ((s64)arg1 > 0)   
    goto spinwheelaxis;
  goto *ra; /* ret */

/* end SpinWheels */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunsubp.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunfext.as
 ************************************************************************/

  /* Field extraction instruction. */
/* start DoCharLdb */

  /* Field Extraction instruction - DoCharLdb */

docharldb:
  if (_trace) printf("docharldb:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoCharLdbIM:
  if (_trace) printf("DoCharLdbIM:\n");

DoCharLdbSP:
  if (_trace) printf("DoCharLdbSP:\n");

DoCharLdbLP:
  if (_trace) printf("DoCharLdbLP:\n");

DoCharLdbFP:
  if (_trace) printf("DoCharLdbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  t7 = zero - 1;   		// t7= -1 
  arg3 = *(s32 *)(iSP + 4);   		// get ARG1 tag/data 
  arg4 = *(s32 *)iSP;   
  arg1 = arg1 + 1;   		// Size of field 
  t7 = t7 << (arg1 & 63);   		// Unmask 
  /* TagType. */
  t8 = arg3 & 63;
  t9 = t8 - Type_Character;   
  arg4 = (u32)arg4;   		// Clear sign extension now 
  if (t9 != 0)   		// Not a character 
    goto charldbexc;
  t4 = arg4 << (arg2 & 63);   		// T4= shifted value if PP==0 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t5 = t4 >> 32;   		// T5= shifted value if PP<>0 
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  if (arg2 == 0)   		// T5= shifted value 
    t5 = t4;
  t3 = t5 & ~t7;		// T3= masked value. 
  t4 = Type_Fixnum;
  *(u32 *)iSP = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;   

charldbexc:
  if (_trace) printf("charldbexc:\n");
  arg5 = 0;
  arg2 = 28;
  goto illegaloperand;

/* end DoCharLdb */
  /* End of Halfword operand from stack instruction - DoCharLdb */
/* start DoPLdb */

  /* Field Extraction instruction - DoPLdb */

dopldb:
  if (_trace) printf("dopldb:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoPLdbIM:
  if (_trace) printf("DoPLdbIM:\n");

DoPLdbSP:
  if (_trace) printf("DoPLdbSP:\n");

DoPLdbLP:
  if (_trace) printf("DoPLdbLP:\n");

DoPLdbFP:
  if (_trace) printf("DoPLdbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  t2 = *(s32 *)iSP;   		// get arg1 tag/data 
  t1 = *(s32 *)(iSP + 4);   
  t2 = (u32)t2;   
  t3 = t1 - Type_PhysicalAddress;   
  t3 = t3 & 63;
  if (t3 == 0) 
    goto pldbillop;
  /* Memory Read Internal */

vma-memory-read16134:
  t3 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t5 = t2 + ivory;
  t4 = *(s32 *)&processor->scovlimit;   
  arg4 = (t5 * 4);   
  arg3 = LDQ_U(t5);   
  t3 = t2 - t3;   		// Stack cache offset 
  t4 = ((u64)t3 < (u64)t4) ? 1 : 0;   		// In range? 
  arg4 = *(s32 *)arg4;   
  arg3 = (u8)(arg3 >> ((t5&7)*8));   
  if (t4 != 0)   
    goto vma-memory-read16136;

vma-memory-read16135:
  arg4 = (u32)arg4;   

vma-memory-read16142:
  t7 = zero - 1;   		// t7= -1 
  arg1 = arg1 + 1;		// Size of field 
  t4 = arg4 << (arg2 & 63);   		// T4= shifted value if PP==0 
  t5 = t4 >> 32;   		// T5= shifted value if PP<>0 
  t7 = t7 << (arg1 & 63);   		// Unmask 
  if (arg2 == 0)   		// T5= shifted value 
    t5 = t4;
  t3 = t5 & ~t7;		// T3= masked value. 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t4 = Type_Fixnum;
  *(u32 *)iSP = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;   

pldbillop:
  if (_trace) printf("pldbillop:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = iSP - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t1 = t2 + t1;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 57;
  goto illegaloperand;

vma-memory-read16136:
  if (_trace) printf("vma-memory-read16136:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t3 = (t3 * 8) + t4;  		// reconstruct SCA 
  arg4 = *(s32 *)t3;   
  arg3 = *(s32 *)(t3 + 4);   		// Read from stack cache 
  goto vma-memory-read16135;   

/* end DoPLdb */
  /* End of Halfword operand from stack instruction - DoPLdb */
/* start DoPTagLdb */

  /* Field Extraction instruction - DoPTagLdb */

doptagldb:
  if (_trace) printf("doptagldb:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoPTagLdbIM:
  if (_trace) printf("DoPTagLdbIM:\n");

DoPTagLdbSP:
  if (_trace) printf("DoPTagLdbSP:\n");

DoPTagLdbLP:
  if (_trace) printf("DoPTagLdbLP:\n");

DoPTagLdbFP:
  if (_trace) printf("DoPTagLdbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  t2 = *(s32 *)iSP;   		// get arg1 tag/data 
  t1 = *(s32 *)(iSP + 4);   
  t2 = (u32)t2;   
  t3 = t1 - Type_PhysicalAddress;   
  t3 = t3 & 63;
  if (t3 == 0) 
    goto ptagldbillop;
  /* Memory Read Internal */

vma-memory-read16143:
  t3 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t5 = t2 + ivory;
  t4 = *(s32 *)&processor->scovlimit;   
  arg4 = (t5 * 4);   
  arg3 = LDQ_U(t5);   
  t3 = t2 - t3;   		// Stack cache offset 
  t4 = ((u64)t3 < (u64)t4) ? 1 : 0;   		// In range? 
  arg4 = *(s32 *)arg4;   
  arg3 = (u8)(arg3 >> ((t5&7)*8));   
  if (t4 != 0)   
    goto vma-memory-read16145;

vma-memory-read16144:

vma-memory-read16151:
  t7 = zero - 1;   		// t7= -1 
  arg1 = arg1 + 1;		// Size of field 
  t4 = arg3 << (arg2 & 63);   		// T4= shifted value if PP==0 
  t5 = t4 >> 32;   		// T5= shifted value if PP<>0 
  t7 = t7 << (arg1 & 63);   		// Unmask 
  if (arg2 == 0)   		// T5= shifted value 
    t5 = t4;
  t3 = t5 & ~t7;		// T3= masked value. 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t4 = Type_Fixnum;
  *(u32 *)iSP = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;   

ptagldbillop:
  if (_trace) printf("ptagldbillop:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = iSP - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t1 = t2 + t1;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 57;
  goto illegaloperand;

vma-memory-read16145:
  if (_trace) printf("vma-memory-read16145:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t3 = (t3 * 8) + t4;  		// reconstruct SCA 
  arg4 = *(s32 *)t3;   
  arg3 = *(s32 *)(t3 + 4);   		// Read from stack cache 
  goto vma-memory-read16144;   

/* end DoPTagLdb */
  /* End of Halfword operand from stack instruction - DoPTagLdb */
/* start DoDpb */

  /* Field Extraction instruction - DoDpb */

dodpb:
  if (_trace) printf("dodpb:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoDpbIM:
  if (_trace) printf("DoDpbIM:\n");

DoDpbSP:
  if (_trace) printf("DoDpbSP:\n");

DoDpbLP:
  if (_trace) printf("DoDpbLP:\n");

DoDpbFP:
  if (_trace) printf("DoDpbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  t6 = *(s32 *)iSP;   		// Get arg2 tag/data 
  t5 = *(s32 *)(iSP + 4);   		// Get arg2 tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  t6 = (u32)t6;   
  arg4 = *(s32 *)iSP;   		// get arg1 tag/data 
  arg3 = *(s32 *)(iSP + 4);   
  arg4 = (u32)arg4;   
  t1 = t5 & 63;		// Strip off any CDR code bits. 
  arg6 = arg3 & 63;		// Strip off any CDR code bits. 
  t2 = (t1 == Type_Fixnum) ? 1 : 0;   

force-alignment16164:
  if (_trace) printf("force-alignment16164:\n");
  if (t2 == 0) 
    goto basic-dispatch16157;
  /* Here if argument TypeFixnum */
  arg5 = (arg6 == Type_Fixnum) ? 1 : 0;   

force-alignment16161:
  if (_trace) printf("force-alignment16161:\n");
  if (arg5 == 0) 
    goto binary-type-dispatch16154;
  /* Here if argument TypeFixnum */
  t7 = zero - 2;   		// t7= -2 
  t7 = t7 << (arg1 & 63);   		// Unmask 
  t5 = ~t7;   		// reuse t5 as mask 
  t3 = arg4 & ~t7;		// T3= masked new value. 
  t5 = t5 << (arg2 & 63);   		// t5 is the inplace mask 
  t4 = t3 << (arg2 & 63);   		// t4 is the shifted field 
  t6 = t6 & ~t5;		// Clear out existing bits in arg2 field 
  t6 = t4 | t6;		// Put the new bits in 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t4 = Type_Fixnum;
  *(u32 *)iSP = t6;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;   

basic-dispatch16158:
  if (_trace) printf("basic-dispatch16158:\n");

basic-dispatch16157:
  if (_trace) printf("basic-dispatch16157:\n");
  /* Here for all other cases */

binary-type-dispatch16153:
  if (_trace) printf("binary-type-dispatch16153:\n");
  arg6 = t5;		// arg6 = tag to dispatch on 
  arg3 = 1;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch16155;   

binary-type-dispatch16154:
  if (_trace) printf("binary-type-dispatch16154:\n");
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 1;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto numericexception;

binary-type-dispatch16155:
  if (_trace) printf("binary-type-dispatch16155:\n");

basic-dispatch16156:
  if (_trace) printf("basic-dispatch16156:\n");

/* end DoDpb */
  /* End of Halfword operand from stack instruction - DoDpb */
/* start DoCharDpb */

  /* Field Extraction instruction - DoCharDpb */

dochardpb:
  if (_trace) printf("dochardpb:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoCharDpbIM:
  if (_trace) printf("DoCharDpbIM:\n");

DoCharDpbSP:
  if (_trace) printf("DoCharDpbSP:\n");

DoCharDpbLP:
  if (_trace) printf("DoCharDpbLP:\n");

DoCharDpbFP:
  if (_trace) printf("DoCharDpbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  t6 = *(s32 *)iSP;   		// Get arg2 tag/data 
  t5 = *(s32 *)(iSP + 4);   		// Get arg2 tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  t6 = (u32)t6;   
  arg4 = *(s32 *)iSP;   		// get arg1 tag/data 
  arg3 = *(s32 *)(iSP + 4);   
  arg4 = (u32)arg4;   
  t1 = t5 & 63;		// Strip off any CDR code bits. 
  arg6 = arg3 & 63;		// Strip off any CDR code bits. 
  t2 = (t1 == Type_Character) ? 1 : 0;   

force-alignment16177:
  if (_trace) printf("force-alignment16177:\n");
  if (t2 == 0) 
    goto basic-dispatch16170;
  /* Here if argument TypeCharacter */
  arg5 = (arg6 == Type_Fixnum) ? 1 : 0;   

force-alignment16174:
  if (_trace) printf("force-alignment16174:\n");
  if (arg5 == 0) 
    goto binary-type-dispatch16167;
  /* Here if argument TypeFixnum */
  t7 = zero - 2;   		// t7= -2 
  t7 = t7 << (arg1 & 63);   		// Unmask 
  t5 = ~t7;   		// reuse t5 as mask 
  t3 = arg4 & ~t7;		// T3= masked new value. 
  t5 = t5 << (arg2 & 63);   		// t5 is the inplace mask 
  t4 = t3 << (arg2 & 63);   		// t4 is the shifted field 
  t6 = t6 & ~t5;		// Clear out existing bits in arg2 field 
  t6 = t4 | t6;		// Put the new bits in 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t4 = Type_Character;
  *(u32 *)iSP = t6;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t4;
  goto cachevalid;   

basic-dispatch16171:
  if (_trace) printf("basic-dispatch16171:\n");

basic-dispatch16170:
  if (_trace) printf("basic-dispatch16170:\n");
  /* Here for all other cases */

binary-type-dispatch16166:
  if (_trace) printf("binary-type-dispatch16166:\n");
  arg6 = t5;		// arg6 = tag to dispatch on 
  arg3 = 1;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 27;
  goto spareexception;
  goto binary-type-dispatch16168;   

binary-type-dispatch16167:
  if (_trace) printf("binary-type-dispatch16167:\n");
  arg5 = 0;
  arg2 = 27;
  goto illegaloperand;

binary-type-dispatch16168:
  if (_trace) printf("binary-type-dispatch16168:\n");

basic-dispatch16169:
  if (_trace) printf("basic-dispatch16169:\n");

/* end DoCharDpb */
  /* End of Halfword operand from stack instruction - DoCharDpb */
/* start DoPDpb */

  /* Field Extraction instruction - DoPDpb */

dopdpb:
  if (_trace) printf("dopdpb:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoPDpbIM:
  if (_trace) printf("DoPDpbIM:\n");

DoPDpbSP:
  if (_trace) printf("DoPDpbSP:\n");

DoPDpbLP:
  if (_trace) printf("DoPDpbLP:\n");

DoPDpbFP:
  if (_trace) printf("DoPDpbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  t2 = *(s32 *)iSP;   		// Get arg2 tag/data 
  t1 = *(s32 *)(iSP + 4);   		// Get arg2 tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  t2 = (u32)t2;   
  t3 = t1 - Type_PhysicalAddress;   
  t3 = t3 & 63;
  if (t3 == 0) 
    goto pdpbillop;
  arg4 = *(s32 *)iSP;   		// get arg1 tag/data 
  arg3 = *(s32 *)(iSP + 4);   		// get arg1 tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  /* Memory Read Internal */

vma-memory-read16178:
  t3 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t1 = t2 + ivory;
  t4 = *(s32 *)&processor->scovlimit;   
  t6 = (t1 * 4);   
  t8 = LDQ_U(t1);   
  t3 = t2 - t3;   		// Stack cache offset 
  t4 = ((u64)t3 < (u64)t4) ? 1 : 0;   		// In range? 
  t6 = *(s32 *)t6;   
  t8 = (u8)(t8 >> ((t1&7)*8));   
  if (t4 != 0)   
    goto vma-memory-read16180;

vma-memory-read16179:
  t6 = (u32)t6;   

vma-memory-read16186:
  t6 = (u32)t6;   
  t1 = arg3 & 63;		// Strip off any CDR code bits. 
  t10 = (t1 == Type_Fixnum) ? 1 : 0;   

force-alignment16193:
  if (_trace) printf("force-alignment16193:\n");
  if (t10 == 0) 
    goto basic-dispatch16188;
  /* Here if argument TypeFixnum */
  t7 = zero - 2;   		// t7= -2 
  t7 = t7 << (arg1 & 63);   		// Unmask 
  t5 = ~t7;   		// reuse t5 as mask 
  t3 = arg4 & ~t7;		// T3= masked new value. 
  t5 = t5 << (arg2 & 63);   		// t5 is the inplace mask 
  t4 = t3 << (arg2 & 63);   		// t4 is the shifted field 
  t6 = t6 & ~t5;		// Clear out existing bits in arg2 field 
  t6 = t4 | t6;		// Put the new bits in 
  t4 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = t2 + ivory;
  t10 = *(s32 *)&processor->scovlimit;   
  t5 = (t3 * 4);   
  t1 = LDQ_U(t3);   
  t4 = t2 - t4;   		// Stack cache offset 
  t10 = ((u64)t4 < (u64)t10) ? 1 : 0;   		// In range? 
  t4 = (t8 & 0xff) << ((t3&7)*8);   
  t1 = t1 & ~(0xffL << (t3&7)*8);   

force-alignment16190:
  if (_trace) printf("force-alignment16190:\n");
  t1 = t1 | t4;
  STQ_U(t3, t1);   
  *(u32 *)t5 = t6;
  if (t10 != 0)   		// J. if in cache 
    goto vma-memory-write16189;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

basic-dispatch16188:
  if (_trace) printf("basic-dispatch16188:\n");
  /* Here for all other cases */
  arg5 = 0;
  arg2 = 6;
  goto illegaloperand;

basic-dispatch16187:
  if (_trace) printf("basic-dispatch16187:\n");

pdpbillop:
  if (_trace) printf("pdpbillop:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = iSP - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t1 = t2 + t1;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 57;
  goto illegaloperand;

vma-memory-write16189:
  if (_trace) printf("vma-memory-write16189:\n");
  t4 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment16194:
  if (_trace) printf("force-alignment16194:\n");
  t3 = *(u64 *)&(processor->stackcachedata);   
  t4 = t2 - t4;   		// Stack cache offset 
  t3 = (t4 * 8) + t3;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t3 = t6;
		/* write the stack cache */
  *(u32 *)(t3 + 4) = t8;
  goto NEXTINSTRUCTION;   

vma-memory-read16180:
  if (_trace) printf("vma-memory-read16180:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t3 = (t3 * 8) + t4;  		// reconstruct SCA 
  t6 = *(s32 *)t3;   
  t8 = *(s32 *)(t3 + 4);   		// Read from stack cache 
  goto vma-memory-read16179;   

/* end DoPDpb */
  /* End of Halfword operand from stack instruction - DoPDpb */
/* start DoPTagDpb */

  /* Field Extraction instruction - DoPTagDpb */

doptagdpb:
  if (_trace) printf("doptagdpb:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoPTagDpbIM:
  if (_trace) printf("DoPTagDpbIM:\n");

DoPTagDpbSP:
  if (_trace) printf("DoPTagDpbSP:\n");

DoPTagDpbLP:
  if (_trace) printf("DoPTagDpbLP:\n");

DoPTagDpbFP:
  if (_trace) printf("DoPTagDpbFP:\n");
  arg1 = arg3 >> 37;   		// Shift the 'size-1' bits into place 
  arg2 = arg2 & 31;		// mask out the unwanted bits in arg2 
  arg1 = arg1 & 31;		// mask out the unwanted bits in arg1 
  /* arg1 has size-1, arg2 has position. */
  t2 = *(s32 *)iSP;   		// Get arg2 tag/data 
  t1 = *(s32 *)(iSP + 4);   		// Get arg2 tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  t2 = (u32)t2;   
  t3 = t1 - Type_PhysicalAddress;   
  t3 = t3 & 63;
  if (t3 == 0) 
    goto ptagdpbillop;
  arg4 = *(s32 *)iSP;   		// get arg1 tag/data 
  arg3 = *(s32 *)(iSP + 4);   		// get arg1 tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  /* Memory Read Internal */

vma-memory-read16195:
  t3 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t1 = t2 + ivory;
  t4 = *(s32 *)&processor->scovlimit;   
  t8 = (t1 * 4);   
  t6 = LDQ_U(t1);   
  t3 = t2 - t3;   		// Stack cache offset 
  t4 = ((u64)t3 < (u64)t4) ? 1 : 0;   		// In range? 
  t8 = *(s32 *)t8;   
  t6 = (u8)(t6 >> ((t1&7)*8));   
  if (t4 != 0)   
    goto vma-memory-read16197;

vma-memory-read16196:

vma-memory-read16203:
  t1 = arg3 & 63;		// Strip off any CDR code bits. 
  t10 = (t1 == Type_Fixnum) ? 1 : 0;   

force-alignment16210:
  if (_trace) printf("force-alignment16210:\n");
  if (t10 == 0) 
    goto basic-dispatch16205;
  /* Here if argument TypeFixnum */
  t7 = zero - 2;   		// t7= -2 
  t7 = t7 << (arg1 & 63);   		// Unmask 
  t5 = ~t7;   		// reuse t5 as mask 
  t3 = arg4 & ~t7;		// T3= masked new value. 
  t5 = t5 << (arg2 & 63);   		// t5 is the inplace mask 
  t4 = t3 << (arg2 & 63);   		// t4 is the shifted field 
  t6 = t6 & ~t5;		// Clear out existing bits in arg2 field 
  t6 = t4 | t6;		// Put the new bits in 
  t4 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = t2 + ivory;
  t10 = *(s32 *)&processor->scovlimit;   
  t5 = (t3 * 4);   
  t1 = LDQ_U(t3);   
  t4 = t2 - t4;   		// Stack cache offset 
  t10 = ((u64)t4 < (u64)t10) ? 1 : 0;   		// In range? 
  t4 = (t6 & 0xff) << ((t3&7)*8);   
  t1 = t1 & ~(0xffL << (t3&7)*8);   

force-alignment16207:
  if (_trace) printf("force-alignment16207:\n");
  t1 = t1 | t4;
  STQ_U(t3, t1);   
  *(u32 *)t5 = t8;
  if (t10 != 0)   		// J. if in cache 
    goto vma-memory-write16206;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

basic-dispatch16205:
  if (_trace) printf("basic-dispatch16205:\n");
  /* Here for all other cases */
  arg5 = 0;
  arg2 = 6;
  goto illegaloperand;

basic-dispatch16204:
  if (_trace) printf("basic-dispatch16204:\n");

ptagdpbillop:
  if (_trace) printf("ptagdpbillop:\n");
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = iSP - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t1 = t2 + t1;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 57;
  goto illegaloperand;

vma-memory-write16206:
  if (_trace) printf("vma-memory-write16206:\n");
  t4 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment16211:
  if (_trace) printf("force-alignment16211:\n");
  t3 = *(u64 *)&(processor->stackcachedata);   
  t4 = t2 - t4;   		// Stack cache offset 
  t3 = (t4 * 8) + t3;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t3 = t8;
		/* write the stack cache */
  *(u32 *)(t3 + 4) = t6;
  goto NEXTINSTRUCTION;   

vma-memory-read16197:
  if (_trace) printf("vma-memory-read16197:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t3 = (t3 * 8) + t4;  		// reconstruct SCA 
  t8 = *(s32 *)t3;   
  t6 = *(s32 *)(t3 + 4);   		// Read from stack cache 
  goto vma-memory-read16196;   

/* end DoPTagDpb */
  /* End of Halfword operand from stack instruction - DoPTagDpb */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunfext.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunlexi.as
 ************************************************************************/

  /* Lexical variable accessors. */
/* start DoPushLexicalVarN */

  /* Halfword operand from stack instruction - DoPushLexicalVarN */
  /* arg2 has the preloaded 8 bit operand. */

dopushlexicalvarn:
  if (_trace) printf("dopushlexicalvarn:\n");

DoPushLexicalVarNSP:
  if (_trace) printf("DoPushLexicalVarNSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPushLexicalVarNLP:
  if (_trace) printf("DoPushLexicalVarNLP:\n");

DoPushLexicalVarNFP:
  if (_trace) printf("DoPushLexicalVarNFP:\n");

begindopushlexicalvarn:
  if (_trace) printf("begindopushlexicalvarn:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t4 = arg3 >> 10;   		// Position the opcode 
  t1 = *(s32 *)arg1;   
  t2 = *(s32 *)(arg1 + 4);   
  t4 = t4 & 7;		// Get the lexical var number 
  t1 = (u32)t1;   
  /* TagType. */
  t3 = t2 & 63;
  t3 = t3 - Type_List;   
  t3 = t3 & ~4L;
  t1 = t1 + t4;		// Compute the address of the lexical variable. 
  if (t3 != 0)   
    goto pushlexvariop;
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read16212:
  t6 = t1 + ivory;
  t3 = (t6 * 4);   
  t2 = LDQ_U(t6);   
  t4 = t1 - arg5;   		// Stack cache offset 
  t7 = *(u64 *)&(processor->dataread_mask);   
  t5 = ((u64)t4 < (u64)arg6) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t2 = (u8)(t2 >> ((t6&7)*8));   
  if (t5 != 0)   
    goto vma-memory-read16214;

vma-memory-read16213:
  t6 = zero + 240;   
  t7 = t7 >> (t2 & 63);   
  t6 = t6 >> (t2 & 63);   
  if (t7 & 1)   
    goto vma-memory-read16216;

vma-memory-read16223:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t4 = t2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  goto cachevalid;   

pushlexvariop:
  if (_trace) printf("pushlexvariop:\n");
  arg5 = 0;
  arg2 = 82;
  goto illegaloperand;

vma-memory-read16214:
  if (_trace) printf("vma-memory-read16214:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t4 = (t4 * 8) + t5;  		// reconstruct SCA 
  t3 = *(s32 *)t4;   
  t2 = *(s32 *)(t4 + 4);   		// Read from stack cache 
  goto vma-memory-read16213;   

vma-memory-read16216:
  if (_trace) printf("vma-memory-read16216:\n");
  if ((t6 & 1) == 0)   
    goto vma-memory-read16215;
  t1 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read16212;   

vma-memory-read16215:
  if (_trace) printf("vma-memory-read16215:\n");
  t7 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t6 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t6 = (t6 * 4) + t7;   		// Adjust for a longword load 
  t7 = *(s32 *)t6;   		// Get the memory action 

vma-memory-read16220:
  if (_trace) printf("vma-memory-read16220:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0) 
    goto vma-memory-read16219;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto vma-memory-read16223;   

vma-memory-read16219:

vma-memory-read16218:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

DoPushLexicalVarNIM:
  goto doistageerror;

/* end DoPushLexicalVarN */
  /* End of Halfword operand from stack instruction - DoPushLexicalVarN */
/* start DoPopLexicalVarN */

  /* Halfword operand from stack instruction - DoPopLexicalVarN */
  /* arg2 has the preloaded 8 bit operand. */

dopoplexicalvarn:
  if (_trace) printf("dopoplexicalvarn:\n");

DoPopLexicalVarNSP:
  if (_trace) printf("DoPopLexicalVarNSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPopLexicalVarNLP:
  if (_trace) printf("DoPopLexicalVarNLP:\n");

DoPopLexicalVarNFP:
  if (_trace) printf("DoPopLexicalVarNFP:\n");

begindopoplexicalvarn:
  if (_trace) printf("begindopoplexicalvarn:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t4 = arg3 >> 10;   		// Position the opcode 
  t1 = *(s32 *)arg1;   
  t2 = *(s32 *)(arg1 + 4);   
  t4 = t4 & 7;		// Get the lexical var number 
  t1 = (u32)t1;   
  /* TagType. */
  t3 = t2 & 63;
  t3 = t3 - Type_List;   
  t3 = t3 & ~4L;
  t1 = t1 + t4;		// Compute the address of the lexical variable. 
  if (t3 != 0)   
    goto poplexvariop;
  t3 = *(s32 *)iSP;   
  t2 = *(s32 *)(iSP + 4);   
  iSP = iSP - 8;   		// Pop Stack. 
  t3 = (u32)t3;   
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read16224:
  t8 = t1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = t1 - arg5;   		// Stack cache offset 
  t9 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read16226;

vma-memory-read16225:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t9 & 1)   
    goto vma-memory-read16228;

vma-memory-read16234:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = t1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = t1 - arg5;   		// Stack cache offset 
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment16236:
  if (_trace) printf("force-alignment16236:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t3;
  if (t9 != 0)   		// J. if in cache 
    goto vma-memory-write16235;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

poplexvariop:
  if (_trace) printf("poplexvariop:\n");
  arg5 = 0;
  arg2 = 17;
  goto illegaloperand;

vma-memory-write16235:
  if (_trace) printf("vma-memory-write16235:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = t1 - arg5;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = t3;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

vma-memory-read16226:
  if (_trace) printf("vma-memory-read16226:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read16225;   

vma-memory-read16228:
  if (_trace) printf("vma-memory-read16228:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read16227;
  t1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read16224;   

vma-memory-read16227:
  if (_trace) printf("vma-memory-read16227:\n");
  t9 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
  t9 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read16231:

vma-memory-read16230:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

DoPopLexicalVarNIM:
  goto doistageerror;

/* end DoPopLexicalVarN */
  /* End of Halfword operand from stack instruction - DoPopLexicalVarN */
/* start DoMovemLexicalVarN */

  /* Halfword operand from stack instruction - DoMovemLexicalVarN */
  /* arg2 has the preloaded 8 bit operand. */

domovemlexicalvarn:
  if (_trace) printf("domovemlexicalvarn:\n");

DoMovemLexicalVarNSP:
  if (_trace) printf("DoMovemLexicalVarNSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoMovemLexicalVarNLP:
  if (_trace) printf("DoMovemLexicalVarNLP:\n");

DoMovemLexicalVarNFP:
  if (_trace) printf("DoMovemLexicalVarNFP:\n");

begindomovemlexicalvarn:
  if (_trace) printf("begindomovemlexicalvarn:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t4 = arg3 >> 10;   		// Position the opcode 
  t1 = *(s32 *)arg1;   
  t2 = *(s32 *)(arg1 + 4);   
  t4 = t4 & 7;		// Get the lexical var number 
  t1 = (u32)t1;   
  /* TagType. */
  t3 = t2 & 63;
  t3 = t3 - Type_List;   
  t3 = t3 & ~4L;
  t1 = t1 + t4;		// Compute the address of the lexical variable. 
  if (t3 != 0)   
    goto movemlexvariop;
  t3 = *(s32 *)iSP;   
  t2 = *(s32 *)(iSP + 4);   
  t3 = (u32)t3;   
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read16237:
  t8 = t1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = t1 - arg5;   		// Stack cache offset 
  t9 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read16239;

vma-memory-read16238:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t9 & 1)   
    goto vma-memory-read16241;

vma-memory-read16247:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = t1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = t1 - arg5;   		// Stack cache offset 
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment16249:
  if (_trace) printf("force-alignment16249:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t3;
  if (t9 != 0)   		// J. if in cache 
    goto vma-memory-write16248;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

movemlexvariop:
  if (_trace) printf("movemlexvariop:\n");
  arg5 = 0;
  arg2 = 17;
  goto illegaloperand;

vma-memory-write16248:
  if (_trace) printf("vma-memory-write16248:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = t1 - arg5;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = t3;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

vma-memory-read16239:
  if (_trace) printf("vma-memory-read16239:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read16238;   

vma-memory-read16241:
  if (_trace) printf("vma-memory-read16241:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read16240;
  t1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read16237;   

vma-memory-read16240:
  if (_trace) printf("vma-memory-read16240:\n");
  t9 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
  t9 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read16244:

vma-memory-read16243:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

DoMovemLexicalVarNIM:
  goto doistageerror;

/* end DoMovemLexicalVarN */
  /* End of Halfword operand from stack instruction - DoMovemLexicalVarN */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunlexi.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunbits.as
 ************************************************************************/

  /* Bits. */
/* start DoLogand */

  /* Halfword operand from stack instruction - DoLogand */
  /* arg2 has the preloaded 8 bit operand. */

dologand:
  if (_trace) printf("dologand:\n");

DoLogandSP:
  if (_trace) printf("DoLogandSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoLogandLP:
  if (_trace) printf("DoLogandLP:\n");

DoLogandFP:
  if (_trace) printf("DoLogandFP:\n");

headdologand:
  if (_trace) printf("headdologand:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindologand:
  if (_trace) printf("begindologand:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  t3 = *(s32 *)(iSP + 4);   		// Get tag from ARG1 
  t4 = *(s32 *)iSP;   		// Grab data for ARG1 
  t1 = (u8)(arg1 >> ((4&7)*8));   		// Get tag from ARG2 
  t6 = t3 - Type_Fixnum;   
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto ilogical16250;
  t6 = t1 - Type_Fixnum;   
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto ilogical16251;
  /* Here we know that both args are fixnums! */
  t4 = t4 & arg1;		// Do the operation 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  r31 = r31 | r31;
  t4 = (u32)t4;   		// Strip high bits 
  t1 = Type_Fixnum;
		/* Push result */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;   

ilogical16250:
  if (_trace) printf("ilogical16250:\n");
  arg6 = t3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

ilogical16251:
  if (_trace) printf("ilogical16251:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

DoLogandIM:
  if (_trace) printf("DoLogandIM:\n");
  t3 = *(s32 *)(iSP + 4);   		// Get tag from ARG1 
  arg2 = arg2 << 56;   
  t4 = *(s32 *)iSP;   		// Grab data for ARG1 
  arg2 = (s64)arg2 >> 56;   
  t6 = t3 - Type_Fixnum;   
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto ilogical-immediate16252;
  /* Here we know that both args are fixnums! */
  t4 = t4 & arg2;		// Do the operation 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  r31 = r31 | r31;
  t4 = (u32)t4;   		// Strip high bits 
  t1 = Type_Fixnum;
		/* Push result */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;   

ilogical-immediate16252:
  if (_trace) printf("ilogical-immediate16252:\n");
  arg1 = Type_Fixnum;
  arg2 = (u32)arg2;   
  /* SetTag. */
  t1 = arg1 << 32;   
  t1 = arg2 | t1;
  arg6 = t3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

/* end DoLogand */
  /* End of Halfword operand from stack instruction - DoLogand */
/* start DoLogior */

  /* Halfword operand from stack instruction - DoLogior */
  /* arg2 has the preloaded 8 bit operand. */

dologior:
  if (_trace) printf("dologior:\n");

DoLogiorSP:
  if (_trace) printf("DoLogiorSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoLogiorLP:
  if (_trace) printf("DoLogiorLP:\n");

DoLogiorFP:
  if (_trace) printf("DoLogiorFP:\n");

headdologior:
  if (_trace) printf("headdologior:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindologior:
  if (_trace) printf("begindologior:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  t3 = *(s32 *)(iSP + 4);   		// Get tag from ARG1 
  t4 = *(s32 *)iSP;   		// Grab data for ARG1 
  t1 = (u8)(arg1 >> ((4&7)*8));   		// Get tag from ARG2 
  t6 = t3 - Type_Fixnum;   
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto ilogical16253;
  t6 = t1 - Type_Fixnum;   
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto ilogical16254;
  /* Here we know that both args are fixnums! */
  t4 = t4 | arg1;		// Do the operation 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  r31 = r31 | r31;
  t4 = (u32)t4;   		// Strip high bits 
  t1 = Type_Fixnum;
		/* Push result */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;   

ilogical16253:
  if (_trace) printf("ilogical16253:\n");
  arg6 = t3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

ilogical16254:
  if (_trace) printf("ilogical16254:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

DoLogiorIM:
  if (_trace) printf("DoLogiorIM:\n");
  t3 = *(s32 *)(iSP + 4);   		// Get tag from ARG1 
  arg2 = arg2 << 56;   
  t4 = *(s32 *)iSP;   		// Grab data for ARG1 
  arg2 = (s64)arg2 >> 56;   
  t6 = t3 - Type_Fixnum;   
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto ilogical-immediate16255;
  /* Here we know that both args are fixnums! */
  t4 = t4 | arg2;		// Do the operation 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  r31 = r31 | r31;
  t4 = (u32)t4;   		// Strip high bits 
  t1 = Type_Fixnum;
		/* Push result */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;   

ilogical-immediate16255:
  if (_trace) printf("ilogical-immediate16255:\n");
  arg1 = Type_Fixnum;
  arg2 = (u32)arg2;   
  /* SetTag. */
  t1 = arg1 << 32;   
  t1 = arg2 | t1;
  arg6 = t3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

/* end DoLogior */
  /* End of Halfword operand from stack instruction - DoLogior */
/* start DoLogxor */

  /* Halfword operand from stack instruction - DoLogxor */
  /* arg2 has the preloaded 8 bit operand. */

dologxor:
  if (_trace) printf("dologxor:\n");

DoLogxorSP:
  if (_trace) printf("DoLogxorSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoLogxorLP:
  if (_trace) printf("DoLogxorLP:\n");

DoLogxorFP:
  if (_trace) printf("DoLogxorFP:\n");

headdologxor:
  if (_trace) printf("headdologxor:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindologxor:
  if (_trace) printf("begindologxor:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  t3 = *(s32 *)(iSP + 4);   		// Get tag from ARG1 
  t4 = *(s32 *)iSP;   		// Grab data for ARG1 
  t1 = (u8)(arg1 >> ((4&7)*8));   		// Get tag from ARG2 
  t6 = t3 - Type_Fixnum;   
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto ilogical16256;
  t6 = t1 - Type_Fixnum;   
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto ilogical16257;
  /* Here we know that both args are fixnums! */
  t4 = t4 ^ arg1;   		// Do the operation 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  r31 = r31 | r31;
  t4 = (u32)t4;   		// Strip high bits 
  t1 = Type_Fixnum;
		/* Push result */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;   

ilogical16256:
  if (_trace) printf("ilogical16256:\n");
  arg6 = t3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

ilogical16257:
  if (_trace) printf("ilogical16257:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

DoLogxorIM:
  if (_trace) printf("DoLogxorIM:\n");
  t3 = *(s32 *)(iSP + 4);   		// Get tag from ARG1 
  arg2 = arg2 << 56;   
  t4 = *(s32 *)iSP;   		// Grab data for ARG1 
  arg2 = (s64)arg2 >> 56;   
  t6 = t3 - Type_Fixnum;   
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto ilogical-immediate16258;
  /* Here we know that both args are fixnums! */
  t4 = t4 ^ arg2;   		// Do the operation 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  r31 = r31 | r31;
  t4 = (u32)t4;   		// Strip high bits 
  t1 = Type_Fixnum;
		/* Push result */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;   

ilogical-immediate16258:
  if (_trace) printf("ilogical-immediate16258:\n");
  arg1 = Type_Fixnum;
  arg2 = (u32)arg2;   
  /* SetTag. */
  t1 = arg1 << 32;   
  t1 = arg2 | t1;
  arg6 = t3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

/* end DoLogxor */
  /* End of Halfword operand from stack instruction - DoLogxor */
/* start DoAsh */

  /* Halfword operand from stack instruction - DoAsh */

doash:
  if (_trace) printf("doash:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoAshIM:
  if (_trace) printf("DoAshIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment16272:
  if (_trace) printf("force-alignment16272:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoash;   

DoAshSP:
  if (_trace) printf("DoAshSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoAshLP:
  if (_trace) printf("DoAshLP:\n");

DoAshFP:
  if (_trace) printf("DoAshFP:\n");

headdoash:
  if (_trace) printf("headdoash:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoash:
  if (_trace) printf("begindoash:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg4 = *(s32 *)iSP;   		// Get ARG1. 
  arg3 = *(s32 *)(iSP + 4);   
  arg4 = (u32)arg4;   
  arg2 = arg1 >> 32;   		// Get ARG2's tag. 
  arg1 = (s32)arg1;		// Sign extended the rotation amount. 
  t1 = arg2 & 63;		// Strip off any CDR code bits. 
  t3 = arg3 & 63;		// Strip off any CDR code bits. 
  t2 = (t1 == Type_Fixnum) ? 1 : 0;   

force-alignment16271:
  if (_trace) printf("force-alignment16271:\n");
  if (t2 == 0) 
    goto basic-dispatch16264;
  /* Here if argument TypeFixnum */
  t4 = (t3 == Type_Fixnum) ? 1 : 0;   

force-alignment16268:
  if (_trace) printf("force-alignment16268:\n");
  if (t4 == 0) 
    goto binary-type-dispatch16261;
  /* Here if argument TypeFixnum */
  if (arg4 == 0) 		// B. if ash of zero -- trivial case 
    goto zerash;
  if ((s64)arg1 <= 0)  		// B. if negative ash. 
    goto negash;
  arg4 = (s32)arg4;		// Sign extend ARG1 before shifting. 
  arg5 = arg1 - 32;   
  if ((s64)arg5 > 0)   
    goto ashovexc;
  arg5 = arg4 << (arg1 & 63);   		// Shift Left 
  arg6 = arg4 ^ arg5;   
  arg6 = arg6 >> 31;   		// arg6<0>=1 if overflow, 0 otherwise 
  /* TagType. */
  arg2 = arg2 & 63;
  if (arg6 != 0)   		// J. if overflow 
    goto ashovexc;
  *(u32 *)iSP = arg5;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = arg2;
  goto NEXTINSTRUCTION;   

negash:
  if (_trace) printf("negash:\n");
  arg1 = zero - arg1;   
  arg4 = (s32)arg4;		// Sign extend ARG1 before shifting. 
  arg5 = (s64)arg4 >> $27(arg1 & 63);   		// Shift Right 
  /* TagType. */
  arg2 = arg2 & 63;
  *(u32 *)iSP = arg5;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = arg2;
  goto NEXTINSTRUCTION;   

zerash:
  if (_trace) printf("zerash:\n");
  arg5 = Type_Fixnum;
  *(u32 *)iSP = arg4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = arg5;
  goto NEXTINSTRUCTION;   

basic-dispatch16265:
  if (_trace) printf("basic-dispatch16265:\n");

basic-dispatch16264:
  if (_trace) printf("basic-dispatch16264:\n");
  /* Here for all other cases */

binary-type-dispatch16260:
  if (_trace) printf("binary-type-dispatch16260:\n");
  arg1 = (u32)arg1;   
  /* SetTag. */
  t2 = arg2 << 32;   
  t2 = arg1 | t2;
  arg6 = arg2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch16262;   

binary-type-dispatch16261:
  if (_trace) printf("binary-type-dispatch16261:\n");
  arg1 = (u32)arg1;   
  /* SetTag. */
  t2 = arg2 << 32;   
  t2 = arg1 | t2;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

binary-type-dispatch16262:
  if (_trace) printf("binary-type-dispatch16262:\n");

basic-dispatch16263:
  if (_trace) printf("basic-dispatch16263:\n");

ashovexc:
  if (_trace) printf("ashovexc:\n");
  arg1 = (u32)arg1;   
  /* SetTag. */
  t1 = arg2 << 32;   
  t1 = arg1 | t1;
  arg6 = arg2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto exception;

/* end DoAsh */
  /* End of Halfword operand from stack instruction - DoAsh */
/* start DoRot */

  /* Halfword operand from stack instruction - DoRot */
  /* arg2 has the preloaded 8 bit operand. */

dorot:
  if (_trace) printf("dorot:\n");

DoRotSP:
  if (_trace) printf("DoRotSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindorot;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoRotLP:
  if (_trace) printf("DoRotLP:\n");

DoRotFP:
  if (_trace) printf("DoRotFP:\n");

begindorot:
  if (_trace) printf("begindorot:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 

with-simple-binary-fixnum-operation16274:
  if (_trace) printf("with-simple-binary-fixnum-operation16274:\n");
  t4 = (u32)(arg6 >> ((4&7)*8));   		// Arg1 on the stack 
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t1 = (u32)arg6;   		// Arg1 on the stack 
  t5 = *(s32 *)(arg1 + 4);   		// Arg2 from operand 
  t4 = t4 & 63;		// Strip CDR code if any. 
  t2 = *(s32 *)arg1;   		// Arg2 from operand 
  t4 = t4 - Type_Fixnum;   
  t8 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t5 = t5 & 63;		// Strip CDR code if any. 
  if (t4 != 0)   
    goto with-simple-binary-fixnum-operation16273;
  t2 = (u32)t2;   
  t5 = t5 - Type_Fixnum;   

force-alignment16275:
  if (_trace) printf("force-alignment16275:\n");
  if (t5 != 0)   
    goto with-simple-binary-fixnum-operation16273;
  t2 = t2 & 31;		// Get low 5 bits of the rotation 
  t3 = t1 << (t2 & 63);   		// Shift left to get new high bits 
  t6 = (u32)(t3 >> ((4&7)*8));   		// Get new low bits 
  t3 = t3 | t6;		// Glue two parts of shifted operand together 

force-alignment16276:
  if (_trace) printf("force-alignment16276:\n");
  iPC = t7;
		/* Put the result back on the stack */
  *(u32 *)iSP = t3;
  iCP = t8;
  goto cachevalid;   

DoRotIM:
  if (_trace) printf("DoRotIM:\n");
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;   
  goto with-simple-binary-fixnum-operation16274;   

with-simple-binary-fixnum-operation16273:
  if (_trace) printf("with-simple-binary-fixnum-operation16273:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end DoRot */
  /* End of Halfword operand from stack instruction - DoRot */
/* start DoLsh */

  /* Halfword operand from stack instruction - DoLsh */
  /* arg2 has the preloaded 8 bit operand. */

dolsh:
  if (_trace) printf("dolsh:\n");

DoLshSP:
  if (_trace) printf("DoLshSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindolsh;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoLshLP:
  if (_trace) printf("DoLshLP:\n");

DoLshFP:
  if (_trace) printf("DoLshFP:\n");

begindolsh:
  if (_trace) printf("begindolsh:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 

with-simple-binary-fixnum-operation16278:
  if (_trace) printf("with-simple-binary-fixnum-operation16278:\n");
  t4 = (u32)(arg6 >> ((4&7)*8));   		// Arg1 on the stack 
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t1 = (u32)arg6;   		// Arg1 on the stack 
  t5 = *(s32 *)(arg1 + 4);   		// Arg2 from operand 
  t4 = t4 & 63;		// Strip CDR code if any. 
  t2 = *(s32 *)arg1;   		// Arg2 from operand 
  t4 = t4 - Type_Fixnum;   
  t8 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t5 = t5 & 63;		// Strip CDR code if any. 
  if (t4 != 0)   
    goto with-simple-binary-fixnum-operation16277;
  t5 = t5 - Type_Fixnum;   

force-alignment16279:
  if (_trace) printf("force-alignment16279:\n");
  if (t5 != 0)   
    goto with-simple-binary-fixnum-operation16277;
  if ((s64)t2 < 0)   		// B. if negative lsh. 
    goto neglsh;
  t3 = t2 - 32;   
  if ((s64)t3 >= 0)   
    goto returnzero;
  t3 = t1 << (t2 & 63);   		// Shift Left 
  goto lshdone;   

neglsh:
  if (_trace) printf("neglsh:\n");
  t2 = zero - t2;   
  t3 = t2 - 32;   
  if ((s64)t3 >= 0)   
    goto returnzero;
  t3 = t1 >> (t2 & 63);   		// Shift Right 
  goto lshdone;   

returnzero:
  if (_trace) printf("returnzero:\n");
  t3 = t3 & ~t3;

lshdone:
  if (_trace) printf("lshdone:\n");

force-alignment16280:
  if (_trace) printf("force-alignment16280:\n");
  iPC = t7;
		/* Put the result back on the stack */
  *(u32 *)iSP = t3;
  iCP = t8;
  goto cachevalid;   

DoLshIM:
  if (_trace) printf("DoLshIM:\n");
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment16281:
  if (_trace) printf("force-alignment16281:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;   
  goto with-simple-binary-fixnum-operation16278;   

with-simple-binary-fixnum-operation16277:
  if (_trace) printf("with-simple-binary-fixnum-operation16277:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end DoLsh */
  /* End of Halfword operand from stack instruction - DoLsh */
/* start Do32BitPlus */

  /* Halfword operand from stack instruction - Do32BitPlus */
  /* arg2 has the preloaded 8 bit operand. */

do32bitplus:
  if (_trace) printf("do32bitplus:\n");

Do32BitPlusSP:
  if (_trace) printf("Do32BitPlusSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindo32bitplus;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

Do32BitPlusLP:
  if (_trace) printf("Do32BitPlusLP:\n");

Do32BitPlusFP:
  if (_trace) printf("Do32BitPlusFP:\n");

begindo32bitplus:
  if (_trace) printf("begindo32bitplus:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 

with-simple-binary-fixnum-operation16283:
  if (_trace) printf("with-simple-binary-fixnum-operation16283:\n");
  t4 = (u32)(arg6 >> ((4&7)*8));   		// Arg1 on the stack 
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t1 = (u32)arg6;   		// Arg1 on the stack 
  t5 = *(s32 *)(arg1 + 4);   		// Arg2 from operand 
  t4 = t4 & 63;		// Strip CDR code if any. 
  t2 = *(s32 *)arg1;   		// Arg2 from operand 
  t4 = t4 - Type_Fixnum;   
  t8 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t5 = t5 & 63;		// Strip CDR code if any. 
  if (t4 != 0)   
    goto with-simple-binary-fixnum-operation16282;
  t2 = (u32)t2;   
  t5 = t5 - Type_Fixnum;   

force-alignment16284:
  if (_trace) printf("force-alignment16284:\n");
  if (t5 != 0)   
    goto with-simple-binary-fixnum-operation16282;
  t3 = t1 + t2;		// Perform the 32 bit Add. 

force-alignment16285:
  if (_trace) printf("force-alignment16285:\n");
  iPC = t7;
		/* Put the result back on the stack */
  *(u32 *)iSP = t3;
  iCP = t8;
  goto cachevalid;   

Do32BitPlusIM:
  if (_trace) printf("Do32BitPlusIM:\n");
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;   
  goto with-simple-binary-fixnum-operation16283;   

with-simple-binary-fixnum-operation16282:
  if (_trace) printf("with-simple-binary-fixnum-operation16282:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end Do32BitPlus */
  /* End of Halfword operand from stack instruction - Do32BitPlus */
/* start Do32BitDifference */

  /* Halfword operand from stack instruction - Do32BitDifference */
  /* arg2 has the preloaded 8 bit operand. */

do32bitdifference:
  if (_trace) printf("do32bitdifference:\n");

Do32BitDifferenceSP:
  if (_trace) printf("Do32BitDifferenceSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindo32bitdifference;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

Do32BitDifferenceLP:
  if (_trace) printf("Do32BitDifferenceLP:\n");

Do32BitDifferenceFP:
  if (_trace) printf("Do32BitDifferenceFP:\n");

begindo32bitdifference:
  if (_trace) printf("begindo32bitdifference:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 

with-simple-binary-fixnum-operation16287:
  if (_trace) printf("with-simple-binary-fixnum-operation16287:\n");
  t4 = (u32)(arg6 >> ((4&7)*8));   		// Arg1 on the stack 
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t1 = (u32)arg6;   		// Arg1 on the stack 
  t5 = *(s32 *)(arg1 + 4);   		// Arg2 from operand 
  t4 = t4 & 63;		// Strip CDR code if any. 
  t2 = *(s32 *)arg1;   		// Arg2 from operand 
  t4 = t4 - Type_Fixnum;   
  t8 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t5 = t5 & 63;		// Strip CDR code if any. 
  if (t4 != 0)   
    goto with-simple-binary-fixnum-operation16286;
  t2 = (u32)t2;   
  t5 = t5 - Type_Fixnum;   

force-alignment16288:
  if (_trace) printf("force-alignment16288:\n");
  if (t5 != 0)   
    goto with-simple-binary-fixnum-operation16286;
  t3 = t1 - t2;   		// Perform the 32 bit Difference. 

force-alignment16289:
  if (_trace) printf("force-alignment16289:\n");
  iPC = t7;
		/* Put the result back on the stack */
  *(u32 *)iSP = t3;
  iCP = t8;
  goto cachevalid;   

Do32BitDifferenceIM:
  if (_trace) printf("Do32BitDifferenceIM:\n");
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;   
  goto with-simple-binary-fixnum-operation16287;   

with-simple-binary-fixnum-operation16286:
  if (_trace) printf("with-simple-binary-fixnum-operation16286:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end Do32BitDifference */
  /* End of Halfword operand from stack instruction - Do32BitDifference */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunbits.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunblok.as
 ************************************************************************/

  /* Block Instructions. */
/* start DoBlock0Read */

  /* Halfword 10 bit immediate instruction - DoBlock0Read */

doblock0read:
  if (_trace) printf("doblock0read:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBlock0ReadIM:
  if (_trace) printf("DoBlock0ReadIM:\n");

DoBlock0ReadSP:
  if (_trace) printf("DoBlock0ReadSP:\n");

DoBlock0ReadLP:
  if (_trace) printf("DoBlock0ReadLP:\n");

DoBlock0ReadFP:
  if (_trace) printf("DoBlock0ReadFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar0;   
  goto blockread;   

/* end DoBlock0Read */
  /* End of Halfword operand from stack instruction - DoBlock0Read */
/* start DoBlock0Write */

  /* Halfword operand from stack instruction - DoBlock0Write */

doblock0write:
  if (_trace) printf("doblock0write:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoBlock0WriteIM:
  if (_trace) printf("DoBlock0WriteIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment16290:
  if (_trace) printf("force-alignment16290:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoblock0write;   

DoBlock0WriteSP:
  if (_trace) printf("DoBlock0WriteSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoBlock0WriteLP:
  if (_trace) printf("DoBlock0WriteLP:\n");

DoBlock0WriteFP:
  if (_trace) printf("DoBlock0WriteFP:\n");

headdoblock0write:
  if (_trace) printf("headdoblock0write:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoblock0write:
  if (_trace) printf("begindoblock0write:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg3 = *(s32 *)&processor->bar0;   
  arg2 = (u64)&processor->bar0;   
  goto blockwrite;   

/* end DoBlock0Write */
  /* End of Halfword operand from stack instruction - DoBlock0Write */
/* start DoBlock0ReadShift */

  /* Halfword 10 bit immediate instruction - DoBlock0ReadShift */

doblock0readshift:
  if (_trace) printf("doblock0readshift:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBlock0ReadShiftIM:
  if (_trace) printf("DoBlock0ReadShiftIM:\n");

DoBlock0ReadShiftSP:
  if (_trace) printf("DoBlock0ReadShiftSP:\n");

DoBlock0ReadShiftLP:
  if (_trace) printf("DoBlock0ReadShiftLP:\n");

DoBlock0ReadShiftFP:
  if (_trace) printf("DoBlock0ReadShiftFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar0;   
  goto blockreadshift;   

/* end DoBlock0ReadShift */
  /* End of Halfword operand from stack instruction - DoBlock0ReadShift */
/* start DoBlock3ReadShift */

  /* Halfword 10 bit immediate instruction - DoBlock3ReadShift */

doblock3readshift:
  if (_trace) printf("doblock3readshift:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBlock3ReadShiftIM:
  if (_trace) printf("DoBlock3ReadShiftIM:\n");

DoBlock3ReadShiftSP:
  if (_trace) printf("DoBlock3ReadShiftSP:\n");

DoBlock3ReadShiftLP:
  if (_trace) printf("DoBlock3ReadShiftLP:\n");

DoBlock3ReadShiftFP:
  if (_trace) printf("DoBlock3ReadShiftFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar3;   
  goto blockreadshift;   

/* end DoBlock3ReadShift */
  /* End of Halfword operand from stack instruction - DoBlock3ReadShift */
/* start DoBlock2ReadShift */

  /* Halfword 10 bit immediate instruction - DoBlock2ReadShift */

doblock2readshift:
  if (_trace) printf("doblock2readshift:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBlock2ReadShiftIM:
  if (_trace) printf("DoBlock2ReadShiftIM:\n");

DoBlock2ReadShiftSP:
  if (_trace) printf("DoBlock2ReadShiftSP:\n");

DoBlock2ReadShiftLP:
  if (_trace) printf("DoBlock2ReadShiftLP:\n");

DoBlock2ReadShiftFP:
  if (_trace) printf("DoBlock2ReadShiftFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar2;   
  goto blockreadshift;   

/* end DoBlock2ReadShift */
  /* End of Halfword operand from stack instruction - DoBlock2ReadShift */
/* start DoBlock1ReadShift */

  /* Halfword 10 bit immediate instruction - DoBlock1ReadShift */

doblock1readshift:
  if (_trace) printf("doblock1readshift:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBlock1ReadShiftIM:
  if (_trace) printf("DoBlock1ReadShiftIM:\n");

DoBlock1ReadShiftSP:
  if (_trace) printf("DoBlock1ReadShiftSP:\n");

DoBlock1ReadShiftLP:
  if (_trace) printf("DoBlock1ReadShiftLP:\n");

DoBlock1ReadShiftFP:
  if (_trace) printf("DoBlock1ReadShiftFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar1;   

blockreadshift:
  if (_trace) printf("blockreadshift:\n");
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t2 = *(s32 *)arg2;   		// Get the vma 
  t1 = arg1 >> 6;   		// cycle type 
  t4 = arg1 & 4;		// =no-incrementp 
  t5 = arg1 & 16;		// =cdr-code-nextp 
  t6 = arg1 & 32;		// =fixnum onlyp 
  t2 = (u32)t2;   
  /* Memory Read Internal */

vma-memory-read16295:
  t11 = t2 + ivory;
  t12 = (t1 * 4);   		// Cycle-number -> table offset 
  t8 = LDQ_U(t11);   
  t12 = (t12 * 4) + ivory;   
  t7 = (t11 * 4);   
  t9 = t2 - arg5;   		// Stack cache offset 
  t12 = *(u64 *)(t12 + PROCESSORSTATE_DATAREAD_MASK);   
  t10 = ((u64)t9 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = *(s32 *)t7;   
  t8 = (u8)(t8 >> ((t11&7)*8));   
  if (t10 != 0)   
    goto vma-memory-read16297;

vma-memory-read16296:
  t12 = t12 >> (t8 & 63);   
  t7 = (u32)t7;   
  if (t12 & 1)   
    goto vma-memory-read16299;

vma-memory-read16306:
  if (t6 == 0) 		// J. if we don't have to test for fixnump. 
    goto i%block-n-read-shift16291;
  t9 = t8 - Type_Fixnum;   
  t9 = t9 & 63;		// Strip CDR code 
  if (t9 != 0)   
    goto i%block-n-read-shift16294;

i%block-n-read-shift16291:
  if (_trace) printf("i%block-n-read-shift16291:\n");
  if (t4 != 0)   		// J. if we don't have to increment the address. 
    goto i%block-n-read-shift16292;
  t2 = t2 + 1;		// Increment the address 

i%block-n-read-shift16292:
  if (_trace) printf("i%block-n-read-shift16292:\n");
		/* Store updated vma in BAR */
  *(u32 *)arg2 = t2;
  if (t5 == 0) 		// J. if we don't have to clear CDR codes. 
    goto i%block-n-read-shift16293;
  t8 = t8 & 63;

i%block-n-read-shift16293:
  if (_trace) printf("i%block-n-read-shift16293:\n");
  t1 = zero + 21504;   
  t3 = *(u64 *)&(processor->byterotate);   		// Get rotate 
  t4 = *(u64 *)&(processor->bytesize);   		// Get bytesize 
  /* Get background */
  t2 = t1 >> 10;   
  t2 = t2 & 3;		// Extract the byte background 
  t5 = (t2 == ALUByteBackground_Op1) ? 1 : 0;   

force-alignment16313:
  if (_trace) printf("force-alignment16313:\n");
  if (t5 == 0) 
    goto basic-dispatch16309;
  /* Here if argument ALUByteBackgroundOp1 */
  t2 = t1;

basic-dispatch16308:
  if (_trace) printf("basic-dispatch16308:\n");
  t6 = t1 >> 12;   
  t6 = t6 & 1;		// Extractthe byte rotate latch 
  t7 = t7 << (t3 & 63);   
  t5 = (u32)(t7 >> ((4&7)*8));   
  t7 = (u32)t7;   
  t7 = t7 | t5;		// OP2 rotated 
  if (t6 == 0) 		// Don't update rotate latch if not requested 
    goto alu-function-byte16307;
  *(u64 *)&processor->rotatelatch = t7;   

alu-function-byte16307:
  if (_trace) printf("alu-function-byte16307:\n");
  t6 = zero + -2;   
  t6 = t6 << (t4 & 63);   
  t6 = ~t6;   		// Compute mask 
  /* Get byte function */
  t5 = t1 >> 13;   
  t5 = t5 & 1;
  t4 = (t5 == ALUByteFunction_Dpb) ? 1 : 0;   

force-alignment16318:
  if (_trace) printf("force-alignment16318:\n");
  if (t4 == 0) 
    goto basic-dispatch16315;
  /* Here if argument ALUByteFunctionDpb */
  t6 = t6 << (t3 & 63);   		// Position mask 

basic-dispatch16314:
  if (_trace) printf("basic-dispatch16314:\n");
  t7 = t7 & t6;		// rotated&mask 
  t2 = t2 & ~t6;		// background&~mask 
  t7 = t7 | t2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u32 *)(iSP + 8) = t7;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto cachevalid;   

i%block-n-read-shift16294:
  if (_trace) printf("i%block-n-read-shift16294:\n");
  arg5 = t2;
  arg2 = 23;
  goto illegaloperand;

basic-dispatch16315:
  if (_trace) printf("basic-dispatch16315:\n");
  t4 = (t5 == ALUByteFunction_Ldb) ? 1 : 0;   

force-alignment16319:
  if (_trace) printf("force-alignment16319:\n");
  if (t4 != 0)   
    goto basic-dispatch16314;
  goto basic-dispatch16314;   

basic-dispatch16309:
  if (_trace) printf("basic-dispatch16309:\n");
  t5 = (t2 == ALUByteBackground_RotateLatch) ? 1 : 0;   

force-alignment16320:
  if (_trace) printf("force-alignment16320:\n");
  if (t5 == 0) 
    goto basic-dispatch16310;
  /* Here if argument ALUByteBackgroundRotateLatch */
  t2 = *(u64 *)&(processor->rotatelatch);   
  goto basic-dispatch16308;   

basic-dispatch16310:
  if (_trace) printf("basic-dispatch16310:\n");
  t5 = (t2 == ALUByteBackground_Zero) ? 1 : 0;   

force-alignment16321:
  if (_trace) printf("force-alignment16321:\n");
  if (t5 == 0) 
    goto basic-dispatch16308;
  /* Here if argument ALUByteBackgroundZero */
  t2 = zero;
  goto basic-dispatch16308;   

vma-memory-read16297:
  if (_trace) printf("vma-memory-read16297:\n");
  t10 = *(u64 *)&(processor->stackcachedata);   
  t9 = (t9 * 8) + t10;  		// reconstruct SCA 
  t7 = *(s32 *)t9;   
  t8 = *(s32 *)(t9 + 4);   		// Read from stack cache 
  goto vma-memory-read16296;   

vma-memory-read16299:
  if (_trace) printf("vma-memory-read16299:\n");

vma-memory-read16298:
  if (_trace) printf("vma-memory-read16298:\n");
  t12 = (t1 * 4);   		// Cycle-number -> table offset 
  t12 = (t12 * 4) + ivory;   
  t12 = *(u64 *)(t12 + PROCESSORSTATE_DATAREAD);   
  /* TagType. */
  t11 = t8 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t2;   		// stash the VMA for the (likely) trap 
  t11 = (t11 * 4) + t12;   		// Adjust for a longword load 
  t12 = *(s32 *)t11;   		// Get the memory action 

vma-memory-read16304:
  if (_trace) printf("vma-memory-read16304:\n");
  t10 = t12 & MemoryActionIndirect;
  if (t10 == 0) 
    goto vma-memory-read16303;
  t2 = (u32)t7;   		// Do the indirect thing 
  goto vma-memory-read16295;   

vma-memory-read16303:
  if (_trace) printf("vma-memory-read16303:\n");
  t11 = t12 & MemoryActionTransform;
  if (t11 == 0) 
    goto vma-memory-read16302;
  t8 = t8 & ~63L;
  t8 = t8 | Type_ExternalValueCellPointer;
  goto vma-memory-read16306;   

vma-memory-read16302:

vma-memory-read16301:
  /* Perform memory action */
  arg1 = t12;
  arg2 = t1;
  goto performmemoryaction;

/* end DoBlock1ReadShift */
  /* End of Halfword operand from stack instruction - DoBlock1ReadShift */
/* start DoBlock0ReadAlu */

  /* Halfword operand from stack instruction - DoBlock0ReadAlu */
  /* arg2 has the preloaded 8 bit operand. */

doblock0readalu:
  if (_trace) printf("doblock0readalu:\n");

DoBlock0ReadAluSP:
  if (_trace) printf("DoBlock0ReadAluSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoBlock0ReadAluLP:
  if (_trace) printf("DoBlock0ReadAluLP:\n");

DoBlock0ReadAluFP:
  if (_trace) printf("DoBlock0ReadAluFP:\n");

begindoblock0readalu:
  if (_trace) printf("begindoblock0readalu:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg2 = (u64)&processor->bar0;   
  goto blockreadalu;   

DoBlock0ReadAluIM:
  goto doistageerror;

/* end DoBlock0ReadAlu */
  /* End of Halfword operand from stack instruction - DoBlock0ReadAlu */
/* start DoBlock3ReadAlu */

  /* Halfword operand from stack instruction - DoBlock3ReadAlu */
  /* arg2 has the preloaded 8 bit operand. */

doblock3readalu:
  if (_trace) printf("doblock3readalu:\n");

DoBlock3ReadAluSP:
  if (_trace) printf("DoBlock3ReadAluSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoBlock3ReadAluLP:
  if (_trace) printf("DoBlock3ReadAluLP:\n");

DoBlock3ReadAluFP:
  if (_trace) printf("DoBlock3ReadAluFP:\n");

begindoblock3readalu:
  if (_trace) printf("begindoblock3readalu:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg2 = (u64)&processor->bar3;   
  goto blockreadalu;   

DoBlock3ReadAluIM:
  goto doistageerror;

/* end DoBlock3ReadAlu */
  /* End of Halfword operand from stack instruction - DoBlock3ReadAlu */
/* start DoBlock2ReadAlu */

  /* Halfword operand from stack instruction - DoBlock2ReadAlu */
  /* arg2 has the preloaded 8 bit operand. */

doblock2readalu:
  if (_trace) printf("doblock2readalu:\n");

DoBlock2ReadAluSP:
  if (_trace) printf("DoBlock2ReadAluSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoBlock2ReadAluLP:
  if (_trace) printf("DoBlock2ReadAluLP:\n");

DoBlock2ReadAluFP:
  if (_trace) printf("DoBlock2ReadAluFP:\n");

begindoblock2readalu:
  if (_trace) printf("begindoblock2readalu:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg2 = (u64)&processor->bar2;   
  goto blockreadalu;   

DoBlock2ReadAluIM:
  goto doistageerror;

/* end DoBlock2ReadAlu */
  /* End of Halfword operand from stack instruction - DoBlock2ReadAlu */
/* start DoBlock1ReadAlu */

  /* Halfword operand from stack instruction - DoBlock1ReadAlu */
  /* arg2 has the preloaded 8 bit operand. */

doblock1readalu:
  if (_trace) printf("doblock1readalu:\n");

DoBlock1ReadAluSP:
  if (_trace) printf("DoBlock1ReadAluSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoBlock1ReadAluLP:
  if (_trace) printf("DoBlock1ReadAluLP:\n");

DoBlock1ReadAluFP:
  if (_trace) printf("DoBlock1ReadAluFP:\n");

begindoblock1readalu:
  if (_trace) printf("begindoblock1readalu:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg2 = (u64)&processor->bar1;   

blockreadalu:
  if (_trace) printf("blockreadalu:\n");
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  t1 = *(s32 *)arg2;   		// Get the vma 
  t5 = *(s32 *)arg1;   
  t4 = *(s32 *)(arg1 + 4);   
  t5 = (u32)t5;   
  t9 = t4 - Type_Fixnum;   
  t9 = t9 & 63;		// Strip CDR code 
  if (t9 != 0)   
    goto i%block-n-read-alu16322;
  t1 = (u32)t1;   
  /* Memory Read Internal */

vma-memory-read16324:
  t11 = t1 + ivory;
  t3 = (t11 * 4);   
  t2 = LDQ_U(t11);   
  t9 = t1 - arg5;   		// Stack cache offset 
  t12 = *(u64 *)&(processor->dataread_mask);   
  t10 = ((u64)t9 < (u64)arg6) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t2 = (u8)(t2 >> ((t11&7)*8));   
  if (t10 != 0)   
    goto vma-memory-read16326;

vma-memory-read16325:
  t11 = zero + 240;   
  t12 = t12 >> (t2 & 63);   
  t11 = t11 >> (t2 & 63);   
  t3 = (u32)t3;   
  if (t12 & 1)   
    goto vma-memory-read16328;

vma-memory-read16335:
  t9 = t2 - Type_Fixnum;   
  t9 = t9 & 63;		// Strip CDR code 
  if (t9 != 0)   
    goto i%block-n-read-alu16323;
  t1 = t1 + 1;		// Increment the address 
		/* Store updated vma in BAR */
  *(u32 *)arg2 = t1;
  t6 = *(u64 *)&(processor->aluop);   
  *(u64 *)&processor->aluoverflow = zero;   
  t7 = *(u64 *)&(processor->aluandrotatecontrol);   
  t1 = (t6 == ALUFunction_Boolean) ? 1 : 0;   

force-alignment16396:
  if (_trace) printf("force-alignment16396:\n");
  if (t1 == 0) 
    goto basic-dispatch16337;
  /* Here if argument ALUFunctionBoolean */
  t8 = t7 >> 10;   
  t8 = t8 & 15;		// Extract the ALU boolean function 
  t1 = (t8 == Boole_Clear) ? 1 : 0;   

force-alignment16356:
  if (_trace) printf("force-alignment16356:\n");
  if (t1 != 0)   
    goto basic-dispatch16338;

basic-dispatch16339:
  if (_trace) printf("basic-dispatch16339:\n");
  t1 = (t8 == Boole_And) ? 1 : 0;   

force-alignment16357:
  if (_trace) printf("force-alignment16357:\n");
  if (t1 == 0) 
    goto basic-dispatch16340;
  /* Here if argument BooleAnd */
  t8 = t3 & t5;
  goto basic-dispatch16338;   

basic-dispatch16340:
  if (_trace) printf("basic-dispatch16340:\n");
  t1 = (t8 == Boole_AndC1) ? 1 : 0;   

force-alignment16358:
  if (_trace) printf("force-alignment16358:\n");
  if (t1 == 0) 
    goto basic-dispatch16341;
  /* Here if argument BooleAndC1 */
  t8 = t5 & ~t3;
  goto basic-dispatch16338;   

basic-dispatch16341:
  if (_trace) printf("basic-dispatch16341:\n");
  t1 = (t8 == Boole_2) ? 1 : 0;   

force-alignment16359:
  if (_trace) printf("force-alignment16359:\n");
  if (t1 == 0) 
    goto basic-dispatch16342;
  /* Here if argument Boole2 */
  t8 = t5;
  goto basic-dispatch16338;   

basic-dispatch16342:
  if (_trace) printf("basic-dispatch16342:\n");
  t1 = (t8 == Boole_AndC2) ? 1 : 0;   

force-alignment16360:
  if (_trace) printf("force-alignment16360:\n");
  if (t1 == 0) 
    goto basic-dispatch16343;
  /* Here if argument BooleAndC2 */
  t8 = t3 & ~t5;
  goto basic-dispatch16338;   

basic-dispatch16343:
  if (_trace) printf("basic-dispatch16343:\n");
  t1 = (t8 == Boole_1) ? 1 : 0;   

force-alignment16361:
  if (_trace) printf("force-alignment16361:\n");
  if (t1 == 0) 
    goto basic-dispatch16344;
  /* Here if argument Boole1 */
  t8 = t3;
  goto basic-dispatch16338;   

basic-dispatch16344:
  if (_trace) printf("basic-dispatch16344:\n");
  t1 = (t8 == Boole_Xor) ? 1 : 0;   

force-alignment16362:
  if (_trace) printf("force-alignment16362:\n");
  if (t1 == 0) 
    goto basic-dispatch16345;
  /* Here if argument BooleXor */
  t8 = t3 ^ t5;   
  goto basic-dispatch16338;   

basic-dispatch16345:
  if (_trace) printf("basic-dispatch16345:\n");
  t1 = (t8 == Boole_Ior) ? 1 : 0;   

force-alignment16363:
  if (_trace) printf("force-alignment16363:\n");
  if (t1 == 0) 
    goto basic-dispatch16346;
  /* Here if argument BooleIor */
  t8 = t3 | t5;
  goto basic-dispatch16338;   

basic-dispatch16346:
  if (_trace) printf("basic-dispatch16346:\n");
  t1 = (t8 == Boole_Nor) ? 1 : 0;   

force-alignment16364:
  if (_trace) printf("force-alignment16364:\n");
  if (t1 == 0) 
    goto basic-dispatch16347;
  /* Here if argument BooleNor */
  t8 = t3 | t5;
  t8 = ~t8;   
  goto basic-dispatch16338;   

basic-dispatch16347:
  if (_trace) printf("basic-dispatch16347:\n");
  t1 = (t8 == Boole_Equiv) ? 1 : 0;   

force-alignment16365:
  if (_trace) printf("force-alignment16365:\n");
  if (t1 == 0) 
    goto basic-dispatch16348;
  /* Here if argument BooleEquiv */
  t8 = t3 ^ t5;   
  t8 = ~t8;   
  goto basic-dispatch16338;   

basic-dispatch16348:
  if (_trace) printf("basic-dispatch16348:\n");
  t1 = (t8 == Boole_C1) ? 1 : 0;   

force-alignment16366:
  if (_trace) printf("force-alignment16366:\n");
  if (t1 == 0) 
    goto basic-dispatch16349;
  /* Here if argument BooleC1 */
  t8 = ~t3;   
  goto basic-dispatch16338;   

basic-dispatch16349:
  if (_trace) printf("basic-dispatch16349:\n");
  t1 = (t8 == Boole_OrC1) ? 1 : 0;   

force-alignment16367:
  if (_trace) printf("force-alignment16367:\n");
  if (t1 == 0) 
    goto basic-dispatch16350;
  /* Here if argument BooleOrC1 */
  t8 = t5 | ~(t3);   
  goto basic-dispatch16338;   

basic-dispatch16350:
  if (_trace) printf("basic-dispatch16350:\n");
  t1 = (t8 == Boole_C2) ? 1 : 0;   

force-alignment16368:
  if (_trace) printf("force-alignment16368:\n");
  if (t1 == 0) 
    goto basic-dispatch16351;
  /* Here if argument BooleC2 */
  t8 = ~t5;   
  goto basic-dispatch16338;   

basic-dispatch16351:
  if (_trace) printf("basic-dispatch16351:\n");
  t1 = (t8 == Boole_OrC2) ? 1 : 0;   

force-alignment16369:
  if (_trace) printf("force-alignment16369:\n");
  if (t1 == 0) 
    goto basic-dispatch16352;
  /* Here if argument BooleOrC2 */
  t8 = t3 & ~t5;
  goto basic-dispatch16338;   

basic-dispatch16352:
  if (_trace) printf("basic-dispatch16352:\n");
  t1 = (t8 == Boole_Nand) ? 1 : 0;   

force-alignment16370:
  if (_trace) printf("force-alignment16370:\n");
  if (t1 == 0) 
    goto basic-dispatch16353;
  /* Here if argument BooleNand */
  t8 = t3 & t5;
  goto basic-dispatch16338;   

basic-dispatch16353:
  if (_trace) printf("basic-dispatch16353:\n");
  t1 = (t8 == Boole_Set) ? 1 : 0;   

force-alignment16371:
  if (_trace) printf("force-alignment16371:\n");
  if (t1 == 0) 
    goto basic-dispatch16338;
  /* Here if argument BooleSet */
  t8 = ~zero;   

basic-dispatch16338:
  if (_trace) printf("basic-dispatch16338:\n");
  *(u32 *)arg1 = t8;
  goto NEXTINSTRUCTION;   

basic-dispatch16337:
  if (_trace) printf("basic-dispatch16337:\n");
  t1 = (t6 == ALUFunction_Byte) ? 1 : 0;   

force-alignment16397:
  if (_trace) printf("force-alignment16397:\n");
  if (t1 == 0) 
    goto basic-dispatch16372;
  /* Here if argument ALUFunctionByte */
  t9 = *(u64 *)&(processor->byterotate);   		// Get rotate 
  t10 = *(u64 *)&(processor->bytesize);   		// Get bytesize 
  /* Get background */
  t1 = t7 >> 10;   
  t1 = t1 & 3;		// Extract the byte background 
  t11 = (t1 == ALUByteBackground_Op1) ? 1 : 0;   

force-alignment16379:
  if (_trace) printf("force-alignment16379:\n");
  if (t11 == 0) 
    goto basic-dispatch16375;
  /* Here if argument ALUByteBackgroundOp1 */
  t1 = t3;

basic-dispatch16374:
  if (_trace) printf("basic-dispatch16374:\n");
  t12 = t7 >> 12;   
  t12 = t12 & 1;		// Extractthe byte rotate latch 
  t8 = t5 << (t9 & 63);   
  t11 = (u32)(t8 >> ((4&7)*8));   
  t8 = (u32)t8;   
  t8 = t8 | t11;		// OP2 rotated 
  if (t12 == 0) 		// Don't update rotate latch if not requested 
    goto alu-function-byte16373;
  *(u64 *)&processor->rotatelatch = t8;   

alu-function-byte16373:
  if (_trace) printf("alu-function-byte16373:\n");
  t12 = zero + -2;   
  t12 = t12 << (t10 & 63);   
  t12 = ~t12;   		// Compute mask 
  /* Get byte function */
  t11 = t7 >> 13;   
  t11 = t11 & 1;
  t10 = (t11 == ALUByteFunction_Dpb) ? 1 : 0;   

force-alignment16384:
  if (_trace) printf("force-alignment16384:\n");
  if (t10 == 0) 
    goto basic-dispatch16381;
  /* Here if argument ALUByteFunctionDpb */
  t12 = t12 << (t9 & 63);   		// Position mask 

basic-dispatch16380:
  if (_trace) printf("basic-dispatch16380:\n");
  t8 = t8 & t12;		// rotated&mask 
  t1 = t1 & ~t12;		// background&~mask 
  t8 = t8 | t1;
  *(u32 *)arg1 = t8;
  goto NEXTINSTRUCTION;   

basic-dispatch16372:
  if (_trace) printf("basic-dispatch16372:\n");
  t1 = (t6 == ALUFunction_Adder) ? 1 : 0;   

force-alignment16398:
  if (_trace) printf("force-alignment16398:\n");
  if (t1 == 0) 
    goto basic-dispatch16385;
  /* Here if argument ALUFunctionAdder */
  t10 = t7 >> 11;   
  t10 = t10 & 3;		// Extract the op2 
  t9 = t7 >> 10;   
  t9 = t9 & 1;		// Extract the adder carry in 
  t11 = (t10 == ALUAdderOp2_Op2) ? 1 : 0;   

force-alignment16393:
  if (_trace) printf("force-alignment16393:\n");
  if (t11 == 0) 
    goto basic-dispatch16388;
  /* Here if argument ALUAdderOp2Op2 */
  t1 = t5;

basic-dispatch16387:
  if (_trace) printf("basic-dispatch16387:\n");
  t8 = t3 + t1;
  t8 = t8 + t9;
  t10 = t8 >> 31;   		// Sign bit 
  t11 = t8 >> 32;   		// Next bit 
  t10 = t10 ^ t11;   		// Low bit is now overflow indicator 
  t11 = t7 >> 24;   		// Get the load-carry-in bit 
  *(u64 *)&processor->aluoverflow = t10;   
  if ((t11 & 1) == 0)   
    goto alu-function-adder16386;
  t10 = (u32)(t8 >> ((4&7)*8));   		// Get the carry 
  t11 = zero + 1024;   
  t7 = t7 & ~t11;
  t11 = t10 & 1;
  t11 = t11 << 10;   
  t7 = t7 | t11;		// Set the adder carry in 
  *(u64 *)&processor->aluandrotatecontrol = t7;   

alu-function-adder16386:
  if (_trace) printf("alu-function-adder16386:\n");
  t10 = ((s64)t3 < (s64)t1) ? 1 : 0;   
  *(u64 *)&processor->aluborrow = t10;   
  t3 = (s32)t3;
  t5 = (s32)t5;
  t10 = ((s64)t3 < (s64)t1) ? 1 : 0;   
  *(u64 *)&processor->alulessthan = t10;   
  *(u32 *)arg1 = t8;
  goto NEXTINSTRUCTION;   

basic-dispatch16385:
  if (_trace) printf("basic-dispatch16385:\n");
  t1 = (t6 == ALUFunction_MultiplyDivide) ? 1 : 0;   

force-alignment16399:
  if (_trace) printf("force-alignment16399:\n");
  if (t1 == 0) 
    goto basic-dispatch16336;
  /* Here if argument ALUFunctionMultiplyDivide */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;
  *(u32 *)arg1 = t8;
  goto NEXTINSTRUCTION;   

basic-dispatch16336:
  if (_trace) printf("basic-dispatch16336:\n");

i%block-n-read-alu16322:
  if (_trace) printf("i%block-n-read-alu16322:\n");
  /* Convert stack cache address to VMA */
  t9 = *(u64 *)&(processor->stackcachedata);   
  t9 = arg1 - t9;   		// stack cache base relative offset 
  t9 = t9 >> 3;   		// convert byte address to word address 
  t1 = t9 + arg5;		// reconstruct VMA 
  arg5 = t1;
  arg2 = 23;
  goto illegaloperand;

i%block-n-read-alu16323:
  if (_trace) printf("i%block-n-read-alu16323:\n");
  arg5 = t1;
  arg2 = 23;
  goto illegaloperand;

basic-dispatch16388:
  if (_trace) printf("basic-dispatch16388:\n");
  t11 = (t10 == ALUAdderOp2_Zero) ? 1 : 0;   

force-alignment16400:
  if (_trace) printf("force-alignment16400:\n");
  if (t11 == 0) 
    goto basic-dispatch16389;
  /* Here if argument ALUAdderOp2Zero */
  t1 = zero;
  goto basic-dispatch16387;   

basic-dispatch16389:
  if (_trace) printf("basic-dispatch16389:\n");
  t11 = (t10 == ALUAdderOp2_Invert) ? 1 : 0;   

force-alignment16401:
  if (_trace) printf("force-alignment16401:\n");
  if (t11 == 0) 
    goto basic-dispatch16390;
  /* Here if argument ALUAdderOp2Invert */
  t1 = (s32)t5;
  t1 = zero - t1;   
  t1 = (u32)t1;   
  goto basic-dispatch16387;   

basic-dispatch16390:
  if (_trace) printf("basic-dispatch16390:\n");
  t11 = (t10 == ALUAdderOp2_MinusOne) ? 1 : 0;   

force-alignment16402:
  if (_trace) printf("force-alignment16402:\n");
  if (t11 == 0) 
    goto basic-dispatch16387;
  /* Here if argument ALUAdderOp2MinusOne */
  t1 = ~zero;   
  t1 = (u32)t1;   
  goto basic-dispatch16387;   

basic-dispatch16381:
  if (_trace) printf("basic-dispatch16381:\n");
  t10 = (t11 == ALUByteFunction_Ldb) ? 1 : 0;   

force-alignment16403:
  if (_trace) printf("force-alignment16403:\n");
  if (t10 != 0)   
    goto basic-dispatch16380;
  goto basic-dispatch16380;   

basic-dispatch16375:
  if (_trace) printf("basic-dispatch16375:\n");
  t11 = (t1 == ALUByteBackground_RotateLatch) ? 1 : 0;   

force-alignment16404:
  if (_trace) printf("force-alignment16404:\n");
  if (t11 == 0) 
    goto basic-dispatch16376;
  /* Here if argument ALUByteBackgroundRotateLatch */
  t1 = *(u64 *)&(processor->rotatelatch);   
  goto basic-dispatch16374;   

basic-dispatch16376:
  if (_trace) printf("basic-dispatch16376:\n");
  t11 = (t1 == ALUByteBackground_Zero) ? 1 : 0;   

force-alignment16405:
  if (_trace) printf("force-alignment16405:\n");
  if (t11 == 0) 
    goto basic-dispatch16374;
  /* Here if argument ALUByteBackgroundZero */
  t1 = zero;
  goto basic-dispatch16374;   

vma-memory-read16326:
  if (_trace) printf("vma-memory-read16326:\n");
  t10 = *(u64 *)&(processor->stackcachedata);   
  t9 = (t9 * 8) + t10;  		// reconstruct SCA 
  t3 = *(s32 *)t9;   
  t2 = *(s32 *)(t9 + 4);   		// Read from stack cache 
  goto vma-memory-read16325;   

vma-memory-read16328:
  if (_trace) printf("vma-memory-read16328:\n");
  if ((t11 & 1) == 0)   
    goto vma-memory-read16327;
  t1 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read16324;   

vma-memory-read16327:
  if (_trace) printf("vma-memory-read16327:\n");
  t12 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t11 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t11 = (t11 * 4) + t12;   		// Adjust for a longword load 
  t12 = *(s32 *)t11;   		// Get the memory action 

vma-memory-read16332:
  if (_trace) printf("vma-memory-read16332:\n");
  t11 = t12 & MemoryActionTransform;
  if (t11 == 0) 
    goto vma-memory-read16331;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto vma-memory-read16335;   

vma-memory-read16331:

vma-memory-read16330:
  /* Perform memory action */
  arg1 = t12;
  arg2 = 0;
  goto performmemoryaction;

DoBlock1ReadAluIM:
  goto doistageerror;

/* end DoBlock1ReadAlu */
  /* End of Halfword operand from stack instruction - DoBlock1ReadAlu */
/* start DoBlock0ReadTest */

  /* Halfword 10 bit immediate instruction - DoBlock0ReadTest */

doblock0readtest:
  if (_trace) printf("doblock0readtest:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBlock0ReadTestIM:
  if (_trace) printf("DoBlock0ReadTestIM:\n");

DoBlock0ReadTestSP:
  if (_trace) printf("DoBlock0ReadTestSP:\n");

DoBlock0ReadTestLP:
  if (_trace) printf("DoBlock0ReadTestLP:\n");

DoBlock0ReadTestFP:
  if (_trace) printf("DoBlock0ReadTestFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar0;   
  goto blockreadtest;   

/* end DoBlock0ReadTest */
  /* End of Halfword operand from stack instruction - DoBlock0ReadTest */
/* start DoBlock3ReadTest */

  /* Halfword 10 bit immediate instruction - DoBlock3ReadTest */

doblock3readtest:
  if (_trace) printf("doblock3readtest:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBlock3ReadTestIM:
  if (_trace) printf("DoBlock3ReadTestIM:\n");

DoBlock3ReadTestSP:
  if (_trace) printf("DoBlock3ReadTestSP:\n");

DoBlock3ReadTestLP:
  if (_trace) printf("DoBlock3ReadTestLP:\n");

DoBlock3ReadTestFP:
  if (_trace) printf("DoBlock3ReadTestFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar3;   
  goto blockreadtest;   

/* end DoBlock3ReadTest */
  /* End of Halfword operand from stack instruction - DoBlock3ReadTest */
/* start DoBlock2ReadTest */

  /* Halfword 10 bit immediate instruction - DoBlock2ReadTest */

doblock2readtest:
  if (_trace) printf("doblock2readtest:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBlock2ReadTestIM:
  if (_trace) printf("DoBlock2ReadTestIM:\n");

DoBlock2ReadTestSP:
  if (_trace) printf("DoBlock2ReadTestSP:\n");

DoBlock2ReadTestLP:
  if (_trace) printf("DoBlock2ReadTestLP:\n");

DoBlock2ReadTestFP:
  if (_trace) printf("DoBlock2ReadTestFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar2;   
  goto blockreadtest;   

/* end DoBlock2ReadTest */
  /* End of Halfword operand from stack instruction - DoBlock2ReadTest */
/* start DoBlock1ReadTest */

  /* Halfword 10 bit immediate instruction - DoBlock1ReadTest */

doblock1readtest:
  if (_trace) printf("doblock1readtest:\n");
  /* Actually only one entry point, but simulate others for dispatch */

DoBlock1ReadTestIM:
  if (_trace) printf("DoBlock1ReadTestIM:\n");

DoBlock1ReadTestSP:
  if (_trace) printf("DoBlock1ReadTestSP:\n");

DoBlock1ReadTestLP:
  if (_trace) printf("DoBlock1ReadTestLP:\n");

DoBlock1ReadTestFP:
  if (_trace) printf("DoBlock1ReadTestFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg2 = (u64)&processor->bar1;   

blockreadtest:
  if (_trace) printf("blockreadtest:\n");
  arg3 = *(s32 *)arg2;   		// Get the vma 
  t1 = arg1 >> 6;   		// cycle type 
  t5 = *(s32 *)iSP;   
  t4 = *(s32 *)(iSP + 4);   
  t5 = (u32)t5;   
  arg3 = (u32)arg3;   
  /* Memory Read Internal */

vma-memory-read16412:
  t9 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t11 = arg3 + ivory;
  t10 = *(s32 *)&processor->scovlimit;   
  t12 = (t1 * 4);   		// Cycle-number -> table offset 
  t2 = LDQ_U(t11);   
  t12 = (t12 * 4) + ivory;   
  t3 = (t11 * 4);   
  t9 = arg3 - t9;   		// Stack cache offset 
  t12 = *(u64 *)(t12 + PROCESSORSTATE_DATAREAD_MASK);   
  t10 = ((u64)t9 < (u64)t10) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t2 = (u8)(t2 >> ((t11&7)*8));   
  if (t10 != 0)   
    goto vma-memory-read16414;

vma-memory-read16413:
  t12 = t12 >> (t2 & 63);   
  t3 = (u32)t3;   
  if (t12 & 1)   
    goto vma-memory-read16416;

vma-memory-read16423:
  t1 = arg1 & 32;		// =fixnum onlyp 
  if (t1 == 0) 		// J. if we don't have to test for fixnump. 
    goto i%block-n-read-test16406;
  t9 = t2 - Type_Fixnum;   
  t9 = t9 & 63;		// Strip CDR code 
  if (t9 != 0)   
    goto i%block-n-read-test16409;
  t9 = t4 - Type_Fixnum;   
  t9 = t9 & 63;		// Strip CDR code 
  if (t9 != 0)   
    goto i%block-n-read-test16410;

i%block-n-read-test16406:
  if (_trace) printf("i%block-n-read-test16406:\n");
  t1 = arg1 & 16;		// =cdr-code-nextp 
  if (t1 == 0) 		// J. if we don't have to clear CDR codes. 
    goto i%block-n-read-test16408;
  /* TagType. */
  t2 = t2 & 63;

i%block-n-read-test16408:
  if (_trace) printf("i%block-n-read-test16408:\n");
  t6 = *(u64 *)&(processor->aluop);   
  *(u64 *)&processor->aluoverflow = zero;   
  t7 = *(u64 *)&(processor->aluandrotatecontrol);   
  t1 = (t6 == ALUFunction_Boolean) ? 1 : 0;   

force-alignment16484:
  if (_trace) printf("force-alignment16484:\n");
  if (t1 == 0) 
    goto basic-dispatch16425;
  /* Here if argument ALUFunctionBoolean */
  t8 = t7 >> 10;   
  t8 = t8 & 15;		// Extract the ALU boolean function 
  t1 = (t8 == Boole_Clear) ? 1 : 0;   

force-alignment16444:
  if (_trace) printf("force-alignment16444:\n");
  if (t1 != 0)   
    goto basic-dispatch16426;

basic-dispatch16427:
  if (_trace) printf("basic-dispatch16427:\n");
  t1 = (t8 == Boole_And) ? 1 : 0;   

force-alignment16445:
  if (_trace) printf("force-alignment16445:\n");
  if (t1 == 0) 
    goto basic-dispatch16428;
  /* Here if argument BooleAnd */
  t8 = t3 & t5;
  goto basic-dispatch16426;   

basic-dispatch16428:
  if (_trace) printf("basic-dispatch16428:\n");
  t1 = (t8 == Boole_AndC1) ? 1 : 0;   

force-alignment16446:
  if (_trace) printf("force-alignment16446:\n");
  if (t1 == 0) 
    goto basic-dispatch16429;
  /* Here if argument BooleAndC1 */
  t8 = t5 & ~t3;
  goto basic-dispatch16426;   

basic-dispatch16429:
  if (_trace) printf("basic-dispatch16429:\n");
  t1 = (t8 == Boole_2) ? 1 : 0;   

force-alignment16447:
  if (_trace) printf("force-alignment16447:\n");
  if (t1 == 0) 
    goto basic-dispatch16430;
  /* Here if argument Boole2 */
  t8 = t5;
  goto basic-dispatch16426;   

basic-dispatch16430:
  if (_trace) printf("basic-dispatch16430:\n");
  t1 = (t8 == Boole_AndC2) ? 1 : 0;   

force-alignment16448:
  if (_trace) printf("force-alignment16448:\n");
  if (t1 == 0) 
    goto basic-dispatch16431;
  /* Here if argument BooleAndC2 */
  t8 = t3 & ~t5;
  goto basic-dispatch16426;   

basic-dispatch16431:
  if (_trace) printf("basic-dispatch16431:\n");
  t1 = (t8 == Boole_1) ? 1 : 0;   

force-alignment16449:
  if (_trace) printf("force-alignment16449:\n");
  if (t1 == 0) 
    goto basic-dispatch16432;
  /* Here if argument Boole1 */
  t8 = t3;
  goto basic-dispatch16426;   

basic-dispatch16432:
  if (_trace) printf("basic-dispatch16432:\n");
  t1 = (t8 == Boole_Xor) ? 1 : 0;   

force-alignment16450:
  if (_trace) printf("force-alignment16450:\n");
  if (t1 == 0) 
    goto basic-dispatch16433;
  /* Here if argument BooleXor */
  t8 = t3 ^ t5;   
  goto basic-dispatch16426;   

basic-dispatch16433:
  if (_trace) printf("basic-dispatch16433:\n");
  t1 = (t8 == Boole_Ior) ? 1 : 0;   

force-alignment16451:
  if (_trace) printf("force-alignment16451:\n");
  if (t1 == 0) 
    goto basic-dispatch16434;
  /* Here if argument BooleIor */
  t8 = t3 | t5;
  goto basic-dispatch16426;   

basic-dispatch16434:
  if (_trace) printf("basic-dispatch16434:\n");
  t1 = (t8 == Boole_Nor) ? 1 : 0;   

force-alignment16452:
  if (_trace) printf("force-alignment16452:\n");
  if (t1 == 0) 
    goto basic-dispatch16435;
  /* Here if argument BooleNor */
  t8 = t3 | t5;
  t8 = ~t8;   
  goto basic-dispatch16426;   

basic-dispatch16435:
  if (_trace) printf("basic-dispatch16435:\n");
  t1 = (t8 == Boole_Equiv) ? 1 : 0;   

force-alignment16453:
  if (_trace) printf("force-alignment16453:\n");
  if (t1 == 0) 
    goto basic-dispatch16436;
  /* Here if argument BooleEquiv */
  t8 = t3 ^ t5;   
  t8 = ~t8;   
  goto basic-dispatch16426;   

basic-dispatch16436:
  if (_trace) printf("basic-dispatch16436:\n");
  t1 = (t8 == Boole_C1) ? 1 : 0;   

force-alignment16454:
  if (_trace) printf("force-alignment16454:\n");
  if (t1 == 0) 
    goto basic-dispatch16437;
  /* Here if argument BooleC1 */
  t8 = ~t3;   
  goto basic-dispatch16426;   

basic-dispatch16437:
  if (_trace) printf("basic-dispatch16437:\n");
  t1 = (t8 == Boole_OrC1) ? 1 : 0;   

force-alignment16455:
  if (_trace) printf("force-alignment16455:\n");
  if (t1 == 0) 
    goto basic-dispatch16438;
  /* Here if argument BooleOrC1 */
  t8 = t5 | ~(t3);   
  goto basic-dispatch16426;   

basic-dispatch16438:
  if (_trace) printf("basic-dispatch16438:\n");
  t1 = (t8 == Boole_C2) ? 1 : 0;   

force-alignment16456:
  if (_trace) printf("force-alignment16456:\n");
  if (t1 == 0) 
    goto basic-dispatch16439;
  /* Here if argument BooleC2 */
  t8 = ~t5;   
  goto basic-dispatch16426;   

basic-dispatch16439:
  if (_trace) printf("basic-dispatch16439:\n");
  t1 = (t8 == Boole_OrC2) ? 1 : 0;   

force-alignment16457:
  if (_trace) printf("force-alignment16457:\n");
  if (t1 == 0) 
    goto basic-dispatch16440;
  /* Here if argument BooleOrC2 */
  t8 = t3 & ~t5;
  goto basic-dispatch16426;   

basic-dispatch16440:
  if (_trace) printf("basic-dispatch16440:\n");
  t1 = (t8 == Boole_Nand) ? 1 : 0;   

force-alignment16458:
  if (_trace) printf("force-alignment16458:\n");
  if (t1 == 0) 
    goto basic-dispatch16441;
  /* Here if argument BooleNand */
  t8 = t3 & t5;
  goto basic-dispatch16426;   

basic-dispatch16441:
  if (_trace) printf("basic-dispatch16441:\n");
  t1 = (t8 == Boole_Set) ? 1 : 0;   

force-alignment16459:
  if (_trace) printf("force-alignment16459:\n");
  if (t1 == 0) 
    goto basic-dispatch16426;
  /* Here if argument BooleSet */
  t8 = ~zero;   

basic-dispatch16426:
  if (_trace) printf("basic-dispatch16426:\n");

basic-dispatch16424:
  if (_trace) printf("basic-dispatch16424:\n");
  t1 = t7 >> 16;   
  t1 = t1 & 31;		// Extract ALU condition 
  t10 = *(u64 *)&(processor->aluoverflow);   
  t11 = *(u64 *)&(processor->aluborrow);   
  t12 = *(u64 *)&(processor->alulessthan);   
  t9 = (t1 == ALUCondition_SignedLessThanOrEqual) ? 1 : 0;   

force-alignment16516:
  if (_trace) printf("force-alignment16516:\n");
  if (t9 == 0) 
    goto basic-dispatch16489;
  /* Here if argument ALUConditionSignedLessThanOrEqual */
  if (t12 != 0)   
    goto alu-compute-condition16485;
  if (t8 == 0) 
    goto alu-compute-condition16485;

basic-dispatch16488:
  if (_trace) printf("basic-dispatch16488:\n");

alu-compute-condition16486:
  if (_trace) printf("alu-compute-condition16486:\n");
  t1 = zero;
  goto alu-compute-condition16487;   

alu-compute-condition16485:
  if (_trace) printf("alu-compute-condition16485:\n");
  t1 = 1;

alu-compute-condition16487:
  if (_trace) printf("alu-compute-condition16487:\n");
  t9 = t7 >> 21;   
  t9 = t9 & 1;		// Extract the condition sense 
  t1 = t1 ^ t9;   
  if (t1 != 0)   
    goto i%block-n-read-test16411;
  t1 = arg1 & 4;		// =no-incrementp 
  if (t1 != 0)   		// J. if we don't have to increment the address. 
    goto i%block-n-read-test16407;
  arg3 = arg3 + 1;		// Increment the address 

i%block-n-read-test16407:
  if (_trace) printf("i%block-n-read-test16407:\n");
		/* Store updated vma in BAR */
  *(u32 *)arg2 = arg3;
  goto NEXTINSTRUCTION;   

i%block-n-read-test16411:
  if (_trace) printf("i%block-n-read-test16411:\n");
  t10 = *(s32 *)(iSP + -8);   
  t9 = *(s32 *)(iSP + -4);   
  t10 = (u32)t10;   
  t10 = t10 << 1;   
  iPC = t9 & 1;
  iPC = iPC + t10;
  goto interpretinstructionforjump;   

i%block-n-read-test16410:
  if (_trace) printf("i%block-n-read-test16410:\n");
  /* Convert stack cache address to VMA */
  t9 = *(u64 *)&(processor->stackcachedata);   
  arg3 = *(u64 *)&(processor->stackcachebasevma);   
  t9 = iSP - t9;   		// stack cache base relative offset 
  t9 = t9 >> 3;   		// convert byte address to word address 
  arg3 = t9 + arg3;		// reconstruct VMA 
  arg5 = arg3;
  arg2 = 23;
  goto illegaloperand;

i%block-n-read-test16409:
  if (_trace) printf("i%block-n-read-test16409:\n");
  arg5 = arg3;
  arg2 = 23;
  goto illegaloperand;

basic-dispatch16489:
  if (_trace) printf("basic-dispatch16489:\n");
  t9 = (t1 == ALUCondition_SignedLessThan) ? 1 : 0;   

force-alignment16517:
  if (_trace) printf("force-alignment16517:\n");
  if (t9 == 0) 
    goto basic-dispatch16490;
  /* Here if argument ALUConditionSignedLessThan */
  if (t12 != 0)   
    goto alu-compute-condition16485;
  goto basic-dispatch16488;   

basic-dispatch16490:
  if (_trace) printf("basic-dispatch16490:\n");
  t9 = (t1 == ALUCondition_Negative) ? 1 : 0;   

force-alignment16518:
  if (_trace) printf("force-alignment16518:\n");
  if (t9 == 0) 
    goto basic-dispatch16491;
  /* Here if argument ALUConditionNegative */
  if ((s64)t8 < 0)   
    goto alu-compute-condition16485;
  goto basic-dispatch16488;   

basic-dispatch16491:
  if (_trace) printf("basic-dispatch16491:\n");
  t9 = (t1 == ALUCondition_SignedOverflow) ? 1 : 0;   

force-alignment16519:
  if (_trace) printf("force-alignment16519:\n");
  if (t9 == 0) 
    goto basic-dispatch16492;
  /* Here if argument ALUConditionSignedOverflow */
  if (t10 != 0)   
    goto alu-compute-condition16485;
  goto basic-dispatch16488;   

basic-dispatch16492:
  if (_trace) printf("basic-dispatch16492:\n");
  t9 = (t1 == ALUCondition_UnsignedLessThanOrEqual) ? 1 : 0;   

force-alignment16520:
  if (_trace) printf("force-alignment16520:\n");
  if (t9 == 0) 
    goto basic-dispatch16493;
  /* Here if argument ALUConditionUnsignedLessThanOrEqual */
  if (t11 != 0)   
    goto alu-compute-condition16485;
  if (t8 == 0) 
    goto alu-compute-condition16485;
  goto basic-dispatch16488;   

basic-dispatch16493:
  if (_trace) printf("basic-dispatch16493:\n");
  t9 = (t1 == ALUCondition_UnsignedLessThan) ? 1 : 0;   

force-alignment16521:
  if (_trace) printf("force-alignment16521:\n");
  if (t9 == 0) 
    goto basic-dispatch16494;
  /* Here if argument ALUConditionUnsignedLessThan */
  if (t11 != 0)   
    goto alu-compute-condition16485;
  goto basic-dispatch16488;   

basic-dispatch16494:
  if (_trace) printf("basic-dispatch16494:\n");
  t9 = (t1 == ALUCondition_Zero) ? 1 : 0;   

force-alignment16522:
  if (_trace) printf("force-alignment16522:\n");
  if (t9 == 0) 
    goto basic-dispatch16495;
  /* Here if argument ALUConditionZero */
  if (t8 == 0) 
    goto alu-compute-condition16485;
  goto basic-dispatch16488;   

basic-dispatch16495:
  if (_trace) printf("basic-dispatch16495:\n");
  t9 = (t1 == ALUCondition_High25Zero) ? 1 : 0;   

force-alignment16523:
  if (_trace) printf("force-alignment16523:\n");
  if (t9 == 0) 
    goto basic-dispatch16496;
  /* Here if argument ALUConditionHigh25Zero */
  t1 = t8 >> 7;   
  if (t1 == 0) 
    goto alu-compute-condition16485;
  goto basic-dispatch16488;   

basic-dispatch16496:
  if (_trace) printf("basic-dispatch16496:\n");
  t9 = (t1 == ALUCondition_Eq) ? 1 : 0;   

force-alignment16524:
  if (_trace) printf("force-alignment16524:\n");
  if (t9 == 0) 
    goto basic-dispatch16497;
  /* Here if argument ALUConditionEq */
  if (t8 != 0)   
    goto alu-compute-condition16486;
  t9 = t2 ^ t4;   
  /* TagType. */
  t9 = t9 & 63;
  if (t9 == 0) 
    goto alu-compute-condition16485;
  goto basic-dispatch16488;   

basic-dispatch16497:
  if (_trace) printf("basic-dispatch16497:\n");
  t9 = (t1 == ALUCondition_Op1Ephemeralp) ? 1 : 0;   

force-alignment16525:
  if (_trace) printf("force-alignment16525:\n");
  if (t9 == 0) 
    goto basic-dispatch16498;
  /* Here if argument ALUConditionOp1Ephemeralp */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16498:
  if (_trace) printf("basic-dispatch16498:\n");
  t9 = (t1 == ALUCondition_ResultTypeNil) ? 1 : 0;   

force-alignment16526:
  if (_trace) printf("force-alignment16526:\n");
  if (t9 == 0) 
    goto basic-dispatch16499;
  /* Here if argument ALUConditionResultTypeNil */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16499:
  if (_trace) printf("basic-dispatch16499:\n");
  t9 = (t1 == ALUCondition_Op2Fixnum) ? 1 : 0;   

force-alignment16527:
  if (_trace) printf("force-alignment16527:\n");
  if (t9 == 0) 
    goto basic-dispatch16500;
  /* Here if argument ALUConditionOp2Fixnum */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16500:
  if (_trace) printf("basic-dispatch16500:\n");
  t9 = (t1 == ALUCondition_False) ? 1 : 0;   

force-alignment16528:
  if (_trace) printf("force-alignment16528:\n");
  if (t9 == 0) 
    goto basic-dispatch16501;
  /* Here if argument ALUConditionFalse */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16501:
  if (_trace) printf("basic-dispatch16501:\n");
  t9 = (t1 == ALUCondition_ResultCdrLow) ? 1 : 0;   

force-alignment16529:
  if (_trace) printf("force-alignment16529:\n");
  if (t9 == 0) 
    goto basic-dispatch16502;
  /* Here if argument ALUConditionResultCdrLow */
  /* TagCdr. */
  t9 = t2 >> 6;   
  t1 = t9 & 1;
  goto alu-compute-condition16487;   

basic-dispatch16502:
  if (_trace) printf("basic-dispatch16502:\n");
  t9 = (t1 == ALUCondition_CleanupBitsSet) ? 1 : 0;   

force-alignment16530:
  if (_trace) printf("force-alignment16530:\n");
  if (t9 == 0) 
    goto basic-dispatch16503;
  /* Here if argument ALUConditionCleanupBitsSet */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16503:
  if (_trace) printf("basic-dispatch16503:\n");
  t9 = (t1 == ALUCondition_AddressInStackCache) ? 1 : 0;   

force-alignment16531:
  if (_trace) printf("force-alignment16531:\n");
  if (t9 == 0) 
    goto basic-dispatch16504;
  /* Here if argument ALUConditionAddressInStackCache */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16504:
  if (_trace) printf("basic-dispatch16504:\n");
  t9 = (t1 == ALUCondition_ExtraStackMode) ? 1 : 0;   

force-alignment16532:
  if (_trace) printf("force-alignment16532:\n");
  if (t9 == 0) 
    goto basic-dispatch16505;
  /* Here if argument ALUConditionExtraStackMode */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16505:
  if (_trace) printf("basic-dispatch16505:\n");
  t9 = (t1 == ALUCondition_FepMode) ? 1 : 0;   

force-alignment16533:
  if (_trace) printf("force-alignment16533:\n");
  if (t9 == 0) 
    goto basic-dispatch16506;
  /* Here if argument ALUConditionFepMode */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16506:
  if (_trace) printf("basic-dispatch16506:\n");
  t9 = (t1 == ALUCondition_FpCoprocessorPresent) ? 1 : 0;   

force-alignment16534:
  if (_trace) printf("force-alignment16534:\n");
  if (t9 == 0) 
    goto basic-dispatch16507;
  /* Here if argument ALUConditionFpCoprocessorPresent */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16507:
  if (_trace) printf("basic-dispatch16507:\n");
  t9 = (t1 == ALUCondition_Op1Oldspacep) ? 1 : 0;   

force-alignment16535:
  if (_trace) printf("force-alignment16535:\n");
  if (t9 == 0) 
    goto basic-dispatch16508;
  /* Here if argument ALUConditionOp1Oldspacep */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16508:
  if (_trace) printf("basic-dispatch16508:\n");
  t9 = (t1 == ALUCondition_PendingSequenceBreakEnabled) ? 1 : 0;   

force-alignment16536:
  if (_trace) printf("force-alignment16536:\n");
  if (t9 == 0) 
    goto basic-dispatch16509;
  /* Here if argument ALUConditionPendingSequenceBreakEnabled */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16509:
  if (_trace) printf("basic-dispatch16509:\n");
  t9 = (t1 == ALUCondition_Op1TypeAcceptable) ? 1 : 0;   

force-alignment16537:
  if (_trace) printf("force-alignment16537:\n");
  if (t9 == 0) 
    goto basic-dispatch16510;
  /* Here if argument ALUConditionOp1TypeAcceptable */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16510:
  if (_trace) printf("basic-dispatch16510:\n");
  t9 = (t1 == ALUCondition_Op1TypeCondition) ? 1 : 0;   

force-alignment16538:
  if (_trace) printf("force-alignment16538:\n");
  if (t9 == 0) 
    goto basic-dispatch16511;
  /* Here if argument ALUConditionOp1TypeCondition */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16511:
  if (_trace) printf("basic-dispatch16511:\n");
  t9 = (t1 == ALUCondition_StackCacheOverflow) ? 1 : 0;   

force-alignment16539:
  if (_trace) printf("force-alignment16539:\n");
  if (t9 == 0) 
    goto basic-dispatch16512;
  /* Here if argument ALUConditionStackCacheOverflow */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16512:
  if (_trace) printf("basic-dispatch16512:\n");
  t9 = (t1 == ALUCondition_OrLogicVariable) ? 1 : 0;   

force-alignment16540:
  if (_trace) printf("force-alignment16540:\n");
  if (t9 == 0) 
    goto basic-dispatch16513;
  /* Here if argument ALUConditionOrLogicVariable */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16513:
  if (_trace) printf("basic-dispatch16513:\n");
  /* Here for all other cases */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16425:
  if (_trace) printf("basic-dispatch16425:\n");
  t1 = (t6 == ALUFunction_Byte) ? 1 : 0;   

force-alignment16541:
  if (_trace) printf("force-alignment16541:\n");
  if (t1 == 0) 
    goto basic-dispatch16460;
  /* Here if argument ALUFunctionByte */
  t9 = *(u64 *)&(processor->byterotate);   		// Get rotate 
  t10 = *(u64 *)&(processor->bytesize);   		// Get bytesize 
  /* Get background */
  t1 = t7 >> 10;   
  t1 = t1 & 3;		// Extract the byte background 
  t11 = (t1 == ALUByteBackground_Op1) ? 1 : 0;   

force-alignment16467:
  if (_trace) printf("force-alignment16467:\n");
  if (t11 == 0) 
    goto basic-dispatch16463;
  /* Here if argument ALUByteBackgroundOp1 */
  t1 = t3;

basic-dispatch16462:
  if (_trace) printf("basic-dispatch16462:\n");
  t12 = t7 >> 12;   
  t12 = t12 & 1;		// Extractthe byte rotate latch 
  t8 = t5 << (t9 & 63);   
  t11 = (u32)(t8 >> ((4&7)*8));   
  t8 = (u32)t8;   
  t8 = t8 | t11;		// OP2 rotated 
  if (t12 == 0) 		// Don't update rotate latch if not requested 
    goto alu-function-byte16461;
  *(u64 *)&processor->rotatelatch = t8;   

alu-function-byte16461:
  if (_trace) printf("alu-function-byte16461:\n");
  t12 = zero + -2;   
  t12 = t12 << (t10 & 63);   
  t12 = ~t12;   		// Compute mask 
  /* Get byte function */
  t11 = t7 >> 13;   
  t11 = t11 & 1;
  t10 = (t11 == ALUByteFunction_Dpb) ? 1 : 0;   

force-alignment16472:
  if (_trace) printf("force-alignment16472:\n");
  if (t10 == 0) 
    goto basic-dispatch16469;
  /* Here if argument ALUByteFunctionDpb */
  t12 = t12 << (t9 & 63);   		// Position mask 

basic-dispatch16468:
  if (_trace) printf("basic-dispatch16468:\n");
  t8 = t8 & t12;		// rotated&mask 
  t1 = t1 & ~t12;		// background&~mask 
  t8 = t8 | t1;
  goto basic-dispatch16424;   

basic-dispatch16460:
  if (_trace) printf("basic-dispatch16460:\n");
  t1 = (t6 == ALUFunction_Adder) ? 1 : 0;   

force-alignment16542:
  if (_trace) printf("force-alignment16542:\n");
  if (t1 == 0) 
    goto basic-dispatch16473;
  /* Here if argument ALUFunctionAdder */
  t10 = t7 >> 11;   
  t10 = t10 & 3;		// Extract the op2 
  t9 = t7 >> 10;   
  t9 = t9 & 1;		// Extract the adder carry in 
  t11 = (t10 == ALUAdderOp2_Op2) ? 1 : 0;   

force-alignment16481:
  if (_trace) printf("force-alignment16481:\n");
  if (t11 == 0) 
    goto basic-dispatch16476;
  /* Here if argument ALUAdderOp2Op2 */
  t1 = t5;

basic-dispatch16475:
  if (_trace) printf("basic-dispatch16475:\n");
  t8 = t3 + t1;
  t8 = t8 + t9;
  t10 = t8 >> 31;   		// Sign bit 
  t11 = t8 >> 32;   		// Next bit 
  t10 = t10 ^ t11;   		// Low bit is now overflow indicator 
  t11 = t7 >> 24;   		// Get the load-carry-in bit 
  *(u64 *)&processor->aluoverflow = t10;   
  if ((t11 & 1) == 0)   
    goto alu-function-adder16474;
  t10 = (u32)(t8 >> ((4&7)*8));   		// Get the carry 
  t11 = zero + 1024;   
  t7 = t7 & ~t11;
  t11 = t10 & 1;
  t11 = t11 << 10;   
  t7 = t7 | t11;		// Set the adder carry in 
  *(u64 *)&processor->aluandrotatecontrol = t7;   

alu-function-adder16474:
  if (_trace) printf("alu-function-adder16474:\n");
  t10 = ((s64)t3 < (s64)t1) ? 1 : 0;   
  *(u64 *)&processor->aluborrow = t10;   
  t3 = (s32)t3;
  t5 = (s32)t5;
  t10 = ((s64)t3 < (s64)t1) ? 1 : 0;   
  *(u64 *)&processor->alulessthan = t10;   
  goto basic-dispatch16424;   

basic-dispatch16473:
  if (_trace) printf("basic-dispatch16473:\n");
  t1 = (t6 == ALUFunction_MultiplyDivide) ? 1 : 0;   

force-alignment16543:
  if (_trace) printf("force-alignment16543:\n");
  if (t1 == 0) 
    goto basic-dispatch16424;
  /* Here if argument ALUFunctionMultiplyDivide */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

basic-dispatch16476:
  if (_trace) printf("basic-dispatch16476:\n");
  t11 = (t10 == ALUAdderOp2_Zero) ? 1 : 0;   

force-alignment16544:
  if (_trace) printf("force-alignment16544:\n");
  if (t11 == 0) 
    goto basic-dispatch16477;
  /* Here if argument ALUAdderOp2Zero */
  t1 = zero;
  goto basic-dispatch16475;   

basic-dispatch16477:
  if (_trace) printf("basic-dispatch16477:\n");
  t11 = (t10 == ALUAdderOp2_Invert) ? 1 : 0;   

force-alignment16545:
  if (_trace) printf("force-alignment16545:\n");
  if (t11 == 0) 
    goto basic-dispatch16478;
  /* Here if argument ALUAdderOp2Invert */
  t1 = (s32)t5;
  t1 = zero - t1;   
  t1 = (u32)t1;   
  goto basic-dispatch16475;   

basic-dispatch16478:
  if (_trace) printf("basic-dispatch16478:\n");
  t11 = (t10 == ALUAdderOp2_MinusOne) ? 1 : 0;   

force-alignment16546:
  if (_trace) printf("force-alignment16546:\n");
  if (t11 == 0) 
    goto basic-dispatch16475;
  /* Here if argument ALUAdderOp2MinusOne */
  t1 = ~zero;   
  t1 = (u32)t1;   
  goto basic-dispatch16475;   

basic-dispatch16469:
  if (_trace) printf("basic-dispatch16469:\n");
  t10 = (t11 == ALUByteFunction_Ldb) ? 1 : 0;   

force-alignment16547:
  if (_trace) printf("force-alignment16547:\n");
  if (t10 != 0)   
    goto basic-dispatch16468;
  goto basic-dispatch16468;   

basic-dispatch16463:
  if (_trace) printf("basic-dispatch16463:\n");
  t11 = (t1 == ALUByteBackground_RotateLatch) ? 1 : 0;   

force-alignment16548:
  if (_trace) printf("force-alignment16548:\n");
  if (t11 == 0) 
    goto basic-dispatch16464;
  /* Here if argument ALUByteBackgroundRotateLatch */
  t1 = *(u64 *)&(processor->rotatelatch);   
  goto basic-dispatch16462;   

basic-dispatch16464:
  if (_trace) printf("basic-dispatch16464:\n");
  t11 = (t1 == ALUByteBackground_Zero) ? 1 : 0;   

force-alignment16549:
  if (_trace) printf("force-alignment16549:\n");
  if (t11 == 0) 
    goto basic-dispatch16462;
  /* Here if argument ALUByteBackgroundZero */
  t1 = zero;
  goto basic-dispatch16462;   

vma-memory-read16414:
  if (_trace) printf("vma-memory-read16414:\n");
  t10 = *(u64 *)&(processor->stackcachedata);   
  t9 = (t9 * 8) + t10;  		// reconstruct SCA 
  t3 = *(s32 *)t9;   
  t2 = *(s32 *)(t9 + 4);   		// Read from stack cache 
  goto vma-memory-read16413;   

vma-memory-read16416:
  if (_trace) printf("vma-memory-read16416:\n");

vma-memory-read16415:
  if (_trace) printf("vma-memory-read16415:\n");
  t12 = (t1 * 4);   		// Cycle-number -> table offset 
  t12 = (t12 * 4) + ivory;   
  t12 = *(u64 *)(t12 + PROCESSORSTATE_DATAREAD);   
  /* TagType. */
  t11 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg3;   		// stash the VMA for the (likely) trap 
  t11 = (t11 * 4) + t12;   		// Adjust for a longword load 
  t12 = *(s32 *)t11;   		// Get the memory action 

vma-memory-read16421:
  if (_trace) printf("vma-memory-read16421:\n");
  t10 = t12 & MemoryActionIndirect;
  if (t10 == 0) 
    goto vma-memory-read16420;
  arg3 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read16412;   

vma-memory-read16420:
  if (_trace) printf("vma-memory-read16420:\n");
  t11 = t12 & MemoryActionTransform;
  if (t11 == 0) 
    goto vma-memory-read16419;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto vma-memory-read16423;   

vma-memory-read16419:

vma-memory-read16418:
  /* Perform memory action */
  arg1 = t12;
  arg2 = t1;
  goto performmemoryaction;

/* end DoBlock1ReadTest */
  /* End of Halfword operand from stack instruction - DoBlock1ReadTest */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunblok.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunbind.as
 ************************************************************************/

  /* Binding Instructions. */
/* start DoBindLocativeToValue */

  /* Halfword operand from stack instruction - DoBindLocativeToValue */

dobindlocativetovalue:
  if (_trace) printf("dobindlocativetovalue:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoBindLocativeToValueIM:
  if (_trace) printf("DoBindLocativeToValueIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment16582:
  if (_trace) printf("force-alignment16582:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindobindlocativetovalue;   

DoBindLocativeToValueSP:
  if (_trace) printf("DoBindLocativeToValueSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoBindLocativeToValueLP:
  if (_trace) printf("DoBindLocativeToValueLP:\n");

DoBindLocativeToValueFP:
  if (_trace) printf("DoBindLocativeToValueFP:\n");

headdobindlocativetovalue:
  if (_trace) printf("headdobindlocativetovalue:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindobindlocativetovalue:
  if (_trace) printf("begindobindlocativetovalue:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg6 = *(s32 *)iSP;   		// ltag/ldata 
  arg5 = *(s32 *)(iSP + 4);   		// ltag/ldata 
  iSP = iSP - 8;   		// Pop Stack. 
  arg6 = (u32)arg6;   
  arg3 = *(u64 *)&(processor->bindingstackpointer);   
  arg2 = arg1 >> 32;   		// new tag 
  arg4 = *(u64 *)&(processor->bindingstacklimit);   
  arg1 = (u32)arg1;   		// new data 
  t1 = arg5 - Type_Locative;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto bindloctovaliop;
#ifdef MINIMA
  t2 = arg3 >> 32;   
#endif
  arg3 = (u32)arg3;   
  arg4 = (u32)arg4;   
  t1 = arg3 - arg4;   
  if ((s64)t1 >= 0)   		// J. if binding stack overflow 
    goto bindloctovalov;
  t3 = arg3 + 1;
#ifdef MINIMA
  /* BSP not a locative -> Deep-bound */
  t1 = t2 - Type_Locative;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto bindloctovaldeep;
#endif
  t9 = *(s32 *)&processor->control;   
  t8 = arg6;
  /* Memory Read Internal */

vma-memory-read16550:
  t4 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t6 = t8 + ivory;
  t5 = *(s32 *)&processor->scovlimit;   
  t1 = (t6 * 4);   
  t2 = LDQ_U(t6);   
  t4 = t8 - t4;   		// Stack cache offset 
  t7 = *(u64 *)&(processor->bindread_mask);   
  t5 = ((u64)t4 < (u64)t5) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;   
  t2 = (u8)(t2 >> ((t6&7)*8));   
  if (t5 != 0)   
    goto vma-memory-read16552;

vma-memory-read16551:
  t6 = zero + 224;   
  t7 = t7 >> (t2 & 63);   
  t6 = t6 >> (t2 & 63);   
  if (t7 & 1)   
    goto vma-memory-read16554;

vma-memory-read16559:
  t10 = t9 >> 19;   
  /* TagType. */
  t8 = arg5 & 63;
  t10 = t10 & 64;		// Extract the CR.cleanup-bindings bit 
  t11 = t10 | t8;
  t5 = *(u64 *)&(processor->stackcachebasevma);   
  t4 = t3 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t7 = (t4 * 4);   
  t6 = LDQ_U(t4);   
  t5 = t3 - t5;   		// Stack cache offset 
  t8 = ((u64)t5 < (u64)t8) ? 1 : 0;   		// In range? 
  t5 = (t11 & 0xff) << ((t4&7)*8);   
  t6 = t6 & ~(0xffL << (t4&7)*8);   

force-alignment16562:
  if (_trace) printf("force-alignment16562:\n");
  t6 = t6 | t5;
  STQ_U(t4, t6);   
  *(u32 *)t7 = arg6;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write16561;

vma-memory-write16560:
  t3 = arg3 + 2;
  t5 = *(u64 *)&(processor->stackcachebasevma);   
  t4 = t3 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t7 = (t4 * 4);   
  t6 = LDQ_U(t4);   
  t5 = t3 - t5;   		// Stack cache offset 
  t8 = ((u64)t5 < (u64)t8) ? 1 : 0;   		// In range? 
  t5 = (t2 & 0xff) << ((t4&7)*8);   
  t6 = t6 & ~(0xffL << (t4&7)*8);   

force-alignment16565:
  if (_trace) printf("force-alignment16565:\n");
  t6 = t6 | t5;
  STQ_U(t4, t6);   
  *(u32 *)t7 = t1;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write16564;

vma-memory-write16563:
  t1 = (512) << 16;   
  /* Memory Read Internal */

vma-memory-read16566:
  t6 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t8 = arg6 + ivory;
  t7 = *(s32 *)&processor->scovlimit;   
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = arg6 - t6;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->bindwrite_mask);   
  t7 = ((u64)t6 < (u64)t7) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read16568;

vma-memory-read16567:
  t8 = zero + 224;   
  t10 = t10 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t10 & 1)   
    goto vma-memory-read16570;

vma-memory-read16575:
  /* Merge cdr-code */
  t5 = arg2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t7 = *(u64 *)&(processor->stackcachebasevma);   
  t6 = arg6 + ivory;
  t10 = *(s32 *)&processor->scovlimit;   
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = arg6 - t7;   		// Stack cache offset 
  t10 = ((u64)t7 < (u64)t10) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment16578:
  if (_trace) printf("force-alignment16578:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = arg1;
  if (t10 != 0)   		// J. if in cache 
    goto vma-memory-write16577;

vma-memory-write16576:
  t9 = t1 | t9;		// Set cr.cleanup-bindings bit 
  *(u32 *)&processor->control = t9;
		/* vma only */
  *(u32 *)&processor->bindingstackpointer = t3;
  goto NEXTINSTRUCTION;   

bindloctovalov:
  if (_trace) printf("bindloctovalov:\n");
  arg5 = 0;
  arg2 = 19;
  goto illegaloperand;

bindloctovaliop:
  if (_trace) printf("bindloctovaliop:\n");
  arg5 = 0;
  arg2 = 18;
  goto illegaloperand;

bindloctovaldeep:
  if (_trace) printf("bindloctovaldeep:\n");
  t1 = *(u64 *)&(processor->restartsp);   		// Get the SP, ->op2 
  /* Convert stack cache address to VMA */
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = t1 - t3;   		// stack cache base relative offset 
  t3 = t3 >> 3;   		// convert byte address to word address 
  t2 = t3 + t2;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 72;
  goto illegaloperand;

vma-memory-write16577:
  if (_trace) printf("vma-memory-write16577:\n");
  t7 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment16579:
  if (_trace) printf("force-alignment16579:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = arg6 - t7;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = arg1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto vma-memory-write16576;   

vma-memory-read16568:
  if (_trace) printf("vma-memory-read16568:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read16567;   

vma-memory-read16570:
  if (_trace) printf("vma-memory-read16570:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read16569;
  arg6 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read16566;   

vma-memory-read16569:
  if (_trace) printf("vma-memory-read16569:\n");
  t10 = *(u64 *)&(processor->bindwrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg6;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read16572:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 3;
  goto performmemoryaction;

vma-memory-write16564:
  if (_trace) printf("vma-memory-write16564:\n");
  t5 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment16580:
  if (_trace) printf("force-alignment16580:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t5 = t3 - t5;   		// Stack cache offset 
  t4 = (t5 * 8) + t4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t4 = t1;
		/* write the stack cache */
  *(u32 *)(t4 + 4) = t2;
  goto vma-memory-write16563;   

vma-memory-write16561:
  if (_trace) printf("vma-memory-write16561:\n");
  t5 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment16581:
  if (_trace) printf("force-alignment16581:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t5 = t3 - t5;   		// Stack cache offset 
  t4 = (t5 * 8) + t4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t4 = arg6;
		/* write the stack cache */
  *(u32 *)(t4 + 4) = t11;
  goto vma-memory-write16560;   

vma-memory-read16552:
  if (_trace) printf("vma-memory-read16552:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t4 = (t4 * 8) + t5;  		// reconstruct SCA 
  t1 = *(s32 *)t4;   
  t2 = *(s32 *)(t4 + 4);   		// Read from stack cache 
  goto vma-memory-read16551;   

vma-memory-read16554:
  if (_trace) printf("vma-memory-read16554:\n");
  if ((t6 & 1) == 0)   
    goto vma-memory-read16553;
  t8 = (u32)t1;   		// Do the indirect thing 
  goto vma-memory-read16550;   

vma-memory-read16553:
  if (_trace) printf("vma-memory-read16553:\n");
  t7 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  t6 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t8;   		// stash the VMA for the (likely) trap 
  t6 = (t6 * 4) + t7;   		// Adjust for a longword load 
  t7 = *(s32 *)t6;   		// Get the memory action 

vma-memory-read16556:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 2;
  goto performmemoryaction;

/* end DoBindLocativeToValue */
  /* End of Halfword operand from stack instruction - DoBindLocativeToValue */
/* start DoBindLocative */

  /* Halfword operand from stack instruction - DoBindLocative */
  /* arg2 has the preloaded 8 bit operand. */

dobindlocative:
  if (_trace) printf("dobindlocative:\n");

DoBindLocativeSP:
  if (_trace) printf("DoBindLocativeSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoBindLocativeLP:
  if (_trace) printf("DoBindLocativeLP:\n");

DoBindLocativeFP:
  if (_trace) printf("DoBindLocativeFP:\n");

begindobindlocative:
  if (_trace) printf("begindobindlocative:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 
  arg3 = *(u64 *)&(processor->bindingstackpointer);   
  arg5 = arg1 >> 32;   		// tag 
  arg4 = *(u64 *)&(processor->bindingstacklimit);   
  arg6 = (u32)arg1;   		// data 
  t1 = arg5 - Type_Locative;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto bindlociop;
#ifdef MINIMA
  t2 = arg3 >> 32;   
#endif
  arg3 = (u32)arg3;   
  arg4 = (u32)arg4;   
  t1 = arg3 - arg4;   
  if ((s64)t1 >= 0)   		// J. if binding stack overflow 
    goto bindlocov;
  t3 = arg3 + 1;
#ifdef MINIMA
  /* BSP not a locative -> Deep-bound */
  t1 = t2 - Type_Locative;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto bindlocdeep;
#endif
  t9 = *(s32 *)&processor->control;   
  t8 = arg6;
  /* Memory Read Internal */

vma-memory-read16583:
  t4 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t6 = t8 + ivory;
  t5 = *(s32 *)&processor->scovlimit;   
  t1 = (t6 * 4);   
  t2 = LDQ_U(t6);   
  t4 = t8 - t4;   		// Stack cache offset 
  t7 = *(u64 *)&(processor->bindread_mask);   
  t5 = ((u64)t4 < (u64)t5) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;   
  t2 = (u8)(t2 >> ((t6&7)*8));   
  if (t5 != 0)   
    goto vma-memory-read16585;

vma-memory-read16584:
  t6 = zero + 224;   
  t7 = t7 >> (t2 & 63);   
  t6 = t6 >> (t2 & 63);   
  if (t7 & 1)   
    goto vma-memory-read16587;

vma-memory-read16592:
  t10 = t9 >> 19;   
  /* TagType. */
  t8 = arg5 & 63;
  t10 = t10 & 64;		// Extract the CR.cleanup-bindings bit 
  t11 = t10 | t8;
  t5 = *(u64 *)&(processor->stackcachebasevma);   
  t4 = t3 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t7 = (t4 * 4);   
  t6 = LDQ_U(t4);   
  t5 = t3 - t5;   		// Stack cache offset 
  t8 = ((u64)t5 < (u64)t8) ? 1 : 0;   		// In range? 
  t5 = (t11 & 0xff) << ((t4&7)*8);   
  t6 = t6 & ~(0xffL << (t4&7)*8);   

force-alignment16595:
  if (_trace) printf("force-alignment16595:\n");
  t6 = t6 | t5;
  STQ_U(t4, t6);   
  *(u32 *)t7 = arg6;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write16594;

vma-memory-write16593:
  t3 = arg3 + 2;
  t5 = *(u64 *)&(processor->stackcachebasevma);   
  t4 = t3 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t7 = (t4 * 4);   
  t6 = LDQ_U(t4);   
  t5 = t3 - t5;   		// Stack cache offset 
  t8 = ((u64)t5 < (u64)t8) ? 1 : 0;   		// In range? 
  t5 = (t2 & 0xff) << ((t4&7)*8);   
  t6 = t6 & ~(0xffL << (t4&7)*8);   

force-alignment16598:
  if (_trace) printf("force-alignment16598:\n");
  t6 = t6 | t5;
  STQ_U(t4, t6);   
  *(u32 *)t7 = t1;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write16597;

vma-memory-write16596:
  t1 = (512) << 16;   
  t9 = t1 | t9;		// Set cr.cleanup-bindings bit 
  *(u32 *)&processor->control = t9;
		/* vma only */
  *(u32 *)&processor->bindingstackpointer = t3;
  goto NEXTINSTRUCTION;   

bindlocov:
  if (_trace) printf("bindlocov:\n");
  arg5 = 0;
  arg2 = 19;
  goto illegaloperand;

bindlociop:
  if (_trace) printf("bindlociop:\n");
  arg5 = 0;
  arg2 = 18;
  goto illegaloperand;

bindlocdeep:
  if (_trace) printf("bindlocdeep:\n");
  t1 = *(u64 *)&(processor->restartsp);   		// Get the SP, ->op2 
  /* Convert stack cache address to VMA */
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = t1 - t3;   		// stack cache base relative offset 
  t3 = t3 >> 3;   		// convert byte address to word address 
  t2 = t3 + t2;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 72;
  goto illegaloperand;

vma-memory-write16597:
  if (_trace) printf("vma-memory-write16597:\n");
  t5 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment16599:
  if (_trace) printf("force-alignment16599:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t5 = t3 - t5;   		// Stack cache offset 
  t4 = (t5 * 8) + t4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t4 = t1;
		/* write the stack cache */
  *(u32 *)(t4 + 4) = t2;
  goto vma-memory-write16596;   

vma-memory-write16594:
  if (_trace) printf("vma-memory-write16594:\n");
  t5 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment16600:
  if (_trace) printf("force-alignment16600:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t5 = t3 - t5;   		// Stack cache offset 
  t4 = (t5 * 8) + t4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t4 = arg6;
		/* write the stack cache */
  *(u32 *)(t4 + 4) = t11;
  goto vma-memory-write16593;   

vma-memory-read16585:
  if (_trace) printf("vma-memory-read16585:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t4 = (t4 * 8) + t5;  		// reconstruct SCA 
  t1 = *(s32 *)t4;   
  t2 = *(s32 *)(t4 + 4);   		// Read from stack cache 
  goto vma-memory-read16584;   

vma-memory-read16587:
  if (_trace) printf("vma-memory-read16587:\n");
  if ((t6 & 1) == 0)   
    goto vma-memory-read16586;
  t8 = (u32)t1;   		// Do the indirect thing 
  goto vma-memory-read16583;   

vma-memory-read16586:
  if (_trace) printf("vma-memory-read16586:\n");
  t7 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  t6 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t8;   		// stash the VMA for the (likely) trap 
  t6 = (t6 * 4) + t7;   		// Adjust for a longword load 
  t7 = *(s32 *)t6;   		// Get the memory action 

vma-memory-read16589:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 2;
  goto performmemoryaction;

DoBindLocativeIM:
  goto doistageerror;

/* end DoBindLocative */
  /* End of Halfword operand from stack instruction - DoBindLocative */
/* start DoUnbindN */

  /* Halfword operand from stack instruction - DoUnbindN */
  /* arg2 has the preloaded 8 bit operand. */

dounbindn:
  if (_trace) printf("dounbindn:\n");

DoUnbindNIM:
  if (_trace) printf("DoUnbindNIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindounbindn;   

DoUnbindNSP:
  if (_trace) printf("DoUnbindNSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoUnbindNLP:
  if (_trace) printf("DoUnbindNLP:\n");

DoUnbindNFP:
  if (_trace) printf("DoUnbindNFP:\n");

headdounbindn:
  if (_trace) printf("headdounbindn:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindounbindn:
  if (_trace) printf("begindounbindn:\n");
  /* arg1 has the operand, not sign extended if immediate. */
#ifdef MINIMA
  arg3 = *(u64 *)&(processor->bindingstackpointer);   
#endif
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t1 = arg2 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto unbindniop;
#ifdef MINIMA
  /* BSP not a locative -> Deep-bound */
  t2 = arg3 >> 32;   
  t1 = t2 - Type_Locative;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto unbindndeep;
#endif
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto unbindnendloop;   

unbindntoploop:
  if (_trace) printf("unbindntoploop:\n");
  arg1 = arg1 - 1;   
  t1 = *(u64 *)&(processor->bindingstackpointer);   
  t4 = *(s32 *)&processor->control;   
  t1 = (u32)t1;   		// vma only 
  t2 = (512) << 16;   
  t5 = t1 - 1;   
  t3 = t4 & t2;
  t4 = t4 & ~t2;		// Turn off the bit 
  if (t3 != 0)   
    goto g16601;
  t4 = *(u64 *)&(processor->restartsp);   		// Get the SP, ->op2 
  arg5 = 0;
  arg2 = 20;
  goto illegaloperand;

g16601:
  if (_trace) printf("g16601:\n");
  /* Memory Read Internal */

vma-memory-read16602:
  arg4 = t1 + ivory;
  t6 = (arg4 * 4);   
  t7 = LDQ_U(arg4);   
  t8 = t1 - t11;   		// Stack cache offset 
  arg5 = *(u64 *)&(processor->bindread_mask);   
  arg3 = ((u64)t8 < (u64)t12) ? 1 : 0;   		// In range? 
  t6 = *(s32 *)t6;   
  t7 = (u8)(t7 >> ((arg4&7)*8));   
  if (arg3 != 0)   
    goto vma-memory-read16604;

vma-memory-read16603:
  arg4 = zero + 224;   
  arg5 = arg5 >> (t7 & 63);   
  arg4 = arg4 >> (t7 & 63);   
  if (arg5 & 1)   
    goto vma-memory-read16606;

vma-memory-read16611:
  /* Memory Read Internal */

vma-memory-read16612:
  arg4 = t5 + ivory;
  t2 = (arg4 * 4);   
  t3 = LDQ_U(arg4);   
  t8 = t5 - t11;   		// Stack cache offset 
  arg5 = *(u64 *)&(processor->bindread_mask);   
  arg3 = ((u64)t8 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t3 = (u8)(t3 >> ((arg4&7)*8));   
  if (arg3 != 0)   
    goto vma-memory-read16614;

vma-memory-read16613:
  arg4 = zero + 224;   
  arg5 = arg5 >> (t3 & 63);   
  arg4 = arg4 >> (t3 & 63);   
  t2 = (u32)t2;   
  if (arg5 & 1)   
    goto vma-memory-read16616;

vma-memory-read16621:
  /* Memory Read Internal */

vma-memory-read16622:
  arg6 = t2 + ivory;
  arg3 = (arg6 * 4);   
  t8 = LDQ_U(arg6);   
  arg4 = t2 - t11;   		// Stack cache offset 
  arg5 = ((u64)arg4 < (u64)t12) ? 1 : 0;   		// In range? 
  arg3 = *(s32 *)arg3;   
  t8 = (u8)(t8 >> ((arg6&7)*8));   
  if (arg5 != 0)   
    goto vma-memory-read16624;

vma-memory-read16623:
  arg4 = *(u64 *)&(processor->bindwrite_mask);   
  arg6 = zero + 224;   
  arg4 = arg4 >> (t8 & 63);   
  arg6 = arg6 >> (t8 & 63);   
  if (arg4 & 1)   
    goto vma-memory-read16626;

vma-memory-read16631:
  /* Merge cdr-code */
  arg3 = t7 & 63;
  t8 = t8 & 192;
  t8 = t8 | arg3;
  arg4 = t2 + ivory;
  arg3 = (arg4 * 4);   
  arg6 = LDQ_U(arg4);   
  arg5 = (t8 & 0xff) << ((arg4&7)*8);   
  arg6 = arg6 & ~(0xffL << (arg4&7)*8);   

force-alignment16634:
  if (_trace) printf("force-alignment16634:\n");
  arg6 = arg6 | arg5;
  STQ_U(arg4, arg6);   
  arg4 = *(s32 *)&processor->scovlimit;   
  arg5 = t2 - t11;   		// Stack cache offset 
  arg4 = ((u64)arg5 < (u64)arg4) ? 1 : 0;   		// In range? 
  *(u32 *)arg3 = t6;
  if (arg4 != 0)   		// J. if in cache 
    goto vma-memory-write16633;

vma-memory-write16632:
  t3 = t3 & 64;		// Get the old cleanup-bindings bit 
  t3 = t3 << 19;   
  t1 = t1 - 2;   
		/* vma only */
  *(u32 *)&processor->bindingstackpointer = t1;
  t4 = t4 | t3;
  *(u32 *)&processor->control = t4;

unbindnendloop:
  if (_trace) printf("unbindnendloop:\n");
  if ((s64)arg1 > 0)   
    goto unbindntoploop;
  t3 = *(s32 *)&processor->interruptreg;   
  t4 = t3 & 2;
  t4 = (t4 == 2) ? 1 : 0;   
  t3 = t3 | t4;
  *(u32 *)&processor->interruptreg = t3;
  if (t3 == 0) 
    goto NEXTINSTRUCTION;
  *(u64 *)&processor->stop_interpreter = t3;   
  goto NEXTINSTRUCTION;   

unbindniop:
  if (_trace) printf("unbindniop:\n");
  arg5 = 0;
  arg2 = 63;
  goto illegaloperand;
#ifdef MINIMA

unbindndeep:
  if (_trace) printf("unbindndeep:\n");
  t1 = *(u64 *)&(processor->restartsp);   		// Get the SP, ->op2 
  /* Convert stack cache address to VMA */
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = t1 - t3;   		// stack cache base relative offset 
  t3 = t3 >> 3;   		// convert byte address to word address 
  t2 = t3 + t2;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 72;
  goto illegaloperand;
#endif

vma-memory-write16633:
  if (_trace) printf("vma-memory-write16633:\n");
  arg4 = *(u64 *)&(processor->stackcachedata);   
  arg4 = (arg5 * 8) + arg4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)arg4 = t6;
		/* write the stack cache */
  *(u32 *)(arg4 + 4) = t8;
  goto vma-memory-write16632;   

vma-memory-read16624:
  if (_trace) printf("vma-memory-read16624:\n");
  arg5 = *(u64 *)&(processor->stackcachedata);   
  arg4 = (arg4 * 8) + arg5;  		// reconstruct SCA 
  arg3 = *(s32 *)arg4;   
  t8 = *(s32 *)(arg4 + 4);   		// Read from stack cache 
  goto vma-memory-read16623;   

vma-memory-read16626:
  if (_trace) printf("vma-memory-read16626:\n");
  if ((arg6 & 1) == 0)   
    goto vma-memory-read16625;
  t2 = (u32)arg3;   		// Do the indirect thing 
  goto vma-memory-read16622;   

vma-memory-read16625:
  if (_trace) printf("vma-memory-read16625:\n");
  arg4 = *(u64 *)&(processor->bindwrite);   		// Load the memory action table for cycle 
  /* TagType. */
  arg6 = t8 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t2;   		// stash the VMA for the (likely) trap 
  arg6 = (arg6 * 4) + arg4;   		// Adjust for a longword load 
  arg4 = *(s32 *)arg6;   		// Get the memory action 

vma-memory-read16628:
  /* Perform memory action */
  arg1 = arg4;
  arg2 = 3;
  goto performmemoryaction;

vma-memory-read16614:
  if (_trace) printf("vma-memory-read16614:\n");
  arg3 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + arg3;  		// reconstruct SCA 
  t2 = *(s32 *)t8;   
  t3 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read16613;   

vma-memory-read16616:
  if (_trace) printf("vma-memory-read16616:\n");
  if ((arg4 & 1) == 0)   
    goto vma-memory-read16615;
  t5 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read16612;   

vma-memory-read16615:
  if (_trace) printf("vma-memory-read16615:\n");
  arg5 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  arg4 = t3 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t5;   		// stash the VMA for the (likely) trap 
  arg4 = (arg4 * 4) + arg5;   		// Adjust for a longword load 
  arg5 = *(s32 *)arg4;   		// Get the memory action 

vma-memory-read16618:
  /* Perform memory action */
  arg1 = arg5;
  arg2 = 2;
  goto performmemoryaction;

vma-memory-read16604:
  if (_trace) printf("vma-memory-read16604:\n");
  arg3 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + arg3;  		// reconstruct SCA 
  t6 = *(s32 *)t8;   
  t7 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read16603;   

vma-memory-read16606:
  if (_trace) printf("vma-memory-read16606:\n");
  if ((arg4 & 1) == 0)   
    goto vma-memory-read16605;
  t1 = (u32)t6;   		// Do the indirect thing 
  goto vma-memory-read16602;   

vma-memory-read16605:
  if (_trace) printf("vma-memory-read16605:\n");
  arg5 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  arg4 = t7 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  arg4 = (arg4 * 4) + arg5;   		// Adjust for a longword load 
  arg5 = *(s32 *)arg4;   		// Get the memory action 

vma-memory-read16608:
  /* Perform memory action */
  arg1 = arg5;
  arg2 = 2;
  goto performmemoryaction;

/* end DoUnbindN */
  /* End of Halfword operand from stack instruction - DoUnbindN */
/* start DoRestoreBindingStack */

  /* Halfword operand from stack instruction - DoRestoreBindingStack */
  /* arg2 has the preloaded 8 bit operand. */

dorestorebindingstack:
  if (_trace) printf("dorestorebindingstack:\n");

DoRestoreBindingStackIM:
  if (_trace) printf("DoRestoreBindingStackIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindorestorebindingstack;   

DoRestoreBindingStackSP:
  if (_trace) printf("DoRestoreBindingStackSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoRestoreBindingStackLP:
  if (_trace) printf("DoRestoreBindingStackLP:\n");

DoRestoreBindingStackFP:
  if (_trace) printf("DoRestoreBindingStackFP:\n");

headdorestorebindingstack:
  if (_trace) printf("headdorestorebindingstack:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindorestorebindingstack:
  if (_trace) printf("begindorestorebindingstack:\n");
  /* arg1 has the operand, not sign extended if immediate. */
#ifdef MINIMA
  arg3 = *(u64 *)&(processor->bindingstackpointer);   
#endif
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t1 = arg2 - Type_Locative;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto restorebsiop;
#ifdef MINIMA
  /* BSP not a locative -> Deep-bound */
  t2 = arg3 >> 32;   
  t1 = t2 - Type_Locative;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto restorebsdeep;
#endif
  t1 = *(u64 *)&(processor->bindingstackpointer);   
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto restorebsendloop;   

restorebstoploop:
  if (_trace) printf("restorebstoploop:\n");
  t1 = *(u64 *)&(processor->bindingstackpointer);   
  t4 = *(s32 *)&processor->control;   
  t1 = (u32)t1;   		// vma only 
  t2 = (512) << 16;   
  t5 = t1 - 1;   
  t3 = t4 & t2;
  t4 = t4 & ~t2;		// Turn off the bit 
  if (t3 != 0)   
    goto g16635;
  t4 = *(u64 *)&(processor->restartsp);   		// Get the SP, ->op2 
  arg5 = 0;
  arg2 = 20;
  goto illegaloperand;

g16635:
  if (_trace) printf("g16635:\n");
  /* Memory Read Internal */

vma-memory-read16636:
  arg4 = t1 + ivory;
  t6 = (arg4 * 4);   
  t7 = LDQ_U(arg4);   
  t8 = t1 - t11;   		// Stack cache offset 
  arg5 = *(u64 *)&(processor->bindread_mask);   
  arg3 = ((u64)t8 < (u64)t12) ? 1 : 0;   		// In range? 
  t6 = *(s32 *)t6;   
  t7 = (u8)(t7 >> ((arg4&7)*8));   
  if (arg3 != 0)   
    goto vma-memory-read16638;

vma-memory-read16637:
  arg4 = zero + 224;   
  arg5 = arg5 >> (t7 & 63);   
  arg4 = arg4 >> (t7 & 63);   
  if (arg5 & 1)   
    goto vma-memory-read16640;

vma-memory-read16645:
  /* Memory Read Internal */

vma-memory-read16646:
  arg4 = t5 + ivory;
  t2 = (arg4 * 4);   
  t3 = LDQ_U(arg4);   
  t8 = t5 - t11;   		// Stack cache offset 
  arg5 = *(u64 *)&(processor->bindread_mask);   
  arg3 = ((u64)t8 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t3 = (u8)(t3 >> ((arg4&7)*8));   
  if (arg3 != 0)   
    goto vma-memory-read16648;

vma-memory-read16647:
  arg4 = zero + 224;   
  arg5 = arg5 >> (t3 & 63);   
  arg4 = arg4 >> (t3 & 63);   
  t2 = (u32)t2;   
  if (arg5 & 1)   
    goto vma-memory-read16650;

vma-memory-read16655:
  /* Memory Read Internal */

vma-memory-read16656:
  arg6 = t2 + ivory;
  arg3 = (arg6 * 4);   
  t8 = LDQ_U(arg6);   
  arg4 = t2 - t11;   		// Stack cache offset 
  arg5 = ((u64)arg4 < (u64)t12) ? 1 : 0;   		// In range? 
  arg3 = *(s32 *)arg3;   
  t8 = (u8)(t8 >> ((arg6&7)*8));   
  if (arg5 != 0)   
    goto vma-memory-read16658;

vma-memory-read16657:
  arg4 = *(u64 *)&(processor->bindwrite_mask);   
  arg6 = zero + 224;   
  arg4 = arg4 >> (t8 & 63);   
  arg6 = arg6 >> (t8 & 63);   
  if (arg4 & 1)   
    goto vma-memory-read16660;

vma-memory-read16665:
  /* Merge cdr-code */
  arg3 = t7 & 63;
  t8 = t8 & 192;
  t8 = t8 | arg3;
  arg4 = t2 + ivory;
  arg3 = (arg4 * 4);   
  arg6 = LDQ_U(arg4);   
  arg5 = (t8 & 0xff) << ((arg4&7)*8);   
  arg6 = arg6 & ~(0xffL << (arg4&7)*8);   

force-alignment16668:
  if (_trace) printf("force-alignment16668:\n");
  arg6 = arg6 | arg5;
  STQ_U(arg4, arg6);   
  arg4 = *(s32 *)&processor->scovlimit;   
  arg5 = t2 - t11;   		// Stack cache offset 
  arg4 = ((u64)arg5 < (u64)arg4) ? 1 : 0;   		// In range? 
  *(u32 *)arg3 = t6;
  if (arg4 != 0)   		// J. if in cache 
    goto vma-memory-write16667;

vma-memory-write16666:
  t3 = t3 & 64;		// Get the old cleanup-bindings bit 
  t3 = t3 << 19;   
  t1 = t1 - 2;   
		/* vma only */
  *(u32 *)&processor->bindingstackpointer = t1;
  t4 = t4 | t3;
  *(u32 *)&processor->control = t4;

restorebsendloop:
  if (_trace) printf("restorebsendloop:\n");
  arg4 = (s32)t1 - (s32)arg1;   
  if ((s64)arg4 > 0)   
    goto restorebstoploop;
  t3 = *(s32 *)&processor->interruptreg;   
  t4 = t3 & 2;
  t4 = (t4 == 2) ? 1 : 0;   
  t3 = t3 | t4;
  *(u32 *)&processor->interruptreg = t3;
  if (t3 == 0) 
    goto NEXTINSTRUCTION;
  *(u64 *)&processor->stop_interpreter = t3;   
  goto NEXTINSTRUCTION;   

restorebsiop:
  if (_trace) printf("restorebsiop:\n");
  arg5 = 0;
  arg2 = 66;
  goto illegaloperand;
#ifdef MINIMA

restorebsdeep:
  if (_trace) printf("restorebsdeep:\n");
  t1 = *(u64 *)&(processor->restartsp);   		// Get the SP, ->op2 
  /* Convert stack cache address to VMA */
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = t1 - t3;   		// stack cache base relative offset 
  t3 = t3 >> 3;   		// convert byte address to word address 
  t2 = t3 + t2;		// reconstruct VMA 
  arg5 = t2;
  arg2 = 66;
  goto illegaloperand;
#endif

vma-memory-write16667:
  if (_trace) printf("vma-memory-write16667:\n");
  arg4 = *(u64 *)&(processor->stackcachedata);   
  arg4 = (arg5 * 8) + arg4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)arg4 = t6;
		/* write the stack cache */
  *(u32 *)(arg4 + 4) = t8;
  goto vma-memory-write16666;   

vma-memory-read16658:
  if (_trace) printf("vma-memory-read16658:\n");
  arg5 = *(u64 *)&(processor->stackcachedata);   
  arg4 = (arg4 * 8) + arg5;  		// reconstruct SCA 
  arg3 = *(s32 *)arg4;   
  t8 = *(s32 *)(arg4 + 4);   		// Read from stack cache 
  goto vma-memory-read16657;   

vma-memory-read16660:
  if (_trace) printf("vma-memory-read16660:\n");
  if ((arg6 & 1) == 0)   
    goto vma-memory-read16659;
  t2 = (u32)arg3;   		// Do the indirect thing 
  goto vma-memory-read16656;   

vma-memory-read16659:
  if (_trace) printf("vma-memory-read16659:\n");
  arg4 = *(u64 *)&(processor->bindwrite);   		// Load the memory action table for cycle 
  /* TagType. */
  arg6 = t8 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t2;   		// stash the VMA for the (likely) trap 
  arg6 = (arg6 * 4) + arg4;   		// Adjust for a longword load 
  arg4 = *(s32 *)arg6;   		// Get the memory action 

vma-memory-read16662:
  /* Perform memory action */
  arg1 = arg4;
  arg2 = 3;
  goto performmemoryaction;

vma-memory-read16648:
  if (_trace) printf("vma-memory-read16648:\n");
  arg3 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + arg3;  		// reconstruct SCA 
  t2 = *(s32 *)t8;   
  t3 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read16647;   

vma-memory-read16650:
  if (_trace) printf("vma-memory-read16650:\n");
  if ((arg4 & 1) == 0)   
    goto vma-memory-read16649;
  t5 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read16646;   

vma-memory-read16649:
  if (_trace) printf("vma-memory-read16649:\n");
  arg5 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  arg4 = t3 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t5;   		// stash the VMA for the (likely) trap 
  arg4 = (arg4 * 4) + arg5;   		// Adjust for a longword load 
  arg5 = *(s32 *)arg4;   		// Get the memory action 

vma-memory-read16652:
  /* Perform memory action */
  arg1 = arg5;
  arg2 = 2;
  goto performmemoryaction;

vma-memory-read16638:
  if (_trace) printf("vma-memory-read16638:\n");
  arg3 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + arg3;  		// reconstruct SCA 
  t6 = *(s32 *)t8;   
  t7 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read16637;   

vma-memory-read16640:
  if (_trace) printf("vma-memory-read16640:\n");
  if ((arg4 & 1) == 0)   
    goto vma-memory-read16639;
  t1 = (u32)t6;   		// Do the indirect thing 
  goto vma-memory-read16636;   

vma-memory-read16639:
  if (_trace) printf("vma-memory-read16639:\n");
  arg5 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  arg4 = t7 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  arg4 = (arg4 * 4) + arg5;   		// Adjust for a longword load 
  arg5 = *(s32 *)arg4;   		// Get the memory action 

vma-memory-read16642:
  /* Perform memory action */
  arg1 = arg5;
  arg2 = 2;
  goto performmemoryaction;

/* end DoRestoreBindingStack */
  /* End of Halfword operand from stack instruction - DoRestoreBindingStack */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunbind.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunfull.as
 ************************************************************************/

  /* The full word instructions */
/* start DoIStageError */

  /*  */
  /*  */
  /* Fullword instruction - DoIStageError */
  /* ======================= */

doistageerror:
  if (_trace) printf("doistageerror:\n");
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

/* end DoIStageError */
  /* End of Fullword instruction - DoIStageError */
  /* ============================== */
  /*  */
/* start nullfw */

  /*  */
  /*  */
  /* Fullword instruction - nullfw */
  /* ======================= */

nullfw:
  if (_trace) printf("nullfw:\n");
  arg5 = 0;
  arg2 = 47;
  goto illegaloperand;

/* end nullfw */
  /* End of Fullword instruction - nullfw */
  /* ============================== */
  /*  */
/* start monitorforwardfw */

  /*  */
  /*  */
  /* Fullword instruction - monitorforwardfw */
  /* ======================= */

monitorforwardfw:
  if (_trace) printf("monitorforwardfw:\n");
  arg5 = 0;
  arg2 = 46;
  goto illegaloperand;

/* end monitorforwardfw */
  /* End of Fullword instruction - monitorforwardfw */
  /* ============================== */
  /*  */
/* start headerpfw */

  /*  */
  /*  */
  /* Fullword instruction - headerpfw */
  /* ======================= */

headerpfw:
  if (_trace) printf("headerpfw:\n");
  arg5 = 0;
  arg2 = 44;
  goto illegaloperand;

/* end headerpfw */
  /* End of Fullword instruction - headerpfw */
  /* ============================== */
  /*  */
/* start headerifw */

  /*  */
  /*  */
  /* Fullword instruction - headerifw */
  /* ======================= */

headerifw:
  if (_trace) printf("headerifw:\n");
  arg5 = 0;
  arg2 = 43;
  goto illegaloperand;

/* end headerifw */
  /* End of Fullword instruction - headerifw */
  /* ============================== */
  /*  */
/* start oneqforwardfw */

  /*  */
  /*  */
  /* Fullword instruction - oneqforwardfw */
  /* ======================= */

oneqforwardfw:
  if (_trace) printf("oneqforwardfw:\n");
  arg5 = 0;
  arg2 = 48;
  goto illegaloperand;

/* end oneqforwardfw */
  /* End of Fullword instruction - oneqforwardfw */
  /* ============================== */
  /*  */
/* start headerforwardfw */

  /*  */
  /*  */
  /* Fullword instruction - headerforwardfw */
  /* ======================= */

headerforwardfw:
  if (_trace) printf("headerforwardfw:\n");
  arg5 = 0;
  arg2 = 42;
  goto illegaloperand;

/* end headerforwardfw */
  /* End of Fullword instruction - headerforwardfw */
  /* ============================== */
  /*  */
/* start elementforwardfw */

  /*  */
  /*  */
  /* Fullword instruction - elementforwardfw */
  /* ======================= */

elementforwardfw:
  if (_trace) printf("elementforwardfw:\n");
  arg5 = 0;
  arg2 = 40;
  goto illegaloperand;

/* end elementforwardfw */
  /* End of Fullword instruction - elementforwardfw */
  /* ============================== */
  /*  */
/* start gcforwardfw */

  /*  */
  /*  */
  /* Fullword instruction - gcforwardfw */
  /* ======================= */

gcforwardfw:
  if (_trace) printf("gcforwardfw:\n");
  arg5 = 0;
  arg2 = 41;
  goto illegaloperand;

/* end gcforwardfw */
  /* End of Fullword instruction - gcforwardfw */
  /* ============================== */
  /*  */
/* start boundlocationfw */

  /*  */
  /*  */
  /* Fullword instruction - boundlocationfw */
  /* ======================= */

boundlocationfw:
  if (_trace) printf("boundlocationfw:\n");
  arg5 = 0;
  arg2 = 39;
  goto illegaloperand;

/* end boundlocationfw */
  /* End of Fullword instruction - boundlocationfw */
  /* ============================== */
  /*  */
/* start logicvariablefw */

  /*  */
  /*  */
  /* Fullword instruction - logicvariablefw */
  /* ======================= */

logicvariablefw:
  if (_trace) printf("logicvariablefw:\n");
  arg5 = 0;
  arg2 = 45;
  goto illegaloperand;

/* end logicvariablefw */
  /* End of Fullword instruction - logicvariablefw */
  /* ============================== */
  /*  */
/* start pushsparepointer3 */

  /*  */
  /*  */
  /* Fullword instruction - pushsparepointer3 */
  /* ======================= */

pushsparepointer3:
  if (_trace) printf("pushsparepointer3:\n");
  arg1 = *(u64 *)&(((CACHELINEP)iCP)->instruction);   		// Get operand 
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

/* end pushsparepointer3 */
  /* End of Fullword instruction - pushsparepointer3 */
  /* ============================== */
  /*  */
/* start pushsparepointer4 */

  /*  */
  /*  */
  /* Fullword instruction - pushsparepointer4 */
  /* ======================= */

pushsparepointer4:
  if (_trace) printf("pushsparepointer4:\n");
  arg1 = *(u64 *)&(((CACHELINEP)iCP)->instruction);   		// Get operand 
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;

/* end pushsparepointer4 */
  /* End of Fullword instruction - pushsparepointer4 */
  /* ============================== */
  /*  */
/* start callcompiledodd */

  /*  */
  /*  */
  /* Fullword instruction - callcompiledodd */
  /* ======================= */

callcompiledodd:
  if (_trace) printf("callcompiledodd:\n");

callcompiledoddprefetch:
  if (_trace) printf("callcompiledoddprefetch:\n");
  arg6 = arg3;		// Get operand 
  arg5 = Type_OddPC;
  arg3 = zero;		// No extra arg 
  goto startcallcompiledmerge;   

/* end callcompiledodd */
  /* End of Fullword instruction - callcompiledodd */
  /* ============================== */
  /*  */
/* start nativeinstruction */

  /*  */
  /*  */
  /* Fullword instruction - nativeinstruction */
  /* ======================= */

nativeinstruction:
  if (_trace) printf("nativeinstruction:\n");
  arg1 = iPC & ~1L;		// arg1 is instruction address*2 here 
  arg1 = arg1 + arg1;		// Select the DATA address 
  arg1 = (ivory * 4) + arg1;   		// Add in the memory base 
    r0 = (*( u64 (*)(u64, u64) )arg1)(arg1, arg2); /* jsr */  		// Jump into the Ivory code 

/* end nativeinstruction */
  /* End of Fullword instruction - nativeinstruction */
  /* ============================== */
  /*  */
/* start resumeemulated */


resumeemulated:
  if (_trace) printf("resumeemulated:\n");
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);   
  iPC = (ivory * 4) - arg1;   
  iPC = zero - iPC;   
  iPC = iPC >> 1;   
  if (arg2 != 0)   
    goto interpretinstructionpredicted;
  goto interpretinstructionforbranch;   

/* end resumeemulated */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunfull.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunbnum.as
 ************************************************************************/

  /* Bignums. */
/* start DoAddBignumStep */

  /* Halfword operand from stack instruction - DoAddBignumStep */
  /* arg2 has the preloaded 8 bit operand. */

doaddbignumstep:
  if (_trace) printf("doaddbignumstep:\n");

DoAddBignumStepIM:
  if (_trace) printf("DoAddBignumStepIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoaddbignumstep;   

DoAddBignumStepSP:
  if (_trace) printf("DoAddBignumStepSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoAddBignumStepLP:
  if (_trace) printf("DoAddBignumStepLP:\n");

DoAddBignumStepFP:
  if (_trace) printf("DoAddBignumStepFP:\n");

headdoaddbignumstep:
  if (_trace) printf("headdoaddbignumstep:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoaddbignumstep:
  if (_trace) printf("begindoaddbignumstep:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg2 = *(s32 *)iSP;   		// Get arg2 
  t2 = *(s32 *)(iSP + 4);   		// and its tag 
  t3 = arg1 >> 32;   
  arg1 = (u32)arg1;   		// Strip type from arg3 
  t4 = t3 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto addbignumsteplose;
  arg3 = *(s32 *)(iSP + -8);   		// Get arg1 
  t1 = *(s32 *)(iSP + -4);   		// and its tag 
  arg2 = (u32)arg2;   		// Clear sign extension from arg2 
  t4 = t2 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto addbignumsteplose;
  arg3 = (u32)arg3;   		// Clear sign extension 
  t4 = t1 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto addbignumsteplose;
  arg4 = arg1 + arg2;
  arg5 = arg3 + arg4;
  arg6 = arg5 >> 32;   		// Shift the carry into arg6 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
		/* Store fixnum result */
  *(u32 *)(iSP + -8) = arg5;
		/* write the stack cache */
  *(u32 *)(iSP + -4) = t1;
		/* Store the carry if any */
  *(u32 *)iSP = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;   

addbignumsteplose:
  if (_trace) printf("addbignumsteplose:\n");
  arg5 = 0;
  arg2 = 76;
  goto illegaloperand;

/* end DoAddBignumStep */
  /* End of Halfword operand from stack instruction - DoAddBignumStep */
/* start DoSubBignumStep */

  /* Halfword operand from stack instruction - DoSubBignumStep */
  /* arg2 has the preloaded 8 bit operand. */

dosubbignumstep:
  if (_trace) printf("dosubbignumstep:\n");

DoSubBignumStepIM:
  if (_trace) printf("DoSubBignumStepIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindosubbignumstep;   

DoSubBignumStepSP:
  if (_trace) printf("DoSubBignumStepSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoSubBignumStepLP:
  if (_trace) printf("DoSubBignumStepLP:\n");

DoSubBignumStepFP:
  if (_trace) printf("DoSubBignumStepFP:\n");

headdosubbignumstep:
  if (_trace) printf("headdosubbignumstep:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindosubbignumstep:
  if (_trace) printf("begindosubbignumstep:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg2 = *(s32 *)iSP;   		// Get arg2 
  t2 = *(s32 *)(iSP + 4);   		// and its tag 
  t3 = arg1 >> 32;   
  arg1 = (u32)arg1;   		// Strip type from arg3 
  t4 = t3 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto subbignumsteplose;
  arg3 = *(s32 *)(iSP + -8);   		// Get arg1 
  t1 = *(s32 *)(iSP + -4);   		// and its tag 
  arg2 = (u32)arg2;   		// Clear sign extension from arg2 
  t4 = t2 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto subbignumsteplose;
  arg3 = (u32)arg3;   		// Clear sign extension 
  t4 = t1 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto subbignumsteplose;
  arg4 = arg3 - arg2;   		// arg1-arg2 
  arg6 = ((s64)arg4 < (s64)zero) ? 1 : 0;   		// arg6=1 if we borrowed in 1st step 
  arg4 = (u32)arg4;   		// Truncate 1st step to 32-bits 
  arg5 = arg4 - arg1;   		// (arg1-arg2)-arg3 
  t6 = ((s64)arg5 < (s64)zero) ? 1 : 0;   		// t6=1 if we borrowed in 2nd step 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
		/* Store fixnum result */
  *(u32 *)(iSP + -8) = arg5;
		/* write the stack cache */
  *(u32 *)(iSP + -4) = t1;
  arg6 = arg6 + t6;		// Compute borrow 
		/* Store the borrow if any */
  *(u32 *)iSP = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;   

subbignumsteplose:
  if (_trace) printf("subbignumsteplose:\n");
  arg5 = 0;
  arg2 = 76;
  goto illegaloperand;

/* end DoSubBignumStep */
  /* End of Halfword operand from stack instruction - DoSubBignumStep */
/* start DoMultiplyBignumStep */

  /* Halfword operand from stack instruction - DoMultiplyBignumStep */
  /* arg2 has the preloaded 8 bit operand. */

domultiplybignumstep:
  if (_trace) printf("domultiplybignumstep:\n");

DoMultiplyBignumStepIM:
  if (_trace) printf("DoMultiplyBignumStepIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindomultiplybignumstep;   

DoMultiplyBignumStepSP:
  if (_trace) printf("DoMultiplyBignumStepSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoMultiplyBignumStepLP:
  if (_trace) printf("DoMultiplyBignumStepLP:\n");

DoMultiplyBignumStepFP:
  if (_trace) printf("DoMultiplyBignumStepFP:\n");

headdomultiplybignumstep:
  if (_trace) printf("headdomultiplybignumstep:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindomultiplybignumstep:
  if (_trace) printf("begindomultiplybignumstep:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg2 = *(s32 *)iSP;   		// Get arg1 
  t1 = *(s32 *)(iSP + 4);   
  t2 = arg1 >> 32;   
  arg1 = (u32)arg1;   		// Strip type from arg2 
  t4 = t2 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto multbignumsteplose;
  arg2 = (u32)arg2;   
  t4 = t1 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto multbignumsteplose;
  arg3 = arg2 * arg1;   		// arg1*arg2 
  arg6 = (u32)(arg3 >> ((4&7)*8));   		// arg6=high order word 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
		/* Store fixnum result ls word */
  *(u32 *)iSP = arg3;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
		/* Store ms word */
  *(u32 *)(iSP + 8) = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto cachevalid;   

multbignumsteplose:
  if (_trace) printf("multbignumsteplose:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end DoMultiplyBignumStep */
  /* End of Halfword operand from stack instruction - DoMultiplyBignumStep */
/* start DoDivideBignumStep */

  /* Halfword operand from stack instruction - DoDivideBignumStep */
  /* arg2 has the preloaded 8 bit operand. */

dodividebignumstep:
  if (_trace) printf("dodividebignumstep:\n");

DoDivideBignumStepIM:
  if (_trace) printf("DoDivideBignumStepIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindodividebignumstep;   

DoDivideBignumStepSP:
  if (_trace) printf("DoDivideBignumStepSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoDivideBignumStepLP:
  if (_trace) printf("DoDivideBignumStepLP:\n");

DoDivideBignumStepFP:
  if (_trace) printf("DoDivideBignumStepFP:\n");

headdodividebignumstep:
  if (_trace) printf("headdodividebignumstep:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindodividebignumstep:
  if (_trace) printf("begindodividebignumstep:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg2 = *(s32 *)iSP;   		// Get arg2 
  t1 = *(s32 *)(iSP + 4);   
  t2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t4 = t2 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto divbignumsteplose1;
  if (arg1 == 0) 		// J. if division by zero 
    goto divbignumsteplose2;
  arg2 = (u32)arg2;   
  arg3 = *(s32 *)(iSP + -8);   		// Get arg1 
  t3 = *(s32 *)(iSP + -4);   
  t4 = t1 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto divbignumsteplose1;
  arg2 = arg2 << 32;   		// arg2=(ash arg2 32) 
  arg3 = (u32)arg3;   
  t4 = t3 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto divbignumsteplose1;
  arg4 = arg3 | arg2;		// arg1+(ash arg2 32) 
  t1 = arg4 / arg1;   		// t1 is now the quotient 
  t2 = t1 * arg1;   
  t2 = arg4 - t2;   		// t2 is now the remainder 
		/* store quotient (already fixnum) */
  *(u32 *)(iSP + -8) = t1;
		/* store remainder (already fixnum) */
  *(u32 *)iSP = t2;
  goto NEXTINSTRUCTION;   

divbignumsteplose1:
  if (_trace) printf("divbignumsteplose1:\n");
  arg5 = 0;
  arg2 = 76;
  goto illegaloperand;

divbignumsteplose2:
  if (_trace) printf("divbignumsteplose2:\n");
  arg5 = 0;
  arg2 = 2;
  goto illegaloperand;

/* end DoDivideBignumStep */
  /* End of Halfword operand from stack instruction - DoDivideBignumStep */
/* start DoLshcBignumStep */

  /* Halfword operand from stack instruction - DoLshcBignumStep */

dolshcbignumstep:
  if (_trace) printf("dolshcbignumstep:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoLshcBignumStepIM:
  if (_trace) printf("DoLshcBignumStepIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment16669:
  if (_trace) printf("force-alignment16669:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindolshcbignumstep;   

DoLshcBignumStepSP:
  if (_trace) printf("DoLshcBignumStepSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoLshcBignumStepLP:
  if (_trace) printf("DoLshcBignumStepLP:\n");

DoLshcBignumStepFP:
  if (_trace) printf("DoLshcBignumStepFP:\n");

headdolshcbignumstep:
  if (_trace) printf("headdolshcbignumstep:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindolshcbignumstep:
  if (_trace) printf("begindolshcbignumstep:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg2 = *(s32 *)iSP;   		// Get arg2 
  t2 = *(s32 *)(iSP + 4);   
  iSP = iSP - 8;   		// Pop Stack 
  t3 = arg1 >> 32;   
  arg1 = (u32)arg1;   		// Strip type from arg3 
  t4 = t3 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto lshcbignumsteplose;
  arg2 = (u32)arg2;   
  arg3 = *(s32 *)iSP;   		// Get arg1 
  t1 = *(s32 *)(iSP + 4);   
  t4 = t2 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto lshcbignumsteplose;
  arg2 = arg2 << 32;   		// arg2=(ash arg2 32) 
  arg3 = (u32)arg3;   
  t4 = t1 - Type_Fixnum;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto lshcbignumsteplose;
  arg4 = arg3 | arg2;		// arg1+(ash arg2 32) 
  arg5 = arg4 << (arg1 & 63);   
  arg6 = (s64)arg5 >> 32;   		// Extract the result 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
		/* Store the result as a fixnum */
  *(u32 *)iSP = arg6;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;   

lshcbignumsteplose:
  if (_trace) printf("lshcbignumsteplose:\n");
  arg5 = 0;
  arg2 = 76;
  goto illegaloperand;

/* end DoLshcBignumStep */
  /* End of Halfword operand from stack instruction - DoLshcBignumStep */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunbnum.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifuntrap.as
 ************************************************************************/

/* start DECODEFAULT */


decodefault:
  if (_trace) printf("decodefault:\n");
  /* We come here when a memory access faults to figure out why */
  t1 = *(u64 *)&(processor->vma);   		// retrieve the trapping VMA 
  t3 = *(u64 *)&(processor->vmattributetable);   		// Per-page attributes table 
  t2 = t1 >> (MemoryPage_AddressShift & 63);   		// Index into the attributes table 
  t3 = t2 + t3;		// Address of the page's attributes 
  t2 = LDQ_U(t3);   		// Get the quadword with the page's attributes 
  *(u64 *)&processor->vma = t1;   		// Stash the VMA 
  t2 = (u8)(t2 >> ((t3&7)*8));   		// Extract the page's attributes 
  if (t2 == 0) 		// Non-existent page 
    goto pagenotresident;
  t3 = t2 & VMAttribute_AccessFault;
  if (t3 != 0)   		// Access fault 
    goto pagefaultrequesthandler;
  t3 = t2 & VMAttribute_TransportFault;
  if (t3 != 0)   		// Transport fault 
    goto transporttrap;
  t3 = t2 & VMAttribute_WriteFault;
  if (t3 != 0)   		// Write fault 
    goto pagewritefault;
  goto buserror;

/* end DECODEFAULT */
/* start HANDLEUNWINDPROTECT */


handleunwindprotect:
  if (_trace) printf("handleunwindprotect:\n");
  t4 = *(s32 *)&processor->catchblock;   
  t4 = (u32)t4;   
  /* Convert VMA to stack cache address */
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = t4 - t2;   		// stack cache base relative offset 
  t3 = (t2 * 8) + t3;  		// reconstruct SCA 
  t6 = *(s32 *)(t3 + 16);   
  t5 = *(s32 *)(t3 + 20);   
  t6 = (u32)t6;   
  t2 = *(s32 *)(t3 + 8);   
  t1 = *(s32 *)(t3 + 12);   
  t2 = (u32)t2;   
  iSP = *(u64 *)&(processor->restartsp);   		// Restore SP 
  t1 = *(u64 *)&(processor->bindingstackpointer);   
  t3 = (s32)t1 - (s32)t2;   
  if (t3 == 0) 		// J. if binding level= binding stack 
    goto do-unwind-protect16670;

do-unwind-protect16671:
  if (_trace) printf("do-unwind-protect16671:\n");
  t1 = *(u64 *)&(processor->bindingstackpointer);   
  t4 = *(s32 *)&processor->control;   
  t1 = (u32)t1;   		// vma only 
  arg1 = (512) << 16;   
  t5 = t1 - 1;   
  t3 = t4 & arg1;
  t4 = t4 & ~arg1;		// Turn off the bit 
  if (t3 != 0)   
    goto g16672;
  t4 = *(u64 *)&(processor->restartsp);   		// Get the SP, ->op2 
  arg5 = 0;
  arg2 = 20;
  goto illegaloperand;

g16672:
  if (_trace) printf("g16672:\n");
  /* Memory Read Internal */

vma-memory-read16673:
  t8 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t1 + ivory;
  t9 = *(s32 *)&processor->scovlimit;   
  t6 = (t10 * 4);   
  t7 = LDQ_U(t10);   
  t8 = t1 - t8;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->bindread_mask);   
  t9 = ((u64)t8 < (u64)t9) ? 1 : 0;   		// In range? 
  t6 = *(s32 *)t6;   
  t7 = (u8)(t7 >> ((t10&7)*8));   
  if (t9 != 0)   
    goto vma-memory-read16675;

vma-memory-read16674:
  t10 = zero + 224;   
  t11 = t11 >> (t7 & 63);   
  t10 = t10 >> (t7 & 63);   
  if (t11 & 1)   
    goto vma-memory-read16677;

vma-memory-read16682:
  /* Memory Read Internal */

vma-memory-read16683:
  t8 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t5 + ivory;
  t9 = *(s32 *)&processor->scovlimit;   
  arg1 = (t10 * 4);   
  t3 = LDQ_U(t10);   
  t8 = t5 - t8;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->bindread_mask);   
  t9 = ((u64)t8 < (u64)t9) ? 1 : 0;   		// In range? 
  arg1 = *(s32 *)arg1;   
  t3 = (u8)(t3 >> ((t10&7)*8));   
  if (t9 != 0)   
    goto vma-memory-read16685;

vma-memory-read16684:
  t10 = zero + 224;   
  t11 = t11 >> (t3 & 63);   
  t10 = t10 >> (t3 & 63);   
  arg1 = (u32)arg1;   
  if (t11 & 1)   
    goto vma-memory-read16687;

vma-memory-read16692:
  /* Memory Read Internal */

vma-memory-read16693:
  t10 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t12 = arg1 + ivory;
  t11 = *(s32 *)&processor->scovlimit;   
  t9 = (t12 * 4);   
  t8 = LDQ_U(t12);   
  t10 = arg1 - t10;   		// Stack cache offset 
  t11 = ((u64)t10 < (u64)t11) ? 1 : 0;   		// In range? 
  t9 = *(s32 *)t9;   
  t8 = (u8)(t8 >> ((t12&7)*8));   
  if (t11 != 0)   
    goto vma-memory-read16695;

vma-memory-read16694:
  t10 = *(u64 *)&(processor->bindwrite_mask);   
  t12 = zero + 224;   
  t10 = t10 >> (t8 & 63);   
  t12 = t12 >> (t8 & 63);   
  if (t10 & 1)   
    goto vma-memory-read16697;

vma-memory-read16702:
  /* Merge cdr-code */
  t9 = t7 & 63;
  t8 = t8 & 192;
  t8 = t8 | t9;
  t10 = arg1 + ivory;
  t9 = (t10 * 4);   
  t12 = LDQ_U(t10);   
  t11 = (t8 & 0xff) << ((t10&7)*8);   
  t12 = t12 & ~(0xffL << (t10&7)*8);   

force-alignment16705:
  if (_trace) printf("force-alignment16705:\n");
  t12 = t12 | t11;
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  STQ_U(t10, t12);   
  t10 = *(s32 *)&processor->scovlimit;   
  t11 = arg1 - t11;   		// Stack cache offset 
  t10 = ((u64)t11 < (u64)t10) ? 1 : 0;   		// In range? 
  *(u32 *)t9 = t6;
  if (t10 != 0)   		// J. if in cache 
    goto vma-memory-write16704;

vma-memory-write16703:
  t3 = t3 & 64;		// Get the old cleanup-bindings bit 
  t3 = t3 << 19;   
  t1 = t1 - 2;   
		/* vma only */
  *(u32 *)&processor->bindingstackpointer = t1;
  t4 = t4 | t3;
  *(u32 *)&processor->control = t4;
  t1 = *(u64 *)&(processor->bindingstackpointer);   
  t3 = (s32)t1 - (s32)t2;   
  if (t3 != 0)   		// J. if binding level/= binding stack 
    goto do-unwind-protect16671;
  t2 = *(s32 *)&processor->interruptreg;   
  t3 = t2 & 2;
  t3 = (t3 == 2) ? 1 : 0;   
  t2 = t2 | t3;
  *(u32 *)&processor->interruptreg = t2;
  if (t2 == 0) 
    goto do-unwind-protect16670;
  *(u64 *)&processor->stop_interpreter = t2;   

do-unwind-protect16670:
  if (_trace) printf("do-unwind-protect16670:\n");
  /* Convert PC to a real continuation. */
  t3 = iPC & 1;
  t1 = iPC >> 1;   		// convert PC to a real word address. 
  t3 = t3 + Type_EvenPC;   
  arg1 = *(s32 *)&processor->control;   
  t2 = arg1 >> 17;   
  t2 = t2 | 128;
  t2 = t2 & 192;
  /* TagType. */
  t3 = t3 & 63;
  t3 = t3 | t2;
  *(u32 *)(iSP + 8) = t1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  /* Load catch-block PC */
  t4 = *(s32 *)&processor->catchblock;   
  t4 = (u32)t4;   
  /* Convert VMA to stack cache address */
  t2 = *(u64 *)&(processor->stackcachebasevma);   
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = t4 - t2;   		// stack cache base relative offset 
  t3 = (t2 * 8) + t3;  		// reconstruct SCA 
  t6 = *(s32 *)t3;   
  t5 = *(s32 *)(t3 + 4);   
  t6 = (u32)t6;   
  /* Convert real continuation to PC. */
  iPC = t5 & 1;
  iPC = t6 + iPC;
  iPC = t6 + iPC;
  t1 = (128) << 16;   
  arg1 = arg1 | t1;
  t10 = *(s32 *)(t3 + 16);   
  t5 = *(s32 *)(t3 + 20);   
  t10 = (u32)t10;   
  t6 = t5 & 128;		// This is the  extra-arg bit 
  t8 = *(s32 *)&processor->extraandcatch;   
  t7 = t5 & 64;		// This is the  cleanup-catch bit 
  t6 = t6 << 1;   		// Shift bit into place for cr 
  t7 = t7 << 20;   		// Shift extra arg bit into place for cr 
  arg1 = arg1 & ~t8;
  t6 = t6 | t7;
  arg1 = arg1 | t6;		// update the bits extra-arg/cleanupcatch 
  *(u32 *)&processor->control = arg1;
  /* TagType. */
  t5 = t5 & 63;
  t5 = t5 << 32;   
  t5 = t5 | t10;
  *(u64 *)&processor->catchblock = t5;   
  goto interpretinstructionforbranch;   		// Execute cleanup 

vma-memory-write16704:
  if (_trace) printf("vma-memory-write16704:\n");
  t10 = *(u64 *)&(processor->stackcachedata);   
  t10 = (t11 * 8) + t10;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t10 = t6;
		/* write the stack cache */
  *(u32 *)(t10 + 4) = t8;
  goto vma-memory-write16703;   

vma-memory-read16695:
  if (_trace) printf("vma-memory-read16695:\n");
  t11 = *(u64 *)&(processor->stackcachedata);   
  t10 = (t10 * 8) + t11;  		// reconstruct SCA 
  t9 = *(s32 *)t10;   
  t8 = *(s32 *)(t10 + 4);   		// Read from stack cache 
  goto vma-memory-read16694;   

vma-memory-read16697:
  if (_trace) printf("vma-memory-read16697:\n");
  if ((t12 & 1) == 0)   
    goto vma-memory-read16696;
  arg1 = (u32)t9;   		// Do the indirect thing 
  goto vma-memory-read16693;   

vma-memory-read16696:
  if (_trace) printf("vma-memory-read16696:\n");
  t10 = *(u64 *)&(processor->bindwrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t12 = t8 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t12 = (t12 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t12;   		// Get the memory action 

vma-memory-read16699:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 3;
  goto performmemoryaction;

vma-memory-read16685:
  if (_trace) printf("vma-memory-read16685:\n");
  t9 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + t9;  		// reconstruct SCA 
  arg1 = *(s32 *)t8;   
  t3 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read16684;   

vma-memory-read16687:
  if (_trace) printf("vma-memory-read16687:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read16686;
  t5 = (u32)arg1;   		// Do the indirect thing 
  goto vma-memory-read16683;   

vma-memory-read16686:
  if (_trace) printf("vma-memory-read16686:\n");
  t11 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t3 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t5;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read16689:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 2;
  goto performmemoryaction;

vma-memory-read16675:
  if (_trace) printf("vma-memory-read16675:\n");
  t9 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + t9;  		// reconstruct SCA 
  t6 = *(s32 *)t8;   
  t7 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read16674;   

vma-memory-read16677:
  if (_trace) printf("vma-memory-read16677:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read16676;
  t1 = (u32)t6;   		// Do the indirect thing 
  goto vma-memory-read16673;   

vma-memory-read16676:
  if (_trace) printf("vma-memory-read16676:\n");
  t11 = *(u64 *)&(processor->bindread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t7 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read16679:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 2;
  goto performmemoryaction;

/* end HANDLEUNWINDPROTECT */
/* start PERFORMMEMORYACTION */


performmemoryaction:
  if (_trace) printf("performmemoryaction:\n");
  /* We get here when a memory action that will trap is detected. */
  /* ARG1 contains the memory action code with the Transport bit removed. */
  /* ARG2 contains the memory cycle so we can generate the proper microstate. */
  t1 = (arg1 == MemoryActionTrap) ? 1 : 0;   

force-alignment16734:
  if (_trace) printf("force-alignment16734:\n");
  if (t1 == 0) 
    goto basic-dispatch16707;
  /* Here if argument MemoryActionTrap */
  t1 = *(u64 *)&(processor->vma);   		// Get the failing VMA 
  t2 = (arg2 == Cycle_DataRead) ? 1 : 0;   

force-alignment16721:
  if (_trace) printf("force-alignment16721:\n");
  if (t2 == 0) 
    goto basic-dispatch16709;
  /* Here if argument CycleDataRead */
  arg5 = t1;
  arg2 = 57;
  goto illegaloperand;

basic-dispatch16709:
  if (_trace) printf("basic-dispatch16709:\n");
  t2 = (arg2 == Cycle_DataWrite) ? 1 : 0;   

force-alignment16722:
  if (_trace) printf("force-alignment16722:\n");
  if (t2 == 0) 
    goto basic-dispatch16710;
  /* Here if argument CycleDataWrite */
  arg5 = t1;
  arg2 = 58;
  goto illegaloperand;

basic-dispatch16710:
  if (_trace) printf("basic-dispatch16710:\n");
  t2 = (arg2 == Cycle_BindRead) ? 1 : 0;   

force-alignment16723:
  if (_trace) printf("force-alignment16723:\n");
  if (t2 != 0)   
    goto basic-dispatch16712;
  t2 = (arg2 == Cycle_BindReadNoMonitor) ? 1 : 0;   

force-alignment16724:
  if (_trace) printf("force-alignment16724:\n");
  if (t2 == 0) 
    goto basic-dispatch16711;

basic-dispatch16712:
  if (_trace) printf("basic-dispatch16712:\n");
  /* Here if argument (CycleBindRead CycleBindReadNoMonitor) */
  arg5 = t1;
  arg2 = 54;
  goto illegaloperand;

basic-dispatch16711:
  if (_trace) printf("basic-dispatch16711:\n");
  t2 = (arg2 == Cycle_BindWrite) ? 1 : 0;   

force-alignment16725:
  if (_trace) printf("force-alignment16725:\n");
  if (t2 != 0)   
    goto basic-dispatch16714;
  t2 = (arg2 == Cycle_BindWriteNoMonitor) ? 1 : 0;   

force-alignment16726:
  if (_trace) printf("force-alignment16726:\n");
  if (t2 == 0) 
    goto basic-dispatch16713;

basic-dispatch16714:
  if (_trace) printf("basic-dispatch16714:\n");
  /* Here if argument (CycleBindWrite CycleBindWriteNoMonitor) */
  arg5 = t1;
  arg2 = 55;
  goto illegaloperand;

basic-dispatch16713:
  if (_trace) printf("basic-dispatch16713:\n");
  t2 = (arg2 == Cycle_Header) ? 1 : 0;   

force-alignment16727:
  if (_trace) printf("force-alignment16727:\n");
  if (t2 != 0)   
    goto basic-dispatch16716;
  t2 = (arg2 == Cycle_StructureOffset) ? 1 : 0;   

force-alignment16728:
  if (_trace) printf("force-alignment16728:\n");
  if (t2 == 0) 
    goto basic-dispatch16715;

basic-dispatch16716:
  if (_trace) printf("basic-dispatch16716:\n");
  /* Here if argument (CycleHeader CycleStructureOffset) */
  arg5 = t1;
  arg2 = 59;
  goto illegaloperand;

basic-dispatch16715:
  if (_trace) printf("basic-dispatch16715:\n");
  t2 = (arg2 == Cycle_Scavenge) ? 1 : 0;   

force-alignment16729:
  if (_trace) printf("force-alignment16729:\n");
  if (t2 != 0)   
    goto basic-dispatch16718;
  t2 = (arg2 == Cycle_GCCopy) ? 1 : 0;   

force-alignment16730:
  if (_trace) printf("force-alignment16730:\n");
  if (t2 == 0) 
    goto basic-dispatch16717;

basic-dispatch16718:
  if (_trace) printf("basic-dispatch16718:\n");
  /* Here if argument (CycleScavenge CycleGCCopy) */
  arg5 = t1;
  arg2 = 60;
  goto illegaloperand;

basic-dispatch16717:
  if (_trace) printf("basic-dispatch16717:\n");
  t2 = (arg2 == Cycle_Cdr) ? 1 : 0;   

force-alignment16731:
  if (_trace) printf("force-alignment16731:\n");
  if (t2 == 0) 
    goto basic-dispatch16708;
  /* Here if argument CycleCdr */
  arg5 = t1;
  arg2 = 56;
  goto illegaloperand;

basic-dispatch16708:
  if (_trace) printf("basic-dispatch16708:\n");

basic-dispatch16707:
  if (_trace) printf("basic-dispatch16707:\n");
  t1 = (arg1 == MemoryActionMonitor) ? 1 : 0;   

force-alignment16735:
  if (_trace) printf("force-alignment16735:\n");
  if (t1 == 0) 
    goto basic-dispatch16706;
  /* Here if argument MemoryActionMonitor */
  goto monitortrap;

basic-dispatch16706:
  if (_trace) printf("basic-dispatch16706:\n");

/* end PERFORMMEMORYACTION */
/* start OutOfLineExceptions */


outoflineexceptions:
  if (_trace) printf("outoflineexceptions:\n");

ldbexception:
  if (_trace) printf("ldbexception:\n");
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 1;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto numericexception;

rplacaexception:
  if (_trace) printf("rplacaexception:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto listexception;

rplacdexception:
  if (_trace) printf("rplacdexception:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto listexception;

pushivexception:
  if (_trace) printf("pushivexception:\n");
  t1 = zero + 8;   
  /* SetTag. */
  t1 = t1 << 32;   
  t1 = arg2 | t1;
  arg6 = t2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

incrementexception:
  if (_trace) printf("incrementexception:\n");
  arg6 = arg2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto unarynumericexception;

decrementexception:
  if (_trace) printf("decrementexception:\n");
  arg6 = arg2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto unarynumericexception;

/* end OutOfLineExceptions */
/* start NUMERICEXCEPTION */


numericexception:
  if (_trace) printf("numericexception:\n");
  t1 = arg6 - Type_Fixnum;   
  t1 = t1 & 56;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto notnumeric;
  goto exception;

notnumeric:
  if (_trace) printf("notnumeric:\n");
  arg5 = 0;
  arg2 = 16;
  goto illegaloperand;

/* end NUMERICEXCEPTION */
/* start UNARYNUMERICEXCEPTION */


unarynumericexception:
  if (_trace) printf("unarynumericexception:\n");
  t1 = arg6 - Type_Fixnum;   
  t1 = t1 & 56;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto unarynotnumeric;
  goto exception;

unarynotnumeric:
  if (_trace) printf("unarynotnumeric:\n");
  arg5 = 0;
  arg2 = 81;
  goto illegaloperand;

/* end UNARYNUMERICEXCEPTION */
/* start LISTEXCEPTION */


listexception:
  if (_trace) printf("listexception:\n");
  t1 = arg6 - Type_List;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto notlist1;
  goto exception;

notlist1:
  if (_trace) printf("notlist1:\n");
  t1 = arg6 - Type_ListInstance;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto notlist2;
  goto exception;

notlist2:
  if (_trace) printf("notlist2:\n");
  arg5 = 0;
  arg2 = 26;
  goto illegaloperand;

/* end LISTEXCEPTION */
/* start ARRAYEXCEPTION */


arrayexception:
  if (_trace) printf("arrayexception:\n");
  t1 = arg6 - Type_Array;   
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto notarray1;
  goto exception;

notarray1:
  if (_trace) printf("notarray1:\n");
  t1 = arg6 - Type_ArrayInstance;   
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto notarray2;
  goto exception;

notarray2:
  if (_trace) printf("notarray2:\n");
  goto spareexception;

/* end ARRAYEXCEPTION */
/* start SPAREEXCEPTION */


spareexception:
  if (_trace) printf("spareexception:\n");
  t1 = arg6 - Type_SparePointer1;   
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto notspare1;
  goto exception;

notspare1:
  if (_trace) printf("notspare1:\n");

notspare2:
  if (_trace) printf("notspare2:\n");
  t1 = arg6 - Type_SpareNumber;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto notspare3;
  goto exception;

notspare3:
  if (_trace) printf("notspare3:\n");
  goto illegaloperand;

/* end SPAREEXCEPTION */
/* start EXCEPTION */


exception:
  if (_trace) printf("exception:\n");
  if (arg4 != 0)   		// J. if arithmetic exception 
    goto arithmeticexception;
  t2 = *(u64 *)&(processor->linkage);   
  iSP = *(u64 *)&(processor->restartsp);   		// fix the stack pointer 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->instruction);   		// fetch the real opcode 
  if (t2 != 0)   
    goto nativeexception;
  if (arg3 != 0)   		// J. if arguments stacked 
    goto exception-handler16737;
  t1 = (u16)(arg2 >> ((4&7)*8));   		// Get original operand 
  t3 = (t1 == 512) ? 1 : 0;   		// t3 is non-zero iff SP|POP operand 
  if (t3 != 0)   		// SP|POP operand recovered by restoring SP 
    goto exception-handler16737;
  arg5 = iFP;   		// Assume FP mode 
  t3 = iSP + -2040;   		// SP mode constant 
  t4 = (u8)(arg2 >> ((5&7)*8));   		// Get the mode bits 
  t2 = (u8)(arg2 >> ((4&7)*8));   		// Extract (8-bit, unsigned) operand 
  t4 = t4 - 2;   		// t4 = -2 FP, -1 LP, 0 SP, 1 Imm 
  if (t4 & 1)   		// LP or Immediate mode 
   arg5 = iLP;
  if (t4 == 0)   		// SP mode 
    arg5 = t3;
  arg5 = (t2 * 8) + arg5;  		// Compute operand address 
  if ((s64)t4 <= 0)  		// Not immediate mode 
    goto exception-handler16738;
  t1 = t2 << 56;   
  t3 = arg2 >> 16;   
  t1 = (s64)t1 >> 56;   
  arg5 = (u64)&processor->immediate_arg;   		// Immediate mode constant 
  if ((t3 & 1) == 0)   		// Signed immediate 
   t2 = t1;
  *(u32 *)&processor->immediate_arg = t2;

exception-handler16738:
  if (_trace) printf("exception-handler16738:\n");
  t1 = zero + -32768;   
  t1 = t1 + ((2) << 16);   
  t2 = arg2 & t1;
  t3 = (t1 == t2) ? 1 : 0;   
  if (t3 == 0) 		// J. if not address-format operand 
    goto exception-handler16739;
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = arg5 - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t1 = t2 + t1;		// reconstruct VMA 
  t2 = Type_Locative;
  /* SetTag. */
  arg5 = t2 << 32;   
  arg5 = t1 | arg5;
  goto exception-handler16740;   

exception-handler16739:
  if (_trace) printf("exception-handler16739:\n");
  arg5 = *(u64 *)arg5;   		// Fetch the arg 

exception-handler16740:
  if (_trace) printf("exception-handler16740:\n");
  *(u64 *)(iSP + 8) = arg5;   
  iSP = iSP + 8;

exception-handler16737:
  if (_trace) printf("exception-handler16737:\n");
  arg2 = arg2 >> 10;   		// Shift opcode into position 
  arg2 = arg2 & 255;		// Just 8-bits of opcode 
  t11 = arg2 + TrapVector_InstructionException;   
#ifdef TRAPMETERING
  t1 = *(u64 *)&(processor->trapmeterdata);   		// pointer to trap data vector 
  t2 = zero + TrapVector_InstructionException;   		// get the vector index 
  t1 = (t2 * 8) + t1;  
  t2 = *(u64 *)t1;   		// get the old value 
  t2 = t2 + 1;   		// increment it 
  *(u64 *)t1 = t2;   		// and store it back 
#endif
  t12 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  goto handleexception;   

/* end EXCEPTION */
/* start ARITHMETICEXCEPTION */


arithmeticexception:
  if (_trace) printf("arithmeticexception:\n");
  t2 = *(u64 *)&(processor->linkage);   
  iSP = *(u64 *)&(processor->restartsp);   		// fix the stack pointer 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->instruction);   		// fetch the real opcode 
  if (t2 != 0)   
    goto nativeexception;
  t1 = (u16)(arg2 >> ((4&7)*8));   		// Get original operand 
  t3 = (t1 == 512) ? 1 : 0;   		// t3 is non-zero iff SP|POP operand 
  if (t3 != 0)   		// SP|POP operand recovered by restoring SP 
    goto exception-handler16742;
  arg5 = iFP;   		// Assume FP mode 
  t3 = iSP + -2040;   		// SP mode constant 
  t4 = (u8)(arg2 >> ((5&7)*8));   		// Get the mode bits 
  t2 = (u8)(arg2 >> ((4&7)*8));   		// Extract (8-bit, unsigned) operand 
  t4 = t4 - 2;   		// t4 = -2 FP, -1 LP, 0 SP, 1 Imm 
  if (t4 & 1)   		// LP or Immediate mode 
   arg5 = iLP;
  if (t4 == 0)   		// SP mode 
    arg5 = t3;
  arg5 = (t2 * 8) + arg5;  		// Compute operand address 
  if ((s64)t4 <= 0)  		// Not immediate mode 
    goto exception-handler16743;
  t1 = t2 << 56;   
  t3 = arg2 >> 16;   
  t1 = (s64)t1 >> 56;   
  arg5 = (u64)&processor->immediate_arg;   		// Immediate mode constant 
  if ((t3 & 1) == 0)   		// Signed immediate 
   t2 = t1;
  *(u32 *)&processor->immediate_arg = t2;

exception-handler16743:
  if (_trace) printf("exception-handler16743:\n");
  t1 = zero + -32768;   
  t1 = t1 + ((2) << 16);   
  t2 = arg2 & t1;
  t3 = (t1 == t2) ? 1 : 0;   
  if (t3 == 0) 		// J. if not address-format operand 
    goto exception-handler16744;
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = arg5 - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t1 = t2 + t1;		// reconstruct VMA 
  t2 = Type_Locative;
  /* SetTag. */
  arg5 = t2 << 32;   
  arg5 = t1 | arg5;
  goto exception-handler16745;   

exception-handler16744:
  if (_trace) printf("exception-handler16744:\n");
  arg5 = *(u64 *)arg5;   		// Fetch the arg 

exception-handler16745:
  if (_trace) printf("exception-handler16745:\n");
  *(u64 *)(iSP + 8) = arg5;   
  iSP = iSP + 8;

exception-handler16742:
  if (_trace) printf("exception-handler16742:\n");
  t4 = arg2 >> 17;   		// Get unary/nary bit of opcode 
  arg1 = 1;		// Assume unary 
  t11 = zero;
  t2 = iSP;
  if ((t4 & 1) == 0)   		// J. if not binary arithmetic dispatch 
    goto exception-handler16741;
  arg1 = 2;		// Nary -> Binary 
  t11 = *(s32 *)(iSP + 4);   
  t2 = t2 - 8;   
  t11 = t11 & 7;		// low three bits has opcode tag for op2 

exception-handler16741:
  if (_trace) printf("exception-handler16741:\n");
  arg2 = arg2 >> 4;   		// Shift opcode into position 
  t2 = *(s32 *)(t2 + 4);   
  arg2 = arg2 & 1984;		// five bits from the opcode 
  t2 = t2 & 7;
  t11 = (t2 * 8) + t11;  
  t11 = arg2 | t11;
  t11 = t11 + TrapVector_ArithmeticInstructionException;   
#ifdef TRAPMETERING
  t1 = *(u64 *)&(processor->trapmeterdata);   		// pointer to trap data vector 
  t2 = zero + TrapVector_ArithmeticInstructionException;   		// get the vector index 
  t1 = (t2 * 8) + t1;  
  t2 = *(u64 *)t1;   		// get the old value 
  t2 = t2 + 1;   		// increment it 
  *(u64 *)t1 = t2;   		// and store it back 
#endif
  t12 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  goto handleexception;   

/* end ARITHMETICEXCEPTION */
/* start LOOPEXCEPTION */


loopexception:
  if (_trace) printf("loopexception:\n");
  t2 = *(u64 *)&(processor->linkage);   
  iSP = *(u64 *)&(processor->restartsp);   		// fix the stack pointer 
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->instruction);   		// fetch the real opcode 
  if (t2 != 0)   
    goto nativeexception;
  if (arg3 != 0)   		// J. if arguments stacked 
    goto exception-handler16747;
  t1 = (u16)(arg2 >> ((4&7)*8));   		// Get original operand 
  t3 = (t1 == 512) ? 1 : 0;   		// t3 is non-zero iff SP|POP operand 
  if (t3 != 0)   		// SP|POP operand recovered by restoring SP 
    goto exception-handler16747;
  arg5 = iFP;   		// Assume FP mode 
  t3 = iSP + -2040;   		// SP mode constant 
  t4 = (u8)(arg2 >> ((5&7)*8));   		// Get the mode bits 
  t2 = (u8)(arg2 >> ((4&7)*8));   		// Extract (8-bit, unsigned) operand 
  t4 = t4 - 2;   		// t4 = -2 FP, -1 LP, 0 SP, 1 Imm 
  if (t4 & 1)   		// LP or Immediate mode 
   arg5 = iLP;
  if (t4 == 0)   		// SP mode 
    arg5 = t3;
  arg5 = (t2 * 8) + arg5;  		// Compute operand address 
  if ((s64)t4 <= 0)  		// Not immediate mode 
    goto exception-handler16748;
  t1 = t2 << 56;   
  t3 = arg2 >> 16;   
  t1 = (s64)t1 >> 56;   
  arg5 = (u64)&processor->immediate_arg;   		// Immediate mode constant 
  if ((t3 & 1) == 0)   		// Signed immediate 
   t2 = t1;
  *(u32 *)&processor->immediate_arg = t2;

exception-handler16748:
  if (_trace) printf("exception-handler16748:\n");
  t1 = zero + -32768;   
  t1 = t1 + ((2) << 16);   
  t2 = arg2 & t1;
  t3 = (t1 == t2) ? 1 : 0;   
  if (t3 == 0) 		// J. if not address-format operand 
    goto exception-handler16749;
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = arg5 - t2;   		// stack cache base relative offset 
  t2 = t2 >> 3;   		// convert byte address to word address 
  t1 = t2 + t1;		// reconstruct VMA 
  t2 = Type_Locative;
  /* SetTag. */
  arg5 = t2 << 32;   
  arg5 = t1 | arg5;
  goto exception-handler16750;   

exception-handler16749:
  if (_trace) printf("exception-handler16749:\n");
  arg5 = *(u64 *)arg5;   		// Fetch the arg 

exception-handler16750:
  if (_trace) printf("exception-handler16750:\n");
  *(u64 *)(iSP + 8) = arg5;   
  iSP = iSP + 8;

exception-handler16747:
  if (_trace) printf("exception-handler16747:\n");
  arg2 = arg2 >> 10;   		// Shift opcode into position 
  arg2 = arg2 & 255;		// Just 8-bits of opcode 
  t11 = arg2 + TrapVector_InstructionException;   
#ifdef TRAPMETERING
  t1 = *(u64 *)&(processor->trapmeterdata);   		// pointer to trap data vector 
  t2 = zero + TrapVector_InstructionException;   		// get the vector index 
  t1 = (t2 * 8) + t1;  
  t2 = *(u64 *)t1;   		// get the old value 
  t2 = t2 + 1;   		// increment it 
  *(u64 *)t1 = t2;   		// and store it back 
#endif
  t12 = arg5;
  goto handleexception;   

/* end LOOPEXCEPTION */
/* start HandleException */


handleexception:
  if (_trace) printf("handleexception:\n");
  t1 = iFP;		// save old frame pointer 
  t4 = *(s32 *)&processor->control;   
  t9 = *(u64 *)&(processor->fepmodetrapvecaddress);   
  t8 = *(u64 *)&(processor->trapvecbase);   
  t5 = (-16384) << 16;   
  t6 = t4 >> 30;   
  t5 = t4 | t5;		// Set trap mode to 3 
  t6 = t6 & 3;
  *(u32 *)&processor->control = t5;
  t7 = t6 - 3;   
  t8 = t8 + t11;
  if (t7 == 0)   
    t8 = t9;
  *(u64 *)&processor->tvi = t8;   		// Record TVI for tracing (if enabled) 
  /* Memory Read Internal */

vma-memory-read16754:
  t9 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t6 = t8 + ivory;
  t7 = *(s32 *)&processor->scovlimit;   
  t3 = (t6 * 4);   
  t2 = LDQ_U(t6);   
  t9 = t8 - t9;   		// Stack cache offset 
  t5 = *(u64 *)&(processor->dataread_mask);   
  t7 = ((u64)t9 < (u64)t7) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t2 = (u8)(t2 >> ((t6&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read16756;

vma-memory-read16755:
  t6 = zero + 240;   
  t5 = t5 >> (t2 & 63);   
  t6 = t6 >> (t2 & 63);   
  t3 = (u32)t3;   
  if (t5 & 1)   
    goto vma-memory-read16758;

vma-memory-read16765:
  t5 = t2 - Type_EvenPC;   
  t5 = t5 & 62;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto get-trap-vector-entry16753;
		/* Restore the cr */
  *(u32 *)&processor->control = t4;
  t8 = *(s32 *)&processor->scovlimit;   		// Current stack cache limit (words) 
  t5 = zero + 128;   
  t6 = *(u64 *)&(processor->stackcachedata);   		// Alpha base of stack cache 
  t5 = t5 + 8;		// Account for what we're about to push 
  t5 = (t5 * 8) + iSP;  		// SCA of desired end of cache 
  t6 = (t8 * 8) + t6;  		// SCA of current end of cache 
  t8 = ((s64)t5 <= (s64)t6) ? 1 : 0;   
  if (t8 == 0) 		// We're done if new SCA is within bounds 
    goto stack-cache-overflow-check16766;
  iFP = (arg1 * 8) + zero;  
  iFP = iSP - iFP;   
  iFP = iFP + 8;
  if (arg1 == 0) 
    goto take-post-trap16751;
  t5 = *(u64 *)iSP;   
  *(u64 *)(iSP + 32) = t5;   
  arg1 = arg1 - 1;   
  if (arg1 == 0) 
    goto take-post-trap16751;
  t5 = *(u64 *)(iSP + -8);   
  *(u64 *)(iSP + 24) = t5;   
  arg1 = arg1 - 1;   
  if (arg1 == 0) 
    goto take-post-trap16751;
  t5 = *(u64 *)(iSP + -16);   
  *(u64 *)(iSP + 16) = t5;   
  arg1 = arg1 - 1;   
  if (arg1 == 0) 
    goto take-post-trap16751;
  t5 = *(u64 *)(iSP + -24);   
  *(u64 *)(iSP + 8) = t5;   
  arg1 = arg1 - 1;   

take-post-trap16751:
  if (_trace) printf("take-post-trap16751:\n");
  iSP = iSP + 32;
  t5 = *(s32 *)&processor->continuation;   
  t7 = *((s32 *)(&processor->continuation)+1);   
  t5 = (u32)t5;   
  t8 = (8192) << 16;   
  t4 = (u32)t4;   
  t7 = t7 | 192;
  *(u32 *)iFP = t5;
		/* write the stack cache */
  *(u32 *)(iFP + 4) = t7;
  t8 = t4 & t8;
  t8 = t8 >> 2;   
  t6 = Type_Fixnum+0xC0;
  t8 = t4 | t8;
  *(u32 *)(iFP + 8) = t8;
		/* write the stack cache */
  *(u32 *)(iFP + 12) = t6;
  iLP = iSP + 8;
  t6 = Type_Fixnum;
  t8 = t11;
  *(u32 *)(iFP + 16) = t8;
		/* write the stack cache */
  *(u32 *)(iFP + 20) = t6;
  /* Convert PC to a real continuation. */
  t6 = iPC & 1;
  t8 = iPC >> 1;   		// convert PC to a real word address. 
  t6 = t6 + Type_EvenPC;   
  *(u32 *)(iFP + 24) = t8;
		/* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  t7 = *(u64 *)&(processor->fccrtrapmask);   		// Get CR mask 
  t5 = (ValueDisposition_Value*4) << 16;   		// 1<<18! 
  t6 = iLP - iFP;   		// Arg size 
  t8 = iFP - t1;   		// Caller Frame Size 
  t6 = t6 >> 3;   		// Arg size in words 
  t8 = t8 << 6;   		// Caller Frame Size in words in place 
  t5 = t5 | t6;
  t5 = t5 | t8;
  /* TagCdr. */
  t9 = t2 >> 6;   
  t6 = t4 >> 30;   
  t8 = t9 - t6;   
  if ((s64)t8 >= 0)  
    t6 = t9;
  t6 = t6 << 30;   
  t4 = t4 & t7;		// Mask off unwanted bits 
  t4 = t4 | t6;		// Add trap mode 
  t4 = t4 | t5;		// Add argsize, apply, disposition, caller FS 
  *(u32 *)&processor->control = t4;
  /* Convert PC to a real continuation. */
  t6 = t12 & 1;
  t8 = t12 >> 1;   		// convert PC to a real word address. 
  t6 = t6 + Type_EvenPC;   
  *(u64 *)&processor->continuationcp = zero;   
  *((u32 *)(&processor->continuation)+1) = t6;
  *(u32 *)&processor->continuation = t8;
  /* Convert real continuation to PC. */
  iPC = t2 & 1;
  iPC = t3 + iPC;
  iPC = t3 + iPC;
  t6 = t4 >> 30;   		// Save current trap mode 
  t4 = t4 >> 30;   		// Isolate trap mode 
  t8 = *(s32 *)&processor->cslimit;   		// Limit for emulator mode 
  t9 = *(s32 *)&processor->csextralimit;   		// Limit for extra stack and higher modes 
  if (t4)   		// Get the right limit for the current trap mode 
    t8 = t9;
  t8 = (u32)t8;   		// Might have been sign extended 
  /* Convert stack cache address to VMA */
  t9 = *(u64 *)&(processor->stackcachedata);   
  t4 = *(u64 *)&(processor->stackcachebasevma);   
  t9 = iSP - t9;   		// stack cache base relative offset 
  t9 = t9 >> 3;   		// convert byte address to word address 
  t4 = t9 + t4;		// reconstruct VMA 
  t9 = ((s64)t4 < (s64)t8) ? 1 : 0;   		// Check for overflow 
  if (t9 == 0) 		// Jump if overflow 
    goto take-post-trap16752;
  /* Convert a halfword address into a CP pointer. */
  iCP = iPC >> (CacheLine_RShift & 63);   		// Get third byte into bottom 
  t9 = *(u64 *)&(processor->icachebase);   		// get the base of the icache 
  t8 = zero + -1;   
  t8 = t8 + ((4) << 16);   
  iCP = iCP << (CacheLine_LShift & 63);   		// Now third byte is zero-shifted 
  iCP = iPC + iCP;
  iCP = iCP & t8;
  t8 = iCP << 5;   		// temp=cpos*32 
  iCP = iCP << 4;   		// cpos=cpos*16 
  t9 = t9 + t8;		// temp2=base+cpos*32 
  iCP = t9 + iCP;		// cpos=base+cpos*48 
  goto cachevalid;   

take-post-trap16752:
  if (_trace) printf("take-post-trap16752:\n");
  if (t6 == 0) 		// Take the overflow if in emulator mode 
    goto stackoverflow;
  goto fatalstackoverflow;

stack-cache-overflow-check16766:
  if (_trace) printf("stack-cache-overflow-check16766:\n");
  arg2 = 8;
  goto stackcacheoverflowhandler;   

vma-memory-read16756:
  if (_trace) printf("vma-memory-read16756:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t9 = (t9 * 8) + t7;  		// reconstruct SCA 
  t3 = *(s32 *)t9;   
  t2 = *(s32 *)(t9 + 4);   		// Read from stack cache 
  goto vma-memory-read16755;   

vma-memory-read16758:
  if (_trace) printf("vma-memory-read16758:\n");
  if ((t6 & 1) == 0)   
    goto vma-memory-read16757;
  t8 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read16754;   

vma-memory-read16757:
  if (_trace) printf("vma-memory-read16757:\n");
  t5 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t6 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t8;   		// stash the VMA for the (likely) trap 
  t6 = (t6 * 4) + t5;   		// Adjust for a longword load 
  t5 = *(s32 *)t6;   		// Get the memory action 

vma-memory-read16762:
  if (_trace) printf("vma-memory-read16762:\n");
  t6 = t5 & MemoryActionTransform;
  if (t6 == 0) 
    goto vma-memory-read16761;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto vma-memory-read16765;   

vma-memory-read16761:

vma-memory-read16760:
  /* Perform memory action */
  arg1 = t5;
  arg2 = 0;
  goto performmemoryaction;

get-trap-vector-entry16753:
  if (_trace) printf("get-trap-vector-entry16753:\n");
  goto illegaltrapvector;

/* end HandleException */
/* start STACKOVERFLOW */


stackoverflow:
  if (_trace) printf("stackoverflow:\n");
  *(u64 *)&processor->restartsp = iSP;   
  t1 = iFP;		// save old frame pointer 
  t4 = *(s32 *)&processor->control;   
  t9 = *(u64 *)&(processor->fepmodetrapvecaddress);   
  t8 = *(u64 *)&(processor->trapvecbase);   
  t5 = (-16384) << 16;   
  t6 = t4 >> 30;   
  t5 = t4 | t5;		// Set trap mode to 3 
  t6 = t6 & 3;
  *(u32 *)&processor->control = t5;
  t7 = t6 - 3;   
  t8 = t8 + TrapVector_StackOverflow;
  if (t7 == 0)   
    t8 = t9;
  *(u64 *)&processor->tvi = t8;   		// Record TVI for tracing (if enabled) 
  /* Memory Read Internal */

vma-memory-read16770:
  t9 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t6 = t8 + ivory;
  t7 = *(s32 *)&processor->scovlimit;   
  t3 = (t6 * 4);   
  t2 = LDQ_U(t6);   
  t9 = t8 - t9;   		// Stack cache offset 
  t5 = *(u64 *)&(processor->dataread_mask);   
  t7 = ((u64)t9 < (u64)t7) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t2 = (u8)(t2 >> ((t6&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read16772;

vma-memory-read16771:
  t6 = zero + 240;   
  t5 = t5 >> (t2 & 63);   
  t6 = t6 >> (t2 & 63);   
  t3 = (u32)t3;   
  if (t5 & 1)   
    goto vma-memory-read16774;

vma-memory-read16781:
  t5 = t2 - Type_EvenPC;   
  t5 = t5 & 62;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto get-trap-vector-entry16769;
		/* Restore the cr */
  *(u32 *)&processor->control = t4;
  t8 = *(s32 *)&processor->scovlimit;   		// Current stack cache limit (words) 
  t5 = zero + 128;   
  t6 = *(u64 *)&(processor->stackcachedata);   		// Alpha base of stack cache 
  t5 = t5 + 8;		// Account for what we're about to push 
  t5 = (t5 * 8) + iSP;  		// SCA of desired end of cache 
  t6 = (t8 * 8) + t6;  		// SCA of current end of cache 
  t8 = ((s64)t5 <= (s64)t6) ? 1 : 0;   
  if (t8 == 0) 		// We're done if new SCA is within bounds 
    goto stack-cache-overflow-check16782;
  iFP = (zero * 8) + zero;  
  iFP = iSP - iFP;   
  iFP = iFP + 8;
  if (zero == 0) 
    goto take-post-trap16767;
  t5 = *(u64 *)iSP;   
  *(u64 *)(iSP + 32) = t5;   
  if (zero == 0) 
    goto take-post-trap16767;
  t5 = *(u64 *)(iSP + -8);   
  *(u64 *)(iSP + 24) = t5;   
  if (zero == 0) 
    goto take-post-trap16767;
  t5 = *(u64 *)(iSP + -16);   
  *(u64 *)(iSP + 16) = t5;   
  if (zero == 0) 
    goto take-post-trap16767;
  t5 = *(u64 *)(iSP + -24);   
  *(u64 *)(iSP + 8) = t5;   

take-post-trap16767:
  if (_trace) printf("take-post-trap16767:\n");
  iSP = iSP + 32;
  t5 = *(s32 *)&processor->continuation;   
  t7 = *((s32 *)(&processor->continuation)+1);   
  t5 = (u32)t5;   
  t8 = (8192) << 16;   
  t4 = (u32)t4;   
  t7 = t7 | 192;
  *(u32 *)iFP = t5;
		/* write the stack cache */
  *(u32 *)(iFP + 4) = t7;
  t8 = t4 & t8;
  t8 = t8 >> 2;   
  t6 = Type_Fixnum+0xC0;
  t8 = t4 | t8;
  *(u32 *)(iFP + 8) = t8;
		/* write the stack cache */
  *(u32 *)(iFP + 12) = t6;
  iLP = iSP + 8;
  t6 = Type_Fixnum;
  t8 = TrapVector_StackOverflow;
  *(u32 *)(iFP + 16) = t8;
		/* write the stack cache */
  *(u32 *)(iFP + 20) = t6;
  /* Convert PC to a real continuation. */
  t6 = iPC & 1;
  t8 = iPC >> 1;   		// convert PC to a real word address. 
  t6 = t6 + Type_EvenPC;   
  *(u32 *)(iFP + 24) = t8;
		/* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  t7 = *(u64 *)&(processor->fccrtrapmask);   		// Get CR mask 
  t5 = (ValueDisposition_Value*4) << 16;   		// 1<<18! 
  t6 = iLP - iFP;   		// Arg size 
  t8 = iFP - t1;   		// Caller Frame Size 
  t6 = t6 >> 3;   		// Arg size in words 
  t8 = t8 << 6;   		// Caller Frame Size in words in place 
  t5 = t5 | t6;
  t5 = t5 | t8;
  /* TagCdr. */
  t9 = t2 >> 6;   
  t6 = t4 >> 30;   
  t8 = t9 - t6;   
  if ((s64)t8 >= 0)  
    t6 = t9;
  t6 = t6 << 30;   
  t4 = t4 & t7;		// Mask off unwanted bits 
  t4 = t4 | t6;		// Add trap mode 
  t4 = t4 | t5;		// Add argsize, apply, disposition, caller FS 
  *(u32 *)&processor->control = t4;
  /* Convert PC to a real continuation. */
  t6 = iPC & 1;
  t8 = iPC >> 1;   		// convert PC to a real word address. 
  t6 = t6 + Type_EvenPC;   
  *(u64 *)&processor->continuationcp = zero;   
  *((u32 *)(&processor->continuation)+1) = t6;
  *(u32 *)&processor->continuation = t8;
  /* Convert real continuation to PC. */
  iPC = t2 & 1;
  iPC = t3 + iPC;
  iPC = t3 + iPC;
  t6 = t4 >> 30;   		// Save current trap mode 
  t4 = t4 >> 30;   		// Isolate trap mode 
  t8 = *(s32 *)&processor->cslimit;   		// Limit for emulator mode 
  t9 = *(s32 *)&processor->csextralimit;   		// Limit for extra stack and higher modes 
  if (t4)   		// Get the right limit for the current trap mode 
    t8 = t9;
  t8 = (u32)t8;   		// Might have been sign extended 
  /* Convert stack cache address to VMA */
  t9 = *(u64 *)&(processor->stackcachedata);   
  t4 = *(u64 *)&(processor->stackcachebasevma);   
  t9 = iSP - t9;   		// stack cache base relative offset 
  t9 = t9 >> 3;   		// convert byte address to word address 
  t4 = t9 + t4;		// reconstruct VMA 
  t9 = ((s64)t4 < (s64)t8) ? 1 : 0;   		// Check for overflow 
  if (t9 == 0) 		// Jump if overflow 
    goto take-post-trap16768;
  /* Convert a halfword address into a CP pointer. */
  iCP = iPC >> (CacheLine_RShift & 63);   		// Get third byte into bottom 
  t9 = *(u64 *)&(processor->icachebase);   		// get the base of the icache 
  t8 = zero + -1;   
  t8 = t8 + ((4) << 16);   
  iCP = iCP << (CacheLine_LShift & 63);   		// Now third byte is zero-shifted 
  iCP = iPC + iCP;
  iCP = iCP & t8;
  t8 = iCP << 5;   		// temp=cpos*32 
  iCP = iCP << 4;   		// cpos=cpos*16 
  t9 = t9 + t8;		// temp2=base+cpos*32 
  iCP = t9 + iCP;		// cpos=base+cpos*48 
  goto cachevalid;   

take-post-trap16768:
  if (_trace) printf("take-post-trap16768:\n");
  if (t6 == 0) 		// Take the overflow if in emulator mode 
    goto stackoverflow;
  goto fatalstackoverflow;

stack-cache-overflow-check16782:
  if (_trace) printf("stack-cache-overflow-check16782:\n");
  arg2 = 8;
  goto stackcacheoverflowhandler;   

vma-memory-read16772:
  if (_trace) printf("vma-memory-read16772:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t9 = (t9 * 8) + t7;  		// reconstruct SCA 
  t3 = *(s32 *)t9;   
  t2 = *(s32 *)(t9 + 4);   		// Read from stack cache 
  goto vma-memory-read16771;   

vma-memory-read16774:
  if (_trace) printf("vma-memory-read16774:\n");
  if ((t6 & 1) == 0)   
    goto vma-memory-read16773;
  t8 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read16770;   

vma-memory-read16773:
  if (_trace) printf("vma-memory-read16773:\n");
  t5 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t6 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t8;   		// stash the VMA for the (likely) trap 
  t6 = (t6 * 4) + t5;   		// Adjust for a longword load 
  t5 = *(s32 *)t6;   		// Get the memory action 

vma-memory-read16778:
  if (_trace) printf("vma-memory-read16778:\n");
  t6 = t5 & MemoryActionTransform;
  if (t6 == 0) 
    goto vma-memory-read16777;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto vma-memory-read16781;   

vma-memory-read16777:

vma-memory-read16776:
  /* Perform memory action */
  arg1 = t5;
  arg2 = 0;
  goto performmemoryaction;

get-trap-vector-entry16769:
  if (_trace) printf("get-trap-vector-entry16769:\n");
  goto illegaltrapvector;

/* end STACKOVERFLOW */
/* start StartPreTrap */


startpretrap:
  if (_trace) printf("startpretrap:\n");
  t2 = *(u64 *)&(processor->linkage);   
  if (t2 != 0)   
    goto nativeexception;
  t4 = *(s32 *)&processor->control;   
  t9 = *(u64 *)&(processor->fepmodetrapvecaddress);   
  t8 = *(u64 *)&(processor->trapvecbase);   
  t5 = (-16384) << 16;   
  t6 = t4 >> 30;   
  t5 = t4 | t5;		// Set trap mode to 3 
  t6 = t6 & 3;
  *(u32 *)&processor->control = t5;
  t7 = t6 - 3;   
  t8 = t8 + t10;
  if (t7 == 0)   
    t8 = t9;
  *(u64 *)&processor->tvi = t8;   		// Record TVI for tracing (if enabled) 
  /* Memory Read Internal */

vma-memory-read16784:
  t9 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t6 = t8 + ivory;
  t7 = *(s32 *)&processor->scovlimit;   
  t3 = (t6 * 4);   
  t2 = LDQ_U(t6);   
  t9 = t8 - t9;   		// Stack cache offset 
  t5 = *(u64 *)&(processor->dataread_mask);   
  t7 = ((u64)t9 < (u64)t7) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t2 = (u8)(t2 >> ((t6&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read16786;

vma-memory-read16785:
  t6 = zero + 240;   
  t5 = t5 >> (t2 & 63);   
  t6 = t6 >> (t2 & 63);   
  t3 = (u32)t3;   
  if (t5 & 1)   
    goto vma-memory-read16788;

vma-memory-read16795:
  t5 = t2 - Type_EvenPC;   
  t5 = t5 & 62;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto get-trap-vector-entry16783;
		/* Restore the cr */
  *(u32 *)&processor->control = t4;
  iSP = *(u64 *)&(processor->restartsp);   
  t7 = *(s32 *)&processor->scovlimit;   		// Current stack cache limit (words) 
  t4 = zero + 128;   
  t5 = *(u64 *)&(processor->stackcachedata);   		// Alpha base of stack cache 
  t4 = t4 + 8;		// Account for what we're about to push 
  t4 = (t4 * 8) + iSP;  		// SCA of desired end of cache 
  t5 = (t7 * 8) + t5;  		// SCA of current end of cache 
  t7 = ((s64)t4 <= (s64)t5) ? 1 : 0;   
  if (t7 == 0) 		// We're done if new SCA is within bounds 
    goto stack-cache-overflow-check16796;
  t5 = *(s32 *)&processor->continuation;   
  t4 = *((s32 *)(&processor->continuation)+1);   
  t5 = (u32)t5;   
  t7 = *(s32 *)&processor->control;   
  t7 = (u32)t7;   
  t4 = t4 | 192;
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  t6 = Type_Fixnum+0xC0;
  *(u32 *)(iSP + 8) = t7;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  t6 = t10;
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  /* Convert PC to a real continuation. */
  t6 = iPC & 1;
  t8 = iPC >> 1;   		// convert PC to a real word address. 
  t6 = t6 + Type_EvenPC;   
  *((u32 *)(&processor->continuation)+1) = t6;
  *(u32 *)&processor->continuation = t8;
  *(u64 *)&processor->continuationcp = iCP;   
  t9 = t6 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t9;
  iSP = iSP + 8;
  goto *r0; /* ret */

stack-cache-overflow-check16796:
  if (_trace) printf("stack-cache-overflow-check16796:\n");
  arg2 = 8;
  goto stackcacheoverflowhandler;   

vma-memory-read16786:
  if (_trace) printf("vma-memory-read16786:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t9 = (t9 * 8) + t7;  		// reconstruct SCA 
  t3 = *(s32 *)t9;   
  t2 = *(s32 *)(t9 + 4);   		// Read from stack cache 
  goto vma-memory-read16785;   

vma-memory-read16788:
  if (_trace) printf("vma-memory-read16788:\n");
  if ((t6 & 1) == 0)   
    goto vma-memory-read16787;
  t8 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read16784;   

vma-memory-read16787:
  if (_trace) printf("vma-memory-read16787:\n");
  t5 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t6 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t8;   		// stash the VMA for the (likely) trap 
  t6 = (t6 * 4) + t5;   		// Adjust for a longword load 
  t5 = *(s32 *)t6;   		// Get the memory action 

vma-memory-read16792:
  if (_trace) printf("vma-memory-read16792:\n");
  t6 = t5 & MemoryActionTransform;
  if (t6 == 0) 
    goto vma-memory-read16791;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto vma-memory-read16795;   

vma-memory-read16791:

vma-memory-read16790:
  /* Perform memory action */
  arg1 = t5;
  arg2 = 0;
  goto performmemoryaction;

get-trap-vector-entry16783:
  if (_trace) printf("get-trap-vector-entry16783:\n");
  goto illegaltrapvector;

/* end StartPreTrap */
/* start FinishPreTrap */


finishpretrap:
  if (_trace) printf("finishpretrap:\n");
  iFP = *(u64 *)&(processor->restartsp);   
  iFP = iFP + 8;		// iFP now points to the start of our new frame 
  iLP = iSP + 8;		// Points beyond the last argument 
  t4 = *(u64 *)&(processor->fccrtrapmask);   		// Get CR mask 
  t5 = (ValueDisposition_Value*4) << 16;   		// 1<<18! 
  t6 = iLP - iFP;   		// Arg size 
  t8 = iFP - t1;   		// Caller Frame Size 
  t6 = t6 >> 3;   		// Arg size in words 
  t8 = t8 << 6;   		// Caller Frame Size in words in place 
  t5 = t5 | t6;
  t5 = t5 | t8;
  /* TagCdr. */
  t9 = t2 >> 6;   
  t6 = t7 >> 30;   
  t8 = t9 - t6;   
  if ((s64)t8 >= 0)  
    t6 = t9;
  t6 = t6 << 30;   
  t7 = t7 & t4;		// Mask off unwanted bits 
  t7 = t7 | t6;		// Add trap mode 
  t7 = t7 | t5;		// Add argsize, apply, disposition, caller FS 
  *(u32 *)&processor->control = t7;
  /* Convert real continuation to PC. */
  iPC = t2 & 1;
  iPC = t3 + iPC;
  iPC = t3 + iPC;
  /* Check for stack overflow */
  t7 = t7 >> 30;   		// Isolate trap mode 
  t8 = *(s32 *)&processor->cslimit;   		// Limit for emulator mode 
  t9 = *(s32 *)&processor->csextralimit;   		// Limit for extra stack and higher modes 
  if (t7)   		// Get the right limit for the current trap mode 
    t8 = t9;
  t8 = (u32)t8;   		// Might have been sign extended 
  /* Convert stack cache address to VMA */
  t9 = *(u64 *)&(processor->stackcachedata);   
  t7 = *(u64 *)&(processor->stackcachebasevma);   
  t9 = iSP - t9;   		// stack cache base relative offset 
  t9 = t9 >> 3;   		// convert byte address to word address 
  t7 = t9 + t7;		// reconstruct VMA 
  t9 = ((s64)t7 < (s64)t8) ? 1 : 0;   		// Check for overflow 
  if (t9 == 0) 		// Jump if overflow 
    goto stackoverflow;
  /* Convert a halfword address into a CP pointer. */
  iCP = iPC >> (CacheLine_RShift & 63);   		// Get third byte into bottom 
  t9 = *(u64 *)&(processor->icachebase);   		// get the base of the icache 
  t8 = zero + -1;   
  t8 = t8 + ((4) << 16);   
  iCP = iCP << (CacheLine_LShift & 63);   		// Now third byte is zero-shifted 
  iCP = iPC + iCP;
  iCP = iCP & t8;
  t8 = iCP << 5;   		// temp=cpos*32 
  iCP = iCP << 4;   		// cpos=cpos*16 
  t9 = t9 + t8;		// temp2=base+cpos*32 
  iCP = t9 + iCP;		// cpos=base+cpos*48 
  goto cachevalid;   

/* end FinishPreTrap */
/* start ILLEGALOPERAND */


illegaloperand:
  if (_trace) printf("illegaloperand:\n");
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_Error;		// save the trap vector index 
  r0 = (u64)&&return0530;
  goto startpretrap;
return0530:
  t11 = Type_Fixnum;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t11;
  iSP = iSP + 8;
  t11 = Type_Locative;
  *(u32 *)(iSP + 8) = arg5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t11;
  iSP = iSP + 8;
  goto finishpretrap;   

/* end ILLEGALOPERAND */
/* start RESETTRAP */


resettrap:
  if (_trace) printf("resettrap:\n");
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_Reset;		// save the trap vector index 
  r0 = (u64)&&return0531;
  goto startpretrap;
return0531:
  goto finishpretrap;   

/* end RESETTRAP */
/* start PULLAPPLYARGSTRAP */


pullapplyargstrap:
  if (_trace) printf("pullapplyargstrap:\n");
  t12 = *(s32 *)iSP;   
  t11 = *(s32 *)(iSP + 4);   
  iSP = iSP - 8;   		// Pop Stack. 
  t12 = (u32)t12;   
  *(u64 *)&processor->restartsp = iSP;   
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_PullApplyArgs;		// save the trap vector index 
  r0 = (u64)&&return0532;
  goto startpretrap;
return0532:
  arg2 = Type_Fixnum;
  *(u32 *)(iSP + 8) = arg1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = arg2;
  iSP = iSP + 8;
  arg2 = t11 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t12;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = arg2;
  iSP = iSP + 8;
  goto finishpretrap;   

/* end PULLAPPLYARGSTRAP */
/* start TRACETRAP */


tracetrap:
  if (_trace) printf("tracetrap:\n");
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_Trace;		// save the trap vector index 
  r0 = (u64)&&return0533;
  goto startpretrap;
return0533:
  goto finishpretrap;   

/* end TRACETRAP */
/* start PREEMPTREQUESTTRAP */


preemptrequesttrap:
  if (_trace) printf("preemptrequesttrap:\n");
#endif
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_PreemptRequest;		// save the trap vector index 
  r0 = (u64)&&return0534;
  goto startpretrap;
return0534:
  goto finishpretrap;   

/* end PREEMPTREQUESTTRAP */
/* start HIGHPRIORITYSEQUENCEBREAK */


highprioritysequencebreak:
  if (_trace) printf("highprioritysequencebreak:\n");
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_HighPrioritySequenceBreak;		// save the trap vector index 
  r0 = (u64)&&return0535;
  goto startpretrap;
return0535:
  goto finishpretrap;   

/* end HIGHPRIORITYSEQUENCEBREAK */
/* start LOWPRIORITYSEQUENCEBREAK */


lowprioritysequencebreak:
  if (_trace) printf("lowprioritysequencebreak:\n");
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_LowPrioritySequenceBreak;		// save the trap vector index 
  r0 = (u64)&&return0536;
  goto startpretrap;
return0536:
  goto finishpretrap;   

/* end LOWPRIORITYSEQUENCEBREAK */
/* start DBUNWINDFRAMETRAP */


dbunwindframetrap:
  if (_trace) printf("dbunwindframetrap:\n");
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_DBUnwindFrame;		// save the trap vector index 
  r0 = (u64)&&return0537;
  goto startpretrap;
return0537:
  t11 = *(u64 *)&(processor->bindingstackpointer);   
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;   

/* end DBUNWINDFRAMETRAP */
/* start DBUNWINDCATCHTRAP */


dbunwindcatchtrap:
  if (_trace) printf("dbunwindcatchtrap:\n");
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_DBUnwindCatch;		// save the trap vector index 
  r0 = (u64)&&return0538;
  goto startpretrap;
return0538:
  t11 = *(u64 *)&(processor->bindingstackpointer);   
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;   

/* end DBUNWINDCATCHTRAP */
/* start TRANSPORTTRAP */


transporttrap:
  if (_trace) printf("transporttrap:\n");
  t11 = *(u64 *)&(processor->vma);   		// Preserve VMA against reading trap vector 
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_Transport;		// save the trap vector index 
  r0 = (u64)&&return0539;
  goto startpretrap;
return0539:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;   

/* end TRANSPORTTRAP */
/* start MONITORTRAP */


monitortrap:
  if (_trace) printf("monitortrap:\n");
  t11 = *(u64 *)&(processor->vma);   		// Preserve VMA against reading trap vector 
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_Monitor;		// save the trap vector index 
  r0 = (u64)&&return0540;
  goto startpretrap;
return0540:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;   

/* end MONITORTRAP */
/* start PAGENOTRESIDENT */


pagenotresident:
  if (_trace) printf("pagenotresident:\n");
  t11 = *(u64 *)&(processor->vma);   		// Preserve VMA against reading trap vector 
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_PageNotResident;		// save the trap vector index 
  r0 = (u64)&&return0541;
  goto startpretrap;
return0541:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;   

/* end PAGENOTRESIDENT */
/* start PAGEFAULTREQUESTHANDLER */


pagefaultrequesthandler:
  if (_trace) printf("pagefaultrequesthandler:\n");
  t11 = *(u64 *)&(processor->vma);   		// Preserve VMA against reading trap vector 
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_PageFaultRequest;		// save the trap vector index 
  r0 = (u64)&&return0542;
  goto startpretrap;
return0542:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;   

/* end PAGEFAULTREQUESTHANDLER */
/* start PAGEWRITEFAULT */


pagewritefault:
  if (_trace) printf("pagewritefault:\n");
  t11 = *(u64 *)&(processor->vma);   		// Preserve VMA against reading trap vector 
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_PageWriteFault;		// save the trap vector index 
  r0 = (u64)&&return0543;
  goto startpretrap;
return0543:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;   

/* end PAGEWRITEFAULT */
#ifdef MINIMA
/* start DBCACHEMISSTRAP */


dbcachemisstrap:
  if (_trace) printf("dbcachemisstrap:\n");
  t11 = *(u64 *)&(processor->vma);   		// Preserve VMA against reading trap vector 
  t1 = iFP;		// save old frame pointer 
  t10 = trapvectordbcachemiss;		// save the trap vector index 
  r0 = (u64)&&return0544;
  goto startpretrap;
return0544:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;   

/* end DBCACHEMISSTRAP */
#endif
  /* The following handlers should never be invoked. */
/* start UNCORRECTABLEMEMORYERROR */


uncorrectablememoryerror:
  if (_trace) printf("uncorrectablememoryerror:\n");
  t11 = *(u64 *)&(processor->vma);   		// Preserve VMA against reading trap vector 
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_UncorrectableMemoryError;		// save the trap vector index 
  r0 = (u64)&&return0545;
  goto startpretrap;
return0545:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;   

/* end UNCORRECTABLEMEMORYERROR */
/* start BUSERROR */


buserror:
  if (_trace) printf("buserror:\n");
  t11 = *(u64 *)&(processor->vma);   		// Preserve VMA against reading trap vector 
  t1 = iFP;		// save old frame pointer 
  t10 = TrapVector_MemoryBusError;		// save the trap vector index 
  r0 = (u64)&&return0546;
  goto startpretrap;
return0546:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;   

/* end BUSERROR */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifuntrap.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ihalt.as
 ************************************************************************/

  /* This file implements the out-of-line parts of the instruction dispatch loop. */
/* start iOutOfLine */


ioutofline:
  if (_trace) printf("ioutofline:\n");

traporsuspendmachine:
  if (_trace) printf("traporsuspendmachine:\n");
  t4 = *(s32 *)&processor->control;   
  *(u64 *)&processor->restartsp = iSP;   		// Be sure this is up-to-date 
  r0 = *(u64 *)&(processor->please_stop); /* lock */     		// Has the spy asked us to stop or trap? 
  t5 = zero;
  *(u64 *)&processor->please_stop = t5; /* lock */   
  t5 = 1;
  if (t5 == 0) 
    goto collision;
  *(u64 *)&processor->stop_interpreter = zero;   

collision:
  t3 = CMPBGE(r0, HaltReason_IllInstn);  		// t3<0>=1 if we've been asked to stop 
  if (t3 & 1)   
    goto SUSPENDMACHINE;
  /* Here when someone wants the emulator to trap. */
  r0 = (u32)(r0 >> ((4&7)*8));   		// Extract PROCESSORSTATE_PLEASE_TRAP (ivory) 
  t4 = t4 >> 30;   		// Isolate current trap mode 
  t3 = (r0 == TrapReason_HighPrioritySequenceBreak) ? 1 : 0;   

force-alignment16802:
  if (_trace) printf("force-alignment16802:\n");
  if (t3 == 0) 
    goto basic-dispatch16798;
  /* Here if argument TrapReasonHighPrioritySequenceBreak */
  t4 = ((u64)t4 <= (u64)TrapMode_ExtraStack) ? 1 : 0;   		// Only interrupts EXTRA-STACK and EMULATOR 
  if (t4 == 0) 
    goto continuecurrentinstruction;
  goto highprioritysequencebreak;

basic-dispatch16798:
  if (_trace) printf("basic-dispatch16798:\n");
  t3 = (r0 == TrapReason_LowPrioritySequenceBreak) ? 1 : 0;   

force-alignment16803:
  if (_trace) printf("force-alignment16803:\n");
  if (t3 == 0) 
    goto basic-dispatch16799;
  /* Here if argument TrapReasonLowPrioritySequenceBreak */
  if (t4 != 0)   		// Only interrupts EMULATOR 
    goto continuecurrentinstruction;
  goto lowprioritysequencebreak;

basic-dispatch16799:
  if (_trace) printf("basic-dispatch16799:\n");
  /* Here for all other cases */
  /* Check for preempt-request trap */
  t5 = *(s32 *)&processor->interruptreg;   		// Get the preempt-pending bit 
  if (t4 != 0)   		// Don't take preempt trap unless in emulator mode 
    goto continuecurrentinstruction;
  if ((t5 & 1) == 0)   		// Jump if preempt request not pending 
    goto continuecurrentinstruction;
  goto preemptrequesttrap;

basic-dispatch16797:
  if (_trace) printf("basic-dispatch16797:\n");

SUSPENDMACHINE:
  if (_trace) printf("SUSPENDMACHINE:\n");
  t1 = (u32)r0;   		// Get the reason 
  goto stopinterp;   

ILLEGALINSTRUCTION:
  if (_trace) printf("ILLEGALINSTRUCTION:\n");
  t1 = HaltReason_IllInstn;
  goto stopinterp;   

haltmachine:
  if (_trace) printf("haltmachine:\n");
  t1 = HaltReason_Halted;
  goto stopinterp;   

fatalstackoverflow:
  if (_trace) printf("fatalstackoverflow:\n");
  t1 = HaltReason_FatalStackOverflow;
  goto stopinterp;   

illegaltrapvector:
  if (_trace) printf("illegaltrapvector:\n");
  t1 = HaltReason_IllegalTrapVector;
  goto stopinterp;   

stopinterp:
  if (_trace) printf("stopinterp:\n");
  r0 = t1;		// Return the halt reason 
		/* Clear the request flag */
  *(u32 *)&processor->please_stop = zero;
  *(u64 *)&processor->cp = iCP;   
  *(u64 *)&processor->epc = iPC;   
  *(u64 *)&processor->sp = iSP;   
  *(u64 *)&processor->fp = iFP;   
  *(u64 *)&processor->lp = iLP;   
  *(u64 *)&processor->runningp = zero;   		// Stop the (emulated) chip 
  r9 = *(u64 *)&(processor->asrr9);   
  r10 = *(u64 *)&(processor->asrr10);   
  r11 = *(u64 *)&(processor->asrr11);   
  r12 = *(u64 *)&(processor->asrr12);   
  r13 = *(u64 *)&(processor->asrr13);   
  r15 = *(u64 *)&(processor->asrr15);   
  r26 = *(u64 *)&(processor->asrr26);   
  r27 = *(u64 *)&(processor->asrr27);   
  r29 = *(u64 *)&(processor->asrr29);   
  r30 = *(u64 *)&(processor->asrr30);   
  r14 = *(u64 *)&(processor->asrr14);   
  goto *ra; /* ret */

/* end iOutOfLine */



/* End of file automatically generated from ../alpha-emulator/ihalt.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/idouble.as
 ************************************************************************/

  /* Support for double precision floating point. */
/* start FetchDoubleFloat */


fetchdoublefloat:
  if (_trace) printf("fetchdoublefloat:\n");
  sp = sp + -8;   
  /* Memory Read Internal */

vma-memory-read16805:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read16807;

vma-memory-read16806:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read16809;

vma-memory-read16816:
  t5 = arg5 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto fetch-double-float-internal16804;
  *((u32 *)(&processor->fp0)+1) = arg6;
  arg2 = arg2 + 1;
  /* Memory Read Internal */

vma-memory-read16817:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);   
  arg5 = LDQ_U(t7);   
  t5 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read16819;

vma-memory-read16818:
  t7 = zero + 240;   
  t8 = t8 >> (arg5 & 63);   
  t7 = t7 >> (arg5 & 63);   
  if (t8 & 1)   
    goto vma-memory-read16821;

vma-memory-read16828:
  t5 = arg5 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto fetch-double-float-internal16804;
  *(u32 *)&processor->fp0 = arg6;
  sp = sp + 8;   
  goto *r0; /* ret */

vma-memory-read16821:
  if (_trace) printf("vma-memory-read16821:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read16820;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read16817;   

vma-memory-read16820:
  if (_trace) printf("vma-memory-read16820:\n");

vma-memory-read16819:
  if (_trace) printf("vma-memory-read16819:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0547;
  goto memoryreaddatadecode;
return0547:
  r0 = *(u64 *)sp;   
  goto vma-memory-read16828;   

vma-memory-read16809:
  if (_trace) printf("vma-memory-read16809:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read16808;
  arg2 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read16805;   

vma-memory-read16808:
  if (_trace) printf("vma-memory-read16808:\n");

vma-memory-read16807:
  if (_trace) printf("vma-memory-read16807:\n");
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0548;
  goto memoryreaddatadecode;
return0548:
  r0 = *(u64 *)sp;   
  goto vma-memory-read16816;   

fetch-double-float-internal16804:
  if (_trace) printf("fetch-double-float-internal16804:\n");
  arg6 = Type_DoubleFloat;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

/* end FetchDoubleFloat */
/* start ConsDoubleFloat */


consdoublefloat:
  if (_trace) printf("consdoublefloat:\n");
  sp = sp + -8;   
  arg6 = *(s32 *)&processor->fp0;   
  arg5 = *((s32 *)(&processor->fp0)+1);   
  t5 = *(u64 *)&(processor->lcarea);   
  t8 = *(u64 *)&(processor->niladdress);   
  t6 = *(s32 *)&processor->lclength;   
  arg2 = *(u64 *)&(processor->lcaddress);   		// Fetch address 
  t7 = (t5 == t8) ? 1 : 0;   
  if (t7 != 0)   		// Decached area 
    goto cons-double-float-internal16829;
  t7 = t6 - 2;   		// Effectively an unsigned 32-bit compare 
  if ((s64)t7 < 0)   		// Insufficient cache 
    goto cons-double-float-internal16829;
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
		/* Store remaining length */
  *(u32 *)&processor->lclength = t7;
  t8 = (u32)arg2;   
  t8 = t8 + 2;		// Increment address 
		/* Store updated address */
  *(u32 *)&processor->lcaddress = t8;
  arg2 = (u32)arg2;   
  t9 = Type_Fixnum;
  t9 = t9 | 128;
  t5 = arg2 + ivory;
  t8 = (t5 * 4);   
  t7 = LDQ_U(t5);   
  t6 = (t9 & 0xff) << ((t5&7)*8);   
  t7 = t7 & ~(0xffL << (t5&7)*8);   

force-alignment16830:
  if (_trace) printf("force-alignment16830:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);   
  *(u32 *)t8 = arg5;
  t10 = arg2 + 1;
  t9 = Type_Fixnum;
  t9 = t9 | 64;
  t5 = t10 + ivory;
  t8 = (t5 * 4);   
  t7 = LDQ_U(t5);   
  t6 = (t9 & 0xff) << ((t5&7)*8);   
  t7 = t7 & ~(0xffL << (t5&7)*8);   

force-alignment16831:
  if (_trace) printf("force-alignment16831:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);   
  *(u32 *)t8 = arg6;
  sp = sp + 8;   
  goto *r0; /* ret */

cons-double-float-internal16829:
  if (_trace) printf("cons-double-float-internal16829:\n");
  arg6 = Type_DoubleFloat;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;

/* end ConsDoubleFloat */
/* start DoDoubleFloatOp */

  /* Halfword operand from stack instruction - DoDoubleFloatOp */
  /* arg2 has the preloaded 8 bit operand. */

dodoublefloatop:
  if (_trace) printf("dodoublefloatop:\n");

DoDoubleFloatOpIM:
  if (_trace) printf("DoDoubleFloatOpIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindodoublefloatop;   

DoDoubleFloatOpSP:
  if (_trace) printf("DoDoubleFloatOpSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoDoubleFloatOpLP:
  if (_trace) printf("DoDoubleFloatOpLP:\n");

DoDoubleFloatOpFP:
  if (_trace) printf("DoDoubleFloatOpFP:\n");

headdodoublefloatop:
  if (_trace) printf("headdodoublefloatop:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindodoublefloatop:
  if (_trace) printf("begindodoublefloatop:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg3 = *(s32 *)(iSP + -24);   		// X high 
  arg4 = *(s32 *)(iSP + -16);   		// X low 
  arg5 = *(s32 *)(iSP + -8);   		// Y high 
  arg6 = *(s32 *)iSP;   		// Y low 
  arg3 = arg3 << 32;   		// Get high part up top 
  arg4 = (u32)arg4;   
  arg5 = arg5 << 32;   		// Get high part up top 
  arg6 = (u32)arg6;   
  arg3 = arg3 | arg4;		// ARG3 is now X 
  arg5 = arg5 | arg6;		// ARG5 is now Y 
  *(u64 *)&processor->fp0 = arg3;   
  *(u64 *)&processor->fp1 = arg5;   
  t2 = arg1 >> 32;   		// Immediate tag 
  t1 = (u32)arg1;   		// Immediate data 
  t3 = t2 - Type_Fixnum;   
  t3 = t3 & 63;		// Strip CDR code 
  if (t3 != 0)   
    goto doublefloatiop;
  LDT(1, f1, processor->fp0);   
  LDT(2, f2, processor->fp1);   
  /* NIL */
  t3 = zero + DoubleFloatOp_Add;   
  t3 = t1 - t3;   
  if (t3 != 0)   
    goto mondo-dispatch16833;
  /* Here if argument DoubleFloatOpAdd */
  ADDT(1, f1, 1, f1, 2, f2); /* addt */   
  goto mondo-dispatch16832;   

mondo-dispatch16833:
  if (_trace) printf("mondo-dispatch16833:\n");
  t3 = zero + DoubleFloatOp_Sub;   
  t3 = t1 - t3;   
  if (t3 != 0)   
    goto mondo-dispatch16834;
  /* Here if argument DoubleFloatOpSub */
  SUBT(1, f1, 1, f1, 2, f2);   
  goto mondo-dispatch16832;   

mondo-dispatch16834:
  if (_trace) printf("mondo-dispatch16834:\n");
  t3 = zero + DoubleFloatOp_Multiply;   
  t3 = t1 - t3;   
  if (t3 != 0)   
    goto mondo-dispatch16835;
  /* Here if argument DoubleFloatOpMultiply */
  MULT(1, f1, 1, f1, 2, f2);   
  goto mondo-dispatch16832;   

mondo-dispatch16835:
  if (_trace) printf("mondo-dispatch16835:\n");
  t3 = zero + DoubleFloatOp_Divide;   
  t3 = t1 - t3;   
  if (t3 != 0)   
    goto mondo-dispatch16836;
  /* Here if argument DoubleFloatOpDivide */
  DIVT(1, f1, 1, f1, 2, f2);   
  goto mondo-dispatch16832;   

mondo-dispatch16836:
  if (_trace) printf("mondo-dispatch16836:\n");

mondo-dispatch16832:
  if (_trace) printf("mondo-dispatch16832:\n");
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t3 = *(u64 *)&(processor->niladdress);   		// There was no FP exception 

doublefloatmerge:
  STT( (u64 *)&processor->fp0, 1, f1 );   
  t1 = *(s32 *)&processor->fp0;   
  t2 = *((s32 *)(&processor->fp0)+1);   
  iSP = iSP - 32;   		// Pop all the operands 
  t4 = Type_Fixnum;
		/* Push high result */
  *(u32 *)(iSP + 8) = t2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  t4 = Type_Fixnum;
		/* Push low result */
  *(u32 *)(iSP + 8) = t1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  iSP = iSP + 8;
  t4 = t3 << 26;   
  t4 = t4 >> 26;   
  *(u64 *)iSP = t4;   		// Push the exception predicate 
  goto NEXTINSTRUCTION;   

doublefloatexc:
  if (_trace) printf("doublefloatexc:\n");
  t3 = *(u64 *)&(processor->taddress);   		// Indicate an FP exception occurred 
  goto doublefloatmerge;   

doublefloatiop:
  if (_trace) printf("doublefloatiop:\n");
  arg5 = 0;
  arg2 = 85;
  goto illegaloperand;

/* end DoDoubleFloatOp */
  /* End of Halfword operand from stack instruction - DoDoubleFloatOp */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/idouble.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunjosh.as
 ************************************************************************/

  /* 'AI' instructions. */
/* start DoDereference */

  /* Halfword operand from stack instruction - DoDereference */

dodereference:
  if (_trace) printf("dodereference:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoDereferenceIM:
  if (_trace) printf("DoDereferenceIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment16861:
  if (_trace) printf("force-alignment16861:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindodereference;   

DoDereferenceSP:
  if (_trace) printf("DoDereferenceSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoDereferenceLP:
  if (_trace) printf("DoDereferenceLP:\n");

DoDereferenceFP:
  if (_trace) printf("DoDereferenceFP:\n");

headdodereference:
  if (_trace) printf("headdodereference:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindodereference:
  if (_trace) printf("begindodereference:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t1 = arg2 & 63;		// Strip off any CDR code bits. 
  t2 = (t1 == Type_OneQForward) ? 1 : 0;   

force-alignment16856:
  if (_trace) printf("force-alignment16856:\n");
  if (t2 != 0)   
    goto basic-dispatch16852;
  t2 = (t1 == Type_ElementForward) ? 1 : 0;   

force-alignment16857:
  if (_trace) printf("force-alignment16857:\n");
  if (t2 != 0)   
    goto basic-dispatch16852;
  t2 = (t1 == Type_HeaderForward) ? 1 : 0;   

force-alignment16858:
  if (_trace) printf("force-alignment16858:\n");
  if (t2 != 0)   
    goto basic-dispatch16852;
  t2 = (t1 == Type_ExternalValueCellPointer) ? 1 : 0;   

force-alignment16859:
  if (_trace) printf("force-alignment16859:\n");
  if (t2 == 0) 
    goto basic-dispatch16839;

basic-dispatch16852:
  if (_trace) printf("basic-dispatch16852:\n");
  /* Here if argument (TypeOneQForward TypeElementForward TypeHeaderForward
                  TypeExternalValueCellPointer) */
  /* Memory Read Internal */

vma-memory-read16840:
  t5 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t7 = arg1 + ivory;
  t6 = *(s32 *)&processor->scovlimit;   
  t3 = (t7 * 4);   
  t4 = LDQ_U(t7);   
  t5 = arg1 - t5;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t6) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read16842;

vma-memory-read16841:
  t7 = zero + 240;   
  t8 = t8 >> (t4 & 63);   
  t7 = t7 >> (t4 & 63);   
  if (t8 & 1)   
    goto vma-memory-read16844;

vma-memory-read16851:
  t5 = t4 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

basic-dispatch16839:
  if (_trace) printf("basic-dispatch16839:\n");
  t2 = (t1 == Type_LogicVariable) ? 1 : 0;   

force-alignment16860:
  if (_trace) printf("force-alignment16860:\n");
  if (t2 == 0) 
    goto basic-dispatch16853;
  /* Here if argument TypeLogicVariable */
  t5 = Type_ExternalValueCellPointer;
  *(u32 *)(iSP + 8) = arg1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

basic-dispatch16853:
  if (_trace) printf("basic-dispatch16853:\n");
  /* Here for all other cases */
  t5 = arg2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

basic-dispatch16838:
  if (_trace) printf("basic-dispatch16838:\n");

vma-memory-read16842:
  if (_trace) printf("vma-memory-read16842:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t3 = *(s32 *)t5;   
  t4 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read16841;   

vma-memory-read16844:
  if (_trace) printf("vma-memory-read16844:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read16843;
  arg1 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read16840;   

vma-memory-read16843:
  if (_trace) printf("vma-memory-read16843:\n");
  t8 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read16848:
  if (_trace) printf("vma-memory-read16848:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0) 
    goto vma-memory-read16847;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto vma-memory-read16851;   

vma-memory-read16847:

vma-memory-read16846:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

/* end DoDereference */
  /* End of Halfword operand from stack instruction - DoDereference */
/* start DoUnify */

  /* Halfword operand from stack instruction - DoUnify */

dounify:
  if (_trace) printf("dounify:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoUnifyIM:
  if (_trace) printf("DoUnifyIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment16862:
  if (_trace) printf("force-alignment16862:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindounify;   

DoUnifySP:
  if (_trace) printf("DoUnifySP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoUnifyLP:
  if (_trace) printf("DoUnifyLP:\n");

DoUnifyFP:
  if (_trace) printf("DoUnifyFP:\n");

headdounify:
  if (_trace) printf("headdounify:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindounify:
  if (_trace) printf("begindounify:\n");
  /* arg1 has the operand, sign extended if immediate. */
  /* This instruction has not been written yet. */
  arg5 = 0;
  arg2 = 38;
  goto illegaloperand;
  goto NEXTINSTRUCTION;   

/* end DoUnify */
  /* End of Halfword operand from stack instruction - DoUnify */
/* start DoPushLocalLogicVariables */

  /* Halfword operand from stack instruction - DoPushLocalLogicVariables */
  /* arg2 has the preloaded 8 bit operand. */

dopushlocallogicvariables:
  if (_trace) printf("dopushlocallogicvariables:\n");

DoPushLocalLogicVariablesIM:
  if (_trace) printf("DoPushLocalLogicVariablesIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindopushlocallogicvariables;   

DoPushLocalLogicVariablesSP:
  if (_trace) printf("DoPushLocalLogicVariablesSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPushLocalLogicVariablesLP:
  if (_trace) printf("DoPushLocalLogicVariablesLP:\n");

DoPushLocalLogicVariablesFP:
  if (_trace) printf("DoPushLocalLogicVariablesFP:\n");

headdopushlocallogicvariables:
  if (_trace) printf("headdopushlocallogicvariables:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindopushlocallogicvariables:
  if (_trace) printf("begindopushlocallogicvariables:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg6 = Type_LogicVariable;
  t1 = arg1 >> 32;   
  arg2 = (u32)arg1;   
  t2 = t1 - Type_Fixnum;   
  t2 = t2 & 63;		// Strip CDR code 
  if (t2 != 0)   
    goto pllvillop;
  t4 = *(s32 *)&processor->scovlimit;   		// Current stack cache limit (words) 
  t1 = zero + 128;   
  t2 = *(u64 *)&(processor->stackcachedata);   		// Alpha base of stack cache 
  t1 = t1 + arg2;		// Account for what we're about to push 
  t1 = (t1 * 8) + iSP;  		// SCA of desired end of cache 
  t2 = (t4 * 8) + t2;  		// SCA of current end of cache 
  t4 = ((s64)t1 <= (s64)t2) ? 1 : 0;   
  if (t4 == 0) 		// We're done if new SCA is within bounds 
    goto stackcacheoverflowhandler;
  goto pllvloopend;   

pllvlooptop:
  if (_trace) printf("pllvlooptop:\n");
  *(u32 *)(iSP + 8) = iSP;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = arg6;
  iSP = iSP + 8;

pllvloopend:
  if (_trace) printf("pllvloopend:\n");
  arg2 = arg2 - 1;   
  if ((s64)arg2 >= 0)   		// J. If iterations to go. 
    goto pllvlooptop;
  goto NEXTINSTRUCTION;   

pllvillop:
  if (_trace) printf("pllvillop:\n");
  arg5 = 0;
  arg2 = 63;
  goto illegaloperand;

/* end DoPushLocalLogicVariables */
  /* End of Halfword operand from stack instruction - DoPushLocalLogicVariables */
/* start DoPushGlobalLogicVariable */

  /* Halfword operand from stack instruction - DoPushGlobalLogicVariable */

dopushgloballogicvariable:
  if (_trace) printf("dopushgloballogicvariable:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoPushGlobalLogicVariableIM:
  if (_trace) printf("DoPushGlobalLogicVariableIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment16879:
  if (_trace) printf("force-alignment16879:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindopushgloballogicvariable;   

DoPushGlobalLogicVariableSP:
  if (_trace) printf("DoPushGlobalLogicVariableSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPushGlobalLogicVariableLP:
  if (_trace) printf("DoPushGlobalLogicVariableLP:\n");

DoPushGlobalLogicVariableFP:
  if (_trace) printf("DoPushGlobalLogicVariableFP:\n");

headdopushgloballogicvariable:
  if (_trace) printf("headdopushgloballogicvariable:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindopushgloballogicvariable:
  if (_trace) printf("begindopushgloballogicvariable:\n");
  /* arg1 has the operand, sign extended if immediate. */
  t1 = *(s32 *)&processor->bar2;   		// Get the structure stack pointer 
  t3 = Type_ExternalValueCellPointer;
  *(u32 *)(iSP + 8) = t1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  /* Memory Read Internal */

vma-memory-read16864:
  t6 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t8 = t1 + ivory;
  t7 = *(s32 *)&processor->scovlimit;   
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = t1 - t6;   		// Stack cache offset 
  t9 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t6 < (u64)t7) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read16866;

vma-memory-read16865:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t9 & 1)   
    goto vma-memory-read16868;

vma-memory-read16874:
  /* Merge cdr-code */
  t5 = t3 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t7 = *(u64 *)&(processor->stackcachebasevma);   
  t6 = t1 + ivory;
  t9 = *(s32 *)&processor->scovlimit;   
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = t1 - t7;   		// Stack cache offset 
  t9 = ((u64)t7 < (u64)t9) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment16877:
  if (_trace) printf("force-alignment16877:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t1;
  if (t9 != 0)   		// J. if in cache 
    goto vma-memory-write16876;

vma-memory-write16875:
  t2 = t1 + 1;		// Increment the structure-stack-pointer 
		/* Set the structure stack pointer */
  *(u32 *)&processor->bar2 = t2;
  goto NEXTINSTRUCTION;   

vma-memory-write16876:
  if (_trace) printf("vma-memory-write16876:\n");
  t7 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment16878:
  if (_trace) printf("force-alignment16878:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = t1 - t7;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = t1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto vma-memory-write16875;   

vma-memory-read16866:
  if (_trace) printf("vma-memory-read16866:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read16865;   

vma-memory-read16868:
  if (_trace) printf("vma-memory-read16868:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read16867;
  t1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read16864;   

vma-memory-read16867:
  if (_trace) printf("vma-memory-read16867:\n");
  t9 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
  t9 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read16871:

vma-memory-read16870:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoPushGlobalLogicVariable */
  /* End of Halfword operand from stack instruction - DoPushGlobalLogicVariable */
/* start DoLogicTailTest */

  /* Halfword operand from stack instruction - DoLogicTailTest */

dologictailtest:
  if (_trace) printf("dologictailtest:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoLogicTailTestIM:
  if (_trace) printf("DoLogicTailTestIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment16889:
  if (_trace) printf("force-alignment16889:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindologictailtest;   

DoLogicTailTestSP:
  if (_trace) printf("DoLogicTailTestSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoLogicTailTestLP:
  if (_trace) printf("DoLogicTailTestLP:\n");

DoLogicTailTestFP:
  if (_trace) printf("DoLogicTailTestFP:\n");

headdologictailtest:
  if (_trace) printf("headdologictailtest:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindologictailtest:
  if (_trace) printf("begindologictailtest:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg2 = arg1 >> 32;   
  t1 = arg2 & 63;		// Strip off any CDR code bits. 
  t2 = (t1 == Type_List) ? 1 : 0;   

force-alignment16886:
  if (_trace) printf("force-alignment16886:\n");
  if (t2 == 0) 
    goto basic-dispatch16881;
  /* Here if argument TypeList */
  t3 = *(u64 *)&(processor->niladdress);   
  *(u64 *)(iSP + 8) = t3;   		// push the data 
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

basic-dispatch16881:
  if (_trace) printf("basic-dispatch16881:\n");
  t2 = (t1 == Type_ExternalValueCellPointer) ? 1 : 0;   

force-alignment16887:
  if (_trace) printf("force-alignment16887:\n");
  if (t2 == 0) 
    goto basic-dispatch16882;
  /* Here if argument TypeExternalValueCellPointer */
  t3 = *(u64 *)&(processor->taddress);   
  *(u64 *)(iSP + 8) = t3;   		// push the data 
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

basic-dispatch16882:
  if (_trace) printf("basic-dispatch16882:\n");
  t2 = (t1 == Type_ListInstance) ? 1 : 0;   

force-alignment16888:
  if (_trace) printf("force-alignment16888:\n");
  if (t2 == 0) 
    goto basic-dispatch16883;
  /* Here if argument TypeListInstance */
  t3 = *(u64 *)&(processor->niladdress);   
  *(u64 *)(iSP + 8) = t3;   		// push the data 
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

basic-dispatch16883:
  if (_trace) printf("basic-dispatch16883:\n");
  /* Here for all other cases */
  arg6 = t2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

basic-dispatch16880:
  if (_trace) printf("basic-dispatch16880:\n");

/* end DoLogicTailTest */
  /* End of Halfword operand from stack instruction - DoLogicTailTest */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunjosh.as */
/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifuntran.as
 ************************************************************************/

/* start NativeException */


nativeexception:
  if (_trace) printf("nativeexception:\n");
  t1 = *(u64 *)&(processor->linkage);   		// Load linkage to escape block 
  r0 = *(u64 *)&(processor->resumeema);   		// Re-load resumemulator 
  iSP = *(u64 *)&(processor->restartsp);   		// Restore SP (Just in case?) 
  *(u64 *)&processor->linkage = zero;   
  goto *t1; /* ret */

/* end NativeException */
/* start PadPastAref1 */


padpastaref1:
  if (_trace) printf("padpastaref1:\n");
  t1 = *(u64 *)&(processor->linkage);   		// Load linkage to escape block 
  r0 = *(u64 *)&(processor->resumeema);   		// Re-load resumemulator 
  iSP = *(u64 *)&(processor->restartsp);   		// Restore SP (Just in case?) 
  *(u64 *)&processor->linkage = zero;   
  t1 = *(u64 *)&(processor->linkage);   		// Load linkage to escape block 
  r0 = *(u64 *)&(processor->resumeema);   		// Re-load resumemulator 
  iSP = *(u64 *)&(processor->restartsp);   		// Restore SP (Just in case?) 
  *(u64 *)&processor->linkage = zero;   
  goto *t1; /* ret */

/* end PadPastAref1 */
/* start CarSubroutine */


carsubroutine:
  if (_trace) printf("carsubroutine:\n");
  sp = sp + -8;   
  *(u64 *)&processor->linkage = r0;   
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  r0 = r0 + 4;
  *(u64 *)&processor->restartsp = iSP;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0549;
  goto carinternal;
return0549:
  r0 = *(u64 *)sp;   
  *(u64 *)&processor->linkage = zero;   
  sp = sp + 8;   
  goto *r0; /* ret */

/* end CarSubroutine */
/* start CdrSubroutine */


cdrsubroutine:
  if (_trace) printf("cdrsubroutine:\n");
  sp = sp + -8;   
  *(u64 *)&processor->linkage = r0;   
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  r0 = r0 + 4;
  *(u64 *)&processor->restartsp = iSP;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0550;
  goto cdrinternal;
return0550:
  r0 = *(u64 *)sp;   
  *(u64 *)&processor->linkage = zero;   
  sp = sp + 8;   
  goto *r0; /* ret */

/* end CdrSubroutine */
/* start CarCdrSubroutine */


carcdrsubroutine:
  if (_trace) printf("carcdrsubroutine:\n");
  sp = sp + -8;   
  *(u64 *)&processor->linkage = r0;   
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  r0 = r0 + 4;
  *(u64 *)&processor->restartsp = iSP;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0551;
  goto carcdrinternal;
return0551:
  r0 = *(u64 *)sp;   
  *(u64 *)&processor->linkage = zero;   
  sp = sp + 8;   
  goto *r0; /* ret */

/* end CarCdrSubroutine */



/* End of file automatically generated from ../alpha-emulator/ifuntran.as */
