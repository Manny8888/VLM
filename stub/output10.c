/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunmath.as
 ************************************************************************/

  /* Arithmetic. */
/* start DoUnaryMinus */

  /* Halfword operand from stack instruction - DoUnaryMinus */
  /* arg2 has the preloaded 8 bit operand. */

dounaryminus:
  if (_trace) printf("dounaryminus:\n");
#ifdef TRACING
#endif

DoUnaryMinusSP:
  if (_trace) printf("DoUnaryMinusSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindounaryminus;   
#endif

DoUnaryMinusLP:
  if (_trace) printf("DoUnaryMinusLP:\n");
#ifdef TRACING
  goto begindounaryminus;   
#endif

DoUnaryMinusFP:
  if (_trace) printf("DoUnaryMinusFP:\n");

begindounaryminus:
  if (_trace) printf("begindounaryminus:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  arg5 = *(s32 *)(arg1 + 4);   		// tag of ARG2 
  arg6 = *(s32 *)arg1;   
  t2 = *(u64 *)&(processor->mostnegativefixnum);   
  LDS(1, f1, *(u32 *)arg1 );   
  t5 = arg5 & 63;		// Strip off any CDR code bits. 
  t4 = (t5 == Type_Fixnum) ? 1 : 0;   

force-alignment10030:
  if (_trace) printf("force-alignment10030:\n");
  if (t4 == 0) 
    goto basic-dispatch10026;
  /* Here if argument TypeFixnum */
  t2 = (s32)arg6 - (s32)t2;   
  arg2 = (s32)zero - (s32)arg6;   
  if (t2 == 0) 
    goto unaryminusexc;
  iPC = t6;
		/* Semi-cheat, we know t5 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
		/* Push the data */
  *(u32 *)(iSP + 8) = arg2;
  iSP = iSP + 8;
  goto cachevalid;   

basic-dispatch10026:
  if (_trace) printf("basic-dispatch10026:\n");
  t4 = (t5 == Type_SingleFloat) ? 1 : 0;   

force-alignment10031:
  if (_trace) printf("force-alignment10031:\n");
  if (t4 == 0) 
    goto basic-dispatch10027;
  /* Here if argument TypeSingleFloat */
  /* NIL */
  SUBS(0, f0, 3, f31, 1, f1); /* subs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = t6;
		/* Semi-cheat, we know t5 has CDRNext/TypeSingleFloat */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
  STS( (u32 *)(iSP + 8), 0, f0 );   		// Push the data 
  iSP = iSP + 8;
  goto cachevalid;   

basic-dispatch10027:
  if (_trace) printf("basic-dispatch10027:\n");
  /* Here for all other cases */

unaryminusexc:
  if (_trace) printf("unaryminusexc:\n");
  arg6 = arg5;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto unarynumericexception;

basic-dispatch10025:
  if (_trace) printf("basic-dispatch10025:\n");
#ifdef TRACING
  goto DoUnaryMinusIM;   
#endif

DoUnaryMinusIM:
  if (_trace) printf("DoUnaryMinusIM:\n");
  arg2 = (s32)zero - (s32)arg2;   		// Negate the 8 bit immediate operand 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t7 = Type_Fixnum;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;   

/* end DoUnaryMinus */
  /* End of Halfword operand from stack instruction - DoUnaryMinus */
/* start DoMultiply */

  /* Halfword operand from stack instruction - DoMultiply */
  /* arg2 has the preloaded 8 bit operand. */

domultiply:
  if (_trace) printf("domultiply:\n");
#ifdef TRACING
#endif

DoMultiplySP:
  if (_trace) printf("DoMultiplySP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomultiply;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindomultiply;   
#endif

DoMultiplyLP:
  if (_trace) printf("DoMultiplyLP:\n");
#ifdef TRACING
  goto begindomultiply;   
#endif

DoMultiplyFP:
  if (_trace) printf("DoMultiplyFP:\n");

begindomultiply:
  if (_trace) printf("begindomultiply:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  /* NIL */
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment10071:
  if (_trace) printf("force-alignment10071:\n");
  if (t10 == 0) 
    goto basic-dispatch10042;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment10048:
  if (_trace) printf("force-alignment10048:\n");
  if (t12 == 0) 
    goto basic-dispatch10044;
  /* Here if argument TypeFixnum */
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t5 = (s64)((s32)t2 * (s64)(s32)t4); /* mull/v */   		// compute 64-bit result 
  if (t5 >> 32)
    exception();  // WARNING !!! THIS IS ADJUSTED BY THE DIFF FILE
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t9;
  iPC = t6;
  *(u32 *)iSP = t5;
  iCP = t7;
  goto cachevalid;   

basic-dispatch10044:
  if (_trace) printf("basic-dispatch10044:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment10049:
  if (_trace) printf("force-alignment10049:\n");
  if (t12 == 0) 
    goto basic-dispatch10045;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple-binary-arithmetic-operation10032;   

basic-dispatch10045:
  if (_trace) printf("basic-dispatch10045:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment10050:
  if (_trace) printf("force-alignment10050:\n");
  if (t12 == 0) 
    goto binary-type-dispatch10039;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple-binary-arithmetic-operation10035;   

basic-dispatch10043:
  if (_trace) printf("basic-dispatch10043:\n");

basic-dispatch10042:
  if (_trace) printf("basic-dispatch10042:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment10072:
  if (_trace) printf("force-alignment10072:\n");
  if (t10 == 0) 
    goto basic-dispatch10051;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment10057:
  if (_trace) printf("force-alignment10057:\n");
  if (t12 == 0) 
    goto basic-dispatch10053;
  /* Here if argument TypeSingleFloat */

simple-binary-arithmetic-operation10032:
  if (_trace) printf("simple-binary-arithmetic-operation10032:\n");
  MULS(0, f0, 1, f1, 2, f2); /* muls */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto cachevalid;   

basic-dispatch10053:
  if (_trace) printf("basic-dispatch10053:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment10058:
  if (_trace) printf("force-alignment10058:\n");
  if (t12 == 0) 
    goto basic-dispatch10054;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple-binary-arithmetic-operation10032;   

basic-dispatch10054:
  if (_trace) printf("basic-dispatch10054:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment10059:
  if (_trace) printf("force-alignment10059:\n");
  if (t12 == 0) 
    goto binary-type-dispatch10039;
  /* Here if argument TypeDoubleFloat */

simple-binary-arithmetic-operation10035:
  if (_trace) printf("simple-binary-arithmetic-operation10035:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto simple-binary-arithmetic-operation10036;   

basic-dispatch10052:
  if (_trace) printf("basic-dispatch10052:\n");

basic-dispatch10051:
  if (_trace) printf("basic-dispatch10051:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

force-alignment10073:
  if (_trace) printf("force-alignment10073:\n");
  if (t10 == 0) 
    goto basic-dispatch10060;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment10066:
  if (_trace) printf("force-alignment10066:\n");
  if (t12 == 0) 
    goto basic-dispatch10062;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0313;
  goto fetchdoublefloat;
return0313:
  LDT(1, f1, processor->fp0);   

simple-binary-arithmetic-operation10036:
  if (_trace) printf("simple-binary-arithmetic-operation10036:\n");
  arg2 = (u32)t4;   
  r0 = (u64)&&return0314;
  goto fetchdoublefloat;
return0314:
  LDT(2, f2, processor->fp0);   

simple-binary-arithmetic-operation10033:
  if (_trace) printf("simple-binary-arithmetic-operation10033:\n");
  MULT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0315;
  goto consdoublefloat;
return0315:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto cachevalid;   

basic-dispatch10062:
  if (_trace) printf("basic-dispatch10062:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment10067:
  if (_trace) printf("force-alignment10067:\n");
  if (t12 == 0) 
    goto basic-dispatch10063;
  /* Here if argument TypeSingleFloat */

simple-binary-arithmetic-operation10034:
  if (_trace) printf("simple-binary-arithmetic-operation10034:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0316;
  goto fetchdoublefloat;
return0316:
  LDT(1, f1, processor->fp0);   
  goto simple-binary-arithmetic-operation10033;   

basic-dispatch10063:
  if (_trace) printf("basic-dispatch10063:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment10068:
  if (_trace) printf("force-alignment10068:\n");
  if (t12 == 0) 
    goto binary-type-dispatch10039;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple-binary-arithmetic-operation10034;   

basic-dispatch10061:
  if (_trace) printf("basic-dispatch10061:\n");

basic-dispatch10060:
  if (_trace) printf("basic-dispatch10060:\n");
  /* Here for all other cases */

binary-type-dispatch10038:
  if (_trace) printf("binary-type-dispatch10038:\n");

domulovfl:
  if (_trace) printf("domulovfl:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch10040;   

binary-type-dispatch10039:
  if (_trace) printf("binary-type-dispatch10039:\n");
  t1 = t3;
  goto domulovfl;   

binary-type-dispatch10040:
  if (_trace) printf("binary-type-dispatch10040:\n");

basic-dispatch10041:
  if (_trace) printf("basic-dispatch10041:\n");
#ifdef TRACING
  goto DoMultiplyIM;   
#endif

DoMultiplyIM:
  if (_trace) printf("DoMultiplyIM:\n");
  arg2 = arg2 << 56;   
  t1 = (u32)(arg6 >> ((4&7)*8));   
  t2 = (s32)arg6;		// get ARG1 tag/data 
  arg2 = (s64)arg2 >> 56;   
  t11 = t1 & 63;		// Strip off any CDR code bits. 
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment10078:
  if (_trace) printf("force-alignment10078:\n");
  if (t12 == 0) 
    goto basic-dispatch10075;
  /* Here if argument TypeFixnum */
  t3 = t2 * arg2;   		// compute 64-bit result 
  t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t10 = (s32)t3;		// compute 32-bit sign-extended result 
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t10 = (t3 == t10) ? 1 : 0;   		// is it the same as the 64-bit result? 
  if (t10 == 0) 		// if not, we overflowed 
    goto domulovfl;
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t11;
  iPC = t4;
  *(u32 *)iSP = t3;
  iCP = t5;
  goto cachevalid;   

basic-dispatch10075:
  if (_trace) printf("basic-dispatch10075:\n");
  /* Here for all other cases */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;   
  arg2 = zero;
  goto begindomultiply;   

basic-dispatch10074:
  if (_trace) printf("basic-dispatch10074:\n");

/* end DoMultiply */
  /* End of Halfword operand from stack instruction - DoMultiply */
/* start BinaryArithmeticDivisionPrelude */


binaryarithmeticdivisionprelude:
  if (_trace) printf("binaryarithmeticdivisionprelude:\n");
  sp = sp + -8;   
  LDS(1, f1, *(u32 *)iSP );   
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment10116:
  if (_trace) printf("force-alignment10116:\n");
  if (t10 == 0) 
    goto basic-dispatch10089;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment10095:
  if (_trace) printf("force-alignment10095:\n");
  if (t12 == 0) 
    goto basic-dispatch10091;
  /* Here if argument TypeFixnum */
  CVTLQ(1, f1, f31, 1, f1);
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(1, f1, f31, 1, f1);
  CVTQT(2, f2, f31, 2, f2);

basic-dispatch10090:
  if (_trace) printf("basic-dispatch10090:\n");

basic-dispatch10088:
  if (_trace) printf("basic-dispatch10088:\n");

binary-arithmetic-division-prelude10079:
  if (_trace) printf("binary-arithmetic-division-prelude10079:\n");
  sp = sp + 8;   
  goto *r0; /* ret */

basic-dispatch10089:
  if (_trace) printf("basic-dispatch10089:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment10117:
  if (_trace) printf("force-alignment10117:\n");
  if (t10 == 0) 
    goto basic-dispatch10096;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment10102:
  if (_trace) printf("force-alignment10102:\n");
  if (t12 != 0)   
    goto binary-arithmetic-division-prelude10079;

basic-dispatch10098:
  if (_trace) printf("basic-dispatch10098:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment10103:
  if (_trace) printf("force-alignment10103:\n");
  if (t12 == 0) 
    goto basic-dispatch10099;
  /* Here if argument TypeFixnum */
  t3 = t1;		// contagion 
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto binary-arithmetic-division-prelude10079;   

basic-dispatch10099:
  if (_trace) printf("basic-dispatch10099:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment10104:
  if (_trace) printf("force-alignment10104:\n");
  if (t12 == 0) 
    goto binary-type-dispatch10086;
  /* Here if argument TypeDoubleFloat */

binary-arithmetic-division-prelude10081:
  if (_trace) printf("binary-arithmetic-division-prelude10081:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto binary-arithmetic-division-prelude10082;   

basic-dispatch10097:
  if (_trace) printf("basic-dispatch10097:\n");

basic-dispatch10096:
  if (_trace) printf("basic-dispatch10096:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

force-alignment10118:
  if (_trace) printf("force-alignment10118:\n");
  if (t10 == 0) 
    goto basic-dispatch10105;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment10111:
  if (_trace) printf("force-alignment10111:\n");
  if (t12 == 0) 
    goto basic-dispatch10107;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0317;
  goto fetchdoublefloat;
return0317:
  r0 = *(u64 *)sp;   
  LDT(1, f1, processor->fp0);   

binary-arithmetic-division-prelude10082:
  if (_trace) printf("binary-arithmetic-division-prelude10082:\n");
  arg2 = (u32)t4;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0318;
  goto fetchdoublefloat;
return0318:
  r0 = *(u64 *)sp;   
  LDT(2, f2, processor->fp0);   
  goto binary-arithmetic-division-prelude10079;   

basic-dispatch10107:
  if (_trace) printf("basic-dispatch10107:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment10112:
  if (_trace) printf("force-alignment10112:\n");
  if (t12 == 0) 
    goto basic-dispatch10108;
  /* Here if argument TypeSingleFloat */

binary-arithmetic-division-prelude10080:
  if (_trace) printf("binary-arithmetic-division-prelude10080:\n");
  t3 = t1;		// contagion 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0319;
  goto fetchdoublefloat;
return0319:
  r0 = *(u64 *)sp;   
  LDT(1, f1, processor->fp0);   
  goto binary-arithmetic-division-prelude10079;   

basic-dispatch10108:
  if (_trace) printf("basic-dispatch10108:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment10113:
  if (_trace) printf("force-alignment10113:\n");
  if (t12 == 0) 
    goto binary-type-dispatch10086;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto binary-arithmetic-division-prelude10080;   

basic-dispatch10106:
  if (_trace) printf("basic-dispatch10106:\n");

basic-dispatch10105:
  if (_trace) printf("basic-dispatch10105:\n");
  /* Here for all other cases */

binary-type-dispatch10085:
  if (_trace) printf("binary-type-dispatch10085:\n");

binary-arithmetic-division-prelude10083:
  if (_trace) printf("binary-arithmetic-division-prelude10083:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch10087;   

binary-type-dispatch10086:
  if (_trace) printf("binary-type-dispatch10086:\n");
  t1 = t3;
  goto binary-arithmetic-division-prelude10083;   

binary-type-dispatch10087:
  if (_trace) printf("binary-type-dispatch10087:\n");

basic-dispatch10091:
  if (_trace) printf("basic-dispatch10091:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment10119:
  if (_trace) printf("force-alignment10119:\n");
  if (t12 == 0) 
    goto basic-dispatch10092;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto binary-arithmetic-division-prelude10079;   

basic-dispatch10092:
  if (_trace) printf("basic-dispatch10092:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment10120:
  if (_trace) printf("force-alignment10120:\n");
  if (t12 == 0) 
    goto binary-type-dispatch10086;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto binary-arithmetic-division-prelude10081;   

/* end BinaryArithmeticDivisionPrelude */
/* start DoQuotient */

  /* Halfword operand from stack instruction - DoQuotient */
  /* arg2 has the preloaded 8 bit operand. */

doquotient:
  if (_trace) printf("doquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoQuotientIM:
  if (_trace) printf("DoQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoquotient;   
#ifdef TRACING
#endif

DoQuotientSP:
  if (_trace) printf("DoQuotientSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoquotient;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindoquotient;   
#endif

DoQuotientLP:
  if (_trace) printf("DoQuotientLP:\n");
#ifdef TRACING
  goto begindoquotient;   
#endif

DoQuotientFP:
  if (_trace) printf("DoQuotientFP:\n");

begindoquotient:
  if (_trace) printf("begindoquotient:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0320;
  goto binaryarithmeticdivisionprelude;
return0320:
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment10126:
  if (_trace) printf("force-alignment10126:\n");
  if (t9 == 0) 
    goto basic-dispatch10122;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   

basic-dispatch10121:
  if (_trace) printf("basic-dispatch10121:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch10122:
  if (_trace) printf("basic-dispatch10122:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment10127:
  if (_trace) printf("force-alignment10127:\n");
  if (t9 == 0) 
    goto basic-dispatch10123;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto basic-dispatch10121;   

basic-dispatch10123:
  if (_trace) printf("basic-dispatch10123:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment10128:
  if (_trace) printf("force-alignment10128:\n");
  if (t9 == 0) 
    goto basic-dispatch10121;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0321;
  goto consdoublefloat;
return0321:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto basic-dispatch10121;   

/* end DoQuotient */
  /* End of Halfword operand from stack instruction - DoQuotient */
/* start DoRationalQuotient */

  /* Halfword operand from stack instruction - DoRationalQuotient */
  /* arg2 has the preloaded 8 bit operand. */

dorationalquotient:
  if (_trace) printf("dorationalquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoRationalQuotientIM:
  if (_trace) printf("DoRationalQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindorationalquotient;   
#ifdef TRACING
#endif

DoRationalQuotientSP:
  if (_trace) printf("DoRationalQuotientSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindorationalquotient;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindorationalquotient;   
#endif

DoRationalQuotientLP:
  if (_trace) printf("DoRationalQuotientLP:\n");
#ifdef TRACING
  goto begindorationalquotient;   
#endif

DoRationalQuotientFP:
  if (_trace) printf("DoRationalQuotientFP:\n");

begindorationalquotient:
  if (_trace) printf("begindorationalquotient:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0322;
  goto binaryarithmeticdivisionprelude;
return0322:
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment10134:
  if (_trace) printf("force-alignment10134:\n");
  if (t9 == 0) 
    goto basic-dispatch10130;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQSVI(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   

basic-dispatch10129:
  if (_trace) printf("basic-dispatch10129:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch10130:
  if (_trace) printf("basic-dispatch10130:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment10135:
  if (_trace) printf("force-alignment10135:\n");
  if (t9 == 0) 
    goto basic-dispatch10131;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto basic-dispatch10129;   

basic-dispatch10131:
  if (_trace) printf("basic-dispatch10131:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment10136:
  if (_trace) printf("force-alignment10136:\n");
  if (t9 == 0) 
    goto basic-dispatch10129;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0323;
  goto consdoublefloat;
return0323:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto basic-dispatch10129;   

/* end DoRationalQuotient */
  /* End of Halfword operand from stack instruction - DoRationalQuotient */
/* start DoFloor */

  /* Halfword operand from stack instruction - DoFloor */
  /* arg2 has the preloaded 8 bit operand. */

dofloor:
  if (_trace) printf("dofloor:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoFloorIM:
  if (_trace) printf("DoFloorIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindofloor;   
#ifdef TRACING
#endif

DoFloorSP:
  if (_trace) printf("DoFloorSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindofloor;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindofloor;   
#endif

DoFloorLP:
  if (_trace) printf("DoFloorLP:\n");
#ifdef TRACING
  goto begindofloor;   
#endif

DoFloorFP:
  if (_trace) printf("DoFloorFP:\n");

begindofloor:
  if (_trace) printf("begindofloor:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0324;
  goto binaryarithmeticdivisionprelude;
return0324:
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment10142:
  if (_trace) printf("force-alignment10142:\n");
  if (t9 == 0) 
    goto basic-dispatch10138;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic-dispatch10137:
  if (_trace) printf("basic-dispatch10137:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch10138:
  if (_trace) printf("basic-dispatch10138:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment10143:
  if (_trace) printf("force-alignment10143:\n");
  if (t9 == 0) 
    goto basic-dispatch10139;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic-dispatch10137;   

basic-dispatch10139:
  if (_trace) printf("basic-dispatch10139:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment10144:
  if (_trace) printf("force-alignment10144:\n");
  if (t9 == 0) 
    goto basic-dispatch10137;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0325;
  goto consdoublefloat;
return0325:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic-dispatch10137;   

/* end DoFloor */
  /* End of Halfword operand from stack instruction - DoFloor */
/* start DoCeiling */

  /* Halfword operand from stack instruction - DoCeiling */
  /* arg2 has the preloaded 8 bit operand. */

doceiling:
  if (_trace) printf("doceiling:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoCeilingIM:
  if (_trace) printf("DoCeilingIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoceiling;   
#ifdef TRACING
#endif

DoCeilingSP:
  if (_trace) printf("DoCeilingSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoceiling;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindoceiling;   
#endif

DoCeilingLP:
  if (_trace) printf("DoCeilingLP:\n");
#ifdef TRACING
  goto begindoceiling;   
#endif

DoCeilingFP:
  if (_trace) printf("DoCeilingFP:\n");

begindoceiling:
  if (_trace) printf("begindoceiling:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0326;
  goto binaryarithmeticdivisionprelude;
return0326:
  CPYSN(2, f2, 2, f2, 2, f2);   
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  CPYSN(0, f0, 3, f3, 3, f3);   
  CVTTQ(0, f0, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment10150:
  if (_trace) printf("force-alignment10150:\n");
  if (t9 == 0) 
    goto basic-dispatch10146;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic-dispatch10145:
  if (_trace) printf("basic-dispatch10145:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch10146:
  if (_trace) printf("basic-dispatch10146:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment10151:
  if (_trace) printf("force-alignment10151:\n");
  if (t9 == 0) 
    goto basic-dispatch10147;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic-dispatch10145;   

basic-dispatch10147:
  if (_trace) printf("basic-dispatch10147:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment10152:
  if (_trace) printf("force-alignment10152:\n");
  if (t9 == 0) 
    goto basic-dispatch10145;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0327;
  goto consdoublefloat;
return0327:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic-dispatch10145;   

/* end DoCeiling */
  /* End of Halfword operand from stack instruction - DoCeiling */
/* start DoTruncate */

  /* Halfword operand from stack instruction - DoTruncate */
  /* arg2 has the preloaded 8 bit operand. */

dotruncate:
  if (_trace) printf("dotruncate:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoTruncateIM:
  if (_trace) printf("DoTruncateIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindotruncate;   
#ifdef TRACING
#endif

DoTruncateSP:
  if (_trace) printf("DoTruncateSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindotruncate;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindotruncate;   
#endif

DoTruncateLP:
  if (_trace) printf("DoTruncateLP:\n");
#ifdef TRACING
  goto begindotruncate;   
#endif

DoTruncateFP:
  if (_trace) printf("DoTruncateFP:\n");

begindotruncate:
  if (_trace) printf("begindotruncate:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0328;
  goto binaryarithmeticdivisionprelude;
return0328:
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment10158:
  if (_trace) printf("force-alignment10158:\n");
  if (t9 == 0) 
    goto basic-dispatch10154;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic-dispatch10153:
  if (_trace) printf("basic-dispatch10153:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch10154:
  if (_trace) printf("basic-dispatch10154:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment10159:
  if (_trace) printf("force-alignment10159:\n");
  if (t9 == 0) 
    goto basic-dispatch10155;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic-dispatch10153;   

basic-dispatch10155:
  if (_trace) printf("basic-dispatch10155:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment10160:
  if (_trace) printf("force-alignment10160:\n");
  if (t9 == 0) 
    goto basic-dispatch10153;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0329;
  goto consdoublefloat;
return0329:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic-dispatch10153;   

/* end DoTruncate */
  /* End of Halfword operand from stack instruction - DoTruncate */
/* start DoRound */

  /* Halfword operand from stack instruction - DoRound */
  /* arg2 has the preloaded 8 bit operand. */

doround:
  if (_trace) printf("doround:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoRoundIM:
  if (_trace) printf("DoRoundIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoround;   
#ifdef TRACING
#endif

DoRoundSP:
  if (_trace) printf("DoRoundSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoround;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindoround;   
#endif

DoRoundLP:
  if (_trace) printf("DoRoundLP:\n");
#ifdef TRACING
  goto begindoround;   
#endif

DoRoundFP:
  if (_trace) printf("DoRoundFP:\n");

begindoround:
  if (_trace) printf("begindoround:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0330;
  goto binaryarithmeticdivisionprelude;
return0330:
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQV(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment10166:
  if (_trace) printf("force-alignment10166:\n");
  if (t9 == 0) 
    goto basic-dispatch10162;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic-dispatch10161:
  if (_trace) printf("basic-dispatch10161:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch10162:
  if (_trace) printf("basic-dispatch10162:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment10167:
  if (_trace) printf("force-alignment10167:\n");
  if (t9 == 0) 
    goto basic-dispatch10163;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic-dispatch10161;   

basic-dispatch10163:
  if (_trace) printf("basic-dispatch10163:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment10168:
  if (_trace) printf("force-alignment10168:\n");
  if (t9 == 0) 
    goto basic-dispatch10161;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0331;
  goto consdoublefloat;
return0331:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic-dispatch10161;   

/* end DoRound */
  /* End of Halfword operand from stack instruction - DoRound */
  /* Other arithmetic. */
/* start DoMax */

  /* Halfword operand from stack instruction - DoMax */
  /* arg2 has the preloaded 8 bit operand. */

domax:
  if (_trace) printf("domax:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMaxIM:
  if (_trace) printf("DoMaxIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindomax;   
#ifdef TRACING
#endif

DoMaxSP:
  if (_trace) printf("DoMaxSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomax;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindomax;   
#endif

DoMaxLP:
  if (_trace) printf("DoMaxLP:\n");
#ifdef TRACING
  goto begindomax;   
#endif

DoMaxFP:
  if (_trace) printf("DoMaxFP:\n");

begindomax:
  if (_trace) printf("begindomax:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment10192:
  if (_trace) printf("force-alignment10192:\n");
  if (t10 == 0) 
    goto basic-dispatch10176;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment10181:
  if (_trace) printf("force-alignment10181:\n");
  if (t12 == 0) 
    goto basic-dispatch10178;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if ((s64)t5 > 0)   
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
		/* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;   

basic-dispatch10178:
  if (_trace) printf("basic-dispatch10178:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment10182:
  if (_trace) printf("force-alignment10182:\n");
  if (t12 == 0) 
    goto binary-type-dispatch10173;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto simple-binary-minmax10170;   

basic-dispatch10177:
  if (_trace) printf("basic-dispatch10177:\n");

basic-dispatch10176:
  if (_trace) printf("basic-dispatch10176:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment10193:
  if (_trace) printf("force-alignment10193:\n");
  if (t10 == 0) 
    goto basic-dispatch10183;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment10188:
  if (_trace) printf("force-alignment10188:\n");
  if (t12 == 0) 
    goto basic-dispatch10185;
  /* Here if argument TypeSingleFloat */

simple-binary-minmax10170:
  if (_trace) printf("simple-binary-minmax10170:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if (FLTU64(0, f0) > 0.0)   
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );   
  goto cachevalid;   

basic-dispatch10185:
  if (_trace) printf("basic-dispatch10185:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment10189:
  if (_trace) printf("force-alignment10189:\n");
  if (t12 == 0) 
    goto binary-type-dispatch10173;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto simple-binary-minmax10170;   

basic-dispatch10184:
  if (_trace) printf("basic-dispatch10184:\n");

basic-dispatch10183:
  if (_trace) printf("basic-dispatch10183:\n");
  /* Here for all other cases */

binary-type-dispatch10172:
  if (_trace) printf("binary-type-dispatch10172:\n");

simple-binary-minmax10169:
  if (_trace) printf("simple-binary-minmax10169:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch10174;   

binary-type-dispatch10173:
  if (_trace) printf("binary-type-dispatch10173:\n");
  t1 = t3;
  goto simple-binary-minmax10169;   

binary-type-dispatch10174:
  if (_trace) printf("binary-type-dispatch10174:\n");

basic-dispatch10175:
  if (_trace) printf("basic-dispatch10175:\n");

/* end DoMax */
  /* End of Halfword operand from stack instruction - DoMax */
/* start DoMin */

  /* Halfword operand from stack instruction - DoMin */
  /* arg2 has the preloaded 8 bit operand. */

domin:
  if (_trace) printf("domin:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMinIM:
  if (_trace) printf("DoMinIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindomin;   
#ifdef TRACING
#endif

DoMinSP:
  if (_trace) printf("DoMinSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomin;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindomin;   
#endif

DoMinLP:
  if (_trace) printf("DoMinLP:\n");
#ifdef TRACING
  goto begindomin;   
#endif

DoMinFP:
  if (_trace) printf("DoMinFP:\n");

begindomin:
  if (_trace) printf("begindomin:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment10217:
  if (_trace) printf("force-alignment10217:\n");
  if (t10 == 0) 
    goto basic-dispatch10201;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment10206:
  if (_trace) printf("force-alignment10206:\n");
  if (t12 == 0) 
    goto basic-dispatch10203;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if ((s64)t5 < 0)   
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
		/* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;   

basic-dispatch10203:
  if (_trace) printf("basic-dispatch10203:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment10207:
  if (_trace) printf("force-alignment10207:\n");
  if (t12 == 0) 
    goto binary-type-dispatch10198;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto simple-binary-minmax10195;   

basic-dispatch10202:
  if (_trace) printf("basic-dispatch10202:\n");

basic-dispatch10201:
  if (_trace) printf("basic-dispatch10201:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment10218:
  if (_trace) printf("force-alignment10218:\n");
  if (t10 == 0) 
    goto basic-dispatch10208;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment10213:
  if (_trace) printf("force-alignment10213:\n");
  if (t12 == 0) 
    goto basic-dispatch10210;
  /* Here if argument TypeSingleFloat */

simple-binary-minmax10195:
  if (_trace) printf("simple-binary-minmax10195:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if (FLTU64(0, f0) < 0.0)   
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );   
  goto cachevalid;   

basic-dispatch10210:
  if (_trace) printf("basic-dispatch10210:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment10214:
  if (_trace) printf("force-alignment10214:\n");
  if (t12 == 0) 
    goto binary-type-dispatch10198;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto simple-binary-minmax10195;   

basic-dispatch10209:
  if (_trace) printf("basic-dispatch10209:\n");

basic-dispatch10208:
  if (_trace) printf("basic-dispatch10208:\n");
  /* Here for all other cases */

binary-type-dispatch10197:
  if (_trace) printf("binary-type-dispatch10197:\n");

simple-binary-minmax10194:
  if (_trace) printf("simple-binary-minmax10194:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch10199;   

binary-type-dispatch10198:
  if (_trace) printf("binary-type-dispatch10198:\n");
  t1 = t3;
  goto simple-binary-minmax10194;   

binary-type-dispatch10199:
  if (_trace) printf("binary-type-dispatch10199:\n");

basic-dispatch10200:
  if (_trace) printf("basic-dispatch10200:\n");

/* end DoMin */
  /* End of Halfword operand from stack instruction - DoMin */
/* start DoMultiplyDouble */

  /* Halfword operand from stack instruction - DoMultiplyDouble */

domultiplydouble:
  if (_trace) printf("domultiplydouble:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMultiplyDoubleIM:
  if (_trace) printf("DoMultiplyDoubleIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment10219:
  if (_trace) printf("force-alignment10219:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindomultiplydouble;   
#ifdef TRACING
#endif

DoMultiplyDoubleSP:
  if (_trace) printf("DoMultiplyDoubleSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdomultiplydouble;   
#endif

DoMultiplyDoubleLP:
  if (_trace) printf("DoMultiplyDoubleLP:\n");
#ifdef TRACING
  goto headdomultiplydouble;   
#endif

DoMultiplyDoubleFP:
  if (_trace) printf("DoMultiplyDoubleFP:\n");

headdomultiplydouble:
  if (_trace) printf("headdomultiplydouble:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindomultiplydouble:
  if (_trace) printf("begindomultiplydouble:\n");
  /* arg1 has the operand, sign extended if immediate. */
  t2 = arg1 >> 32;   		// ARG2 tag 
  t3 = *(s32 *)iSP;   		// ARG1 data, sign extended 
  t4 = (s32)arg1 + (s32)0;		// ARG2 data, sign extended 
  t1 = *(s32 *)(iSP + 4);   		// ARG1 tag 
  /* TagType. */
  t1 = t1 & 63;		// Strip CDR code if any. 
  t1 = t1 - Type_Fixnum;   
  /* TagType. */
  t2 = t2 & 63;		// Strip CDR code if any. 
  t5 = t3 * t4;   		// Perform the 63 bit multiply. 
  t2 = t2 - Type_Fixnum;   
  if (t1 != 0)   
    goto muldexc;
  if (t2 != 0)   
    goto muldexc;
  t6 = (u32)t5;   		// Get the low 32 bit half. 
  t5 = (u32)(t5 >> ((4&7)*8));   		// Get the high 32 bit half. 
		/* Put the result back on the stack */
  *(u32 *)iSP = t6;
  t1 = Type_Fixnum;
		/* Push high order half */
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

muldexc:
  if (_trace) printf("muldexc:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end DoMultiplyDouble */
  /* End of Halfword operand from stack instruction - DoMultiplyDouble */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunmath.as */
