/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunmath.as
 ************************************************************************/

  /* Arithmetic. */
/* start DoUnaryMinus */

  /* Halfword operand from stack instruction - DoUnaryMinus */
  /* arg2 has the preloaded 8 bit operand. */

dounaryminus:
  if (_trace) printf("dounaryminus:\n");

DoUnaryMinusSP:
  if (_trace) printf("DoUnaryMinusSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoUnaryMinusLP:
  if (_trace) printf("DoUnaryMinusLP:\n");

DoUnaryMinusFP:
  if (_trace) printf("DoUnaryMinusFP:\n");

begindounaryminus:
  if (_trace) printf("begindounaryminus:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  arg5 = *(s32 *)(arg1 + 4);   		// tag of ARG2 
  arg6 = *(s32 *)arg1;   
  t2 = *(u64 *)&(processor->mostnegativefixnum);   
  LDS(1, f1, *(u32 *)arg1 );   
  t5 = arg5 & 63;		// Strip off any CDR code bits. 
  t4 = (t5 == Type_Fixnum) ? 1 : 0;   

force-alignment12728:
  if (_trace) printf("force-alignment12728:\n");
  if (t4 == 0) 
    goto basic-dispatch12724;
  /* Here if argument TypeFixnum */
  t2 = (s32)arg6 - (s32)t2;   
  arg2 = (s32)zero - (s32)arg6;   
  if (t2 == 0) 
    goto unaryminusexc;
  iPC = t6;
		/* Semi-cheat, we know t5 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
		/* Push the data */
  *(u32 *)(iSP + 8) = arg2;
  iSP = iSP + 8;
  goto cachevalid;   

basic-dispatch12724:
  if (_trace) printf("basic-dispatch12724:\n");
  t4 = (t5 == Type_SingleFloat) ? 1 : 0;   

force-alignment12729:
  if (_trace) printf("force-alignment12729:\n");
  if (t4 == 0) 
    goto basic-dispatch12725;
  /* Here if argument TypeSingleFloat */
  /* NIL */
  SUBS(0, f0, 3, f31, 1, f1); /* subs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = t6;
		/* Semi-cheat, we know t5 has CDRNext/TypeSingleFloat */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
  STS( (u32 *)(iSP + 8), 0, f0 );   		// Push the data 
  iSP = iSP + 8;
  goto cachevalid;   

basic-dispatch12725:
  if (_trace) printf("basic-dispatch12725:\n");
  /* Here for all other cases */

unaryminusexc:
  if (_trace) printf("unaryminusexc:\n");
  arg6 = arg5;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto unarynumericexception;

basic-dispatch12723:
  if (_trace) printf("basic-dispatch12723:\n");

DoUnaryMinusIM:
  if (_trace) printf("DoUnaryMinusIM:\n");
  arg2 = (s32)zero - (s32)arg2;   		// Negate the 8 bit immediate operand 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t7 = Type_Fixnum;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;   

/* end DoUnaryMinus */
  /* End of Halfword operand from stack instruction - DoUnaryMinus */
/* start DoMultiply */

  /* Halfword operand from stack instruction - DoMultiply */
  /* arg2 has the preloaded 8 bit operand. */

domultiply:
  if (_trace) printf("domultiply:\n");

DoMultiplySP:
  if (_trace) printf("DoMultiplySP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomultiply;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoMultiplyLP:
  if (_trace) printf("DoMultiplyLP:\n");

DoMultiplyFP:
  if (_trace) printf("DoMultiplyFP:\n");

begindomultiply:
  if (_trace) printf("begindomultiply:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  /* NIL */
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment12769:
  if (_trace) printf("force-alignment12769:\n");
  if (t10 == 0) 
    goto basic-dispatch12740;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment12746:
  if (_trace) printf("force-alignment12746:\n");
  if (t12 == 0) 
    goto basic-dispatch12742;
  /* Here if argument TypeFixnum */
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t5 = (s64)((s32)t2 * (s64)(s32)t4); /* mull/v */   		// compute 64-bit result 
  if (t5 >> 32)
    exception();  // WARNING !!! THIS IS ADJUSTED BY THE DIFF FILE
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t9;
  iPC = t6;
  *(u32 *)iSP = t5;
  iCP = t7;
  goto cachevalid;   

basic-dispatch12742:
  if (_trace) printf("basic-dispatch12742:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment12747:
  if (_trace) printf("force-alignment12747:\n");
  if (t12 == 0) 
    goto basic-dispatch12743;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple-binary-arithmetic-operation12730;   

basic-dispatch12743:
  if (_trace) printf("basic-dispatch12743:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment12748:
  if (_trace) printf("force-alignment12748:\n");
  if (t12 == 0) 
    goto binary-type-dispatch12737;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple-binary-arithmetic-operation12733;   

basic-dispatch12741:
  if (_trace) printf("basic-dispatch12741:\n");

basic-dispatch12740:
  if (_trace) printf("basic-dispatch12740:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment12770:
  if (_trace) printf("force-alignment12770:\n");
  if (t10 == 0) 
    goto basic-dispatch12749;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment12755:
  if (_trace) printf("force-alignment12755:\n");
  if (t12 == 0) 
    goto basic-dispatch12751;
  /* Here if argument TypeSingleFloat */

simple-binary-arithmetic-operation12730:
  if (_trace) printf("simple-binary-arithmetic-operation12730:\n");
  MULS(0, f0, 1, f1, 2, f2); /* muls */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto cachevalid;   

basic-dispatch12751:
  if (_trace) printf("basic-dispatch12751:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment12756:
  if (_trace) printf("force-alignment12756:\n");
  if (t12 == 0) 
    goto basic-dispatch12752;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple-binary-arithmetic-operation12730;   

basic-dispatch12752:
  if (_trace) printf("basic-dispatch12752:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment12757:
  if (_trace) printf("force-alignment12757:\n");
  if (t12 == 0) 
    goto binary-type-dispatch12737;
  /* Here if argument TypeDoubleFloat */

simple-binary-arithmetic-operation12733:
  if (_trace) printf("simple-binary-arithmetic-operation12733:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto simple-binary-arithmetic-operation12734;   

basic-dispatch12750:
  if (_trace) printf("basic-dispatch12750:\n");

basic-dispatch12749:
  if (_trace) printf("basic-dispatch12749:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

force-alignment12771:
  if (_trace) printf("force-alignment12771:\n");
  if (t10 == 0) 
    goto basic-dispatch12758;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment12764:
  if (_trace) printf("force-alignment12764:\n");
  if (t12 == 0) 
    goto basic-dispatch12760;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0409;
  goto fetchdoublefloat;
return0409:
  LDT(1, f1, processor->fp0);   

simple-binary-arithmetic-operation12734:
  if (_trace) printf("simple-binary-arithmetic-operation12734:\n");
  arg2 = (u32)t4;   
  r0 = (u64)&&return0410;
  goto fetchdoublefloat;
return0410:
  LDT(2, f2, processor->fp0);   

simple-binary-arithmetic-operation12731:
  if (_trace) printf("simple-binary-arithmetic-operation12731:\n");
  MULT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0411;
  goto consdoublefloat;
return0411:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto cachevalid;   

basic-dispatch12760:
  if (_trace) printf("basic-dispatch12760:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment12765:
  if (_trace) printf("force-alignment12765:\n");
  if (t12 == 0) 
    goto basic-dispatch12761;
  /* Here if argument TypeSingleFloat */

simple-binary-arithmetic-operation12732:
  if (_trace) printf("simple-binary-arithmetic-operation12732:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0412;
  goto fetchdoublefloat;
return0412:
  LDT(1, f1, processor->fp0);   
  goto simple-binary-arithmetic-operation12731;   

basic-dispatch12761:
  if (_trace) printf("basic-dispatch12761:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment12766:
  if (_trace) printf("force-alignment12766:\n");
  if (t12 == 0) 
    goto binary-type-dispatch12737;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple-binary-arithmetic-operation12732;   

basic-dispatch12759:
  if (_trace) printf("basic-dispatch12759:\n");

basic-dispatch12758:
  if (_trace) printf("basic-dispatch12758:\n");
  /* Here for all other cases */

binary-type-dispatch12736:
  if (_trace) printf("binary-type-dispatch12736:\n");

domulovfl:
  if (_trace) printf("domulovfl:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch12738;   

binary-type-dispatch12737:
  if (_trace) printf("binary-type-dispatch12737:\n");
  t1 = t3;
  goto domulovfl;   

binary-type-dispatch12738:
  if (_trace) printf("binary-type-dispatch12738:\n");

basic-dispatch12739:
  if (_trace) printf("basic-dispatch12739:\n");

DoMultiplyIM:
  if (_trace) printf("DoMultiplyIM:\n");
  arg2 = arg2 << 56;   
  t1 = (u32)(arg6 >> ((4&7)*8));   
  t2 = (s32)arg6;		// get ARG1 tag/data 
  arg2 = (s64)arg2 >> 56;   
  t11 = t1 & 63;		// Strip off any CDR code bits. 
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment12776:
  if (_trace) printf("force-alignment12776:\n");
  if (t12 == 0) 
    goto basic-dispatch12773;
  /* Here if argument TypeFixnum */
  t3 = t2 * arg2;   		// compute 64-bit result 
  t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t10 = (s32)t3;		// compute 32-bit sign-extended result 
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t10 = (t3 == t10) ? 1 : 0;   		// is it the same as the 64-bit result? 
  if (t10 == 0) 		// if not, we overflowed 
    goto domulovfl;
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t11;
  iPC = t4;
  *(u32 *)iSP = t3;
  iCP = t5;
  goto cachevalid;   

basic-dispatch12773:
  if (_trace) printf("basic-dispatch12773:\n");
  /* Here for all other cases */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;   
  arg2 = zero;
  goto begindomultiply;   

basic-dispatch12772:
  if (_trace) printf("basic-dispatch12772:\n");

/* end DoMultiply */
  /* End of Halfword operand from stack instruction - DoMultiply */
/* start BinaryArithmeticDivisionPrelude */


binaryarithmeticdivisionprelude:
  if (_trace) printf("binaryarithmeticdivisionprelude:\n");
  sp = sp + -8;   
  LDS(1, f1, *(u32 *)iSP );   
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment12814:
  if (_trace) printf("force-alignment12814:\n");
  if (t10 == 0) 
    goto basic-dispatch12787;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment12793:
  if (_trace) printf("force-alignment12793:\n");
  if (t12 == 0) 
    goto basic-dispatch12789;
  /* Here if argument TypeFixnum */
  CVTLQ(1, f1, f31, 1, f1);
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(1, f1, f31, 1, f1);
  CVTQT(2, f2, f31, 2, f2);

basic-dispatch12788:
  if (_trace) printf("basic-dispatch12788:\n");

basic-dispatch12786:
  if (_trace) printf("basic-dispatch12786:\n");

binary-arithmetic-division-prelude12777:
  if (_trace) printf("binary-arithmetic-division-prelude12777:\n");
  sp = sp + 8;   
  goto *r0; /* ret */

basic-dispatch12787:
  if (_trace) printf("basic-dispatch12787:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment12815:
  if (_trace) printf("force-alignment12815:\n");
  if (t10 == 0) 
    goto basic-dispatch12794;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment12800:
  if (_trace) printf("force-alignment12800:\n");
  if (t12 != 0)   
    goto binary-arithmetic-division-prelude12777;

basic-dispatch12796:
  if (_trace) printf("basic-dispatch12796:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment12801:
  if (_trace) printf("force-alignment12801:\n");
  if (t12 == 0) 
    goto basic-dispatch12797;
  /* Here if argument TypeFixnum */
  t3 = t1;		// contagion 
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto binary-arithmetic-division-prelude12777;   

basic-dispatch12797:
  if (_trace) printf("basic-dispatch12797:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment12802:
  if (_trace) printf("force-alignment12802:\n");
  if (t12 == 0) 
    goto binary-type-dispatch12784;
  /* Here if argument TypeDoubleFloat */

binary-arithmetic-division-prelude12779:
  if (_trace) printf("binary-arithmetic-division-prelude12779:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto binary-arithmetic-division-prelude12780;   

basic-dispatch12795:
  if (_trace) printf("basic-dispatch12795:\n");

basic-dispatch12794:
  if (_trace) printf("basic-dispatch12794:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

force-alignment12816:
  if (_trace) printf("force-alignment12816:\n");
  if (t10 == 0) 
    goto basic-dispatch12803;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment12809:
  if (_trace) printf("force-alignment12809:\n");
  if (t12 == 0) 
    goto basic-dispatch12805;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0413;
  goto fetchdoublefloat;
return0413:
  r0 = *(u64 *)sp;   
  LDT(1, f1, processor->fp0);   

binary-arithmetic-division-prelude12780:
  if (_trace) printf("binary-arithmetic-division-prelude12780:\n");
  arg2 = (u32)t4;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0414;
  goto fetchdoublefloat;
return0414:
  r0 = *(u64 *)sp;   
  LDT(2, f2, processor->fp0);   
  goto binary-arithmetic-division-prelude12777;   

basic-dispatch12805:
  if (_trace) printf("basic-dispatch12805:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment12810:
  if (_trace) printf("force-alignment12810:\n");
  if (t12 == 0) 
    goto basic-dispatch12806;
  /* Here if argument TypeSingleFloat */

binary-arithmetic-division-prelude12778:
  if (_trace) printf("binary-arithmetic-division-prelude12778:\n");
  t3 = t1;		// contagion 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0415;
  goto fetchdoublefloat;
return0415:
  r0 = *(u64 *)sp;   
  LDT(1, f1, processor->fp0);   
  goto binary-arithmetic-division-prelude12777;   

basic-dispatch12806:
  if (_trace) printf("basic-dispatch12806:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment12811:
  if (_trace) printf("force-alignment12811:\n");
  if (t12 == 0) 
    goto binary-type-dispatch12784;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto binary-arithmetic-division-prelude12778;   

basic-dispatch12804:
  if (_trace) printf("basic-dispatch12804:\n");

basic-dispatch12803:
  if (_trace) printf("basic-dispatch12803:\n");
  /* Here for all other cases */

binary-type-dispatch12783:
  if (_trace) printf("binary-type-dispatch12783:\n");

binary-arithmetic-division-prelude12781:
  if (_trace) printf("binary-arithmetic-division-prelude12781:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch12785;   

binary-type-dispatch12784:
  if (_trace) printf("binary-type-dispatch12784:\n");
  t1 = t3;
  goto binary-arithmetic-division-prelude12781;   

binary-type-dispatch12785:
  if (_trace) printf("binary-type-dispatch12785:\n");

basic-dispatch12789:
  if (_trace) printf("basic-dispatch12789:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment12817:
  if (_trace) printf("force-alignment12817:\n");
  if (t12 == 0) 
    goto basic-dispatch12790;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto binary-arithmetic-division-prelude12777;   

basic-dispatch12790:
  if (_trace) printf("basic-dispatch12790:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force-alignment12818:
  if (_trace) printf("force-alignment12818:\n");
  if (t12 == 0) 
    goto binary-type-dispatch12784;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto binary-arithmetic-division-prelude12779;   

/* end BinaryArithmeticDivisionPrelude */
/* start DoQuotient */

  /* Halfword operand from stack instruction - DoQuotient */
  /* arg2 has the preloaded 8 bit operand. */

doquotient:
  if (_trace) printf("doquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoQuotientIM:
  if (_trace) printf("DoQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoquotient;   

DoQuotientSP:
  if (_trace) printf("DoQuotientSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoquotient;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoQuotientLP:
  if (_trace) printf("DoQuotientLP:\n");

DoQuotientFP:
  if (_trace) printf("DoQuotientFP:\n");

begindoquotient:
  if (_trace) printf("begindoquotient:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0416;
  goto binaryarithmeticdivisionprelude;
return0416:
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment12824:
  if (_trace) printf("force-alignment12824:\n");
  if (t9 == 0) 
    goto basic-dispatch12820;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   

basic-dispatch12819:
  if (_trace) printf("basic-dispatch12819:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch12820:
  if (_trace) printf("basic-dispatch12820:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment12825:
  if (_trace) printf("force-alignment12825:\n");
  if (t9 == 0) 
    goto basic-dispatch12821;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto basic-dispatch12819;   

basic-dispatch12821:
  if (_trace) printf("basic-dispatch12821:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment12826:
  if (_trace) printf("force-alignment12826:\n");
  if (t9 == 0) 
    goto basic-dispatch12819;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0417;
  goto consdoublefloat;
return0417:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto basic-dispatch12819;   

/* end DoQuotient */
  /* End of Halfword operand from stack instruction - DoQuotient */
/* start DoRationalQuotient */

  /* Halfword operand from stack instruction - DoRationalQuotient */
  /* arg2 has the preloaded 8 bit operand. */

dorationalquotient:
  if (_trace) printf("dorationalquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoRationalQuotientIM:
  if (_trace) printf("DoRationalQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindorationalquotient;   

DoRationalQuotientSP:
  if (_trace) printf("DoRationalQuotientSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindorationalquotient;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoRationalQuotientLP:
  if (_trace) printf("DoRationalQuotientLP:\n");

DoRationalQuotientFP:
  if (_trace) printf("DoRationalQuotientFP:\n");

begindorationalquotient:
  if (_trace) printf("begindorationalquotient:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0418;
  goto binaryarithmeticdivisionprelude;
return0418:
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment12832:
  if (_trace) printf("force-alignment12832:\n");
  if (t9 == 0) 
    goto basic-dispatch12828;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQSVI(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   

basic-dispatch12827:
  if (_trace) printf("basic-dispatch12827:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch12828:
  if (_trace) printf("basic-dispatch12828:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment12833:
  if (_trace) printf("force-alignment12833:\n");
  if (t9 == 0) 
    goto basic-dispatch12829;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto basic-dispatch12827;   

basic-dispatch12829:
  if (_trace) printf("basic-dispatch12829:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment12834:
  if (_trace) printf("force-alignment12834:\n");
  if (t9 == 0) 
    goto basic-dispatch12827;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0419;
  goto consdoublefloat;
return0419:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto basic-dispatch12827;   

/* end DoRationalQuotient */
  /* End of Halfword operand from stack instruction - DoRationalQuotient */
/* start DoFloor */

  /* Halfword operand from stack instruction - DoFloor */
  /* arg2 has the preloaded 8 bit operand. */

dofloor:
  if (_trace) printf("dofloor:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoFloorIM:
  if (_trace) printf("DoFloorIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindofloor;   

DoFloorSP:
  if (_trace) printf("DoFloorSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindofloor;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoFloorLP:
  if (_trace) printf("DoFloorLP:\n");

DoFloorFP:
  if (_trace) printf("DoFloorFP:\n");

begindofloor:
  if (_trace) printf("begindofloor:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0420;
  goto binaryarithmeticdivisionprelude;
return0420:
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment12840:
  if (_trace) printf("force-alignment12840:\n");
  if (t9 == 0) 
    goto basic-dispatch12836;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic-dispatch12835:
  if (_trace) printf("basic-dispatch12835:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch12836:
  if (_trace) printf("basic-dispatch12836:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment12841:
  if (_trace) printf("force-alignment12841:\n");
  if (t9 == 0) 
    goto basic-dispatch12837;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic-dispatch12835;   

basic-dispatch12837:
  if (_trace) printf("basic-dispatch12837:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment12842:
  if (_trace) printf("force-alignment12842:\n");
  if (t9 == 0) 
    goto basic-dispatch12835;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0421;
  goto consdoublefloat;
return0421:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic-dispatch12835;   

/* end DoFloor */
  /* End of Halfword operand from stack instruction - DoFloor */
/* start DoCeiling */

  /* Halfword operand from stack instruction - DoCeiling */
  /* arg2 has the preloaded 8 bit operand. */

doceiling:
  if (_trace) printf("doceiling:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoCeilingIM:
  if (_trace) printf("DoCeilingIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoceiling;   

DoCeilingSP:
  if (_trace) printf("DoCeilingSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoceiling;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoCeilingLP:
  if (_trace) printf("DoCeilingLP:\n");

DoCeilingFP:
  if (_trace) printf("DoCeilingFP:\n");

begindoceiling:
  if (_trace) printf("begindoceiling:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0422;
  goto binaryarithmeticdivisionprelude;
return0422:
  CPYSN(2, f2, 2, f2, 2, f2);   
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  CPYSN(0, f0, 3, f3, 3, f3);   
  CVTTQ(0, f0, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment12848:
  if (_trace) printf("force-alignment12848:\n");
  if (t9 == 0) 
    goto basic-dispatch12844;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic-dispatch12843:
  if (_trace) printf("basic-dispatch12843:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch12844:
  if (_trace) printf("basic-dispatch12844:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment12849:
  if (_trace) printf("force-alignment12849:\n");
  if (t9 == 0) 
    goto basic-dispatch12845;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic-dispatch12843;   

basic-dispatch12845:
  if (_trace) printf("basic-dispatch12845:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment12850:
  if (_trace) printf("force-alignment12850:\n");
  if (t9 == 0) 
    goto basic-dispatch12843;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0423;
  goto consdoublefloat;
return0423:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic-dispatch12843;   

/* end DoCeiling */
  /* End of Halfword operand from stack instruction - DoCeiling */
/* start DoTruncate */

  /* Halfword operand from stack instruction - DoTruncate */
  /* arg2 has the preloaded 8 bit operand. */

dotruncate:
  if (_trace) printf("dotruncate:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoTruncateIM:
  if (_trace) printf("DoTruncateIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindotruncate;   

DoTruncateSP:
  if (_trace) printf("DoTruncateSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindotruncate;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoTruncateLP:
  if (_trace) printf("DoTruncateLP:\n");

DoTruncateFP:
  if (_trace) printf("DoTruncateFP:\n");

begindotruncate:
  if (_trace) printf("begindotruncate:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0424;
  goto binaryarithmeticdivisionprelude;
return0424:
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment12856:
  if (_trace) printf("force-alignment12856:\n");
  if (t9 == 0) 
    goto basic-dispatch12852;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic-dispatch12851:
  if (_trace) printf("basic-dispatch12851:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch12852:
  if (_trace) printf("basic-dispatch12852:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment12857:
  if (_trace) printf("force-alignment12857:\n");
  if (t9 == 0) 
    goto basic-dispatch12853;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic-dispatch12851;   

basic-dispatch12853:
  if (_trace) printf("basic-dispatch12853:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment12858:
  if (_trace) printf("force-alignment12858:\n");
  if (t9 == 0) 
    goto basic-dispatch12851;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0425;
  goto consdoublefloat;
return0425:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic-dispatch12851;   

/* end DoTruncate */
  /* End of Halfword operand from stack instruction - DoTruncate */
/* start DoRound */

  /* Halfword operand from stack instruction - DoRound */
  /* arg2 has the preloaded 8 bit operand. */

doround:
  if (_trace) printf("doround:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoRoundIM:
  if (_trace) printf("DoRoundIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoround;   

DoRoundSP:
  if (_trace) printf("DoRoundSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoround;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoRoundLP:
  if (_trace) printf("DoRoundLP:\n");

DoRoundFP:
  if (_trace) printf("DoRoundFP:\n");

begindoround:
  if (_trace) printf("begindoround:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0426;
  goto binaryarithmeticdivisionprelude;
return0426:
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQV(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment12864:
  if (_trace) printf("force-alignment12864:\n");
  if (t9 == 0) 
    goto basic-dispatch12860;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic-dispatch12859:
  if (_trace) printf("basic-dispatch12859:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic-dispatch12860:
  if (_trace) printf("basic-dispatch12860:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force-alignment12865:
  if (_trace) printf("force-alignment12865:\n");
  if (t9 == 0) 
    goto basic-dispatch12861;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic-dispatch12859;   

basic-dispatch12861:
  if (_trace) printf("basic-dispatch12861:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force-alignment12866:
  if (_trace) printf("force-alignment12866:\n");
  if (t9 == 0) 
    goto basic-dispatch12859;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0427;
  goto consdoublefloat;
return0427:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic-dispatch12859;   

/* end DoRound */
  /* End of Halfword operand from stack instruction - DoRound */
  /* Other arithmetic. */
/* start DoMax */

  /* Halfword operand from stack instruction - DoMax */
  /* arg2 has the preloaded 8 bit operand. */

domax:
  if (_trace) printf("domax:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoMaxIM:
  if (_trace) printf("DoMaxIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindomax;   

DoMaxSP:
  if (_trace) printf("DoMaxSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomax;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoMaxLP:
  if (_trace) printf("DoMaxLP:\n");

DoMaxFP:
  if (_trace) printf("DoMaxFP:\n");

begindomax:
  if (_trace) printf("begindomax:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment12890:
  if (_trace) printf("force-alignment12890:\n");
  if (t10 == 0) 
    goto basic-dispatch12874;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment12879:
  if (_trace) printf("force-alignment12879:\n");
  if (t12 == 0) 
    goto basic-dispatch12876;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if ((s64)t5 > 0)   
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
		/* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;   

basic-dispatch12876:
  if (_trace) printf("basic-dispatch12876:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment12880:
  if (_trace) printf("force-alignment12880:\n");
  if (t12 == 0) 
    goto binary-type-dispatch12871;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto simple-binary-minmax12868;   

basic-dispatch12875:
  if (_trace) printf("basic-dispatch12875:\n");

basic-dispatch12874:
  if (_trace) printf("basic-dispatch12874:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment12891:
  if (_trace) printf("force-alignment12891:\n");
  if (t10 == 0) 
    goto basic-dispatch12881;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment12886:
  if (_trace) printf("force-alignment12886:\n");
  if (t12 == 0) 
    goto basic-dispatch12883;
  /* Here if argument TypeSingleFloat */

simple-binary-minmax12868:
  if (_trace) printf("simple-binary-minmax12868:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if (FLTU64(0, f0) > 0.0)   
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );   
  goto cachevalid;   

basic-dispatch12883:
  if (_trace) printf("basic-dispatch12883:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment12887:
  if (_trace) printf("force-alignment12887:\n");
  if (t12 == 0) 
    goto binary-type-dispatch12871;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto simple-binary-minmax12868;   

basic-dispatch12882:
  if (_trace) printf("basic-dispatch12882:\n");

basic-dispatch12881:
  if (_trace) printf("basic-dispatch12881:\n");
  /* Here for all other cases */

binary-type-dispatch12870:
  if (_trace) printf("binary-type-dispatch12870:\n");

simple-binary-minmax12867:
  if (_trace) printf("simple-binary-minmax12867:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch12872;   

binary-type-dispatch12871:
  if (_trace) printf("binary-type-dispatch12871:\n");
  t1 = t3;
  goto simple-binary-minmax12867;   

binary-type-dispatch12872:
  if (_trace) printf("binary-type-dispatch12872:\n");

basic-dispatch12873:
  if (_trace) printf("basic-dispatch12873:\n");

/* end DoMax */
  /* End of Halfword operand from stack instruction - DoMax */
/* start DoMin */

  /* Halfword operand from stack instruction - DoMin */
  /* arg2 has the preloaded 8 bit operand. */

domin:
  if (_trace) printf("domin:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoMinIM:
  if (_trace) printf("DoMinIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindomin;   

DoMinSP:
  if (_trace) printf("DoMinSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomin;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoMinLP:
  if (_trace) printf("DoMinLP:\n");

DoMinFP:
  if (_trace) printf("DoMinFP:\n");

begindomin:
  if (_trace) printf("begindomin:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force-alignment12915:
  if (_trace) printf("force-alignment12915:\n");
  if (t10 == 0) 
    goto basic-dispatch12899;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment12904:
  if (_trace) printf("force-alignment12904:\n");
  if (t12 == 0) 
    goto basic-dispatch12901;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if ((s64)t5 < 0)   
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
		/* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;   

basic-dispatch12901:
  if (_trace) printf("basic-dispatch12901:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment12905:
  if (_trace) printf("force-alignment12905:\n");
  if (t12 == 0) 
    goto binary-type-dispatch12896;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto simple-binary-minmax12893;   

basic-dispatch12900:
  if (_trace) printf("basic-dispatch12900:\n");

basic-dispatch12899:
  if (_trace) printf("basic-dispatch12899:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force-alignment12916:
  if (_trace) printf("force-alignment12916:\n");
  if (t10 == 0) 
    goto basic-dispatch12906;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force-alignment12911:
  if (_trace) printf("force-alignment12911:\n");
  if (t12 == 0) 
    goto basic-dispatch12908;
  /* Here if argument TypeSingleFloat */

simple-binary-minmax12893:
  if (_trace) printf("simple-binary-minmax12893:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if (FLTU64(0, f0) < 0.0)   
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );   
  goto cachevalid;   

basic-dispatch12908:
  if (_trace) printf("basic-dispatch12908:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force-alignment12912:
  if (_trace) printf("force-alignment12912:\n");
  if (t12 == 0) 
    goto binary-type-dispatch12896;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto simple-binary-minmax12893;   

basic-dispatch12907:
  if (_trace) printf("basic-dispatch12907:\n");

basic-dispatch12906:
  if (_trace) printf("basic-dispatch12906:\n");
  /* Here for all other cases */

binary-type-dispatch12895:
  if (_trace) printf("binary-type-dispatch12895:\n");

simple-binary-minmax12892:
  if (_trace) printf("simple-binary-minmax12892:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary-type-dispatch12897;   

binary-type-dispatch12896:
  if (_trace) printf("binary-type-dispatch12896:\n");
  t1 = t3;
  goto simple-binary-minmax12892;   

binary-type-dispatch12897:
  if (_trace) printf("binary-type-dispatch12897:\n");

basic-dispatch12898:
  if (_trace) printf("basic-dispatch12898:\n");

/* end DoMin */
  /* End of Halfword operand from stack instruction - DoMin */
/* start DoMultiplyDouble */

  /* Halfword operand from stack instruction - DoMultiplyDouble */

domultiplydouble:
  if (_trace) printf("domultiplydouble:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoMultiplyDoubleIM:
  if (_trace) printf("DoMultiplyDoubleIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment12917:
  if (_trace) printf("force-alignment12917:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindomultiplydouble;   

DoMultiplyDoubleSP:
  if (_trace) printf("DoMultiplyDoubleSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoMultiplyDoubleLP:
  if (_trace) printf("DoMultiplyDoubleLP:\n");

DoMultiplyDoubleFP:
  if (_trace) printf("DoMultiplyDoubleFP:\n");

headdomultiplydouble:
  if (_trace) printf("headdomultiplydouble:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindomultiplydouble:
  if (_trace) printf("begindomultiplydouble:\n");
  /* arg1 has the operand, sign extended if immediate. */
  t2 = arg1 >> 32;   		// ARG2 tag 
  t3 = *(s32 *)iSP;   		// ARG1 data, sign extended 
  t4 = (s32)arg1 + (s32)0;		// ARG2 data, sign extended 
  t1 = *(s32 *)(iSP + 4);   		// ARG1 tag 
  /* TagType. */
  t1 = t1 & 63;		// Strip CDR code if any. 
  t1 = t1 - Type_Fixnum;   
  /* TagType. */
  t2 = t2 & 63;		// Strip CDR code if any. 
  t5 = t3 * t4;   		// Perform the 63 bit multiply. 
  t2 = t2 - Type_Fixnum;   
  if (t1 != 0)   
    goto muldexc;
  if (t2 != 0)   
    goto muldexc;
  t6 = (u32)t5;   		// Get the low 32 bit half. 
  t5 = (u32)(t5 >> ((4&7)*8));   		// Get the high 32 bit half. 
		/* Put the result back on the stack */
  *(u32 *)iSP = t6;
  t1 = Type_Fixnum;
		/* Push high order half */
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

muldexc:
  if (_trace) printf("muldexc:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end DoMultiplyDouble */
  /* End of Halfword operand from stack instruction - DoMultiplyDouble */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunmath.as */
