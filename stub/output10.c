/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunmath.as
 ************************************************************************/

  /* Arithmetic. */
/* start DoUnaryMinus */

  /* Halfword operand from stack instruction - DoUnaryMinus */
  /* arg2 has the preloaded 8 bit operand. */

dounaryminus:
  if (_trace) printf("dounaryminus:\n");
#ifdef TRACING
#endif

DoUnaryMinusSP:
  if (_trace) printf("DoUnaryMinusSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindounaryminus;
#endif

DoUnaryMinusLP:
  if (_trace) printf("DoUnaryMinusLP:\n");
#ifdef TRACING
  goto begindounaryminus;
#endif

DoUnaryMinusFP:
  if (_trace) printf("DoUnaryMinusFP:\n");

begindounaryminus:
  if (_trace) printf("begindounaryminus:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* tag of ARG2 */
  arg5 = *(s32 *)(arg1 + 4);
  arg6 = *(s32 *)arg1;
  t2 = *(u64 *)&(processor->mostnegativefixnum);
  LDS(1, f1, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t5 = arg5 & 63;
  t4 = (t5 == Type_Fixnum) ? 1 : 0;

g7642:
  if (_trace) printf("g7642:\n");
  if (t4 == 0)
    goto g7638;
  /* Here if argument TypeFixnum */
  t2 = (s32)arg6 - (s32)t2;
  arg2 = (s32)zero - (s32)arg6;
  if (t2 == 0)
    goto unaryminusexc;
  iPC = t6;
  /* Semi-cheat, we know t5 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
  /* Push the data */
  *(u32 *)(iSP + 8) = arg2;
  iSP = iSP + 8;
  goto cachevalid;

g7638:
  if (_trace) printf("g7638:\n");
  t4 = (t5 == Type_SingleFloat) ? 1 : 0;

g7643:
  if (_trace) printf("g7643:\n");
  if (t4 == 0)
    goto g7639;
  /* Here if argument TypeSingleFloat */
  /* NIL */
  SUBS(0, f0, 3, f31, 1, f1); /* subs */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  iPC = t6;
  /* Semi-cheat, we know t5 has CDRNext/TypeSingleFloat */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
  /* Push the data */
  STS( (u32 *)(iSP + 8), 0, f0 );
  iSP = iSP + 8;
  goto cachevalid;

g7639:
  if (_trace) printf("g7639:\n");
  /* Here for all other cases */

unaryminusexc:
  if (_trace) printf("unaryminusexc:\n");
  /* arg6 = tag to dispatch on */
  arg6 = arg5;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto unarynumericexception;

g7637:
  if (_trace) printf("g7637:\n");
#ifdef TRACING
  goto DoUnaryMinusIM;
#endif

DoUnaryMinusIM:
  if (_trace) printf("DoUnaryMinusIM:\n");
  /* Negate the 8 bit immediate operand */
  arg2 = (s32)zero - (s32)arg2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t7 = Type_Fixnum;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;

/* end DoUnaryMinus */
  /* End of Halfword operand from stack instruction - DoUnaryMinus */
/* start DoMultiply */

  /* Halfword operand from stack instruction - DoMultiply */
  /* arg2 has the preloaded 8 bit operand. */

domultiply:
  if (_trace) printf("domultiply:\n");
#ifdef TRACING
#endif

DoMultiplySP:
  if (_trace) printf("DoMultiplySP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindomultiply;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindomultiply;
#endif

DoMultiplyLP:
  if (_trace) printf("DoMultiplyLP:\n");
#ifdef TRACING
  goto begindomultiply;
#endif

DoMultiplyFP:
  if (_trace) printf("DoMultiplyFP:\n");

begindomultiply:
  if (_trace) printf("begindomultiply:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  LDS(1, f1, *(u32 *)iSP );
  /* ARG1 tag */
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  /* ARG1 data */
  t2 = (s32)arg6;
  /* ARG2 data */
  t4 = *(s32 *)arg1;
  LDS(2, f2, *(u32 *)arg1 );
  /* NIL */
  /* Strip off any CDR code bits. */
  t9 = t1 & 63;
  /* Strip off any CDR code bits. */
  t11 = t3 & 63;
  t10 = (t9 == Type_Fixnum) ? 1 : 0;

g7683:
  if (_trace) printf("g7683:\n");
  if (t10 == 0)
    goto g7654;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7660:
  if (_trace) printf("g7660:\n");
  if (t12 == 0)
    goto g7656;
  /* Here if argument TypeFixnum */
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* compute 64-bit result */
  /* compute 64-bit result */
  t5 = (s64)((s32)t2 * (s64)(s32)t4); /* mull/v */
  if (t5 >> 32)
    exception();
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  /* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t9;
  iPC = t6;
  *(u32 *)iSP = t5;
  iCP = t7;
  goto cachevalid;

g7656:
  if (_trace) printf("g7656:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7661:
  if (_trace) printf("g7661:\n");
  if (t12 == 0)
    goto g7657;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g7644;

g7657:
  if (_trace) printf("g7657:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g7662:
  if (_trace) printf("g7662:\n");
  if (t12 == 0)
    goto g7651;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g7647;

g7655:
  if (_trace) printf("g7655:\n");

g7654:
  if (_trace) printf("g7654:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;

g7684:
  if (_trace) printf("g7684:\n");
  if (t10 == 0)
    goto g7663;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7669:
  if (_trace) printf("g7669:\n");
  if (t12 == 0)
    goto g7665;
  /* Here if argument TypeSingleFloat */

g7644:
  if (_trace) printf("g7644:\n");
  MULS(0, f0, 1, f1, 2, f2); /* muls */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  goto cachevalid;

g7665:
  if (_trace) printf("g7665:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7670:
  if (_trace) printf("g7670:\n");
  if (t12 == 0)
    goto g7666;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g7644;

g7666:
  if (_trace) printf("g7666:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g7671:
  if (_trace) printf("g7671:\n");
  if (t12 == 0)
    goto g7651;
  /* Here if argument TypeDoubleFloat */

g7647:
  if (_trace) printf("g7647:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  goto g7648;

g7664:
  if (_trace) printf("g7664:\n");

g7663:
  if (_trace) printf("g7663:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;

g7685:
  if (_trace) printf("g7685:\n");
  if (t10 == 0)
    goto g7672;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g7678:
  if (_trace) printf("g7678:\n");
  if (t12 == 0)
    goto g7674;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  r0 = (u64)&&return0258;
  goto fetchdoublefloat;
return0258:
  LDT(1, f1, processor->fp0);

g7648:
  if (_trace) printf("g7648:\n");
  arg2 = (u32)t4;
  r0 = (u64)&&return0259;
  goto fetchdoublefloat;
return0259:
  LDT(2, f2, processor->fp0);

g7645:
  if (_trace) printf("g7645:\n");
  MULT(0, f0, 1, f1, 2, f2);
  STT( (u64 *)&processor->fp0, 0, f0 );
  r0 = (u64)&&return0260;
  goto consdoublefloat;
return0260:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto cachevalid;

g7674:
  if (_trace) printf("g7674:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7679:
  if (_trace) printf("g7679:\n");
  if (t12 == 0)
    goto g7675;
  /* Here if argument TypeSingleFloat */

g7646:
  if (_trace) printf("g7646:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  r0 = (u64)&&return0261;
  goto fetchdoublefloat;
return0261:
  LDT(1, f1, processor->fp0);
  goto g7645;

g7675:
  if (_trace) printf("g7675:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7680:
  if (_trace) printf("g7680:\n");
  if (t12 == 0)
    goto g7651;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g7646;

g7673:
  if (_trace) printf("g7673:\n");

g7672:
  if (_trace) printf("g7672:\n");
  /* Here for all other cases */

g7650:
  if (_trace) printf("g7650:\n");

domulovfl:
  if (_trace) printf("domulovfl:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
  goto g7652;

g7651:
  if (_trace) printf("g7651:\n");
  t1 = t3;
  goto domulovfl;

g7652:
  if (_trace) printf("g7652:\n");

g7653:
  if (_trace) printf("g7653:\n");
#ifdef TRACING
  goto DoMultiplyIM;
#endif

DoMultiplyIM:
  if (_trace) printf("DoMultiplyIM:\n");
  arg2 = arg2 << 56;
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* get ARG1 tag/data */
  t2 = (s32)arg6;
  arg2 = (s64)arg2 >> 56;
  /* Strip off any CDR code bits. */
  t11 = t1 & 63;
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7690:
  if (_trace) printf("g7690:\n");
  if (t12 == 0)
    goto g7687;
  /* Here if argument TypeFixnum */
  /* compute 64-bit result */
  t3 = t2 * arg2;
  t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* compute 32-bit sign-extended result */
  t10 = (s32)t3;
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* is it the same as the 64-bit result? */
  t10 = (t3 == t10) ? 1 : 0;
  /* if not, we overflowed */
  if (t10 == 0)
    goto domulovfl;
  /* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t11;
  iPC = t4;
  *(u32 *)iSP = t3;
  iCP = t5;
  goto cachevalid;

g7687:
  if (_trace) printf("g7687:\n");
  /* Here for all other cases */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;
  arg2 = zero;
  goto begindomultiply;

g7686:
  if (_trace) printf("g7686:\n");

/* end DoMultiply */
  /* End of Halfword operand from stack instruction - DoMultiply */
/* start BinaryArithmeticDivisionPrelude */


binaryarithmeticdivisionprelude:
  if (_trace) printf("binaryarithmeticdivisionprelude:\n");
  sp = sp + -8;
  LDS(1, f1, *(u32 *)iSP );
  /* ARG1 data */
  t2 = (s32)arg6;
  /* ARG2 data */
  t4 = *(s32 *)arg1;
  /* ARG1 tag */
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  LDS(2, f2, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t9 = t1 & 63;
  /* Strip off any CDR code bits. */
  t11 = t3 & 63;
  t10 = (t9 == Type_Fixnum) ? 1 : 0;

g7728:
  if (_trace) printf("g7728:\n");
  if (t10 == 0)
    goto g7701;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7707:
  if (_trace) printf("g7707:\n");
  if (t12 == 0)
    goto g7703;
  /* Here if argument TypeFixnum */
  CVTLQ(1, f1, f31, 1, f1);
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(1, f1, f31, 1, f1);
  CVTQT(2, f2, f31, 2, f2);

g7702:
  if (_trace) printf("g7702:\n");

g7700:
  if (_trace) printf("g7700:\n");

g7691:
  if (_trace) printf("g7691:\n");
  sp = sp + 8;
  goto *r0; /* ret */

g7701:
  if (_trace) printf("g7701:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;

g7729:
  if (_trace) printf("g7729:\n");
  if (t10 == 0)
    goto g7708;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7714:
  if (_trace) printf("g7714:\n");
  if (t12 != 0)
    goto g7691;

g7710:
  if (_trace) printf("g7710:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7715:
  if (_trace) printf("g7715:\n");
  if (t12 == 0)
    goto g7711;
  /* Here if argument TypeFixnum */
  /* contagion */
  t3 = t1;
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g7691;

g7711:
  if (_trace) printf("g7711:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g7716:
  if (_trace) printf("g7716:\n");
  if (t12 == 0)
    goto g7698;
  /* Here if argument TypeDoubleFloat */

g7693:
  if (_trace) printf("g7693:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  goto g7694;

g7709:
  if (_trace) printf("g7709:\n");

g7708:
  if (_trace) printf("g7708:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;

g7730:
  if (_trace) printf("g7730:\n");
  if (t10 == 0)
    goto g7717;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g7723:
  if (_trace) printf("g7723:\n");
  if (t12 == 0)
    goto g7719;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  *(u64 *)sp = r0;
  r0 = (u64)&&return0262;
  goto fetchdoublefloat;
return0262:
  r0 = *(u64 *)sp;
  LDT(1, f1, processor->fp0);

g7694:
  if (_trace) printf("g7694:\n");
  arg2 = (u32)t4;
  *(u64 *)sp = r0;
  r0 = (u64)&&return0263;
  goto fetchdoublefloat;
return0263:
  r0 = *(u64 *)sp;
  LDT(2, f2, processor->fp0);
  goto g7691;

g7719:
  if (_trace) printf("g7719:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7724:
  if (_trace) printf("g7724:\n");
  if (t12 == 0)
    goto g7720;
  /* Here if argument TypeSingleFloat */

g7692:
  if (_trace) printf("g7692:\n");
  /* contagion */
  t3 = t1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  *(u64 *)sp = r0;
  r0 = (u64)&&return0264;
  goto fetchdoublefloat;
return0264:
  r0 = *(u64 *)sp;
  LDT(1, f1, processor->fp0);
  goto g7691;

g7720:
  if (_trace) printf("g7720:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7725:
  if (_trace) printf("g7725:\n");
  if (t12 == 0)
    goto g7698;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g7692;

g7718:
  if (_trace) printf("g7718:\n");

g7717:
  if (_trace) printf("g7717:\n");
  /* Here for all other cases */

g7697:
  if (_trace) printf("g7697:\n");

g7695:
  if (_trace) printf("g7695:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
  goto g7699;

g7698:
  if (_trace) printf("g7698:\n");
  t1 = t3;
  goto g7695;

g7699:
  if (_trace) printf("g7699:\n");

g7703:
  if (_trace) printf("g7703:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7731:
  if (_trace) printf("g7731:\n");
  if (t12 == 0)
    goto g7704;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g7691;

g7704:
  if (_trace) printf("g7704:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g7732:
  if (_trace) printf("g7732:\n");
  if (t12 == 0)
    goto g7698;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g7693;

/* end BinaryArithmeticDivisionPrelude */
/* start DoQuotient */

  /* Halfword operand from stack instruction - DoQuotient */
  /* arg2 has the preloaded 8 bit operand. */

doquotient:
  if (_trace) printf("doquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoQuotientIM:
  if (_trace) printf("DoQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindoquotient;
#ifdef TRACING
#endif

DoQuotientSP:
  if (_trace) printf("DoQuotientSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindoquotient;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindoquotient;
#endif

DoQuotientLP:
  if (_trace) printf("DoQuotientLP:\n");
#ifdef TRACING
  goto begindoquotient;
#endif

DoQuotientFP:
  if (_trace) printf("DoQuotientFP:\n");

begindoquotient:
  if (_trace) printf("begindoquotient:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0265;
  goto binaryarithmeticdivisionprelude;
return0265:
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g7738:
  if (_trace) printf("g7738:\n");
  if (t9 == 0)
    goto g7734;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );

g7733:
  if (_trace) printf("g7733:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g7734:
  if (_trace) printf("g7734:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g7739:
  if (_trace) printf("g7739:\n");
  if (t9 == 0)
    goto g7735;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  goto g7733;

g7735:
  if (_trace) printf("g7735:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g7740:
  if (_trace) printf("g7740:\n");
  if (t9 == 0)
    goto g7733;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);
  STT( (u64 *)&processor->fp0, 0, f0 );
  r0 = (u64)&&return0266;
  goto consdoublefloat;
return0266:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto g7733;

/* end DoQuotient */
  /* End of Halfword operand from stack instruction - DoQuotient */
/* start DoRationalQuotient */

  /* Halfword operand from stack instruction - DoRationalQuotient */
  /* arg2 has the preloaded 8 bit operand. */

dorationalquotient:
  if (_trace) printf("dorationalquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoRationalQuotientIM:
  if (_trace) printf("DoRationalQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindorationalquotient;
#ifdef TRACING
#endif

DoRationalQuotientSP:
  if (_trace) printf("DoRationalQuotientSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindorationalquotient;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindorationalquotient;
#endif

DoRationalQuotientLP:
  if (_trace) printf("DoRationalQuotientLP:\n");
#ifdef TRACING
  goto begindorationalquotient;
#endif

DoRationalQuotientFP:
  if (_trace) printf("DoRationalQuotientFP:\n");

begindorationalquotient:
  if (_trace) printf("begindorationalquotient:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0267;
  goto binaryarithmeticdivisionprelude;
return0267:
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g7746:
  if (_trace) printf("g7746:\n");
  if (t9 == 0)
    goto g7742;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQSVI(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );

g7741:
  if (_trace) printf("g7741:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g7742:
  if (_trace) printf("g7742:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g7747:
  if (_trace) printf("g7747:\n");
  if (t9 == 0)
    goto g7743;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  goto g7741;

g7743:
  if (_trace) printf("g7743:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g7748:
  if (_trace) printf("g7748:\n");
  if (t9 == 0)
    goto g7741;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);
  STT( (u64 *)&processor->fp0, 0, f0 );
  r0 = (u64)&&return0268;
  goto consdoublefloat;
return0268:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto g7741;

/* end DoRationalQuotient */
  /* End of Halfword operand from stack instruction - DoRationalQuotient */
/* start DoFloor */

  /* Halfword operand from stack instruction - DoFloor */
  /* arg2 has the preloaded 8 bit operand. */

dofloor:
  if (_trace) printf("dofloor:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoFloorIM:
  if (_trace) printf("DoFloorIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindofloor;
#ifdef TRACING
#endif

DoFloorSP:
  if (_trace) printf("DoFloorSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindofloor;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindofloor;
#endif

DoFloorLP:
  if (_trace) printf("DoFloorLP:\n");
#ifdef TRACING
  goto begindofloor;
#endif

DoFloorFP:
  if (_trace) printf("DoFloorFP:\n");

begindofloor:
  if (_trace) printf("begindofloor:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0269;
  goto binaryarithmeticdivisionprelude;
return0269:
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);
  SUBT(3, f3, 1, f1, 3, f3);
  CVTQLV(0, f0, f31, 0, f0);
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g7754:
  if (_trace) printf("g7754:\n");
  if (t9 == 0)
    goto g7750;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;

g7749:
  if (_trace) printf("g7749:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g7750:
  if (_trace) printf("g7750:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g7755:
  if (_trace) printf("g7755:\n");
  if (t9 == 0)
    goto g7751;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;
  goto g7749;

g7751:
  if (_trace) printf("g7751:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g7756:
  if (_trace) printf("g7756:\n");
  if (t9 == 0)
    goto g7749;
  /* Here if argument TypeDoubleFloat */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  STT( (u64 *)&processor->fp0, 3, f3 );
  r0 = (u64)&&return0270;
  goto consdoublefloat;
return0270:
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g7749;

/* end DoFloor */
  /* End of Halfword operand from stack instruction - DoFloor */
/* start DoCeiling */

  /* Halfword operand from stack instruction - DoCeiling */
  /* arg2 has the preloaded 8 bit operand. */

doceiling:
  if (_trace) printf("doceiling:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoCeilingIM:
  if (_trace) printf("DoCeilingIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindoceiling;
#ifdef TRACING
#endif

DoCeilingSP:
  if (_trace) printf("DoCeilingSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindoceiling;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindoceiling;
#endif

DoCeilingLP:
  if (_trace) printf("DoCeilingLP:\n");
#ifdef TRACING
  goto begindoceiling;
#endif

DoCeilingFP:
  if (_trace) printf("DoCeilingFP:\n");

begindoceiling:
  if (_trace) printf("begindoceiling:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0271;
  goto binaryarithmeticdivisionprelude;
return0271:
  CPYSN(2, f2, 2, f2, 2, f2);
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  CPYSN(0, f0, 3, f3, 3, f3);
  CVTTQ(0, f0, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);
  SUBT(3, f3, 1, f1, 3, f3);
  CVTQLV(0, f0, f31, 0, f0);
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g7762:
  if (_trace) printf("g7762:\n");
  if (t9 == 0)
    goto g7758;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;

g7757:
  if (_trace) printf("g7757:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g7758:
  if (_trace) printf("g7758:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g7763:
  if (_trace) printf("g7763:\n");
  if (t9 == 0)
    goto g7759;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;
  goto g7757;

g7759:
  if (_trace) printf("g7759:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g7764:
  if (_trace) printf("g7764:\n");
  if (t9 == 0)
    goto g7757;
  /* Here if argument TypeDoubleFloat */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  STT( (u64 *)&processor->fp0, 3, f3 );
  r0 = (u64)&&return0272;
  goto consdoublefloat;
return0272:
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g7757;

/* end DoCeiling */
  /* End of Halfword operand from stack instruction - DoCeiling */
/* start DoTruncate */

  /* Halfword operand from stack instruction - DoTruncate */
  /* arg2 has the preloaded 8 bit operand. */

dotruncate:
  if (_trace) printf("dotruncate:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoTruncateIM:
  if (_trace) printf("DoTruncateIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindotruncate;
#ifdef TRACING
#endif

DoTruncateSP:
  if (_trace) printf("DoTruncateSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindotruncate;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindotruncate;
#endif

DoTruncateLP:
  if (_trace) printf("DoTruncateLP:\n");
#ifdef TRACING
  goto begindotruncate;
#endif

DoTruncateFP:
  if (_trace) printf("DoTruncateFP:\n");

begindotruncate:
  if (_trace) printf("begindotruncate:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0273;
  goto binaryarithmeticdivisionprelude;
return0273:
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);
  SUBT(3, f3, 1, f1, 3, f3);
  CVTQLV(0, f0, f31, 0, f0);
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g7770:
  if (_trace) printf("g7770:\n");
  if (t9 == 0)
    goto g7766;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;

g7765:
  if (_trace) printf("g7765:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g7766:
  if (_trace) printf("g7766:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g7771:
  if (_trace) printf("g7771:\n");
  if (t9 == 0)
    goto g7767;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;
  goto g7765;

g7767:
  if (_trace) printf("g7767:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g7772:
  if (_trace) printf("g7772:\n");
  if (t9 == 0)
    goto g7765;
  /* Here if argument TypeDoubleFloat */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  STT( (u64 *)&processor->fp0, 3, f3 );
  r0 = (u64)&&return0274;
  goto consdoublefloat;
return0274:
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g7765;

/* end DoTruncate */
  /* End of Halfword operand from stack instruction - DoTruncate */
/* start DoRound */

  /* Halfword operand from stack instruction - DoRound */
  /* arg2 has the preloaded 8 bit operand. */

doround:
  if (_trace) printf("doround:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoRoundIM:
  if (_trace) printf("DoRoundIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindoround;
#ifdef TRACING
#endif

DoRoundSP:
  if (_trace) printf("DoRoundSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindoround;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindoround;
#endif

DoRoundLP:
  if (_trace) printf("DoRoundLP:\n");
#ifdef TRACING
  goto begindoround;
#endif

DoRoundFP:
  if (_trace) printf("DoRoundFP:\n");

begindoround:
  if (_trace) printf("begindoround:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0275;
  goto binaryarithmeticdivisionprelude;
return0275:
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQV(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);
  SUBT(3, f3, 1, f1, 3, f3);
  CVTQLV(0, f0, f31, 0, f0);
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g7778:
  if (_trace) printf("g7778:\n");
  if (t9 == 0)
    goto g7774;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;

g7773:
  if (_trace) printf("g7773:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g7774:
  if (_trace) printf("g7774:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g7779:
  if (_trace) printf("g7779:\n");
  if (t9 == 0)
    goto g7775;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;
  goto g7773;

g7775:
  if (_trace) printf("g7775:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g7780:
  if (_trace) printf("g7780:\n");
  if (t9 == 0)
    goto g7773;
  /* Here if argument TypeDoubleFloat */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  STT( (u64 *)&processor->fp0, 3, f3 );
  r0 = (u64)&&return0276;
  goto consdoublefloat;
return0276:
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g7773;

/* end DoRound */
  /* End of Halfword operand from stack instruction - DoRound */
  /* Other arithmetic. */
/* start DoMax */

  /* Halfword operand from stack instruction - DoMax */
  /* arg2 has the preloaded 8 bit operand. */

domax:
  if (_trace) printf("domax:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMaxIM:
  if (_trace) printf("DoMaxIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindomax;
#ifdef TRACING
#endif

DoMaxSP:
  if (_trace) printf("DoMaxSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindomax;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindomax;
#endif

DoMaxLP:
  if (_trace) printf("DoMaxLP:\n");
#ifdef TRACING
  goto begindomax;
#endif

DoMaxFP:
  if (_trace) printf("DoMaxFP:\n");

begindomax:
  if (_trace) printf("begindomax:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  LDS(1, f1, *(u32 *)iSP );
  /* ARG1 tag */
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  /* ARG1 data */
  t2 = (s32)arg6;
  /* ARG2 data */
  t4 = *(s32 *)arg1;
  LDS(2, f2, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t9 = t1 & 63;
  /* Strip off any CDR code bits. */
  t11 = t3 & 63;
  t10 = (t9 == Type_Fixnum) ? 1 : 0;

g7804:
  if (_trace) printf("g7804:\n");
  if (t10 == 0)
    goto g7788;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7793:
  if (_trace) printf("g7793:\n");
  if (t12 == 0)
    goto g7790;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if ((s64)t5 > 0)
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;

g7790:
  if (_trace) printf("g7790:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7794:
  if (_trace) printf("g7794:\n");
  if (t12 == 0)
    goto g7785;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto g7782;

g7789:
  if (_trace) printf("g7789:\n");

g7788:
  if (_trace) printf("g7788:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;

g7805:
  if (_trace) printf("g7805:\n");
  if (t10 == 0)
    goto g7795;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7800:
  if (_trace) printf("g7800:\n");
  if (t12 == 0)
    goto g7797;
  /* Here if argument TypeSingleFloat */

g7782:
  if (_trace) printf("g7782:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if (FLTU64(0, f0) > 0.0)
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );
  goto cachevalid;

g7797:
  if (_trace) printf("g7797:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7801:
  if (_trace) printf("g7801:\n");
  if (t12 == 0)
    goto g7785;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto g7782;

g7796:
  if (_trace) printf("g7796:\n");

g7795:
  if (_trace) printf("g7795:\n");
  /* Here for all other cases */

g7784:
  if (_trace) printf("g7784:\n");

g7781:
  if (_trace) printf("g7781:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
  goto g7786;

g7785:
  if (_trace) printf("g7785:\n");
  t1 = t3;
  goto g7781;

g7786:
  if (_trace) printf("g7786:\n");

g7787:
  if (_trace) printf("g7787:\n");

/* end DoMax */
  /* End of Halfword operand from stack instruction - DoMax */
/* start DoMin */

  /* Halfword operand from stack instruction - DoMin */
  /* arg2 has the preloaded 8 bit operand. */

domin:
  if (_trace) printf("domin:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMinIM:
  if (_trace) printf("DoMinIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindomin;
#ifdef TRACING
#endif

DoMinSP:
  if (_trace) printf("DoMinSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindomin;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindomin;
#endif

DoMinLP:
  if (_trace) printf("DoMinLP:\n");
#ifdef TRACING
  goto begindomin;
#endif

DoMinFP:
  if (_trace) printf("DoMinFP:\n");

begindomin:
  if (_trace) printf("begindomin:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  LDS(1, f1, *(u32 *)iSP );
  /* ARG1 tag */
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  /* ARG1 data */
  t2 = (s32)arg6;
  /* ARG2 data */
  t4 = *(s32 *)arg1;
  LDS(2, f2, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t9 = t1 & 63;
  /* Strip off any CDR code bits. */
  t11 = t3 & 63;
  t10 = (t9 == Type_Fixnum) ? 1 : 0;

g7829:
  if (_trace) printf("g7829:\n");
  if (t10 == 0)
    goto g7813;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7818:
  if (_trace) printf("g7818:\n");
  if (t12 == 0)
    goto g7815;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if ((s64)t5 < 0)
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;

g7815:
  if (_trace) printf("g7815:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7819:
  if (_trace) printf("g7819:\n");
  if (t12 == 0)
    goto g7810;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto g7807;

g7814:
  if (_trace) printf("g7814:\n");

g7813:
  if (_trace) printf("g7813:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;

g7830:
  if (_trace) printf("g7830:\n");
  if (t10 == 0)
    goto g7820;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7825:
  if (_trace) printf("g7825:\n");
  if (t12 == 0)
    goto g7822;
  /* Here if argument TypeSingleFloat */

g7807:
  if (_trace) printf("g7807:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if (FLTU64(0, f0) < 0.0)
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );
  goto cachevalid;

g7822:
  if (_trace) printf("g7822:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7826:
  if (_trace) printf("g7826:\n");
  if (t12 == 0)
    goto g7810;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto g7807;

g7821:
  if (_trace) printf("g7821:\n");

g7820:
  if (_trace) printf("g7820:\n");
  /* Here for all other cases */

g7809:
  if (_trace) printf("g7809:\n");

g7806:
  if (_trace) printf("g7806:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
  goto g7811;

g7810:
  if (_trace) printf("g7810:\n");
  t1 = t3;
  goto g7806;

g7811:
  if (_trace) printf("g7811:\n");

g7812:
  if (_trace) printf("g7812:\n");

/* end DoMin */
  /* End of Halfword operand from stack instruction - DoMin */
/* start DoMultiplyDouble */

  /* Halfword operand from stack instruction - DoMultiplyDouble */

domultiplydouble:
  if (_trace) printf("domultiplydouble:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMultiplyDoubleIM:
  if (_trace) printf("DoMultiplyDoubleIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g7831:
  if (_trace) printf("g7831:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindomultiplydouble;
#ifdef TRACING
#endif

DoMultiplyDoubleSP:
  if (_trace) printf("DoMultiplyDoubleSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdomultiplydouble;
#endif

DoMultiplyDoubleLP:
  if (_trace) printf("DoMultiplyDoubleLP:\n");
#ifdef TRACING
  goto headdomultiplydouble;
#endif

DoMultiplyDoubleFP:
  if (_trace) printf("DoMultiplyDoubleFP:\n");

headdomultiplydouble:
  if (_trace) printf("headdomultiplydouble:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindomultiplydouble:
  if (_trace) printf("begindomultiplydouble:\n");
  /* arg1 has the operand, sign extended if immediate. */
  /* ARG2 tag */
  t2 = arg1 >> 32;
  /* ARG1 data, sign extended */
  t3 = *(s32 *)iSP;
  /* ARG2 data, sign extended */
  t4 = (s32)arg1 + (s32)0;
  /* ARG1 tag */
  t1 = *(s32 *)(iSP + 4);
  /* TagType. */
  /* Strip CDR code if any. */
  t1 = t1 & 63;
  t1 = t1 - Type_Fixnum;
  /* TagType. */
  /* Strip CDR code if any. */
  t2 = t2 & 63;
  /* Perform the 63 bit multiply. */
  t5 = t3 * t4;
  t2 = t2 - Type_Fixnum;
  if (t1 != 0)
    goto muldexc;
  if (t2 != 0)
    goto muldexc;
  /* Get the low 32 bit half. */
  t6 = (u32)t5;
  /* Get the high 32 bit half. */
  t5 = (u32)(t5 >> ((4&7)*8));
  /* Put the result back on the stack */
  *(u32 *)iSP = t6;
  t1 = Type_Fixnum;
  /* Push high order half */
  *(u32 *)(iSP + 8) = t5;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

muldexc:
  if (_trace) printf("muldexc:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end DoMultiplyDouble */
  /* End of Halfword operand from stack instruction - DoMultiplyDouble */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunmath.as */
