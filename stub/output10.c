/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunmath.as
 ************************************************************************/

  /* Arithmetic. */
/* start DoUnaryMinus */

  /* Halfword operand from stack instruction - DoUnaryMinus */
  /* arg2 has the preloaded 8 bit operand. */

dounaryminus:
  if (_trace) printf("dounaryminus:\n");

DoUnaryMinusSP:
  if (_trace) printf("DoUnaryMinusSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoUnaryMinusLP:
  if (_trace) printf("DoUnaryMinusLP:\n");

DoUnaryMinusFP:
  if (_trace) printf("DoUnaryMinusFP:\n");

begindounaryminus:
  if (_trace) printf("begindounaryminus:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  arg5 = *(s32 *)(arg1 + 4);   		// tag of ARG2 
  arg6 = *(s32 *)arg1;   
  t2 = *(u64 *)&(processor->mostnegativefixnum);   
  LDS(1, f1, *(u32 *)arg1 );   
  t5 = arg5 & 63;		// Strip off any CDR code bits. 
  t4 = (t5 == Type_Fixnum) ? 1 : 0;   

force_alignment31616:
  if (_trace) printf("force_alignment31616:\n");
  if (t4 == 0) 
    goto basic_dispatch31612;
  /* Here if argument TypeFixnum */
  t2 = (s32)arg6 - (s32)t2;   
  arg2 = (s32)zero - (s32)arg6;   
  if (t2 == 0) 
    goto unaryminusexc;
  iPC = t6;
  *(u32 *)(iSP + 12) = t5;   		// Semi-cheat, we know t5 has CDRNext/TypeFixnum 
  iCP = t7;
  *(u32 *)(iSP + 8) = arg2;   		// Push the data 
  iSP = iSP + 8;
  goto cachevalid;   

basic_dispatch31612:
  if (_trace) printf("basic_dispatch31612:\n");
  t4 = (t5 == Type_SingleFloat) ? 1 : 0;   

force_alignment31617:
  if (_trace) printf("force_alignment31617:\n");
  if (t4 == 0) 
    goto basic_dispatch31613;
  /* Here if argument TypeSingleFloat */
  /* NIL */
  SUBS(0, f0, 3, f31, 1, f1); /* subs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = t6;
  *(u32 *)(iSP + 12) = t5;   		// Semi-cheat, we know t5 has CDRNext/TypeSingleFloat 
  iCP = t7;
  STS( (u32 *)(iSP + 8), 0, f0 );   		// Push the data 
  iSP = iSP + 8;
  goto cachevalid;   

basic_dispatch31613:
  if (_trace) printf("basic_dispatch31613:\n");
  /* Here for all other cases */

unaryminusexc:
  if (_trace) printf("unaryminusexc:\n");
  arg6 = arg5;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto unarynumericexception;

basic_dispatch31611:
  if (_trace) printf("basic_dispatch31611:\n");

DoUnaryMinusIM:
  if (_trace) printf("DoUnaryMinusIM:\n");
  arg2 = (s32)zero - (s32)arg2;   		// Negate the 8 bit immediate operand 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t7 = Type_Fixnum;
  *(u32 *)(iSP + 8) = arg2;   
  *(u32 *)(iSP + 12) = t7;   		// write the stack cache 
  iSP = iSP + 8;
  goto cachevalid;   

/* end DoUnaryMinus */
  /* End of Halfword operand from stack instruction - DoUnaryMinus */
/* start DoMultiply */

  /* Halfword operand from stack instruction - DoMultiply */
  /* arg2 has the preloaded 8 bit operand. */

domultiply:
  if (_trace) printf("domultiply:\n");

DoMultiplySP:
  if (_trace) printf("DoMultiplySP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomultiply;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoMultiplyLP:
  if (_trace) printf("DoMultiplyLP:\n");

DoMultiplyFP:
  if (_trace) printf("DoMultiplyFP:\n");

begindomultiply:
  if (_trace) printf("begindomultiply:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  /* NIL */
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force_alignment31657:
  if (_trace) printf("force_alignment31657:\n");
  if (t10 == 0) 
    goto basic_dispatch31628;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment31634:
  if (_trace) printf("force_alignment31634:\n");
  if (t12 == 0) 
    goto basic_dispatch31630;
  /* Here if argument TypeFixnum */
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t5 = (s64)((s32)t2 * (s64)(s32)t4); /* mull/v */   		// compute 64-bit result 
  if (t5 >> 31) exception(3, t5);  // WARNING !!! THIS SHOULD REFLECT THE DIFF FILE
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  *(u32 *)(iSP + 4) = t9;   		// Semi-cheat, we know temp2 has CDRNext/TypeFixnum 
  iPC = t6;
  *(u32 *)iSP = t5;   
  iCP = t7;
  goto cachevalid;   

basic_dispatch31630:
  if (_trace) printf("basic_dispatch31630:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment31635:
  if (_trace) printf("force_alignment31635:\n");
  if (t12 == 0) 
    goto basic_dispatch31631;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple_binary_arithmetic_operation31618;   

basic_dispatch31631:
  if (_trace) printf("basic_dispatch31631:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force_alignment31636:
  if (_trace) printf("force_alignment31636:\n");
  if (t12 == 0) 
    goto binary_type_dispatch31625;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple_binary_arithmetic_operation31621;   

basic_dispatch31629:
  if (_trace) printf("basic_dispatch31629:\n");

basic_dispatch31628:
  if (_trace) printf("basic_dispatch31628:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force_alignment31658:
  if (_trace) printf("force_alignment31658:\n");
  if (t10 == 0) 
    goto basic_dispatch31637;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment31643:
  if (_trace) printf("force_alignment31643:\n");
  if (t12 == 0) 
    goto basic_dispatch31639;
  /* Here if argument TypeSingleFloat */

simple_binary_arithmetic_operation31618:
  if (_trace) printf("simple_binary_arithmetic_operation31618:\n");
  MULS(0, f0, 1, f1, 2, f2); /* muls */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_SingleFloat;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   
  goto cachevalid;   

basic_dispatch31639:
  if (_trace) printf("basic_dispatch31639:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment31644:
  if (_trace) printf("force_alignment31644:\n");
  if (t12 == 0) 
    goto basic_dispatch31640;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple_binary_arithmetic_operation31618;   

basic_dispatch31640:
  if (_trace) printf("basic_dispatch31640:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force_alignment31645:
  if (_trace) printf("force_alignment31645:\n");
  if (t12 == 0) 
    goto binary_type_dispatch31625;
  /* Here if argument TypeDoubleFloat */

simple_binary_arithmetic_operation31621:
  if (_trace) printf("simple_binary_arithmetic_operation31621:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto simple_binary_arithmetic_operation31622;   

basic_dispatch31638:
  if (_trace) printf("basic_dispatch31638:\n");

basic_dispatch31637:
  if (_trace) printf("basic_dispatch31637:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

force_alignment31659:
  if (_trace) printf("force_alignment31659:\n");
  if (t10 == 0) 
    goto basic_dispatch31646;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force_alignment31652:
  if (_trace) printf("force_alignment31652:\n");
  if (t12 == 0) 
    goto basic_dispatch31648;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0049;
  goto fetchdoublefloat;
return0049:
  LDT(1, f1, processor->fp0);   

simple_binary_arithmetic_operation31622:
  if (_trace) printf("simple_binary_arithmetic_operation31622:\n");
  arg2 = (u32)t4;   
  r0 = (u64)&&return0050;
  goto fetchdoublefloat;
return0050:
  LDT(2, f2, processor->fp0);   

simple_binary_arithmetic_operation31619:
  if (_trace) printf("simple_binary_arithmetic_operation31619:\n");
  MULT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0051;
  goto consdoublefloat;
return0051:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;   
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  goto cachevalid;   

basic_dispatch31648:
  if (_trace) printf("basic_dispatch31648:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment31653:
  if (_trace) printf("force_alignment31653:\n");
  if (t12 == 0) 
    goto basic_dispatch31649;
  /* Here if argument TypeSingleFloat */

simple_binary_arithmetic_operation31620:
  if (_trace) printf("simple_binary_arithmetic_operation31620:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0052;
  goto fetchdoublefloat;
return0052:
  LDT(1, f1, processor->fp0);   
  goto simple_binary_arithmetic_operation31619;   

basic_dispatch31649:
  if (_trace) printf("basic_dispatch31649:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment31654:
  if (_trace) printf("force_alignment31654:\n");
  if (t12 == 0) 
    goto binary_type_dispatch31625;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple_binary_arithmetic_operation31620;   

basic_dispatch31647:
  if (_trace) printf("basic_dispatch31647:\n");

basic_dispatch31646:
  if (_trace) printf("basic_dispatch31646:\n");
  /* Here for all other cases */

binary_type_dispatch31624:
  if (_trace) printf("binary_type_dispatch31624:\n");

domulovfl:
  if (_trace) printf("domulovfl:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary_type_dispatch31626;   

binary_type_dispatch31625:
  if (_trace) printf("binary_type_dispatch31625:\n");
  t1 = t3;
  goto domulovfl;   

binary_type_dispatch31626:
  if (_trace) printf("binary_type_dispatch31626:\n");

basic_dispatch31627:
  if (_trace) printf("basic_dispatch31627:\n");

DoMultiplyIM:
  if (_trace) printf("DoMultiplyIM:\n");
  arg2 = arg2 << 56;   
  t1 = (u32)(arg6 >> ((4&7)*8));   
  t2 = (s32)arg6;		// get ARG1 tag/data 
  arg2 = (s64)arg2 >> 56;   
  t11 = t1 & 63;		// Strip off any CDR code bits. 
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment31664:
  if (_trace) printf("force_alignment31664:\n");
  if (t12 == 0) 
    goto basic_dispatch31661;
  /* Here if argument TypeFixnum */
  t3 = t2 * arg2;   		// compute 64-bit result 
  t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t10 = (s32)t3;		// compute 32-bit sign-extended result 
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t10 = (t3 == t10) ? 1 : 0;   		// is it the same as the 64-bit result? 
  if (t10 == 0) 		// if not, we overflowed 
    goto domulovfl;
  *(u32 *)(iSP + 4) = t11;   		// Semi-cheat, we know temp2 has CDRNext/TypeFixnum 
  iPC = t4;
  *(u32 *)iSP = t3;   
  iCP = t5;
  goto cachevalid;   

basic_dispatch31661:
  if (_trace) printf("basic_dispatch31661:\n");
  /* Here for all other cases */
  *(u32 *)&processor->immediate_arg = arg2;   
  arg1 = (u64)&processor->immediate_arg;   
  arg2 = zero;
  goto begindomultiply;   

basic_dispatch31660:
  if (_trace) printf("basic_dispatch31660:\n");

/* end DoMultiply */
  /* End of Halfword operand from stack instruction - DoMultiply */
/* start BinaryArithmeticDivisionPrelude */


binaryarithmeticdivisionprelude:
  if (_trace) printf("binaryarithmeticdivisionprelude:\n");
  sp = sp + -8;   
  LDS(1, f1, *(u32 *)iSP );   
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force_alignment31702:
  if (_trace) printf("force_alignment31702:\n");
  if (t10 == 0) 
    goto basic_dispatch31675;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment31681:
  if (_trace) printf("force_alignment31681:\n");
  if (t12 == 0) 
    goto basic_dispatch31677;
  /* Here if argument TypeFixnum */
  CVTLQ(1, f1, f31, 1, f1);
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(1, f1, f31, 1, f1);
  CVTQT(2, f2, f31, 2, f2);

basic_dispatch31676:
  if (_trace) printf("basic_dispatch31676:\n");

basic_dispatch31674:
  if (_trace) printf("basic_dispatch31674:\n");

binary_arithmetic_division_prelude31665:
  if (_trace) printf("binary_arithmetic_division_prelude31665:\n");
  sp = sp + 8;   
  goto *r0; /* ret */

basic_dispatch31675:
  if (_trace) printf("basic_dispatch31675:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force_alignment31703:
  if (_trace) printf("force_alignment31703:\n");
  if (t10 == 0) 
    goto basic_dispatch31682;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment31688:
  if (_trace) printf("force_alignment31688:\n");
  if (t12 != 0)   
    goto binary_arithmetic_division_prelude31665;

basic_dispatch31684:
  if (_trace) printf("basic_dispatch31684:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment31689:
  if (_trace) printf("force_alignment31689:\n");
  if (t12 == 0) 
    goto basic_dispatch31685;
  /* Here if argument TypeFixnum */
  t3 = t1;		// contagion 
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto binary_arithmetic_division_prelude31665;   

basic_dispatch31685:
  if (_trace) printf("basic_dispatch31685:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force_alignment31690:
  if (_trace) printf("force_alignment31690:\n");
  if (t12 == 0) 
    goto binary_type_dispatch31672;
  /* Here if argument TypeDoubleFloat */

binary_arithmetic_division_prelude31667:
  if (_trace) printf("binary_arithmetic_division_prelude31667:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto binary_arithmetic_division_prelude31668;   

basic_dispatch31683:
  if (_trace) printf("basic_dispatch31683:\n");

basic_dispatch31682:
  if (_trace) printf("basic_dispatch31682:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

force_alignment31704:
  if (_trace) printf("force_alignment31704:\n");
  if (t10 == 0) 
    goto basic_dispatch31691;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force_alignment31697:
  if (_trace) printf("force_alignment31697:\n");
  if (t12 == 0) 
    goto basic_dispatch31693;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0053;
  goto fetchdoublefloat;
return0053:
  r0 = *(u64 *)sp;   
  LDT(1, f1, processor->fp0);   

binary_arithmetic_division_prelude31668:
  if (_trace) printf("binary_arithmetic_division_prelude31668:\n");
  arg2 = (u32)t4;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0054;
  goto fetchdoublefloat;
return0054:
  r0 = *(u64 *)sp;   
  LDT(2, f2, processor->fp0);   
  goto binary_arithmetic_division_prelude31665;   

basic_dispatch31693:
  if (_trace) printf("basic_dispatch31693:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment31698:
  if (_trace) printf("force_alignment31698:\n");
  if (t12 == 0) 
    goto basic_dispatch31694;
  /* Here if argument TypeSingleFloat */

binary_arithmetic_division_prelude31666:
  if (_trace) printf("binary_arithmetic_division_prelude31666:\n");
  t3 = t1;		// contagion 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0055;
  goto fetchdoublefloat;
return0055:
  r0 = *(u64 *)sp;   
  LDT(1, f1, processor->fp0);   
  goto binary_arithmetic_division_prelude31665;   

basic_dispatch31694:
  if (_trace) printf("basic_dispatch31694:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment31699:
  if (_trace) printf("force_alignment31699:\n");
  if (t12 == 0) 
    goto binary_type_dispatch31672;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto binary_arithmetic_division_prelude31666;   

basic_dispatch31692:
  if (_trace) printf("basic_dispatch31692:\n");

basic_dispatch31691:
  if (_trace) printf("basic_dispatch31691:\n");
  /* Here for all other cases */

binary_type_dispatch31671:
  if (_trace) printf("binary_type_dispatch31671:\n");

binary_arithmetic_division_prelude31669:
  if (_trace) printf("binary_arithmetic_division_prelude31669:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary_type_dispatch31673;   

binary_type_dispatch31672:
  if (_trace) printf("binary_type_dispatch31672:\n");
  t1 = t3;
  goto binary_arithmetic_division_prelude31669;   

binary_type_dispatch31673:
  if (_trace) printf("binary_type_dispatch31673:\n");

basic_dispatch31677:
  if (_trace) printf("basic_dispatch31677:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment31705:
  if (_trace) printf("force_alignment31705:\n");
  if (t12 == 0) 
    goto basic_dispatch31678;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto binary_arithmetic_division_prelude31665;   

basic_dispatch31678:
  if (_trace) printf("basic_dispatch31678:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force_alignment31706:
  if (_trace) printf("force_alignment31706:\n");
  if (t12 == 0) 
    goto binary_type_dispatch31672;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto binary_arithmetic_division_prelude31667;   

/* end BinaryArithmeticDivisionPrelude */
/* start DoQuotient */

  /* Halfword operand from stack instruction - DoQuotient */
  /* arg2 has the preloaded 8 bit operand. */

doquotient:
  if (_trace) printf("doquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoQuotientIM:
  if (_trace) printf("DoQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;   
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoquotient;   

DoQuotientSP:
  if (_trace) printf("DoQuotientSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoquotient;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoQuotientLP:
  if (_trace) printf("DoQuotientLP:\n");

DoQuotientFP:
  if (_trace) printf("DoQuotientFP:\n");

begindoquotient:
  if (_trace) printf("begindoquotient:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0056;
  goto binaryarithmeticdivisionprelude;
return0056:
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force_alignment31712:
  if (_trace) printf("force_alignment31712:\n");
  if (t9 == 0) 
    goto basic_dispatch31708;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   

basic_dispatch31707:
  if (_trace) printf("basic_dispatch31707:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic_dispatch31708:
  if (_trace) printf("basic_dispatch31708:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force_alignment31713:
  if (_trace) printf("force_alignment31713:\n");
  if (t9 == 0) 
    goto basic_dispatch31709;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   
  goto basic_dispatch31707;   

basic_dispatch31709:
  if (_trace) printf("basic_dispatch31709:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force_alignment31714:
  if (_trace) printf("force_alignment31714:\n");
  if (t9 == 0) 
    goto basic_dispatch31707;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0057;
  goto consdoublefloat;
return0057:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;   
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  goto basic_dispatch31707;   

/* end DoQuotient */
  /* End of Halfword operand from stack instruction - DoQuotient */
/* start DoRationalQuotient */

  /* Halfword operand from stack instruction - DoRationalQuotient */
  /* arg2 has the preloaded 8 bit operand. */

dorationalquotient:
  if (_trace) printf("dorationalquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoRationalQuotientIM:
  if (_trace) printf("DoRationalQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;   
  arg1 = (u64)&processor->immediate_arg;   
  goto begindorationalquotient;   

DoRationalQuotientSP:
  if (_trace) printf("DoRationalQuotientSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindorationalquotient;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoRationalQuotientLP:
  if (_trace) printf("DoRationalQuotientLP:\n");

DoRationalQuotientFP:
  if (_trace) printf("DoRationalQuotientFP:\n");

begindorationalquotient:
  if (_trace) printf("begindorationalquotient:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0058;
  goto binaryarithmeticdivisionprelude;
return0058:
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force_alignment31720:
  if (_trace) printf("force_alignment31720:\n");
  if (t9 == 0) 
    goto basic_dispatch31716;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQSVI(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   

basic_dispatch31715:
  if (_trace) printf("basic_dispatch31715:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic_dispatch31716:
  if (_trace) printf("basic_dispatch31716:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force_alignment31721:
  if (_trace) printf("force_alignment31721:\n");
  if (t9 == 0) 
    goto basic_dispatch31717;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   
  goto basic_dispatch31715;   

basic_dispatch31717:
  if (_trace) printf("basic_dispatch31717:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force_alignment31722:
  if (_trace) printf("force_alignment31722:\n");
  if (t9 == 0) 
    goto basic_dispatch31715;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0059;
  goto consdoublefloat;
return0059:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;   
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  goto basic_dispatch31715;   

/* end DoRationalQuotient */
  /* End of Halfword operand from stack instruction - DoRationalQuotient */
/* start DoFloor */

  /* Halfword operand from stack instruction - DoFloor */
  /* arg2 has the preloaded 8 bit operand. */

dofloor:
  if (_trace) printf("dofloor:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoFloorIM:
  if (_trace) printf("DoFloorIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;   
  arg1 = (u64)&processor->immediate_arg;   
  goto begindofloor;   

DoFloorSP:
  if (_trace) printf("DoFloorSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindofloor;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoFloorLP:
  if (_trace) printf("DoFloorLP:\n");

DoFloorFP:
  if (_trace) printf("DoFloorFP:\n");

begindofloor:
  if (_trace) printf("begindofloor:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0060;
  goto binaryarithmeticdivisionprelude;
return0060:
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force_alignment31728:
  if (_trace) printf("force_alignment31728:\n");
  if (t9 == 0) 
    goto basic_dispatch31724;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 12) = t8;   		// write the stack cache 
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic_dispatch31723:
  if (_trace) printf("basic_dispatch31723:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic_dispatch31724:
  if (_trace) printf("basic_dispatch31724:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force_alignment31729:
  if (_trace) printf("force_alignment31729:\n");
  if (t9 == 0) 
    goto basic_dispatch31725;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
  *(u32 *)(iSP + 12) = t8;   		// write the stack cache 
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic_dispatch31723;   

basic_dispatch31725:
  if (_trace) printf("basic_dispatch31725:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force_alignment31730:
  if (_trace) printf("force_alignment31730:\n");
  if (t9 == 0) 
    goto basic_dispatch31723;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0061;
  goto consdoublefloat;
return0061:
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;   
  *(u32 *)(iSP + 12) = t8;   		// write the stack cache 
  iSP = iSP + 8;
  goto basic_dispatch31723;   

/* end DoFloor */
  /* End of Halfword operand from stack instruction - DoFloor */
/* start DoCeiling */

  /* Halfword operand from stack instruction - DoCeiling */
  /* arg2 has the preloaded 8 bit operand. */

doceiling:
  if (_trace) printf("doceiling:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoCeilingIM:
  if (_trace) printf("DoCeilingIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;   
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoceiling;   

DoCeilingSP:
  if (_trace) printf("DoCeilingSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoceiling;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoCeilingLP:
  if (_trace) printf("DoCeilingLP:\n");

DoCeilingFP:
  if (_trace) printf("DoCeilingFP:\n");

begindoceiling:
  if (_trace) printf("begindoceiling:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0062;
  goto binaryarithmeticdivisionprelude;
return0062:
  CPYSN(2, f2, 2, f2, 2, f2);   
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  CPYSN(0, f0, 3, f3, 3, f3);   
  CVTTQ(0, f0, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force_alignment31736:
  if (_trace) printf("force_alignment31736:\n");
  if (t9 == 0) 
    goto basic_dispatch31732;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 12) = t8;   		// write the stack cache 
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic_dispatch31731:
  if (_trace) printf("basic_dispatch31731:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic_dispatch31732:
  if (_trace) printf("basic_dispatch31732:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force_alignment31737:
  if (_trace) printf("force_alignment31737:\n");
  if (t9 == 0) 
    goto basic_dispatch31733;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
  *(u32 *)(iSP + 12) = t8;   		// write the stack cache 
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic_dispatch31731;   

basic_dispatch31733:
  if (_trace) printf("basic_dispatch31733:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force_alignment31738:
  if (_trace) printf("force_alignment31738:\n");
  if (t9 == 0) 
    goto basic_dispatch31731;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0063;
  goto consdoublefloat;
return0063:
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;   
  *(u32 *)(iSP + 12) = t8;   		// write the stack cache 
  iSP = iSP + 8;
  goto basic_dispatch31731;   

/* end DoCeiling */
  /* End of Halfword operand from stack instruction - DoCeiling */
/* start DoTruncate */

  /* Halfword operand from stack instruction - DoTruncate */
  /* arg2 has the preloaded 8 bit operand. */

dotruncate:
  if (_trace) printf("dotruncate:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoTruncateIM:
  if (_trace) printf("DoTruncateIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;   
  arg1 = (u64)&processor->immediate_arg;   
  goto begindotruncate;   

DoTruncateSP:
  if (_trace) printf("DoTruncateSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindotruncate;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoTruncateLP:
  if (_trace) printf("DoTruncateLP:\n");

DoTruncateFP:
  if (_trace) printf("DoTruncateFP:\n");

begindotruncate:
  if (_trace) printf("begindotruncate:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0064;
  goto binaryarithmeticdivisionprelude;
return0064:
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force_alignment31744:
  if (_trace) printf("force_alignment31744:\n");
  if (t9 == 0) 
    goto basic_dispatch31740;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 12) = t8;   		// write the stack cache 
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic_dispatch31739:
  if (_trace) printf("basic_dispatch31739:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic_dispatch31740:
  if (_trace) printf("basic_dispatch31740:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force_alignment31745:
  if (_trace) printf("force_alignment31745:\n");
  if (t9 == 0) 
    goto basic_dispatch31741;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
  *(u32 *)(iSP + 12) = t8;   		// write the stack cache 
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic_dispatch31739;   

basic_dispatch31741:
  if (_trace) printf("basic_dispatch31741:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force_alignment31746:
  if (_trace) printf("force_alignment31746:\n");
  if (t9 == 0) 
    goto basic_dispatch31739;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0065;
  goto consdoublefloat;
return0065:
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;   
  *(u32 *)(iSP + 12) = t8;   		// write the stack cache 
  iSP = iSP + 8;
  goto basic_dispatch31739;   

/* end DoTruncate */
  /* End of Halfword operand from stack instruction - DoTruncate */
/* start DoRound */

  /* Halfword operand from stack instruction - DoRound */
  /* arg2 has the preloaded 8 bit operand. */

doround:
  if (_trace) printf("doround:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoRoundIM:
  if (_trace) printf("DoRoundIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;   
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoround;   

DoRoundSP:
  if (_trace) printf("DoRoundSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoround;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoRoundLP:
  if (_trace) printf("DoRoundLP:\n");

DoRoundFP:
  if (_trace) printf("DoRoundFP:\n");

begindoround:
  if (_trace) printf("begindoround:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0066;
  goto binaryarithmeticdivisionprelude;
return0066:
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQV(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force_alignment31752:
  if (_trace) printf("force_alignment31752:\n");
  if (t9 == 0) 
    goto basic_dispatch31748;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 12) = t8;   		// write the stack cache 
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic_dispatch31747:
  if (_trace) printf("basic_dispatch31747:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic_dispatch31748:
  if (_trace) printf("basic_dispatch31748:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force_alignment31753:
  if (_trace) printf("force_alignment31753:\n");
  if (t9 == 0) 
    goto basic_dispatch31749;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
  *(u32 *)(iSP + 12) = t8;   		// write the stack cache 
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic_dispatch31747;   

basic_dispatch31749:
  if (_trace) printf("basic_dispatch31749:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force_alignment31754:
  if (_trace) printf("force_alignment31754:\n");
  if (t9 == 0) 
    goto basic_dispatch31747;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0067;
  goto consdoublefloat;
return0067:
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;   
  *(u32 *)(iSP + 12) = t8;   		// write the stack cache 
  iSP = iSP + 8;
  goto basic_dispatch31747;   

/* end DoRound */
  /* End of Halfword operand from stack instruction - DoRound */
  /* Other arithmetic. */
/* start DoMax */

  /* Halfword operand from stack instruction - DoMax */
  /* arg2 has the preloaded 8 bit operand. */

domax:
  if (_trace) printf("domax:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoMaxIM:
  if (_trace) printf("DoMaxIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;   
  arg1 = (u64)&processor->immediate_arg;   
  goto begindomax;   

DoMaxSP:
  if (_trace) printf("DoMaxSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomax;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoMaxLP:
  if (_trace) printf("DoMaxLP:\n");

DoMaxFP:
  if (_trace) printf("DoMaxFP:\n");

begindomax:
  if (_trace) printf("begindomax:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force_alignment31778:
  if (_trace) printf("force_alignment31778:\n");
  if (t10 == 0) 
    goto basic_dispatch31762;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment31767:
  if (_trace) printf("force_alignment31767:\n");
  if (t12 == 0) 
    goto basic_dispatch31764;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if ((s64)t5 > 0)   
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u32 *)iSP = t4;   		// We know temp2 has CDRNext/TypeFixnum 
  *(u32 *)(iSP + 4) = t9;   		// write the stack cache 
  goto cachevalid;   

basic_dispatch31764:
  if (_trace) printf("basic_dispatch31764:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment31768:
  if (_trace) printf("force_alignment31768:\n");
  if (t12 == 0) 
    goto binary_type_dispatch31759;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto simple_binary_minmax31756;   

basic_dispatch31763:
  if (_trace) printf("basic_dispatch31763:\n");

basic_dispatch31762:
  if (_trace) printf("basic_dispatch31762:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force_alignment31779:
  if (_trace) printf("force_alignment31779:\n");
  if (t10 == 0) 
    goto basic_dispatch31769;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment31774:
  if (_trace) printf("force_alignment31774:\n");
  if (t12 == 0) 
    goto basic_dispatch31771;
  /* Here if argument TypeSingleFloat */

simple_binary_minmax31756:
  if (_trace) printf("simple_binary_minmax31756:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if (FLTU64(0, f0) > 0.0)   
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 2, f2 );   
  goto cachevalid;   

basic_dispatch31771:
  if (_trace) printf("basic_dispatch31771:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment31775:
  if (_trace) printf("force_alignment31775:\n");
  if (t12 == 0) 
    goto binary_type_dispatch31759;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto simple_binary_minmax31756;   

basic_dispatch31770:
  if (_trace) printf("basic_dispatch31770:\n");

basic_dispatch31769:
  if (_trace) printf("basic_dispatch31769:\n");
  /* Here for all other cases */

binary_type_dispatch31758:
  if (_trace) printf("binary_type_dispatch31758:\n");

simple_binary_minmax31755:
  if (_trace) printf("simple_binary_minmax31755:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary_type_dispatch31760;   

binary_type_dispatch31759:
  if (_trace) printf("binary_type_dispatch31759:\n");
  t1 = t3;
  goto simple_binary_minmax31755;   

binary_type_dispatch31760:
  if (_trace) printf("binary_type_dispatch31760:\n");

basic_dispatch31761:
  if (_trace) printf("basic_dispatch31761:\n");

/* end DoMax */
  /* End of Halfword operand from stack instruction - DoMax */
/* start DoMin */

  /* Halfword operand from stack instruction - DoMin */
  /* arg2 has the preloaded 8 bit operand. */

domin:
  if (_trace) printf("domin:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoMinIM:
  if (_trace) printf("DoMinIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;   
  arg1 = (u64)&processor->immediate_arg;   
  goto begindomin;   

DoMinSP:
  if (_trace) printf("DoMinSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomin;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoMinLP:
  if (_trace) printf("DoMinLP:\n");

DoMinFP:
  if (_trace) printf("DoMinFP:\n");

begindomin:
  if (_trace) printf("begindomin:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force_alignment31803:
  if (_trace) printf("force_alignment31803:\n");
  if (t10 == 0) 
    goto basic_dispatch31787;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment31792:
  if (_trace) printf("force_alignment31792:\n");
  if (t12 == 0) 
    goto basic_dispatch31789;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if ((s64)t5 < 0)   
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u32 *)iSP = t4;   		// We know temp2 has CDRNext/TypeFixnum 
  *(u32 *)(iSP + 4) = t9;   		// write the stack cache 
  goto cachevalid;   

basic_dispatch31789:
  if (_trace) printf("basic_dispatch31789:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment31793:
  if (_trace) printf("force_alignment31793:\n");
  if (t12 == 0) 
    goto binary_type_dispatch31784;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto simple_binary_minmax31781;   

basic_dispatch31788:
  if (_trace) printf("basic_dispatch31788:\n");

basic_dispatch31787:
  if (_trace) printf("basic_dispatch31787:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force_alignment31804:
  if (_trace) printf("force_alignment31804:\n");
  if (t10 == 0) 
    goto basic_dispatch31794;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment31799:
  if (_trace) printf("force_alignment31799:\n");
  if (t12 == 0) 
    goto basic_dispatch31796;
  /* Here if argument TypeSingleFloat */

simple_binary_minmax31781:
  if (_trace) printf("simple_binary_minmax31781:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if (FLTU64(0, f0) < 0.0)   
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
  *(u32 *)(iSP + 4) = t8;   		// write the stack cache 
  STS( (u32 *)iSP, 2, f2 );   
  goto cachevalid;   

basic_dispatch31796:
  if (_trace) printf("basic_dispatch31796:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment31800:
  if (_trace) printf("force_alignment31800:\n");
  if (t12 == 0) 
    goto binary_type_dispatch31784;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto simple_binary_minmax31781;   

basic_dispatch31795:
  if (_trace) printf("basic_dispatch31795:\n");

basic_dispatch31794:
  if (_trace) printf("basic_dispatch31794:\n");
  /* Here for all other cases */

binary_type_dispatch31783:
  if (_trace) printf("binary_type_dispatch31783:\n");

simple_binary_minmax31780:
  if (_trace) printf("simple_binary_minmax31780:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary_type_dispatch31785;   

binary_type_dispatch31784:
  if (_trace) printf("binary_type_dispatch31784:\n");
  t1 = t3;
  goto simple_binary_minmax31780;   

binary_type_dispatch31785:
  if (_trace) printf("binary_type_dispatch31785:\n");

basic_dispatch31786:
  if (_trace) printf("basic_dispatch31786:\n");

/* end DoMin */
  /* End of Halfword operand from stack instruction - DoMin */
/* start DoMultiplyDouble */

  /* Halfword operand from stack instruction - DoMultiplyDouble */

domultiplydouble:
  if (_trace) printf("domultiplydouble:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoMultiplyDoubleIM:
  if (_trace) printf("DoMultiplyDoubleIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force_alignment31805:
  if (_trace) printf("force_alignment31805:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;   
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindomultiplydouble;   

DoMultiplyDoubleSP:
  if (_trace) printf("DoMultiplyDoubleSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoMultiplyDoubleLP:
  if (_trace) printf("DoMultiplyDoubleLP:\n");

DoMultiplyDoubleFP:
  if (_trace) printf("DoMultiplyDoubleFP:\n");

headdomultiplydouble:
  if (_trace) printf("headdomultiplydouble:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindomultiplydouble:
  if (_trace) printf("begindomultiplydouble:\n");
  /* arg1 has the operand, sign extended if immediate. */
  t2 = arg1 >> 32;   		// ARG2 tag 
  t3 = *(s32 *)iSP;   		// ARG1 data, sign extended 
  t4 = (s32)arg1 + (s32)0;		// ARG2 data, sign extended 
  t1 = *(s32 *)(iSP + 4);   		// ARG1 tag 
  /* TagType. */
  t1 = t1 & 63;		// Strip CDR code if any. 
  t1 = t1 - Type_Fixnum;   
  /* TagType. */
  t2 = t2 & 63;		// Strip CDR code if any. 
  t5 = t3 * t4;   		// Perform the 63 bit multiply. 
  t2 = t2 - Type_Fixnum;   
  if (t1 != 0)   
    goto muldexc;
  if (t2 != 0)   
    goto muldexc;
  t6 = (u32)t5;   		// Get the low 32 bit half. 
  t5 = (u32)(t5 >> ((4&7)*8));   		// Get the high 32 bit half. 
  *(u32 *)iSP = t6;   		// Put the result back on the stack 
  t1 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t5;   		// Push high order half 
  *(u32 *)(iSP + 12) = t1;   		// write the stack cache 
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

muldexc:
  if (_trace) printf("muldexc:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end DoMultiplyDouble */
  /* End of Halfword operand from stack instruction - DoMultiplyDouble */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunmath.as */
