/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunmath.as
 ************************************************************************/

  /* Arithmetic. */
/* start DoUnaryMinus */

  /* Halfword operand from stack instruction - DoUnaryMinus */
  /* arg2 has the preloaded 8 bit operand. */

dounaryminus:
  if (_trace) printf("dounaryminus:\n");
#ifdef TRACING
#endif

DoUnaryMinusSP:
  if (_trace) printf("DoUnaryMinusSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindounaryminus;   
#endif

DoUnaryMinusLP:
  if (_trace) printf("DoUnaryMinusLP:\n");
#ifdef TRACING
  goto begindounaryminus;   
#endif

DoUnaryMinusFP:
  if (_trace) printf("DoUnaryMinusFP:\n");

begindounaryminus:
  if (_trace) printf("begindounaryminus:\n");
  /* arg1 has the operand address. */
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
		/* tag of ARG2 */
  arg5 = *(s32 *)(arg1 + 4);
  arg6 = *(s32 *)arg1;
  t2 = *(u64 *)&(processor->mostnegativefixnum);
  LDS(1, f1, *(u32 *)arg1 );   
  t5 = arg5 & 63;		// Strip off any CDR code bits. 
  t4 = (t5 == Type_Fixnum) ? 1 : 0;   

g29311:
  if (_trace) printf("g29311:\n");
  if (t4 == 0) 
    goto g29307;
  /* Here if argument TypeFixnum */
  t2 = (s32)arg6 - (s32)t2;
  arg2 = (s32)zero - (s32)arg6;
  if (t2 == 0) 
    goto unaryminusexc;
  iPC = t6;
		/* Semi-cheat, we know t5 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
		/* Push the data */
  *(u32 *)(iSP + 8) = arg2;
  iSP = iSP + 8;
  goto cachevalid;   

g29307:
  if (_trace) printf("g29307:\n");
  t4 = (t5 == Type_SingleFloat) ? 1 : 0;   

g29312:
  if (_trace) printf("g29312:\n");
  if (t4 == 0) 
    goto g29308;
  /* Here if argument TypeSingleFloat */
  /* NIL */
  SUBS(0, f0, 3, f31, 1, f1); /* subs */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = t6;
		/* Semi-cheat, we know t5 has CDRNext/TypeSingleFloat */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
  STS( (u32 *)(iSP + 8), 0, f0 );   		// Push the data 
  iSP = iSP + 8;
  goto cachevalid;   

g29308:
  if (_trace) printf("g29308:\n");
  /* Here for all other cases */

unaryminusexc:
  if (_trace) printf("unaryminusexc:\n");
  arg6 = arg5;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto unarynumericexception;

g29306:
  if (_trace) printf("g29306:\n");
#ifdef TRACING
  goto DoUnaryMinusIM;   
#endif

DoUnaryMinusIM:
  if (_trace) printf("DoUnaryMinusIM:\n");
		/* Negate the 8 bit immediate operand */
  arg2 = (s32)zero - (s32)arg2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t7 = Type_Fixnum;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;   

/* end DoUnaryMinus */
  /* End of Halfword operand from stack instruction - DoUnaryMinus */
/* start DoMultiply */

  /* Halfword operand from stack instruction - DoMultiply */
  /* arg2 has the preloaded 8 bit operand. */

domultiply:
  if (_trace) printf("domultiply:\n");
#ifdef TRACING
#endif

DoMultiplySP:
  if (_trace) printf("DoMultiplySP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomultiply;
		/* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindomultiply;   
#endif

DoMultiplyLP:
  if (_trace) printf("DoMultiplyLP:\n");
#ifdef TRACING
  goto begindomultiply;   
#endif

DoMultiplyFP:
  if (_trace) printf("DoMultiplyFP:\n");

begindomultiply:
  if (_trace) printf("begindomultiply:\n");
  /* arg1 has the operand address. */
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
		/* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  t2 = (s32)arg6;		// ARG1 data 
		/* ARG2 data */
  t4 = *(s32 *)arg1;
  LDS(2, f2, *(u32 *)arg1 );   
  /* NIL */
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

g29352:
  if (_trace) printf("g29352:\n");
  if (t10 == 0) 
    goto g29323;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

g29329:
  if (_trace) printf("g29329:\n");
  if (t12 == 0) 
    goto g29325;
  /* Here if argument TypeFixnum */
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  t5 = (s64)((s32)t2 * (s64)(s32)t4); /* mull/v */   		// compute 64-bit result 
  if (t5 >> 32)
    exception();  // WARNING !!! THIS IS ADJUSTED BY THE DIFF FILE
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t9;
  iPC = t6;
  *(u32 *)iSP = t5;
  iCP = t7;
  goto cachevalid;   

g29325:
  if (_trace) printf("g29325:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

g29330:
  if (_trace) printf("g29330:\n");
  if (t12 == 0) 
    goto g29326;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g29313;   

g29326:
  if (_trace) printf("g29326:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

g29331:
  if (_trace) printf("g29331:\n");
  if (t12 == 0) 
    goto g29320;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g29316;   

g29324:
  if (_trace) printf("g29324:\n");

g29323:
  if (_trace) printf("g29323:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

g29353:
  if (_trace) printf("g29353:\n");
  if (t10 == 0) 
    goto g29332;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

g29338:
  if (_trace) printf("g29338:\n");
  if (t12 == 0) 
    goto g29334;
  /* Here if argument TypeSingleFloat */

g29313:
  if (_trace) printf("g29313:\n");
  MULS(0, f0, 1, f1, 2, f2); /* muls */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto cachevalid;   

g29334:
  if (_trace) printf("g29334:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

g29339:
  if (_trace) printf("g29339:\n");
  if (t12 == 0) 
    goto g29335;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g29313;   

g29335:
  if (_trace) printf("g29335:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

g29340:
  if (_trace) printf("g29340:\n");
  if (t12 == 0) 
    goto g29320;
  /* Here if argument TypeDoubleFloat */

g29316:
  if (_trace) printf("g29316:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  goto g29317;   

g29333:
  if (_trace) printf("g29333:\n");

g29332:
  if (_trace) printf("g29332:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

g29354:
  if (_trace) printf("g29354:\n");
  if (t10 == 0) 
    goto g29341;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

g29347:
  if (_trace) printf("g29347:\n");
  if (t12 == 0) 
    goto g29343;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;   
  r0 = (u64)&&return0626;
  goto fetchdoublefloat;
return0626:
  LDT(1, f1, processor->fp0);   

g29317:
  if (_trace) printf("g29317:\n");
  arg2 = (u32)t4;   
  r0 = (u64)&&return0627;
  goto fetchdoublefloat;
return0627:
  LDT(2, f2, processor->fp0);   

g29314:
  if (_trace) printf("g29314:\n");
  MULT(0, f0, 1, f1, 2, f2);
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0628;
  goto consdoublefloat;
return0628:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto cachevalid;   

g29343:
  if (_trace) printf("g29343:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

g29348:
  if (_trace) printf("g29348:\n");
  if (t12 == 0) 
    goto g29344;
  /* Here if argument TypeSingleFloat */

g29315:
  if (_trace) printf("g29315:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;   
  r0 = (u64)&&return0629;
  goto fetchdoublefloat;
return0629:
  LDT(1, f1, processor->fp0);   
  goto g29314;   

g29344:
  if (_trace) printf("g29344:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

g29349:
  if (_trace) printf("g29349:\n");
  if (t12 == 0) 
    goto g29320;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g29315;   

g29342:
  if (_trace) printf("g29342:\n");

g29341:
  if (_trace) printf("g29341:\n");
  /* Here for all other cases */

g29319:
  if (_trace) printf("g29319:\n");

domulovfl:
  if (_trace) printf("domulovfl:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto g29321;   

g29320:
  if (_trace) printf("g29320:\n");
  t1 = t3;
  goto domulovfl;   

g29321:
  if (_trace) printf("g29321:\n");

g29322:
  if (_trace) printf("g29322:\n");
#ifdef TRACING
  goto DoMultiplyIM;   
#endif

DoMultiplyIM:
  if (_trace) printf("DoMultiplyIM:\n");
  arg2 = arg2 << 56;
  t1 = (u32)(arg6 >> ((4&7)*8));   
  t2 = (s32)arg6;		// get ARG1 tag/data 
  arg2 = (s64)arg2 >> 56;
  t11 = t1 & 63;		// Strip off any CDR code bits. 
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

g29359:
  if (_trace) printf("g29359:\n");
  if (t12 == 0) 
    goto g29356;
  /* Here if argument TypeFixnum */
		/* compute 64-bit result */
  t3 = t2 * arg2;
  t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  t10 = (s32)t3;		// compute 32-bit sign-extended result 
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t10 = (t3 == t10) ? 1 : 0;   		// is it the same as the 64-bit result? 
  if (t10 == 0) 		// if not, we overflowed 
    goto domulovfl;
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t11;
  iPC = t4;
  *(u32 *)iSP = t3;
  iCP = t5;
  goto cachevalid;   

g29356:
  if (_trace) printf("g29356:\n");
  /* Here for all other cases */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;   
  arg2 = zero;
  goto begindomultiply;   

g29355:
  if (_trace) printf("g29355:\n");

/* end DoMultiply */
  /* End of Halfword operand from stack instruction - DoMultiply */
/* start BinaryArithmeticDivisionPrelude */


binaryarithmeticdivisionprelude:
  if (_trace) printf("binaryarithmeticdivisionprelude:\n");
  sp = sp + -8;   
  LDS(1, f1, *(u32 *)iSP );   
  t2 = (s32)arg6;		// ARG1 data 
		/* ARG2 data */
  t4 = *(s32 *)arg1;
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
		/* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

g29397:
  if (_trace) printf("g29397:\n");
  if (t10 == 0) 
    goto g29370;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

g29376:
  if (_trace) printf("g29376:\n");
  if (t12 == 0) 
    goto g29372;
  /* Here if argument TypeFixnum */
  CVTLQ(1, f1, f31, 1, f1);
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(1, f1, f31, 1, f1);
  CVTQT(2, f2, f31, 2, f2);

g29371:
  if (_trace) printf("g29371:\n");

g29369:
  if (_trace) printf("g29369:\n");

g29360:
  if (_trace) printf("g29360:\n");
  sp = sp + 8;   
  goto *r0; /* ret */

g29370:
  if (_trace) printf("g29370:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

g29398:
  if (_trace) printf("g29398:\n");
  if (t10 == 0) 
    goto g29377;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

g29383:
  if (_trace) printf("g29383:\n");
  if (t12 != 0)   
    goto g29360;

g29379:
  if (_trace) printf("g29379:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

g29384:
  if (_trace) printf("g29384:\n");
  if (t12 == 0) 
    goto g29380;
  /* Here if argument TypeFixnum */
  t3 = t1;		// contagion 
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g29360;   

g29380:
  if (_trace) printf("g29380:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

g29385:
  if (_trace) printf("g29385:\n");
  if (t12 == 0) 
    goto g29367;
  /* Here if argument TypeDoubleFloat */

g29362:
  if (_trace) printf("g29362:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  goto g29363;   

g29378:
  if (_trace) printf("g29378:\n");

g29377:
  if (_trace) printf("g29377:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

g29399:
  if (_trace) printf("g29399:\n");
  if (t10 == 0) 
    goto g29386;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

g29392:
  if (_trace) printf("g29392:\n");
  if (t12 == 0) 
    goto g29388;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;   
  *(u64 *)sp = r0;
  r0 = (u64)&&return0630;
  goto fetchdoublefloat;
return0630:
  r0 = *(u64 *)sp;
  LDT(1, f1, processor->fp0);   

g29363:
  if (_trace) printf("g29363:\n");
  arg2 = (u32)t4;   
  *(u64 *)sp = r0;
  r0 = (u64)&&return0631;
  goto fetchdoublefloat;
return0631:
  r0 = *(u64 *)sp;
  LDT(2, f2, processor->fp0);   
  goto g29360;   

g29388:
  if (_trace) printf("g29388:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

g29393:
  if (_trace) printf("g29393:\n");
  if (t12 == 0) 
    goto g29389;
  /* Here if argument TypeSingleFloat */

g29361:
  if (_trace) printf("g29361:\n");
  t3 = t1;		// contagion 
  t11 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;   
  *(u64 *)sp = r0;
  r0 = (u64)&&return0632;
  goto fetchdoublefloat;
return0632:
  r0 = *(u64 *)sp;
  LDT(1, f1, processor->fp0);   
  goto g29360;   

g29389:
  if (_trace) printf("g29389:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

g29394:
  if (_trace) printf("g29394:\n");
  if (t12 == 0) 
    goto g29367;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g29361;   

g29387:
  if (_trace) printf("g29387:\n");

g29386:
  if (_trace) printf("g29386:\n");
  /* Here for all other cases */

g29366:
  if (_trace) printf("g29366:\n");

g29364:
  if (_trace) printf("g29364:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto g29368;   

g29367:
  if (_trace) printf("g29367:\n");
  t1 = t3;
  goto g29364;   

g29368:
  if (_trace) printf("g29368:\n");

g29372:
  if (_trace) printf("g29372:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

g29400:
  if (_trace) printf("g29400:\n");
  if (t12 == 0) 
    goto g29373;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g29360;   

g29373:
  if (_trace) printf("g29373:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

g29401:
  if (_trace) printf("g29401:\n");
  if (t12 == 0) 
    goto g29367;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g29362;   

/* end BinaryArithmeticDivisionPrelude */
/* start DoQuotient */

  /* Halfword operand from stack instruction - DoQuotient */
  /* arg2 has the preloaded 8 bit operand. */

doquotient:
  if (_trace) printf("doquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoQuotientIM:
  if (_trace) printf("DoQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
		/* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
		/* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoquotient;   
#ifdef TRACING
#endif

DoQuotientSP:
  if (_trace) printf("DoQuotientSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoquotient;
		/* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindoquotient;   
#endif

DoQuotientLP:
  if (_trace) printf("DoQuotientLP:\n");
#ifdef TRACING
  goto begindoquotient;   
#endif

DoQuotientFP:
  if (_trace) printf("DoQuotientFP:\n");

begindoquotient:
  if (_trace) printf("begindoquotient:\n");
  /* arg1 has the operand address. */
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0633;
  goto binaryarithmeticdivisionprelude;
return0633:
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

g29407:
  if (_trace) printf("g29407:\n");
  if (t9 == 0) 
    goto g29403;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   

g29402:
  if (_trace) printf("g29402:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;   

g29403:
  if (_trace) printf("g29403:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

g29408:
  if (_trace) printf("g29408:\n");
  if (t9 == 0) 
    goto g29404;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto g29402;   

g29404:
  if (_trace) printf("g29404:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

g29409:
  if (_trace) printf("g29409:\n");
  if (t9 == 0) 
    goto g29402;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0634;
  goto consdoublefloat;
return0634:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto g29402;   

/* end DoQuotient */
  /* End of Halfword operand from stack instruction - DoQuotient */
/* start DoRationalQuotient */

  /* Halfword operand from stack instruction - DoRationalQuotient */
  /* arg2 has the preloaded 8 bit operand. */

dorationalquotient:
  if (_trace) printf("dorationalquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoRationalQuotientIM:
  if (_trace) printf("DoRationalQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
		/* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
		/* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindorationalquotient;   
#ifdef TRACING
#endif

DoRationalQuotientSP:
  if (_trace) printf("DoRationalQuotientSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindorationalquotient;
		/* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindorationalquotient;   
#endif

DoRationalQuotientLP:
  if (_trace) printf("DoRationalQuotientLP:\n");
#ifdef TRACING
  goto begindorationalquotient;   
#endif

DoRationalQuotientFP:
  if (_trace) printf("DoRationalQuotientFP:\n");

begindorationalquotient:
  if (_trace) printf("begindorationalquotient:\n");
  /* arg1 has the operand address. */
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0635;
  goto binaryarithmeticdivisionprelude;
return0635:
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

g29415:
  if (_trace) printf("g29415:\n");
  if (t9 == 0) 
    goto g29411;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQSVI(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   

g29410:
  if (_trace) printf("g29410:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;   

g29411:
  if (_trace) printf("g29411:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

g29416:
  if (_trace) printf("g29416:\n");
  if (t9 == 0) 
    goto g29412;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto g29410;   

g29412:
  if (_trace) printf("g29412:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

g29417:
  if (_trace) printf("g29417:\n");
  if (t9 == 0) 
    goto g29410;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0636;
  goto consdoublefloat;
return0636:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto g29410;   

/* end DoRationalQuotient */
  /* End of Halfword operand from stack instruction - DoRationalQuotient */
/* start DoFloor */

  /* Halfword operand from stack instruction - DoFloor */
  /* arg2 has the preloaded 8 bit operand. */

dofloor:
  if (_trace) printf("dofloor:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoFloorIM:
  if (_trace) printf("DoFloorIM:\n");
  /* This sequence only sucks a moderate amount */
		/* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
		/* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindofloor;   
#ifdef TRACING
#endif

DoFloorSP:
  if (_trace) printf("DoFloorSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindofloor;
		/* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindofloor;   
#endif

DoFloorLP:
  if (_trace) printf("DoFloorLP:\n");
#ifdef TRACING
  goto begindofloor;   
#endif

DoFloorFP:
  if (_trace) printf("DoFloorFP:\n");

begindofloor:
  if (_trace) printf("begindofloor:\n");
  /* arg1 has the operand address. */
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0637;
  goto binaryarithmeticdivisionprelude;
return0637:
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);
  SUBT(3, f3, 1, f1, 3, f3);
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

g29423:
  if (_trace) printf("g29423:\n");
  if (t9 == 0) 
    goto g29419;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

g29418:
  if (_trace) printf("g29418:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;   

g29419:
  if (_trace) printf("g29419:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

g29424:
  if (_trace) printf("g29424:\n");
  if (t9 == 0) 
    goto g29420;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto g29418;   

g29420:
  if (_trace) printf("g29420:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

g29425:
  if (_trace) printf("g29425:\n");
  if (t9 == 0) 
    goto g29418;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0638;
  goto consdoublefloat;
return0638:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g29418;   

/* end DoFloor */
  /* End of Halfword operand from stack instruction - DoFloor */
/* start DoCeiling */

  /* Halfword operand from stack instruction - DoCeiling */
  /* arg2 has the preloaded 8 bit operand. */

doceiling:
  if (_trace) printf("doceiling:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoCeilingIM:
  if (_trace) printf("DoCeilingIM:\n");
  /* This sequence only sucks a moderate amount */
		/* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
		/* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoceiling;   
#ifdef TRACING
#endif

DoCeilingSP:
  if (_trace) printf("DoCeilingSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoceiling;
		/* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindoceiling;   
#endif

DoCeilingLP:
  if (_trace) printf("DoCeilingLP:\n");
#ifdef TRACING
  goto begindoceiling;   
#endif

DoCeilingFP:
  if (_trace) printf("DoCeilingFP:\n");

begindoceiling:
  if (_trace) printf("begindoceiling:\n");
  /* arg1 has the operand address. */
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0639;
  goto binaryarithmeticdivisionprelude;
return0639:
  CPYSN(2, f2, 2, f2, 2, f2);   
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  CPYSN(0, f0, 3, f3, 3, f3);   
  CVTTQ(0, f0, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);
  SUBT(3, f3, 1, f1, 3, f3);
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

g29431:
  if (_trace) printf("g29431:\n");
  if (t9 == 0) 
    goto g29427;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

g29426:
  if (_trace) printf("g29426:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;   

g29427:
  if (_trace) printf("g29427:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

g29432:
  if (_trace) printf("g29432:\n");
  if (t9 == 0) 
    goto g29428;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto g29426;   

g29428:
  if (_trace) printf("g29428:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

g29433:
  if (_trace) printf("g29433:\n");
  if (t9 == 0) 
    goto g29426;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0640;
  goto consdoublefloat;
return0640:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g29426;   

/* end DoCeiling */
  /* End of Halfword operand from stack instruction - DoCeiling */
/* start DoTruncate */

  /* Halfword operand from stack instruction - DoTruncate */
  /* arg2 has the preloaded 8 bit operand. */

dotruncate:
  if (_trace) printf("dotruncate:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoTruncateIM:
  if (_trace) printf("DoTruncateIM:\n");
  /* This sequence only sucks a moderate amount */
		/* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
		/* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindotruncate;   
#ifdef TRACING
#endif

DoTruncateSP:
  if (_trace) printf("DoTruncateSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindotruncate;
		/* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindotruncate;   
#endif

DoTruncateLP:
  if (_trace) printf("DoTruncateLP:\n");
#ifdef TRACING
  goto begindotruncate;   
#endif

DoTruncateFP:
  if (_trace) printf("DoTruncateFP:\n");

begindotruncate:
  if (_trace) printf("begindotruncate:\n");
  /* arg1 has the operand address. */
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0641;
  goto binaryarithmeticdivisionprelude;
return0641:
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);
  SUBT(3, f3, 1, f1, 3, f3);
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

g29439:
  if (_trace) printf("g29439:\n");
  if (t9 == 0) 
    goto g29435;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

g29434:
  if (_trace) printf("g29434:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;   

g29435:
  if (_trace) printf("g29435:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

g29440:
  if (_trace) printf("g29440:\n");
  if (t9 == 0) 
    goto g29436;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto g29434;   

g29436:
  if (_trace) printf("g29436:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

g29441:
  if (_trace) printf("g29441:\n");
  if (t9 == 0) 
    goto g29434;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0642;
  goto consdoublefloat;
return0642:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g29434;   

/* end DoTruncate */
  /* End of Halfword operand from stack instruction - DoTruncate */
/* start DoRound */

  /* Halfword operand from stack instruction - DoRound */
  /* arg2 has the preloaded 8 bit operand. */

doround:
  if (_trace) printf("doround:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoRoundIM:
  if (_trace) printf("DoRoundIM:\n");
  /* This sequence only sucks a moderate amount */
		/* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
		/* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoround;   
#ifdef TRACING
#endif

DoRoundSP:
  if (_trace) printf("DoRoundSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoround;
		/* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindoround;   
#endif

DoRoundLP:
  if (_trace) printf("DoRoundLP:\n");
#ifdef TRACING
  goto begindoround;   
#endif

DoRoundFP:
  if (_trace) printf("DoRoundFP:\n");

begindoround:
  if (_trace) printf("begindoround:\n");
  /* arg1 has the operand address. */
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0643;
  goto binaryarithmeticdivisionprelude;
return0643:
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQV(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);
  SUBT(3, f3, 1, f1, 3, f3);
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

g29447:
  if (_trace) printf("g29447:\n");
  if (t9 == 0) 
    goto g29443;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

g29442:
  if (_trace) printf("g29442:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;   

g29443:
  if (_trace) printf("g29443:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

g29448:
  if (_trace) printf("g29448:\n");
  if (t9 == 0) 
    goto g29444;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto g29442;   

g29444:
  if (_trace) printf("g29444:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

g29449:
  if (_trace) printf("g29449:\n");
  if (t9 == 0) 
    goto g29442;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0644;
  goto consdoublefloat;
return0644:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g29442;   

/* end DoRound */
  /* End of Halfword operand from stack instruction - DoRound */
  /* Other arithmetic. */
/* start DoMax */

  /* Halfword operand from stack instruction - DoMax */
  /* arg2 has the preloaded 8 bit operand. */

domax:
  if (_trace) printf("domax:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMaxIM:
  if (_trace) printf("DoMaxIM:\n");
  /* This sequence only sucks a moderate amount */
		/* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
		/* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindomax;   
#ifdef TRACING
#endif

DoMaxSP:
  if (_trace) printf("DoMaxSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomax;
		/* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindomax;   
#endif

DoMaxLP:
  if (_trace) printf("DoMaxLP:\n");
#ifdef TRACING
  goto begindomax;   
#endif

DoMaxFP:
  if (_trace) printf("DoMaxFP:\n");

begindomax:
  if (_trace) printf("begindomax:\n");
  /* arg1 has the operand address. */
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
		/* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  t2 = (s32)arg6;		// ARG1 data 
		/* ARG2 data */
  t4 = *(s32 *)arg1;
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

g29473:
  if (_trace) printf("g29473:\n");
  if (t10 == 0) 
    goto g29457;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

g29462:
  if (_trace) printf("g29462:\n");
  if (t12 == 0) 
    goto g29459;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if ((s64)t5 > 0)   
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
		/* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;   

g29459:
  if (_trace) printf("g29459:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

g29463:
  if (_trace) printf("g29463:\n");
  if (t12 == 0) 
    goto g29454;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto g29451;   

g29458:
  if (_trace) printf("g29458:\n");

g29457:
  if (_trace) printf("g29457:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

g29474:
  if (_trace) printf("g29474:\n");
  if (t10 == 0) 
    goto g29464;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

g29469:
  if (_trace) printf("g29469:\n");
  if (t12 == 0) 
    goto g29466;
  /* Here if argument TypeSingleFloat */

g29451:
  if (_trace) printf("g29451:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if (FLTU64(0, f0) > 0.0)   
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );   
  goto cachevalid;   

g29466:
  if (_trace) printf("g29466:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

g29470:
  if (_trace) printf("g29470:\n");
  if (t12 == 0) 
    goto g29454;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto g29451;   

g29465:
  if (_trace) printf("g29465:\n");

g29464:
  if (_trace) printf("g29464:\n");
  /* Here for all other cases */

g29453:
  if (_trace) printf("g29453:\n");

g29450:
  if (_trace) printf("g29450:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto g29455;   

g29454:
  if (_trace) printf("g29454:\n");
  t1 = t3;
  goto g29450;   

g29455:
  if (_trace) printf("g29455:\n");

g29456:
  if (_trace) printf("g29456:\n");

/* end DoMax */
  /* End of Halfword operand from stack instruction - DoMax */
/* start DoMin */

  /* Halfword operand from stack instruction - DoMin */
  /* arg2 has the preloaded 8 bit operand. */

domin:
  if (_trace) printf("domin:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMinIM:
  if (_trace) printf("DoMinIM:\n");
  /* This sequence only sucks a moderate amount */
		/* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
		/* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindomin;   
#ifdef TRACING
#endif

DoMinSP:
  if (_trace) printf("DoMinSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomin;
		/* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 
#ifdef TRACING
  goto begindomin;   
#endif

DoMinLP:
  if (_trace) printf("DoMinLP:\n");
#ifdef TRACING
  goto begindomin;   
#endif

DoMinFP:
  if (_trace) printf("DoMinFP:\n");

begindomin:
  if (_trace) printf("begindomin:\n");
  /* arg1 has the operand address. */
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
		/* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  t2 = (s32)arg6;		// ARG1 data 
		/* ARG2 data */
  t4 = *(s32 *)arg1;
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

g29498:
  if (_trace) printf("g29498:\n");
  if (t10 == 0) 
    goto g29482;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

g29487:
  if (_trace) printf("g29487:\n");
  if (t12 == 0) 
    goto g29484;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if ((s64)t5 < 0)   
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
		/* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;   

g29484:
  if (_trace) printf("g29484:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

g29488:
  if (_trace) printf("g29488:\n");
  if (t12 == 0) 
    goto g29479;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto g29476;   

g29483:
  if (_trace) printf("g29483:\n");

g29482:
  if (_trace) printf("g29482:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

g29499:
  if (_trace) printf("g29499:\n");
  if (t10 == 0) 
    goto g29489;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

g29494:
  if (_trace) printf("g29494:\n");
  if (t12 == 0) 
    goto g29491;
  /* Here if argument TypeSingleFloat */

g29476:
  if (_trace) printf("g29476:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if (FLTU64(0, f0) < 0.0)   
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );   
  goto cachevalid;   

g29491:
  if (_trace) printf("g29491:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

g29495:
  if (_trace) printf("g29495:\n");
  if (t12 == 0) 
    goto g29479;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto g29476;   

g29490:
  if (_trace) printf("g29490:\n");

g29489:
  if (_trace) printf("g29489:\n");
  /* Here for all other cases */

g29478:
  if (_trace) printf("g29478:\n");

g29475:
  if (_trace) printf("g29475:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto g29480;   

g29479:
  if (_trace) printf("g29479:\n");
  t1 = t3;
  goto g29475;   

g29480:
  if (_trace) printf("g29480:\n");

g29481:
  if (_trace) printf("g29481:\n");

/* end DoMin */
  /* End of Halfword operand from stack instruction - DoMin */
/* start DoMultiplyDouble */

  /* Halfword operand from stack instruction - DoMultiplyDouble */

domultiplydouble:
  if (_trace) printf("domultiplydouble:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMultiplyDoubleIM:
  if (_trace) printf("DoMultiplyDoubleIM:\n");
  /* This sequence only sucks a moderate amount */
		/* sign extend the byte argument. */
  arg2 = arg2 << 56;

g29500:
  if (_trace) printf("g29500:\n");
		/* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindomultiplydouble;   
#ifdef TRACING
#endif

DoMultiplyDoubleSP:
  if (_trace) printf("DoMultiplyDoubleSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdomultiplydouble;   
#endif

DoMultiplyDoubleLP:
  if (_trace) printf("DoMultiplyDoubleLP:\n");
#ifdef TRACING
  goto headdomultiplydouble;   
#endif

DoMultiplyDoubleFP:
  if (_trace) printf("DoMultiplyDoubleFP:\n");

headdomultiplydouble:
  if (_trace) printf("headdomultiplydouble:\n");
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
		/* Get the operand */
  arg1 = *(u64 *)arg1;

begindomultiplydouble:
  if (_trace) printf("begindomultiplydouble:\n");
  /* arg1 has the operand, sign extended if immediate. */
		/* ARG2 tag */
  t2 = arg1 >> 32;
		/* ARG1 data, sign extended */
  t3 = *(s32 *)iSP;
  t4 = (s32)arg1 + (s32)0;		// ARG2 data, sign extended 
		/* ARG1 tag */
  t1 = *(s32 *)(iSP + 4);
  /* TagType. */
  t1 = t1 & 63;		// Strip CDR code if any. 
  t1 = t1 - Type_Fixnum;
  /* TagType. */
  t2 = t2 & 63;		// Strip CDR code if any. 
		/* Perform the 63 bit multiply. */
  t5 = t3 * t4;
  t2 = t2 - Type_Fixnum;
  if (t1 != 0)   
    goto muldexc;
  if (t2 != 0)   
    goto muldexc;
  t6 = (u32)t5;   		// Get the low 32 bit half. 
  t5 = (u32)(t5 >> ((4&7)*8));   		// Get the high 32 bit half. 
		/* Put the result back on the stack */
  *(u32 *)iSP = t6;
  t1 = Type_Fixnum;
		/* Push high order half */
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

muldexc:
  if (_trace) printf("muldexc:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end DoMultiplyDouble */
  /* End of Halfword operand from stack instruction - DoMultiplyDouble */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunmath.as */
