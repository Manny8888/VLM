/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunmath.as
 ************************************************************************/

  /* Arithmetic. */
/* start DoUnaryMinus */

  /* Halfword operand from stack instruction - DoUnaryMinus */
  /* arg2 has the preloaded 8 bit operand. */

dounaryminus:
  if (_trace) printf("dounaryminus:\n");

DoUnaryMinusSP:
  if (_trace) printf("DoUnaryMinusSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoUnaryMinusLP:
  if (_trace) printf("DoUnaryMinusLP:\n");

DoUnaryMinusFP:
  if (_trace) printf("DoUnaryMinusFP:\n");

begindounaryminus:
  if (_trace) printf("begindounaryminus:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  arg5 = *(s32 *)(arg1 + 4);   		// tag of ARG2 
  arg6 = *(s32 *)arg1;   
  t2 = *(u64 *)&(processor->mostnegativefixnum);   
  LDS(1, f1, *(u32 *)arg1 );   
  t5 = arg5 & 63;		// Strip off any CDR code bits. 
  t4 = (t5 == Type_Fixnum) ? 1 : 0;   

force_alignment28921:
  if (_trace) printf("force_alignment28921:\n");
  if (t4 == 0) 
    goto basic_dispatch28917;
  /* Here if argument TypeFixnum */
  t2 = (s32)arg6 - (s32)t2;   
  arg2 = (s32)zero - (s32)arg6;   
  if (t2 == 0) 
    goto unaryminusexc;
  iPC = t6;
		/* Semi-cheat, we know t5 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
		/* Push the data */
  *(u32 *)(iSP + 8) = arg2;
  iSP = iSP + 8;
  goto cachevalid;   

basic_dispatch28917:
  if (_trace) printf("basic_dispatch28917:\n");
  t4 = (t5 == Type_SingleFloat) ? 1 : 0;   

force_alignment28922:
  if (_trace) printf("force_alignment28922:\n");
  if (t4 == 0) 
    goto basic_dispatch28918;
  /* Here if argument TypeSingleFloat */
  /* NIL */
  SUBS(0, f0, 3, f31, 1, f1); /* subs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = t6;
		/* Semi-cheat, we know t5 has CDRNext/TypeSingleFloat */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
  STS( (u32 *)(iSP + 8), 0, f0 );   		// Push the data 
  iSP = iSP + 8;
  goto cachevalid;   

basic_dispatch28918:
  if (_trace) printf("basic_dispatch28918:\n");
  /* Here for all other cases */

unaryminusexc:
  if (_trace) printf("unaryminusexc:\n");
  arg6 = arg5;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto unarynumericexception;

basic_dispatch28916:
  if (_trace) printf("basic_dispatch28916:\n");

DoUnaryMinusIM:
  if (_trace) printf("DoUnaryMinusIM:\n");
  arg2 = (s32)zero - (s32)arg2;   		// Negate the 8 bit immediate operand 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t7 = Type_Fixnum;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;   

/* end DoUnaryMinus */
  /* End of Halfword operand from stack instruction - DoUnaryMinus */
/* start DoMultiply */

  /* Halfword operand from stack instruction - DoMultiply */
  /* arg2 has the preloaded 8 bit operand. */

domultiply:
  if (_trace) printf("domultiply:\n");

DoMultiplySP:
  if (_trace) printf("DoMultiplySP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomultiply;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoMultiplyLP:
  if (_trace) printf("DoMultiplyLP:\n");

DoMultiplyFP:
  if (_trace) printf("DoMultiplyFP:\n");

begindomultiply:
  if (_trace) printf("begindomultiply:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  /* NIL */
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force_alignment28962:
  if (_trace) printf("force_alignment28962:\n");
  if (t10 == 0) 
    goto basic_dispatch28933;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment28939:
  if (_trace) printf("force_alignment28939:\n");
  if (t12 == 0) 
    goto basic_dispatch28935;
  /* Here if argument TypeFixnum */
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t5 = (s64)((s32)t2 * (s64)(s32)t4); /* mull/v */   		// compute 64-bit result 
  if (t5 >> 32)
    exception();  // WARNING !!! THIS IS ADJUSTED BY THE DIFF FILE
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t9;
  iPC = t6;
  *(u32 *)iSP = t5;
  iCP = t7;
  goto cachevalid;   

basic_dispatch28935:
  if (_trace) printf("basic_dispatch28935:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment28940:
  if (_trace) printf("force_alignment28940:\n");
  if (t12 == 0) 
    goto basic_dispatch28936;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple_binary_arithmetic_operation28923;   

basic_dispatch28936:
  if (_trace) printf("basic_dispatch28936:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force_alignment28941:
  if (_trace) printf("force_alignment28941:\n");
  if (t12 == 0) 
    goto binary_type_dispatch28930;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto simple_binary_arithmetic_operation28926;   

basic_dispatch28934:
  if (_trace) printf("basic_dispatch28934:\n");

basic_dispatch28933:
  if (_trace) printf("basic_dispatch28933:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force_alignment28963:
  if (_trace) printf("force_alignment28963:\n");
  if (t10 == 0) 
    goto basic_dispatch28942;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment28948:
  if (_trace) printf("force_alignment28948:\n");
  if (t12 == 0) 
    goto basic_dispatch28944;
  /* Here if argument TypeSingleFloat */

simple_binary_arithmetic_operation28923:
  if (_trace) printf("simple_binary_arithmetic_operation28923:\n");
  MULS(0, f0, 1, f1, 2, f2); /* muls */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto cachevalid;   

basic_dispatch28944:
  if (_trace) printf("basic_dispatch28944:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment28949:
  if (_trace) printf("force_alignment28949:\n");
  if (t12 == 0) 
    goto basic_dispatch28945;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple_binary_arithmetic_operation28923;   

basic_dispatch28945:
  if (_trace) printf("basic_dispatch28945:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force_alignment28950:
  if (_trace) printf("force_alignment28950:\n");
  if (t12 == 0) 
    goto binary_type_dispatch28930;
  /* Here if argument TypeDoubleFloat */

simple_binary_arithmetic_operation28926:
  if (_trace) printf("simple_binary_arithmetic_operation28926:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto simple_binary_arithmetic_operation28927;   

basic_dispatch28943:
  if (_trace) printf("basic_dispatch28943:\n");

basic_dispatch28942:
  if (_trace) printf("basic_dispatch28942:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

force_alignment28964:
  if (_trace) printf("force_alignment28964:\n");
  if (t10 == 0) 
    goto basic_dispatch28951;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force_alignment28957:
  if (_trace) printf("force_alignment28957:\n");
  if (t12 == 0) 
    goto basic_dispatch28953;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0338;
  goto fetchdoublefloat;
return0338:
  LDT(1, f1, processor->fp0);   

simple_binary_arithmetic_operation28927:
  if (_trace) printf("simple_binary_arithmetic_operation28927:\n");
  arg2 = (u32)t4;   
  r0 = (u64)&&return0339;
  goto fetchdoublefloat;
return0339:
  LDT(2, f2, processor->fp0);   

simple_binary_arithmetic_operation28924:
  if (_trace) printf("simple_binary_arithmetic_operation28924:\n");
  MULT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0340;
  goto consdoublefloat;
return0340:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto cachevalid;   

basic_dispatch28953:
  if (_trace) printf("basic_dispatch28953:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment28958:
  if (_trace) printf("force_alignment28958:\n");
  if (t12 == 0) 
    goto basic_dispatch28954;
  /* Here if argument TypeSingleFloat */

simple_binary_arithmetic_operation28925:
  if (_trace) printf("simple_binary_arithmetic_operation28925:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  r0 = (u64)&&return0341;
  goto fetchdoublefloat;
return0341:
  LDT(1, f1, processor->fp0);   
  goto simple_binary_arithmetic_operation28924;   

basic_dispatch28954:
  if (_trace) printf("basic_dispatch28954:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment28959:
  if (_trace) printf("force_alignment28959:\n");
  if (t12 == 0) 
    goto binary_type_dispatch28930;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto simple_binary_arithmetic_operation28925;   

basic_dispatch28952:
  if (_trace) printf("basic_dispatch28952:\n");

basic_dispatch28951:
  if (_trace) printf("basic_dispatch28951:\n");
  /* Here for all other cases */

binary_type_dispatch28929:
  if (_trace) printf("binary_type_dispatch28929:\n");

domulovfl:
  if (_trace) printf("domulovfl:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary_type_dispatch28931;   

binary_type_dispatch28930:
  if (_trace) printf("binary_type_dispatch28930:\n");
  t1 = t3;
  goto domulovfl;   

binary_type_dispatch28931:
  if (_trace) printf("binary_type_dispatch28931:\n");

basic_dispatch28932:
  if (_trace) printf("basic_dispatch28932:\n");

DoMultiplyIM:
  if (_trace) printf("DoMultiplyIM:\n");
  arg2 = arg2 << 56;   
  t1 = (u32)(arg6 >> ((4&7)*8));   
  t2 = (s32)arg6;		// get ARG1 tag/data 
  arg2 = (s64)arg2 >> 56;   
  t11 = t1 & 63;		// Strip off any CDR code bits. 
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment28969:
  if (_trace) printf("force_alignment28969:\n");
  if (t12 == 0) 
    goto basic_dispatch28966;
  /* Here if argument TypeFixnum */
  t3 = t2 * arg2;   		// compute 64-bit result 
  t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  t10 = (s32)t3;		// compute 32-bit sign-extended result 
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t10 = (t3 == t10) ? 1 : 0;   		// is it the same as the 64-bit result? 
  if (t10 == 0) 		// if not, we overflowed 
    goto domulovfl;
		/* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t11;
  iPC = t4;
  *(u32 *)iSP = t3;
  iCP = t5;
  goto cachevalid;   

basic_dispatch28966:
  if (_trace) printf("basic_dispatch28966:\n");
  /* Here for all other cases */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;   
  arg2 = zero;
  goto begindomultiply;   

basic_dispatch28965:
  if (_trace) printf("basic_dispatch28965:\n");

/* end DoMultiply */
  /* End of Halfword operand from stack instruction - DoMultiply */
/* start BinaryArithmeticDivisionPrelude */


binaryarithmeticdivisionprelude:
  if (_trace) printf("binaryarithmeticdivisionprelude:\n");
  sp = sp + -8;   
  LDS(1, f1, *(u32 *)iSP );   
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force_alignment29007:
  if (_trace) printf("force_alignment29007:\n");
  if (t10 == 0) 
    goto basic_dispatch28980;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment28986:
  if (_trace) printf("force_alignment28986:\n");
  if (t12 == 0) 
    goto basic_dispatch28982;
  /* Here if argument TypeFixnum */
  CVTLQ(1, f1, f31, 1, f1);
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(1, f1, f31, 1, f1);
  CVTQT(2, f2, f31, 2, f2);

basic_dispatch28981:
  if (_trace) printf("basic_dispatch28981:\n");

basic_dispatch28979:
  if (_trace) printf("basic_dispatch28979:\n");

binary_arithmetic_division_prelude28970:
  if (_trace) printf("binary_arithmetic_division_prelude28970:\n");
  sp = sp + 8;   
  goto *r0; /* ret */

basic_dispatch28980:
  if (_trace) printf("basic_dispatch28980:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force_alignment29008:
  if (_trace) printf("force_alignment29008:\n");
  if (t10 == 0) 
    goto basic_dispatch28987;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment28993:
  if (_trace) printf("force_alignment28993:\n");
  if (t12 != 0)   
    goto binary_arithmetic_division_prelude28970;

basic_dispatch28989:
  if (_trace) printf("basic_dispatch28989:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment28994:
  if (_trace) printf("force_alignment28994:\n");
  if (t12 == 0) 
    goto basic_dispatch28990;
  /* Here if argument TypeFixnum */
  t3 = t1;		// contagion 
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto binary_arithmetic_division_prelude28970;   

basic_dispatch28990:
  if (_trace) printf("basic_dispatch28990:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force_alignment28995:
  if (_trace) printf("force_alignment28995:\n");
  if (t12 == 0) 
    goto binary_type_dispatch28977;
  /* Here if argument TypeDoubleFloat */

binary_arithmetic_division_prelude28972:
  if (_trace) printf("binary_arithmetic_division_prelude28972:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  goto binary_arithmetic_division_prelude28973;   

basic_dispatch28988:
  if (_trace) printf("basic_dispatch28988:\n");

basic_dispatch28987:
  if (_trace) printf("basic_dispatch28987:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;   

force_alignment29009:
  if (_trace) printf("force_alignment29009:\n");
  if (t10 == 0) 
    goto basic_dispatch28996;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force_alignment29002:
  if (_trace) printf("force_alignment29002:\n");
  if (t12 == 0) 
    goto basic_dispatch28998;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0342;
  goto fetchdoublefloat;
return0342:
  r0 = *(u64 *)sp;   
  LDT(1, f1, processor->fp0);   

binary_arithmetic_division_prelude28973:
  if (_trace) printf("binary_arithmetic_division_prelude28973:\n");
  arg2 = (u32)t4;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0343;
  goto fetchdoublefloat;
return0343:
  r0 = *(u64 *)sp;   
  LDT(2, f2, processor->fp0);   
  goto binary_arithmetic_division_prelude28970;   

basic_dispatch28998:
  if (_trace) printf("basic_dispatch28998:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment29003:
  if (_trace) printf("force_alignment29003:\n");
  if (t12 == 0) 
    goto basic_dispatch28999;
  /* Here if argument TypeSingleFloat */

binary_arithmetic_division_prelude28971:
  if (_trace) printf("binary_arithmetic_division_prelude28971:\n");
  t3 = t1;		// contagion 
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  arg2 = (u32)t2;   
  *(u64 *)sp = r0;   
  r0 = (u64)&&return0344;
  goto fetchdoublefloat;
return0344:
  r0 = *(u64 *)sp;   
  LDT(1, f1, processor->fp0);   
  goto binary_arithmetic_division_prelude28970;   

basic_dispatch28999:
  if (_trace) printf("basic_dispatch28999:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment29004:
  if (_trace) printf("force_alignment29004:\n");
  if (t12 == 0) 
    goto binary_type_dispatch28977;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto binary_arithmetic_division_prelude28971;   

basic_dispatch28997:
  if (_trace) printf("basic_dispatch28997:\n");

basic_dispatch28996:
  if (_trace) printf("basic_dispatch28996:\n");
  /* Here for all other cases */

binary_type_dispatch28976:
  if (_trace) printf("binary_type_dispatch28976:\n");

binary_arithmetic_division_prelude28974:
  if (_trace) printf("binary_arithmetic_division_prelude28974:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary_type_dispatch28978;   

binary_type_dispatch28977:
  if (_trace) printf("binary_type_dispatch28977:\n");
  t1 = t3;
  goto binary_arithmetic_division_prelude28974;   

binary_type_dispatch28978:
  if (_trace) printf("binary_type_dispatch28978:\n");

basic_dispatch28982:
  if (_trace) printf("basic_dispatch28982:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment29010:
  if (_trace) printf("force_alignment29010:\n");
  if (t12 == 0) 
    goto basic_dispatch28983;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto binary_arithmetic_division_prelude28970;   

basic_dispatch28983:
  if (_trace) printf("basic_dispatch28983:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;   

force_alignment29011:
  if (_trace) printf("force_alignment29011:\n");
  if (t12 == 0) 
    goto binary_type_dispatch28977;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto binary_arithmetic_division_prelude28972;   

/* end BinaryArithmeticDivisionPrelude */
/* start DoQuotient */

  /* Halfword operand from stack instruction - DoQuotient */
  /* arg2 has the preloaded 8 bit operand. */

doquotient:
  if (_trace) printf("doquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoQuotientIM:
  if (_trace) printf("DoQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoquotient;   

DoQuotientSP:
  if (_trace) printf("DoQuotientSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoquotient;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoQuotientLP:
  if (_trace) printf("DoQuotientLP:\n");

DoQuotientFP:
  if (_trace) printf("DoQuotientFP:\n");

begindoquotient:
  if (_trace) printf("begindoquotient:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0345;
  goto binaryarithmeticdivisionprelude;
return0345:
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force_alignment29017:
  if (_trace) printf("force_alignment29017:\n");
  if (t9 == 0) 
    goto basic_dispatch29013;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   

basic_dispatch29012:
  if (_trace) printf("basic_dispatch29012:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic_dispatch29013:
  if (_trace) printf("basic_dispatch29013:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force_alignment29018:
  if (_trace) printf("force_alignment29018:\n");
  if (t9 == 0) 
    goto basic_dispatch29014;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto basic_dispatch29012;   

basic_dispatch29014:
  if (_trace) printf("basic_dispatch29014:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force_alignment29019:
  if (_trace) printf("force_alignment29019:\n");
  if (t9 == 0) 
    goto basic_dispatch29012;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0346;
  goto consdoublefloat;
return0346:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto basic_dispatch29012;   

/* end DoQuotient */
  /* End of Halfword operand from stack instruction - DoQuotient */
/* start DoRationalQuotient */

  /* Halfword operand from stack instruction - DoRationalQuotient */
  /* arg2 has the preloaded 8 bit operand. */

dorationalquotient:
  if (_trace) printf("dorationalquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoRationalQuotientIM:
  if (_trace) printf("DoRationalQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindorationalquotient;   

DoRationalQuotientSP:
  if (_trace) printf("DoRationalQuotientSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindorationalquotient;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoRationalQuotientLP:
  if (_trace) printf("DoRationalQuotientLP:\n");

DoRationalQuotientFP:
  if (_trace) printf("DoRationalQuotientFP:\n");

begindorationalquotient:
  if (_trace) printf("begindorationalquotient:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0347;
  goto binaryarithmeticdivisionprelude;
return0347:
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force_alignment29025:
  if (_trace) printf("force_alignment29025:\n");
  if (t9 == 0) 
    goto basic_dispatch29021;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQSVI(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   

basic_dispatch29020:
  if (_trace) printf("basic_dispatch29020:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic_dispatch29021:
  if (_trace) printf("basic_dispatch29021:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force_alignment29026:
  if (_trace) printf("force_alignment29026:\n");
  if (t9 == 0) 
    goto basic_dispatch29022;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  goto basic_dispatch29020;   

basic_dispatch29022:
  if (_trace) printf("basic_dispatch29022:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force_alignment29027:
  if (_trace) printf("force_alignment29027:\n");
  if (t9 == 0) 
    goto basic_dispatch29020;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);   
  STT( (u64 *)&processor->fp0, 0, f0 );   
  r0 = (u64)&&return0348;
  goto consdoublefloat;
return0348:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto basic_dispatch29020;   

/* end DoRationalQuotient */
  /* End of Halfword operand from stack instruction - DoRationalQuotient */
/* start DoFloor */

  /* Halfword operand from stack instruction - DoFloor */
  /* arg2 has the preloaded 8 bit operand. */

dofloor:
  if (_trace) printf("dofloor:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoFloorIM:
  if (_trace) printf("DoFloorIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindofloor;   

DoFloorSP:
  if (_trace) printf("DoFloorSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindofloor;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoFloorLP:
  if (_trace) printf("DoFloorLP:\n");

DoFloorFP:
  if (_trace) printf("DoFloorFP:\n");

begindofloor:
  if (_trace) printf("begindofloor:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0349;
  goto binaryarithmeticdivisionprelude;
return0349:
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force_alignment29033:
  if (_trace) printf("force_alignment29033:\n");
  if (t9 == 0) 
    goto basic_dispatch29029;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic_dispatch29028:
  if (_trace) printf("basic_dispatch29028:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic_dispatch29029:
  if (_trace) printf("basic_dispatch29029:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force_alignment29034:
  if (_trace) printf("force_alignment29034:\n");
  if (t9 == 0) 
    goto basic_dispatch29030;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic_dispatch29028;   

basic_dispatch29030:
  if (_trace) printf("basic_dispatch29030:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force_alignment29035:
  if (_trace) printf("force_alignment29035:\n");
  if (t9 == 0) 
    goto basic_dispatch29028;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0350;
  goto consdoublefloat;
return0350:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic_dispatch29028;   

/* end DoFloor */
  /* End of Halfword operand from stack instruction - DoFloor */
/* start DoCeiling */

  /* Halfword operand from stack instruction - DoCeiling */
  /* arg2 has the preloaded 8 bit operand. */

doceiling:
  if (_trace) printf("doceiling:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoCeilingIM:
  if (_trace) printf("DoCeilingIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoceiling;   

DoCeilingSP:
  if (_trace) printf("DoCeilingSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoceiling;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoCeilingLP:
  if (_trace) printf("DoCeilingLP:\n");

DoCeilingFP:
  if (_trace) printf("DoCeilingFP:\n");

begindoceiling:
  if (_trace) printf("begindoceiling:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0351;
  goto binaryarithmeticdivisionprelude;
return0351:
  CPYSN(2, f2, 2, f2, 2, f2);   
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  CPYSN(0, f0, 3, f3, 3, f3);   
  CVTTQ(0, f0, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force_alignment29041:
  if (_trace) printf("force_alignment29041:\n");
  if (t9 == 0) 
    goto basic_dispatch29037;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic_dispatch29036:
  if (_trace) printf("basic_dispatch29036:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic_dispatch29037:
  if (_trace) printf("basic_dispatch29037:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force_alignment29042:
  if (_trace) printf("force_alignment29042:\n");
  if (t9 == 0) 
    goto basic_dispatch29038;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic_dispatch29036;   

basic_dispatch29038:
  if (_trace) printf("basic_dispatch29038:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force_alignment29043:
  if (_trace) printf("force_alignment29043:\n");
  if (t9 == 0) 
    goto basic_dispatch29036;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0352;
  goto consdoublefloat;
return0352:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic_dispatch29036;   

/* end DoCeiling */
  /* End of Halfword operand from stack instruction - DoCeiling */
/* start DoTruncate */

  /* Halfword operand from stack instruction - DoTruncate */
  /* arg2 has the preloaded 8 bit operand. */

dotruncate:
  if (_trace) printf("dotruncate:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoTruncateIM:
  if (_trace) printf("DoTruncateIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindotruncate;   

DoTruncateSP:
  if (_trace) printf("DoTruncateSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindotruncate;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoTruncateLP:
  if (_trace) printf("DoTruncateLP:\n");

DoTruncateFP:
  if (_trace) printf("DoTruncateFP:\n");

begindotruncate:
  if (_trace) printf("begindotruncate:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0353;
  goto binaryarithmeticdivisionprelude;
return0353:
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force_alignment29049:
  if (_trace) printf("force_alignment29049:\n");
  if (t9 == 0) 
    goto basic_dispatch29045;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic_dispatch29044:
  if (_trace) printf("basic_dispatch29044:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic_dispatch29045:
  if (_trace) printf("basic_dispatch29045:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force_alignment29050:
  if (_trace) printf("force_alignment29050:\n");
  if (t9 == 0) 
    goto basic_dispatch29046;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic_dispatch29044;   

basic_dispatch29046:
  if (_trace) printf("basic_dispatch29046:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force_alignment29051:
  if (_trace) printf("force_alignment29051:\n");
  if (t9 == 0) 
    goto basic_dispatch29044;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0354;
  goto consdoublefloat;
return0354:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic_dispatch29044;   

/* end DoTruncate */
  /* End of Halfword operand from stack instruction - DoTruncate */
/* start DoRound */

  /* Halfword operand from stack instruction - DoRound */
  /* arg2 has the preloaded 8 bit operand. */

doround:
  if (_trace) printf("doround:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoRoundIM:
  if (_trace) printf("DoRoundIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindoround;   

DoRoundSP:
  if (_trace) printf("DoRoundSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindoround;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoRoundLP:
  if (_trace) printf("DoRoundLP:\n");

DoRoundFP:
  if (_trace) printf("DoRoundFP:\n");

begindoround:
  if (_trace) printf("begindoround:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  r0 = (u64)&&return0355;
  goto binaryarithmeticdivisionprelude;
return0355:
  DIVT(0, f0, 1, f1, 2, f2);   
  CVTTQV(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);   
  SUBT(3, f3, 1, f1, 3, f3);   
  CVTQLV(0, f0, f31, 0, f0);
  t8 = t3 & 63;		// Strip off any CDR code bits. 
  t9 = (t8 == Type_Fixnum) ? 1 : 0;   

force_alignment29057:
  if (_trace) printf("force_alignment29057:\n");
  if (t9 == 0) 
    goto basic_dispatch29053;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;

basic_dispatch29052:
  if (_trace) printf("basic_dispatch29052:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  goto cachevalid;   

basic_dispatch29053:
  if (_trace) printf("basic_dispatch29053:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;   

force_alignment29058:
  if (_trace) printf("force_alignment29058:\n");
  if (t9 == 0) 
    goto basic_dispatch29054;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );   
  iSP = iSP + 8;
  goto basic_dispatch29052;   

basic_dispatch29054:
  if (_trace) printf("basic_dispatch29054:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;   

force_alignment29059:
  if (_trace) printf("force_alignment29059:\n");
  if (t9 == 0) 
    goto basic_dispatch29052;
  /* Here if argument TypeDoubleFloat */
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  STT( (u64 *)&processor->fp0, 3, f3 );   
  r0 = (u64)&&return0356;
  goto consdoublefloat;
return0356:
  t8 = Type_Fixnum;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );   
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto basic_dispatch29052;   

/* end DoRound */
  /* End of Halfword operand from stack instruction - DoRound */
  /* Other arithmetic. */
/* start DoMax */

  /* Halfword operand from stack instruction - DoMax */
  /* arg2 has the preloaded 8 bit operand. */

domax:
  if (_trace) printf("domax:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoMaxIM:
  if (_trace) printf("DoMaxIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindomax;   

DoMaxSP:
  if (_trace) printf("DoMaxSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomax;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoMaxLP:
  if (_trace) printf("DoMaxLP:\n");

DoMaxFP:
  if (_trace) printf("DoMaxFP:\n");

begindomax:
  if (_trace) printf("begindomax:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force_alignment29083:
  if (_trace) printf("force_alignment29083:\n");
  if (t10 == 0) 
    goto basic_dispatch29067;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment29072:
  if (_trace) printf("force_alignment29072:\n");
  if (t12 == 0) 
    goto basic_dispatch29069;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if ((s64)t5 > 0)   
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
		/* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;   

basic_dispatch29069:
  if (_trace) printf("basic_dispatch29069:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment29073:
  if (_trace) printf("force_alignment29073:\n");
  if (t12 == 0) 
    goto binary_type_dispatch29064;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto simple_binary_minmax29061;   

basic_dispatch29068:
  if (_trace) printf("basic_dispatch29068:\n");

basic_dispatch29067:
  if (_trace) printf("basic_dispatch29067:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force_alignment29084:
  if (_trace) printf("force_alignment29084:\n");
  if (t10 == 0) 
    goto basic_dispatch29074;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment29079:
  if (_trace) printf("force_alignment29079:\n");
  if (t12 == 0) 
    goto basic_dispatch29076;
  /* Here if argument TypeSingleFloat */

simple_binary_minmax29061:
  if (_trace) printf("simple_binary_minmax29061:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if (FLTU64(0, f0) > 0.0)   
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );   
  goto cachevalid;   

basic_dispatch29076:
  if (_trace) printf("basic_dispatch29076:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment29080:
  if (_trace) printf("force_alignment29080:\n");
  if (t12 == 0) 
    goto binary_type_dispatch29064;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto simple_binary_minmax29061;   

basic_dispatch29075:
  if (_trace) printf("basic_dispatch29075:\n");

basic_dispatch29074:
  if (_trace) printf("basic_dispatch29074:\n");
  /* Here for all other cases */

binary_type_dispatch29063:
  if (_trace) printf("binary_type_dispatch29063:\n");

simple_binary_minmax29060:
  if (_trace) printf("simple_binary_minmax29060:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary_type_dispatch29065;   

binary_type_dispatch29064:
  if (_trace) printf("binary_type_dispatch29064:\n");
  t1 = t3;
  goto simple_binary_minmax29060;   

binary_type_dispatch29065:
  if (_trace) printf("binary_type_dispatch29065:\n");

basic_dispatch29066:
  if (_trace) printf("basic_dispatch29066:\n");

/* end DoMax */
  /* End of Halfword operand from stack instruction - DoMax */
/* start DoMin */

  /* Halfword operand from stack instruction - DoMin */
  /* arg2 has the preloaded 8 bit operand. */

domin:
  if (_trace) printf("domin:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoMinIM:
  if (_trace) printf("DoMinIM:\n");
  /* This sequence only sucks a moderate amount */
  arg1 = arg2 << 56;   		// sign extend the byte argument. 
  arg2 = zero;
  arg1 = (s64)arg1 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;   
  goto begindomin;   

DoMinSP:
  if (_trace) printf("DoMinSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 != 0)   
    goto begindomin;
  arg6 = *(u64 *)arg4;   		// SP-pop, Reload TOS 
  arg1 = iSP;		// SP-pop mode 
  iSP = arg4;		// Adjust SP 

DoMinLP:
  if (_trace) printf("DoMinLP:\n");

DoMinFP:
  if (_trace) printf("DoMinFP:\n");

begindomin:
  if (_trace) printf("begindomin:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  LDS(1, f1, *(u32 *)iSP );   
  t1 = (u32)(arg6 >> ((4&7)*8));   		// ARG1 tag 
  t3 = *(s32 *)(arg1 + 4);   		// ARG2 tag 
  t2 = (s32)arg6;		// ARG1 data 
  t4 = *(s32 *)arg1;   		// ARG2 data 
  LDS(2, f2, *(u32 *)arg1 );   
  t9 = t1 & 63;		// Strip off any CDR code bits. 
  t11 = t3 & 63;		// Strip off any CDR code bits. 
  t10 = (t9 == Type_Fixnum) ? 1 : 0;   

force_alignment29108:
  if (_trace) printf("force_alignment29108:\n");
  if (t10 == 0) 
    goto basic_dispatch29092;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment29097:
  if (_trace) printf("force_alignment29097:\n");
  if (t12 == 0) 
    goto basic_dispatch29094;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if ((s64)t5 < 0)   
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
		/* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;   

basic_dispatch29094:
  if (_trace) printf("basic_dispatch29094:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment29098:
  if (_trace) printf("force_alignment29098:\n");
  if (t12 == 0) 
    goto binary_type_dispatch29089;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto simple_binary_minmax29086;   

basic_dispatch29093:
  if (_trace) printf("basic_dispatch29093:\n");

basic_dispatch29092:
  if (_trace) printf("basic_dispatch29092:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;   

force_alignment29109:
  if (_trace) printf("force_alignment29109:\n");
  if (t10 == 0) 
    goto basic_dispatch29099;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;   

force_alignment29104:
  if (_trace) printf("force_alignment29104:\n");
  if (t12 == 0) 
    goto basic_dispatch29101;
  /* Here if argument TypeSingleFloat */

simple_binary_minmax29086:
  if (_trace) printf("simple_binary_minmax29086:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */   
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  if (FLTU64(0, f0) < 0.0)   
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  /* trapb force the trap to occur here */   		// Force the trap to occur here 
  t8 = Type_SingleFloat;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );   
  goto cachevalid;   

basic_dispatch29101:
  if (_trace) printf("basic_dispatch29101:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;   

force_alignment29105:
  if (_trace) printf("force_alignment29105:\n");
  if (t12 == 0) 
    goto binary_type_dispatch29089;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto simple_binary_minmax29086;   

basic_dispatch29100:
  if (_trace) printf("basic_dispatch29100:\n");

basic_dispatch29099:
  if (_trace) printf("basic_dispatch29099:\n");
  /* Here for all other cases */

binary_type_dispatch29088:
  if (_trace) printf("binary_type_dispatch29088:\n");

simple_binary_minmax29085:
  if (_trace) printf("simple_binary_minmax29085:\n");
  arg6 = t1;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 1;		// arg4 = arithmeticp 
  goto numericexception;
  goto binary_type_dispatch29090;   

binary_type_dispatch29089:
  if (_trace) printf("binary_type_dispatch29089:\n");
  t1 = t3;
  goto simple_binary_minmax29085;   

binary_type_dispatch29090:
  if (_trace) printf("binary_type_dispatch29090:\n");

basic_dispatch29091:
  if (_trace) printf("basic_dispatch29091:\n");

/* end DoMin */
  /* End of Halfword operand from stack instruction - DoMin */
/* start DoMultiplyDouble */

  /* Halfword operand from stack instruction - DoMultiplyDouble */

domultiplydouble:
  if (_trace) printf("domultiplydouble:\n");
  /* arg2 has the preloaded 8 bit operand. */

DoMultiplyDoubleIM:
  if (_trace) printf("DoMultiplyDoubleIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force_alignment29110:
  if (_trace) printf("force_alignment29110:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindomultiplydouble;   

DoMultiplyDoubleSP:
  if (_trace) printf("DoMultiplyDoubleSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoMultiplyDoubleLP:
  if (_trace) printf("DoMultiplyDoubleLP:\n");

DoMultiplyDoubleFP:
  if (_trace) printf("DoMultiplyDoubleFP:\n");

headdomultiplydouble:
  if (_trace) printf("headdomultiplydouble:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindomultiplydouble:
  if (_trace) printf("begindomultiplydouble:\n");
  /* arg1 has the operand, sign extended if immediate. */
  t2 = arg1 >> 32;   		// ARG2 tag 
  t3 = *(s32 *)iSP;   		// ARG1 data, sign extended 
  t4 = (s32)arg1 + (s32)0;		// ARG2 data, sign extended 
  t1 = *(s32 *)(iSP + 4);   		// ARG1 tag 
  /* TagType. */
  t1 = t1 & 63;		// Strip CDR code if any. 
  t1 = t1 - Type_Fixnum;   
  /* TagType. */
  t2 = t2 & 63;		// Strip CDR code if any. 
  t5 = t3 * t4;   		// Perform the 63 bit multiply. 
  t2 = t2 - Type_Fixnum;   
  if (t1 != 0)   
    goto muldexc;
  if (t2 != 0)   
    goto muldexc;
  t6 = (u32)t5;   		// Get the low 32 bit half. 
  t5 = (u32)(t5 >> ((4&7)*8));   		// Get the high 32 bit half. 
		/* Put the result back on the stack */
  *(u32 *)iSP = t6;
  t1 = Type_Fixnum;
		/* Push high order half */
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

muldexc:
  if (_trace) printf("muldexc:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end DoMultiplyDouble */
  /* End of Halfword operand from stack instruction - DoMultiplyDouble */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunmath.as */
