/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunmath.as
 ************************************************************************/

/* Arithmetic. */
/* start DoUnaryMinus */

/* Halfword operand from stack instruction - DoUnaryMinus */
/* arg2 has the preloaded 8 bit operand. */

dounaryminus : if (_trace) printf("dounaryminus:\n");

DoUnaryMinusSP : if (_trace) printf("DoUnaryMinusSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoUnaryMinusLP : if (_trace) printf("DoUnaryMinusLP:\n");

DoUnaryMinusFP : if (_trace) printf("DoUnaryMinusFP:\n");

begindounaryminus : if (_trace) printf("begindounaryminus:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
arg5 = *(s32 *)(arg1 + 4); // tag of ARG2
arg6 = *(s32 *)arg1;
t2 = *(u64 *)&(processor->mostnegativefixnum);
LDS(1, f1, *(u32 *)arg1);
t5 = arg5 & 63; // Strip off any CDR code bits.
t4 = (t5 == Type_Fixnum) ? 1 : 0;

force_alignment45061 : if (_trace) printf("force_alignment45061:\n");
if (t4 == 0)
    goto basic_dispatch45057;
/* Here if argument TypeFixnum */
t2 = (s32)arg6 - (s32)t2;
arg2 = (s32)zero - (s32)arg6;
if (t2 == 0)
    goto unaryminusexc;
iPC = t6;
*(u32 *)(iSP + 12) = t5; // Semi-cheat, we know t5 has CDRNext/TypeFixnum
iCP = t7;
*(u32 *)(iSP + 8) = arg2; // Push the data
iSP = iSP + 8;
goto cachevalid;

basic_dispatch45057 : if (_trace) printf("basic_dispatch45057:\n");
t4 = (t5 == Type_SingleFloat) ? 1 : 0;

force_alignment45062 : if (_trace) printf("force_alignment45062:\n");
if (t4 == 0)
    goto basic_dispatch45058;
/* Here if argument TypeSingleFloat */
/* NIL */
SUBS(0, f0, 3, f31, 1, f1); /* subs */
/* trapb force the trap to occur here */ // Force the trap to occur here
iPC = t6;
*(u32 *)(iSP + 12) = t5; // Semi-cheat, we know t5 has CDRNext/TypeSingleFloat
iCP = t7;
STS((u32 *)(iSP + 8), 0, f0); // Push the data
iSP = iSP + 8;
goto cachevalid;

basic_dispatch45058 : if (_trace) printf("basic_dispatch45058:\n");
/* Here for all other cases */

unaryminusexc : if (_trace) printf("unaryminusexc:\n");
arg6 = arg5; // arg6 = tag to dispatch on
arg3 = 0; // arg3 = stackp
arg1 = 1; // arg1 = instruction arity
arg4 = 1; // arg4 = arithmeticp
goto unarynumericexception;

basic_dispatch45056 : if (_trace) printf("basic_dispatch45056:\n");

DoUnaryMinusIM : if (_trace) printf("DoUnaryMinusIM:\n");
arg2 = (s32)zero - (s32)arg2; // Negate the 8 bit immediate operand
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
t7 = Type_Fixnum;
*(u32 *)(iSP + 8) = arg2;
*(u32 *)(iSP + 12) = t7; // write the stack cache
iSP = iSP + 8;
goto cachevalid;

/* end DoUnaryMinus */
/* End of Halfword operand from stack instruction - DoUnaryMinus */
/* start DoMultiply */

/* Halfword operand from stack instruction - DoMultiply */
/* arg2 has the preloaded 8 bit operand. */

domultiply : if (_trace) printf("domultiply:\n");

DoMultiplySP : if (_trace) printf("DoMultiplySP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto begindomultiply;
arg6 = *(u64 *)arg4; // SP-pop, Reload TOS
arg1 = iSP; // SP-pop mode
iSP = arg4; // Adjust SP

DoMultiplyLP : if (_trace) printf("DoMultiplyLP:\n");

DoMultiplyFP : if (_trace) printf("DoMultiplyFP:\n");

begindomultiply : if (_trace) printf("begindomultiply:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
LDS(1, f1, *(u32 *)iSP);
t1 = (u32)(arg6 >> ((4 & 7) * 8)); // ARG1 tag
t3 = *(s32 *)(arg1 + 4); // ARG2 tag
t2 = (s32)arg6; // ARG1 data
t4 = *(s32 *)arg1; // ARG2 data
LDS(2, f2, *(u32 *)arg1);
/* NIL */
t9 = t1 & 63; // Strip off any CDR code bits.
t11 = t3 & 63; // Strip off any CDR code bits.
t10 = (t9 == Type_Fixnum) ? 1 : 0;

force_alignment45102 : if (_trace) printf("force_alignment45102:\n");
if (t10 == 0)
    goto basic_dispatch45073;
/* Here if argument TypeFixnum */
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment45079 : if (_trace) printf("force_alignment45079:\n");
if (t12 == 0)
    goto basic_dispatch45075;
/* Here if argument TypeFixnum */
t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
t5 = (s64)((s32)t2 * (s64)(s32)t4); /* mull/v */ // compute 64-bit result
if (t5 >> 31)
    exception(3, t5); // WARNING !!! THIS SHOULD REFLECT THE DIFF FILE
t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
/* trapb force the trap to occur here */ // Force the trap to occur here
*(u32 *)(iSP + 4) = t9; // Semi-cheat, we know temp2 has CDRNext/TypeFixnum
iPC = t6;
*(u32 *)iSP = t5;
iCP = t7;
goto cachevalid;

basic_dispatch45075 : if (_trace) printf("basic_dispatch45075:\n");
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment45080 : if (_trace) printf("force_alignment45080:\n");
if (t12 == 0)
    goto basic_dispatch45076;
/* Here if argument TypeSingleFloat */
CVTLQ(1, f1, f31, 1, f1);
CVTQT(1, f1, f31, 1, f1);
goto simple_binary_arithmetic_operation45063;

basic_dispatch45076 : if (_trace) printf("basic_dispatch45076:\n");
t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

force_alignment45081 : if (_trace) printf("force_alignment45081:\n");
if (t12 == 0)
    goto binary_type_dispatch45070;
/* Here if argument TypeDoubleFloat */
CVTLQ(1, f1, f31, 1, f1);
CVTQT(1, f1, f31, 1, f1);
goto simple_binary_arithmetic_operation45066;

basic_dispatch45074 : if (_trace) printf("basic_dispatch45074:\n");

basic_dispatch45073 : if (_trace) printf("basic_dispatch45073:\n");
t10 = (t9 == Type_SingleFloat) ? 1 : 0;

force_alignment45103 : if (_trace) printf("force_alignment45103:\n");
if (t10 == 0)
    goto basic_dispatch45082;
/* Here if argument TypeSingleFloat */
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment45088 : if (_trace) printf("force_alignment45088:\n");
if (t12 == 0)
    goto basic_dispatch45084;
/* Here if argument TypeSingleFloat */

simple_binary_arithmetic_operation45063 : if (_trace) printf("simple_binary_arithmetic_operation45063:\n");
MULS(0, f0, 1, f1, 2, f2); /* muls */
/* trapb force the trap to occur here */ // Force the trap to occur here
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
t8 = Type_SingleFloat;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
goto cachevalid;

basic_dispatch45084 : if (_trace) printf("basic_dispatch45084:\n");
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment45089 : if (_trace) printf("force_alignment45089:\n");
if (t12 == 0)
    goto basic_dispatch45085;
/* Here if argument TypeFixnum */
CVTLQ(2, f2, f31, 2, f2);
CVTQT(2, f2, f31, 2, f2);
goto simple_binary_arithmetic_operation45063;

basic_dispatch45085 : if (_trace) printf("basic_dispatch45085:\n");
t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

force_alignment45090 : if (_trace) printf("force_alignment45090:\n");
if (t12 == 0)
    goto binary_type_dispatch45070;
/* Here if argument TypeDoubleFloat */

simple_binary_arithmetic_operation45066 : if (_trace) printf("simple_binary_arithmetic_operation45066:\n");
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
goto simple_binary_arithmetic_operation45067;

basic_dispatch45083 : if (_trace) printf("basic_dispatch45083:\n");

basic_dispatch45082 : if (_trace) printf("basic_dispatch45082:\n");
t10 = (t9 == Type_DoubleFloat) ? 1 : 0;

force_alignment45104 : if (_trace) printf("force_alignment45104:\n");
if (t10 == 0)
    goto basic_dispatch45091;
/* Here if argument TypeDoubleFloat */
t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

force_alignment45097 : if (_trace) printf("force_alignment45097:\n");
if (t12 == 0)
    goto basic_dispatch45093;
/* Here if argument TypeDoubleFloat */
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
arg2 = (u32)t2;
r0 = (u64) && return0049;
goto fetchdoublefloat;
return0049 : LDT(1, f1, processor->fp0);

simple_binary_arithmetic_operation45067 : if (_trace) printf("simple_binary_arithmetic_operation45067:\n");
arg2 = (u32)t4;
r0 = (u64) && return0050;
goto fetchdoublefloat;
return0050 : LDT(2, f2, processor->fp0);

simple_binary_arithmetic_operation45064 : if (_trace) printf("simple_binary_arithmetic_operation45064:\n");
MULT(0, f0, 1, f1, 2, f2);
STT((u64 *)&processor->fp0, 0, f0);
r0 = (u64) && return0051;
goto consdoublefloat;
return0051 : iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
t8 = Type_DoubleFloat;
*(u32 *)iSP = arg2;
*(u32 *)(iSP + 4) = t8; // write the stack cache
goto cachevalid;

basic_dispatch45093 : if (_trace) printf("basic_dispatch45093:\n");
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment45098 : if (_trace) printf("force_alignment45098:\n");
if (t12 == 0)
    goto basic_dispatch45094;
/* Here if argument TypeSingleFloat */

simple_binary_arithmetic_operation45065 : if (_trace) printf("simple_binary_arithmetic_operation45065:\n");
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
arg2 = (u32)t2;
r0 = (u64) && return0052;
goto fetchdoublefloat;
return0052 : LDT(1, f1, processor->fp0);
goto simple_binary_arithmetic_operation45064;

basic_dispatch45094 : if (_trace) printf("basic_dispatch45094:\n");
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment45099 : if (_trace) printf("force_alignment45099:\n");
if (t12 == 0)
    goto binary_type_dispatch45070;
/* Here if argument TypeFixnum */
CVTLQ(2, f2, f31, 2, f2);
CVTQT(2, f2, f31, 2, f2);
goto simple_binary_arithmetic_operation45065;

basic_dispatch45092 : if (_trace) printf("basic_dispatch45092:\n");

basic_dispatch45091 : if (_trace) printf("basic_dispatch45091:\n");
/* Here for all other cases */

binary_type_dispatch45069 : if (_trace) printf("binary_type_dispatch45069:\n");

domulovfl : if (_trace) printf("domulovfl:\n");
arg6 = t1; // arg6 = tag to dispatch on
arg3 = 0; // arg3 = stackp
arg1 = 2; // arg1 = instruction arity
arg4 = 1; // arg4 = arithmeticp
goto numericexception;
goto binary_type_dispatch45071;

binary_type_dispatch45070 : if (_trace) printf("binary_type_dispatch45070:\n");
t1 = t3;
goto domulovfl;

binary_type_dispatch45071 : if (_trace) printf("binary_type_dispatch45071:\n");

basic_dispatch45072 : if (_trace) printf("basic_dispatch45072:\n");

DoMultiplyIM : if (_trace) printf("DoMultiplyIM:\n");
arg2 = arg2 << 56;
t1 = (u32)(arg6 >> ((4 & 7) * 8));
t2 = (s32)arg6; // get ARG1 tag/data
arg2 = (s64)arg2 >> 56;
t11 = t1 & 63; // Strip off any CDR code bits.
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment45109 : if (_trace) printf("force_alignment45109:\n");
if (t12 == 0)
    goto basic_dispatch45106;
/* Here if argument TypeFixnum */
t3 = t2 * arg2; // compute 64-bit result
t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
t10 = (s32)t3; // compute 32-bit sign-extended result
t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
t10 = (t3 == t10) ? 1 : 0; // is it the same as the 64-bit result?
if (t10 == 0) // if not, we overflowed
    goto domulovfl;
*(u32 *)(iSP + 4) = t11; // Semi-cheat, we know temp2 has CDRNext/TypeFixnum
iPC = t4;
*(u32 *)iSP = t3;
iCP = t5;
goto cachevalid;

basic_dispatch45106 : if (_trace) printf("basic_dispatch45106:\n");
/* Here for all other cases */
*(u32 *)&processor->immediate_arg = arg2;
arg1 = (u64)&processor->immediate_arg;
arg2 = zero;
goto begindomultiply;

basic_dispatch45105 : if (_trace) printf("basic_dispatch45105:\n");

/* end DoMultiply */
/* End of Halfword operand from stack instruction - DoMultiply */
/* start BinaryArithmeticDivisionPrelude */

binaryarithmeticdivisionprelude : if (_trace) printf("binaryarithmeticdivisionprelude:\n");
sp = sp + -8;
LDS(1, f1, *(u32 *)iSP);
t2 = (s32)arg6; // ARG1 data
t4 = *(s32 *)arg1; // ARG2 data
t1 = (u32)(arg6 >> ((4 & 7) * 8)); // ARG1 tag
t3 = *(s32 *)(arg1 + 4); // ARG2 tag
LDS(2, f2, *(u32 *)arg1);
t9 = t1 & 63; // Strip off any CDR code bits.
t11 = t3 & 63; // Strip off any CDR code bits.
t10 = (t9 == Type_Fixnum) ? 1 : 0;

force_alignment45147 : if (_trace) printf("force_alignment45147:\n");
if (t10 == 0)
    goto basic_dispatch45120;
/* Here if argument TypeFixnum */
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment45126 : if (_trace) printf("force_alignment45126:\n");
if (t12 == 0)
    goto basic_dispatch45122;
/* Here if argument TypeFixnum */
CVTLQ(1, f1, f31, 1, f1);
CVTLQ(2, f2, f31, 2, f2);
CVTQT(1, f1, f31, 1, f1);
CVTQT(2, f2, f31, 2, f2);

basic_dispatch45121 : if (_trace) printf("basic_dispatch45121:\n");

basic_dispatch45119 : if (_trace) printf("basic_dispatch45119:\n");

binary_arithmetic_division_prelude45110 : if (_trace) printf("binary_arithmetic_division_prelude45110:\n");
sp = sp + 8;
goto *r0; /* ret */

basic_dispatch45120 : if (_trace) printf("basic_dispatch45120:\n");
t10 = (t9 == Type_SingleFloat) ? 1 : 0;

force_alignment45148 : if (_trace) printf("force_alignment45148:\n");
if (t10 == 0)
    goto basic_dispatch45127;
/* Here if argument TypeSingleFloat */
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment45133 : if (_trace) printf("force_alignment45133:\n");
if (t12 != 0)
    goto binary_arithmetic_division_prelude45110;

basic_dispatch45129 : if (_trace) printf("basic_dispatch45129:\n");
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment45134 : if (_trace) printf("force_alignment45134:\n");
if (t12 == 0)
    goto basic_dispatch45130;
/* Here if argument TypeFixnum */
t3 = t1; // contagion
CVTLQ(2, f2, f31, 2, f2);
CVTQT(2, f2, f31, 2, f2);
goto binary_arithmetic_division_prelude45110;

basic_dispatch45130 : if (_trace) printf("basic_dispatch45130:\n");
t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

force_alignment45135 : if (_trace) printf("force_alignment45135:\n");
if (t12 == 0)
    goto binary_type_dispatch45117;
/* Here if argument TypeDoubleFloat */

binary_arithmetic_division_prelude45112 : if (_trace) printf("binary_arithmetic_division_prelude45112:\n");
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
goto binary_arithmetic_division_prelude45113;

basic_dispatch45128 : if (_trace) printf("basic_dispatch45128:\n");

basic_dispatch45127 : if (_trace) printf("basic_dispatch45127:\n");
t10 = (t9 == Type_DoubleFloat) ? 1 : 0;

force_alignment45149 : if (_trace) printf("force_alignment45149:\n");
if (t10 == 0)
    goto basic_dispatch45136;
/* Here if argument TypeDoubleFloat */
t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

force_alignment45142 : if (_trace) printf("force_alignment45142:\n");
if (t12 == 0)
    goto basic_dispatch45138;
/* Here if argument TypeDoubleFloat */
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
arg2 = (u32)t2;
*(u64 *)sp = r0;
r0 = (u64) && return0053;
goto fetchdoublefloat;
return0053 : r0 = *(u64 *)sp;
LDT(1, f1, processor->fp0);

binary_arithmetic_division_prelude45113 : if (_trace) printf("binary_arithmetic_division_prelude45113:\n");
arg2 = (u32)t4;
*(u64 *)sp = r0;
r0 = (u64) && return0054;
goto fetchdoublefloat;
return0054 : r0 = *(u64 *)sp;
LDT(2, f2, processor->fp0);
goto binary_arithmetic_division_prelude45110;

basic_dispatch45138 : if (_trace) printf("basic_dispatch45138:\n");
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment45143 : if (_trace) printf("force_alignment45143:\n");
if (t12 == 0)
    goto basic_dispatch45139;
/* Here if argument TypeSingleFloat */

binary_arithmetic_division_prelude45111 : if (_trace) printf("binary_arithmetic_division_prelude45111:\n");
t3 = t1; // contagion
t11 = *(u64 *)&(processor->stackcachebasevma);
t12 = *(s32 *)&processor->scovlimit; // Size of the stack cache (words)
arg2 = (u32)t2;
*(u64 *)sp = r0;
r0 = (u64) && return0055;
goto fetchdoublefloat;
return0055 : r0 = *(u64 *)sp;
LDT(1, f1, processor->fp0);
goto binary_arithmetic_division_prelude45110;

basic_dispatch45139 : if (_trace) printf("basic_dispatch45139:\n");
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment45144 : if (_trace) printf("force_alignment45144:\n");
if (t12 == 0)
    goto binary_type_dispatch45117;
/* Here if argument TypeFixnum */
CVTLQ(2, f2, f31, 2, f2);
CVTQT(2, f2, f31, 2, f2);
goto binary_arithmetic_division_prelude45111;

basic_dispatch45137 : if (_trace) printf("basic_dispatch45137:\n");

basic_dispatch45136 : if (_trace) printf("basic_dispatch45136:\n");
/* Here for all other cases */

binary_type_dispatch45116 : if (_trace) printf("binary_type_dispatch45116:\n");

binary_arithmetic_division_prelude45114 : if (_trace) printf("binary_arithmetic_division_prelude45114:\n");
arg6 = t1; // arg6 = tag to dispatch on
arg3 = 0; // arg3 = stackp
arg1 = 2; // arg1 = instruction arity
arg4 = 1; // arg4 = arithmeticp
goto numericexception;
goto binary_type_dispatch45118;

binary_type_dispatch45117 : if (_trace) printf("binary_type_dispatch45117:\n");
t1 = t3;
goto binary_arithmetic_division_prelude45114;

binary_type_dispatch45118 : if (_trace) printf("binary_type_dispatch45118:\n");

basic_dispatch45122 : if (_trace) printf("basic_dispatch45122:\n");
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment45150 : if (_trace) printf("force_alignment45150:\n");
if (t12 == 0)
    goto basic_dispatch45123;
/* Here if argument TypeSingleFloat */
CVTLQ(1, f1, f31, 1, f1);
CVTQT(1, f1, f31, 1, f1);
goto binary_arithmetic_division_prelude45110;

basic_dispatch45123 : if (_trace) printf("basic_dispatch45123:\n");
t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

force_alignment45151 : if (_trace) printf("force_alignment45151:\n");
if (t12 == 0)
    goto binary_type_dispatch45117;
/* Here if argument TypeDoubleFloat */
CVTLQ(1, f1, f31, 1, f1);
CVTQT(1, f1, f31, 1, f1);
goto binary_arithmetic_division_prelude45112;

/* end BinaryArithmeticDivisionPrelude */
/* start DoQuotient */

/* Halfword operand from stack instruction - DoQuotient */
/* arg2 has the preloaded 8 bit operand. */

doquotient : if (_trace) printf("doquotient:\n");
/* arg2 has the preloaded 8 bit operand. */

DoQuotientIM : if (_trace) printf("DoQuotientIM:\n");
/* This sequence only sucks a moderate amount */
arg1 = arg2 << 56; // sign extend the byte argument.
arg2 = zero;
arg1 = (s64)arg1 >> 56; // Rest of sign extension
*(u32 *)&processor->immediate_arg = arg1;
arg1 = (u64)&processor->immediate_arg;
goto begindoquotient;

DoQuotientSP : if (_trace) printf("DoQuotientSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto begindoquotient;
arg6 = *(u64 *)arg4; // SP-pop, Reload TOS
arg1 = iSP; // SP-pop mode
iSP = arg4; // Adjust SP

DoQuotientLP : if (_trace) printf("DoQuotientLP:\n");

DoQuotientFP : if (_trace) printf("DoQuotientFP:\n");

begindoquotient : if (_trace) printf("begindoquotient:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
r0 = (u64) && return0056;
goto binaryarithmeticdivisionprelude;
return0056 : t8 = t3 & 63; // Strip off any CDR code bits.
t9 = (t8 == Type_Fixnum) ? 1 : 0;

force_alignment45157 : if (_trace) printf("force_alignment45157:\n");
if (t9 == 0)
    goto basic_dispatch45153;
/* Here if argument TypeFixnum */
DIVT(0, f0, 1, f1, 2, f2);
CVTTQVC(0, f0, f31, 0, f0);
CVTQLV(0, f0, f31, 0, f0);
/* trapb force the trap to occur here */ // Force the trap to occur here
t8 = Type_Fixnum;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);

basic_dispatch45152 : if (_trace) printf("basic_dispatch45152:\n");
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
goto cachevalid;

basic_dispatch45153 : if (_trace) printf("basic_dispatch45153:\n");
t9 = (t8 == Type_SingleFloat) ? 1 : 0;

force_alignment45158 : if (_trace) printf("force_alignment45158:\n");
if (t9 == 0)
    goto basic_dispatch45154;
/* Here if argument TypeSingleFloat */
DIVS(0, f0, 1, f1, 2, f2); /* divs */
/* trapb force the trap to occur here */ // Force the trap to occur here
t8 = Type_SingleFloat;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
goto basic_dispatch45152;

basic_dispatch45154 : if (_trace) printf("basic_dispatch45154:\n");
t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

force_alignment45159 : if (_trace) printf("force_alignment45159:\n");
if (t9 == 0)
    goto basic_dispatch45152;
/* Here if argument TypeDoubleFloat */
DIVT(0, f0, 1, f1, 2, f2);
STT((u64 *)&processor->fp0, 0, f0);
r0 = (u64) && return0057;
goto consdoublefloat;
return0057 : t8 = Type_DoubleFloat;
*(u32 *)iSP = arg2;
*(u32 *)(iSP + 4) = t8; // write the stack cache
goto basic_dispatch45152;

/* end DoQuotient */
/* End of Halfword operand from stack instruction - DoQuotient */
/* start DoRationalQuotient */

/* Halfword operand from stack instruction - DoRationalQuotient */
/* arg2 has the preloaded 8 bit operand. */

dorationalquotient : if (_trace) printf("dorationalquotient:\n");
/* arg2 has the preloaded 8 bit operand. */

DoRationalQuotientIM : if (_trace) printf("DoRationalQuotientIM:\n");
/* This sequence only sucks a moderate amount */
arg1 = arg2 << 56; // sign extend the byte argument.
arg2 = zero;
arg1 = (s64)arg1 >> 56; // Rest of sign extension
*(u32 *)&processor->immediate_arg = arg1;
arg1 = (u64)&processor->immediate_arg;
goto begindorationalquotient;

DoRationalQuotientSP : if (_trace) printf("DoRationalQuotientSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto begindorationalquotient;
arg6 = *(u64 *)arg4; // SP-pop, Reload TOS
arg1 = iSP; // SP-pop mode
iSP = arg4; // Adjust SP

DoRationalQuotientLP : if (_trace) printf("DoRationalQuotientLP:\n");

DoRationalQuotientFP : if (_trace) printf("DoRationalQuotientFP:\n");

begindorationalquotient : if (_trace) printf("begindorationalquotient:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
r0 = (u64) && return0058;
goto binaryarithmeticdivisionprelude;
return0058 : t8 = t3 & 63; // Strip off any CDR code bits.
t9 = (t8 == Type_Fixnum) ? 1 : 0;

force_alignment45165 : if (_trace) printf("force_alignment45165:\n");
if (t9 == 0)
    goto basic_dispatch45161;
/* Here if argument TypeFixnum */
DIVT(0, f0, 1, f1, 2, f2);
CVTTQSVI(0, f0, f31, 0, f0);
CVTQLV(0, f0, f31, 0, f0);
/* trapb force the trap to occur here */ // Force the trap to occur here
t8 = Type_Fixnum;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);

basic_dispatch45160 : if (_trace) printf("basic_dispatch45160:\n");
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
goto cachevalid;

basic_dispatch45161 : if (_trace) printf("basic_dispatch45161:\n");
t9 = (t8 == Type_SingleFloat) ? 1 : 0;

force_alignment45166 : if (_trace) printf("force_alignment45166:\n");
if (t9 == 0)
    goto basic_dispatch45162;
/* Here if argument TypeSingleFloat */
DIVS(0, f0, 1, f1, 2, f2); /* divs */
/* trapb force the trap to occur here */ // Force the trap to occur here
t8 = Type_SingleFloat;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
goto basic_dispatch45160;

basic_dispatch45162 : if (_trace) printf("basic_dispatch45162:\n");
t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

force_alignment45167 : if (_trace) printf("force_alignment45167:\n");
if (t9 == 0)
    goto basic_dispatch45160;
/* Here if argument TypeDoubleFloat */
DIVT(0, f0, 1, f1, 2, f2);
STT((u64 *)&processor->fp0, 0, f0);
r0 = (u64) && return0059;
goto consdoublefloat;
return0059 : t8 = Type_DoubleFloat;
*(u32 *)iSP = arg2;
*(u32 *)(iSP + 4) = t8; // write the stack cache
goto basic_dispatch45160;

/* end DoRationalQuotient */
/* End of Halfword operand from stack instruction - DoRationalQuotient */
/* start DoFloor */

/* Halfword operand from stack instruction - DoFloor */
/* arg2 has the preloaded 8 bit operand. */

dofloor : if (_trace) printf("dofloor:\n");
/* arg2 has the preloaded 8 bit operand. */

DoFloorIM : if (_trace) printf("DoFloorIM:\n");
/* This sequence only sucks a moderate amount */
arg1 = arg2 << 56; // sign extend the byte argument.
arg2 = zero;
arg1 = (s64)arg1 >> 56; // Rest of sign extension
*(u32 *)&processor->immediate_arg = arg1;
arg1 = (u64)&processor->immediate_arg;
goto begindofloor;

DoFloorSP : if (_trace) printf("DoFloorSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto begindofloor;
arg6 = *(u64 *)arg4; // SP-pop, Reload TOS
arg1 = iSP; // SP-pop mode
iSP = arg4; // Adjust SP

DoFloorLP : if (_trace) printf("DoFloorLP:\n");

DoFloorFP : if (_trace) printf("DoFloorFP:\n");

begindofloor : if (_trace) printf("begindofloor:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
r0 = (u64) && return0060;
goto binaryarithmeticdivisionprelude;
return0060 : DIVT(0, f0, 1, f1, 2, f2);
CVTTQVM(0, f0, f31, 0, f0);
CVTQT(3, f3, f31, 0, f0);
MULT(3, f3, 3, f3, 2, f2);
SUBT(3, f3, 1, f1, 3, f3);
CVTQLV(0, f0, f31, 0, f0);
t8 = t3 & 63; // Strip off any CDR code bits.
t9 = (t8 == Type_Fixnum) ? 1 : 0;

force_alignment45173 : if (_trace) printf("force_alignment45173:\n");
if (t9 == 0)
    goto basic_dispatch45169;
/* Here if argument TypeFixnum */
CVTTQ(3, f3, f31, 3, f3);
CVTQL(3, f3, f31, 3, f3);
/* trapb force the trap to occur here */ // Force the trap to occur here
t8 = Type_Fixnum;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
t8 = Type_Fixnum;
*(u32 *)(iSP + 12) = t8; // write the stack cache
STS((u32 *)(iSP + 8), 3, f3);
iSP = iSP + 8;

basic_dispatch45168 : if (_trace) printf("basic_dispatch45168:\n");
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
goto cachevalid;

basic_dispatch45169 : if (_trace) printf("basic_dispatch45169:\n");
t9 = (t8 == Type_SingleFloat) ? 1 : 0;

force_alignment45174 : if (_trace) printf("force_alignment45174:\n");
if (t9 == 0)
    goto basic_dispatch45170;
/* Here if argument TypeSingleFloat */
CVTTS(3, f3, f31, 3, f3);
/* trapb force the trap to occur here */ // Force the trap to occur here
t8 = Type_Fixnum;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
t8 = Type_SingleFloat;
*(u32 *)(iSP + 12) = t8; // write the stack cache
STS((u32 *)(iSP + 8), 3, f3);
iSP = iSP + 8;
goto basic_dispatch45168;

basic_dispatch45170 : if (_trace) printf("basic_dispatch45170:\n");
t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

force_alignment45175 : if (_trace) printf("force_alignment45175:\n");
if (t9 == 0)
    goto basic_dispatch45168;
/* Here if argument TypeDoubleFloat */
/* trapb force the trap to occur here */ // Force the trap to occur here
STT((u64 *)&processor->fp0, 3, f3);
r0 = (u64) && return0061;
goto consdoublefloat;
return0061 : t8 = Type_Fixnum;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
t8 = Type_DoubleFloat;
*(u32 *)(iSP + 8) = arg2;
*(u32 *)(iSP + 12) = t8; // write the stack cache
iSP = iSP + 8;
goto basic_dispatch45168;

/* end DoFloor */
/* End of Halfword operand from stack instruction - DoFloor */
/* start DoCeiling */

/* Halfword operand from stack instruction - DoCeiling */
/* arg2 has the preloaded 8 bit operand. */

doceiling : if (_trace) printf("doceiling:\n");
/* arg2 has the preloaded 8 bit operand. */

DoCeilingIM : if (_trace) printf("DoCeilingIM:\n");
/* This sequence only sucks a moderate amount */
arg1 = arg2 << 56; // sign extend the byte argument.
arg2 = zero;
arg1 = (s64)arg1 >> 56; // Rest of sign extension
*(u32 *)&processor->immediate_arg = arg1;
arg1 = (u64)&processor->immediate_arg;
goto begindoceiling;

DoCeilingSP : if (_trace) printf("DoCeilingSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto begindoceiling;
arg6 = *(u64 *)arg4; // SP-pop, Reload TOS
arg1 = iSP; // SP-pop mode
iSP = arg4; // Adjust SP

DoCeilingLP : if (_trace) printf("DoCeilingLP:\n");

DoCeilingFP : if (_trace) printf("DoCeilingFP:\n");

begindoceiling : if (_trace) printf("begindoceiling:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
r0 = (u64) && return0062;
goto binaryarithmeticdivisionprelude;
return0062 : CPYSN(2, f2, 2, f2, 2, f2);
DIVT(0, f0, 1, f1, 2, f2);
CVTTQVM(0, f0, f31, 0, f0);
CVTQT(3, f3, f31, 0, f0);
CPYSN(0, f0, 3, f3, 3, f3);
CVTTQ(0, f0, f31, 0, f0);
MULT(3, f3, 3, f3, 2, f2);
SUBT(3, f3, 1, f1, 3, f3);
CVTQLV(0, f0, f31, 0, f0);
t8 = t3 & 63; // Strip off any CDR code bits.
t9 = (t8 == Type_Fixnum) ? 1 : 0;

force_alignment45181 : if (_trace) printf("force_alignment45181:\n");
if (t9 == 0)
    goto basic_dispatch45177;
/* Here if argument TypeFixnum */
CVTTQ(3, f3, f31, 3, f3);
CVTQL(3, f3, f31, 3, f3);
/* trapb force the trap to occur here */ // Force the trap to occur here
t8 = Type_Fixnum;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
t8 = Type_Fixnum;
*(u32 *)(iSP + 12) = t8; // write the stack cache
STS((u32 *)(iSP + 8), 3, f3);
iSP = iSP + 8;

basic_dispatch45176 : if (_trace) printf("basic_dispatch45176:\n");
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
goto cachevalid;

basic_dispatch45177 : if (_trace) printf("basic_dispatch45177:\n");
t9 = (t8 == Type_SingleFloat) ? 1 : 0;

force_alignment45182 : if (_trace) printf("force_alignment45182:\n");
if (t9 == 0)
    goto basic_dispatch45178;
/* Here if argument TypeSingleFloat */
CVTTS(3, f3, f31, 3, f3);
/* trapb force the trap to occur here */ // Force the trap to occur here
t8 = Type_Fixnum;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
t8 = Type_SingleFloat;
*(u32 *)(iSP + 12) = t8; // write the stack cache
STS((u32 *)(iSP + 8), 3, f3);
iSP = iSP + 8;
goto basic_dispatch45176;

basic_dispatch45178 : if (_trace) printf("basic_dispatch45178:\n");
t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

force_alignment45183 : if (_trace) printf("force_alignment45183:\n");
if (t9 == 0)
    goto basic_dispatch45176;
/* Here if argument TypeDoubleFloat */
/* trapb force the trap to occur here */ // Force the trap to occur here
STT((u64 *)&processor->fp0, 3, f3);
r0 = (u64) && return0063;
goto consdoublefloat;
return0063 : t8 = Type_Fixnum;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
t8 = Type_DoubleFloat;
*(u32 *)(iSP + 8) = arg2;
*(u32 *)(iSP + 12) = t8; // write the stack cache
iSP = iSP + 8;
goto basic_dispatch45176;

/* end DoCeiling */
/* End of Halfword operand from stack instruction - DoCeiling */
/* start DoTruncate */

/* Halfword operand from stack instruction - DoTruncate */
/* arg2 has the preloaded 8 bit operand. */

dotruncate : if (_trace) printf("dotruncate:\n");
/* arg2 has the preloaded 8 bit operand. */

DoTruncateIM : if (_trace) printf("DoTruncateIM:\n");
/* This sequence only sucks a moderate amount */
arg1 = arg2 << 56; // sign extend the byte argument.
arg2 = zero;
arg1 = (s64)arg1 >> 56; // Rest of sign extension
*(u32 *)&processor->immediate_arg = arg1;
arg1 = (u64)&processor->immediate_arg;
goto begindotruncate;

DoTruncateSP : if (_trace) printf("DoTruncateSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto begindotruncate;
arg6 = *(u64 *)arg4; // SP-pop, Reload TOS
arg1 = iSP; // SP-pop mode
iSP = arg4; // Adjust SP

DoTruncateLP : if (_trace) printf("DoTruncateLP:\n");

DoTruncateFP : if (_trace) printf("DoTruncateFP:\n");

begindotruncate : if (_trace) printf("begindotruncate:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
r0 = (u64) && return0064;
goto binaryarithmeticdivisionprelude;
return0064 : DIVT(0, f0, 1, f1, 2, f2);
CVTTQVC(0, f0, f31, 0, f0);
CVTQT(3, f3, f31, 0, f0);
MULT(3, f3, 3, f3, 2, f2);
SUBT(3, f3, 1, f1, 3, f3);
CVTQLV(0, f0, f31, 0, f0);
t8 = t3 & 63; // Strip off any CDR code bits.
t9 = (t8 == Type_Fixnum) ? 1 : 0;

force_alignment45189 : if (_trace) printf("force_alignment45189:\n");
if (t9 == 0)
    goto basic_dispatch45185;
/* Here if argument TypeFixnum */
CVTTQ(3, f3, f31, 3, f3);
CVTQL(3, f3, f31, 3, f3);
/* trapb force the trap to occur here */ // Force the trap to occur here
t8 = Type_Fixnum;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
t8 = Type_Fixnum;
*(u32 *)(iSP + 12) = t8; // write the stack cache
STS((u32 *)(iSP + 8), 3, f3);
iSP = iSP + 8;

basic_dispatch45184 : if (_trace) printf("basic_dispatch45184:\n");
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
goto cachevalid;

basic_dispatch45185 : if (_trace) printf("basic_dispatch45185:\n");
t9 = (t8 == Type_SingleFloat) ? 1 : 0;

force_alignment45190 : if (_trace) printf("force_alignment45190:\n");
if (t9 == 0)
    goto basic_dispatch45186;
/* Here if argument TypeSingleFloat */
CVTTS(3, f3, f31, 3, f3);
/* trapb force the trap to occur here */ // Force the trap to occur here
t8 = Type_Fixnum;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
t8 = Type_SingleFloat;
*(u32 *)(iSP + 12) = t8; // write the stack cache
STS((u32 *)(iSP + 8), 3, f3);
iSP = iSP + 8;
goto basic_dispatch45184;

basic_dispatch45186 : if (_trace) printf("basic_dispatch45186:\n");
t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

force_alignment45191 : if (_trace) printf("force_alignment45191:\n");
if (t9 == 0)
    goto basic_dispatch45184;
/* Here if argument TypeDoubleFloat */
/* trapb force the trap to occur here */ // Force the trap to occur here
STT((u64 *)&processor->fp0, 3, f3);
r0 = (u64) && return0065;
goto consdoublefloat;
return0065 : t8 = Type_Fixnum;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
t8 = Type_DoubleFloat;
*(u32 *)(iSP + 8) = arg2;
*(u32 *)(iSP + 12) = t8; // write the stack cache
iSP = iSP + 8;
goto basic_dispatch45184;

/* end DoTruncate */
/* End of Halfword operand from stack instruction - DoTruncate */
/* start DoRound */

/* Halfword operand from stack instruction - DoRound */
/* arg2 has the preloaded 8 bit operand. */

doround : if (_trace) printf("doround:\n");
/* arg2 has the preloaded 8 bit operand. */

DoRoundIM : if (_trace) printf("DoRoundIM:\n");
/* This sequence only sucks a moderate amount */
arg1 = arg2 << 56; // sign extend the byte argument.
arg2 = zero;
arg1 = (s64)arg1 >> 56; // Rest of sign extension
*(u32 *)&processor->immediate_arg = arg1;
arg1 = (u64)&processor->immediate_arg;
goto begindoround;

DoRoundSP : if (_trace) printf("DoRoundSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto begindoround;
arg6 = *(u64 *)arg4; // SP-pop, Reload TOS
arg1 = iSP; // SP-pop mode
iSP = arg4; // Adjust SP

DoRoundLP : if (_trace) printf("DoRoundLP:\n");

DoRoundFP : if (_trace) printf("DoRoundFP:\n");

begindoround : if (_trace) printf("begindoround:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
r0 = (u64) && return0066;
goto binaryarithmeticdivisionprelude;
return0066 : DIVT(0, f0, 1, f1, 2, f2);
CVTTQV(0, f0, f31, 0, f0);
CVTQT(3, f3, f31, 0, f0);
MULT(3, f3, 3, f3, 2, f2);
SUBT(3, f3, 1, f1, 3, f3);
CVTQLV(0, f0, f31, 0, f0);
t8 = t3 & 63; // Strip off any CDR code bits.
t9 = (t8 == Type_Fixnum) ? 1 : 0;

force_alignment45197 : if (_trace) printf("force_alignment45197:\n");
if (t9 == 0)
    goto basic_dispatch45193;
/* Here if argument TypeFixnum */
CVTTQ(3, f3, f31, 3, f3);
CVTQL(3, f3, f31, 3, f3);
/* trapb force the trap to occur here */ // Force the trap to occur here
t8 = Type_Fixnum;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
t8 = Type_Fixnum;
*(u32 *)(iSP + 12) = t8; // write the stack cache
STS((u32 *)(iSP + 8), 3, f3);
iSP = iSP + 8;

basic_dispatch45192 : if (_trace) printf("basic_dispatch45192:\n");
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
goto cachevalid;

basic_dispatch45193 : if (_trace) printf("basic_dispatch45193:\n");
t9 = (t8 == Type_SingleFloat) ? 1 : 0;

force_alignment45198 : if (_trace) printf("force_alignment45198:\n");
if (t9 == 0)
    goto basic_dispatch45194;
/* Here if argument TypeSingleFloat */
CVTTS(3, f3, f31, 3, f3);
/* trapb force the trap to occur here */ // Force the trap to occur here
t8 = Type_Fixnum;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
t8 = Type_SingleFloat;
*(u32 *)(iSP + 12) = t8; // write the stack cache
STS((u32 *)(iSP + 8), 3, f3);
iSP = iSP + 8;
goto basic_dispatch45192;

basic_dispatch45194 : if (_trace) printf("basic_dispatch45194:\n");
t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

force_alignment45199 : if (_trace) printf("force_alignment45199:\n");
if (t9 == 0)
    goto basic_dispatch45192;
/* Here if argument TypeDoubleFloat */
/* trapb force the trap to occur here */ // Force the trap to occur here
STT((u64 *)&processor->fp0, 3, f3);
r0 = (u64) && return0067;
goto consdoublefloat;
return0067 : t8 = Type_Fixnum;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 0, f0);
t8 = Type_DoubleFloat;
*(u32 *)(iSP + 8) = arg2;
*(u32 *)(iSP + 12) = t8; // write the stack cache
iSP = iSP + 8;
goto basic_dispatch45192;

/* end DoRound */
/* End of Halfword operand from stack instruction - DoRound */
/* Other arithmetic. */
/* start DoMax */

/* Halfword operand from stack instruction - DoMax */
/* arg2 has the preloaded 8 bit operand. */

domax : if (_trace) printf("domax:\n");
/* arg2 has the preloaded 8 bit operand. */

DoMaxIM : if (_trace) printf("DoMaxIM:\n");
/* This sequence only sucks a moderate amount */
arg1 = arg2 << 56; // sign extend the byte argument.
arg2 = zero;
arg1 = (s64)arg1 >> 56; // Rest of sign extension
*(u32 *)&processor->immediate_arg = arg1;
arg1 = (u64)&processor->immediate_arg;
goto begindomax;

DoMaxSP : if (_trace) printf("DoMaxSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto begindomax;
arg6 = *(u64 *)arg4; // SP-pop, Reload TOS
arg1 = iSP; // SP-pop mode
iSP = arg4; // Adjust SP

DoMaxLP : if (_trace) printf("DoMaxLP:\n");

DoMaxFP : if (_trace) printf("DoMaxFP:\n");

begindomax : if (_trace) printf("begindomax:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
LDS(1, f1, *(u32 *)iSP);
t1 = (u32)(arg6 >> ((4 & 7) * 8)); // ARG1 tag
t3 = *(s32 *)(arg1 + 4); // ARG2 tag
t2 = (s32)arg6; // ARG1 data
t4 = *(s32 *)arg1; // ARG2 data
LDS(2, f2, *(u32 *)arg1);
t9 = t1 & 63; // Strip off any CDR code bits.
t11 = t3 & 63; // Strip off any CDR code bits.
t10 = (t9 == Type_Fixnum) ? 1 : 0;

force_alignment45223 : if (_trace) printf("force_alignment45223:\n");
if (t10 == 0)
    goto basic_dispatch45207;
/* Here if argument TypeFixnum */
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment45212 : if (_trace) printf("force_alignment45212:\n");
if (t12 == 0)
    goto basic_dispatch45209;
/* Here if argument TypeFixnum */
t5 = t2 - t4;
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
if ((s64)t5 > 0)
    t4 = t2;
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
*(u32 *)iSP = t4; // We know temp2 has CDRNext/TypeFixnum
*(u32 *)(iSP + 4) = t9; // write the stack cache
goto cachevalid;

basic_dispatch45209 : if (_trace) printf("basic_dispatch45209:\n");
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment45213 : if (_trace) printf("force_alignment45213:\n");
if (t12 == 0)
    goto binary_type_dispatch45204;
/* Here if argument TypeSingleFloat */
CVTLQ(1, f1, f31, 1, f1);
CVTQS(1, f1, f31, 1, f1);
goto simple_binary_minmax45201;

basic_dispatch45208 : if (_trace) printf("basic_dispatch45208:\n");

basic_dispatch45207 : if (_trace) printf("basic_dispatch45207:\n");
t10 = (t9 == Type_SingleFloat) ? 1 : 0;

force_alignment45224 : if (_trace) printf("force_alignment45224:\n");
if (t10 == 0)
    goto basic_dispatch45214;
/* Here if argument TypeSingleFloat */
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment45219 : if (_trace) printf("force_alignment45219:\n");
if (t12 == 0)
    goto basic_dispatch45216;
/* Here if argument TypeSingleFloat */

simple_binary_minmax45201 : if (_trace) printf("simple_binary_minmax45201:\n");
/* NIL */
SUBS(0, f0, 1, f1, 2, f2); /* subs */
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
if (FLTU64(0, f0) > 0.0)
    f2 = f1;
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
/* trapb force the trap to occur here */ // Force the trap to occur here
t8 = Type_SingleFloat;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 2, f2);
goto cachevalid;

basic_dispatch45216 : if (_trace) printf("basic_dispatch45216:\n");
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment45220 : if (_trace) printf("force_alignment45220:\n");
if (t12 == 0)
    goto binary_type_dispatch45204;
/* Here if argument TypeFixnum */
CVTLQ(2, f2, f31, 2, f2);
CVTQS(2, f2, f31, 2, f2);
goto simple_binary_minmax45201;

basic_dispatch45215 : if (_trace) printf("basic_dispatch45215:\n");

basic_dispatch45214 : if (_trace) printf("basic_dispatch45214:\n");
/* Here for all other cases */

binary_type_dispatch45203 : if (_trace) printf("binary_type_dispatch45203:\n");

simple_binary_minmax45200 : if (_trace) printf("simple_binary_minmax45200:\n");
arg6 = t1; // arg6 = tag to dispatch on
arg3 = 0; // arg3 = stackp
arg1 = 2; // arg1 = instruction arity
arg4 = 1; // arg4 = arithmeticp
goto numericexception;
goto binary_type_dispatch45205;

binary_type_dispatch45204 : if (_trace) printf("binary_type_dispatch45204:\n");
t1 = t3;
goto simple_binary_minmax45200;

binary_type_dispatch45205 : if (_trace) printf("binary_type_dispatch45205:\n");

basic_dispatch45206 : if (_trace) printf("basic_dispatch45206:\n");

/* end DoMax */
/* End of Halfword operand from stack instruction - DoMax */
/* start DoMin */

/* Halfword operand from stack instruction - DoMin */
/* arg2 has the preloaded 8 bit operand. */

domin : if (_trace) printf("domin:\n");
/* arg2 has the preloaded 8 bit operand. */

DoMinIM : if (_trace) printf("DoMinIM:\n");
/* This sequence only sucks a moderate amount */
arg1 = arg2 << 56; // sign extend the byte argument.
arg2 = zero;
arg1 = (s64)arg1 >> 56; // Rest of sign extension
*(u32 *)&processor->immediate_arg = arg1;
arg1 = (u64)&processor->immediate_arg;
goto begindomin;

DoMinSP : if (_trace) printf("DoMinSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 != 0)
    goto begindomin;
arg6 = *(u64 *)arg4; // SP-pop, Reload TOS
arg1 = iSP; // SP-pop mode
iSP = arg4; // Adjust SP

DoMinLP : if (_trace) printf("DoMinLP:\n");

DoMinFP : if (_trace) printf("DoMinFP:\n");

begindomin : if (_trace) printf("begindomin:\n");
/* arg1 has the operand address. */
arg1 = (arg2 * 8) + arg1; // Compute operand address
LDS(1, f1, *(u32 *)iSP);
t1 = (u32)(arg6 >> ((4 & 7) * 8)); // ARG1 tag
t3 = *(s32 *)(arg1 + 4); // ARG2 tag
t2 = (s32)arg6; // ARG1 data
t4 = *(s32 *)arg1; // ARG2 data
LDS(2, f2, *(u32 *)arg1);
t9 = t1 & 63; // Strip off any CDR code bits.
t11 = t3 & 63; // Strip off any CDR code bits.
t10 = (t9 == Type_Fixnum) ? 1 : 0;

force_alignment45248 : if (_trace) printf("force_alignment45248:\n");
if (t10 == 0)
    goto basic_dispatch45232;
/* Here if argument TypeFixnum */
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment45237 : if (_trace) printf("force_alignment45237:\n");
if (t12 == 0)
    goto basic_dispatch45234;
/* Here if argument TypeFixnum */
t5 = t2 - t4;
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
if ((s64)t5 < 0)
    t4 = t2;
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
*(u32 *)iSP = t4; // We know temp2 has CDRNext/TypeFixnum
*(u32 *)(iSP + 4) = t9; // write the stack cache
goto cachevalid;

basic_dispatch45234 : if (_trace) printf("basic_dispatch45234:\n");
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment45238 : if (_trace) printf("force_alignment45238:\n");
if (t12 == 0)
    goto binary_type_dispatch45229;
/* Here if argument TypeSingleFloat */
CVTLQ(1, f1, f31, 1, f1);
CVTQS(1, f1, f31, 1, f1);
goto simple_binary_minmax45226;

basic_dispatch45233 : if (_trace) printf("basic_dispatch45233:\n");

basic_dispatch45232 : if (_trace) printf("basic_dispatch45232:\n");
t10 = (t9 == Type_SingleFloat) ? 1 : 0;

force_alignment45249 : if (_trace) printf("force_alignment45249:\n");
if (t10 == 0)
    goto basic_dispatch45239;
/* Here if argument TypeSingleFloat */
t12 = (t11 == Type_SingleFloat) ? 1 : 0;

force_alignment45244 : if (_trace) printf("force_alignment45244:\n");
if (t12 == 0)
    goto basic_dispatch45241;
/* Here if argument TypeSingleFloat */

simple_binary_minmax45226 : if (_trace) printf("simple_binary_minmax45226:\n");
/* NIL */
SUBS(0, f0, 1, f1, 2, f2); /* subs */
iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
if (FLTU64(0, f0) < 0.0)
    f2 = f1;
iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
/* trapb force the trap to occur here */ // Force the trap to occur here
t8 = Type_SingleFloat;
*(u32 *)(iSP + 4) = t8; // write the stack cache
STS((u32 *)iSP, 2, f2);
goto cachevalid;

basic_dispatch45241 : if (_trace) printf("basic_dispatch45241:\n");
t12 = (t11 == Type_Fixnum) ? 1 : 0;

force_alignment45245 : if (_trace) printf("force_alignment45245:\n");
if (t12 == 0)
    goto binary_type_dispatch45229;
/* Here if argument TypeFixnum */
CVTLQ(2, f2, f31, 2, f2);
CVTQS(2, f2, f31, 2, f2);
goto simple_binary_minmax45226;

basic_dispatch45240 : if (_trace) printf("basic_dispatch45240:\n");

basic_dispatch45239 : if (_trace) printf("basic_dispatch45239:\n");
/* Here for all other cases */

binary_type_dispatch45228 : if (_trace) printf("binary_type_dispatch45228:\n");

simple_binary_minmax45225 : if (_trace) printf("simple_binary_minmax45225:\n");
arg6 = t1; // arg6 = tag to dispatch on
arg3 = 0; // arg3 = stackp
arg1 = 2; // arg1 = instruction arity
arg4 = 1; // arg4 = arithmeticp
goto numericexception;
goto binary_type_dispatch45230;

binary_type_dispatch45229 : if (_trace) printf("binary_type_dispatch45229:\n");
t1 = t3;
goto simple_binary_minmax45225;

binary_type_dispatch45230 : if (_trace) printf("binary_type_dispatch45230:\n");

basic_dispatch45231 : if (_trace) printf("basic_dispatch45231:\n");

/* end DoMin */
/* End of Halfword operand from stack instruction - DoMin */
/* start DoMultiplyDouble */

/* Halfword operand from stack instruction - DoMultiplyDouble */

domultiplydouble : if (_trace) printf("domultiplydouble:\n");
/* arg2 has the preloaded 8 bit operand. */

DoMultiplyDoubleIM : if (_trace) printf("DoMultiplyDoubleIM:\n");
/* This sequence only sucks a moderate amount */
arg2 = arg2 << 56; // sign extend the byte argument.

force_alignment45250 : if (_trace) printf("force_alignment45250:\n");
arg2 = (s64)arg2 >> 56; // Rest of sign extension
*(u32 *)&processor->immediate_arg = arg2;
arg1 = *(u64 *)&(processor->immediate_arg);
goto begindomultiplydouble;

DoMultiplyDoubleSP : if (_trace) printf("DoMultiplyDoubleSP:\n");
arg1 = arg5; // Assume SP mode
if (arg2 == 0) // SP-pop mode
    arg1 = iSP;
if (arg2 == 0) // Adjust SP if SP-pop mode
    iSP = arg4;

DoMultiplyDoubleLP : if (_trace) printf("DoMultiplyDoubleLP:\n");

DoMultiplyDoubleFP : if (_trace) printf("DoMultiplyDoubleFP:\n");

headdomultiplydouble : if (_trace) printf("headdomultiplydouble:\n");
arg1 = (arg2 * 8) + arg1; // Compute operand address
arg1 = *(u64 *)arg1; // Get the operand

begindomultiplydouble : if (_trace) printf("begindomultiplydouble:\n");
/* arg1 has the operand, sign extended if immediate. */
t2 = arg1 >> 32; // ARG2 tag
t3 = *(s32 *)iSP; // ARG1 data, sign extended
t4 = (s32)arg1 + (s32)0; // ARG2 data, sign extended
t1 = *(s32 *)(iSP + 4); // ARG1 tag
/* TagType. */
t1 = t1 & 63; // Strip CDR code if any.
t1 = t1 - Type_Fixnum;
/* TagType. */
t2 = t2 & 63; // Strip CDR code if any.
t5 = t3 * t4; // Perform the 63 bit multiply.
t2 = t2 - Type_Fixnum;
if (t1 != 0)
    goto muldexc;
if (t2 != 0)
    goto muldexc;
t6 = (u32)t5; // Get the low 32 bit half.
t5 = (u32)(t5 >> ((4 & 7) * 8)); // Get the high 32 bit half.
*(u32 *)iSP = t6; // Put the result back on the stack
t1 = Type_Fixnum;
*(u32 *)(iSP + 8) = t5; // Push high order half
*(u32 *)(iSP + 12) = t1; // write the stack cache
iSP = iSP + 8;
goto NEXTINSTRUCTION;

muldexc : if (_trace) printf("muldexc:\n");
arg5 = 0;
arg2 = 80;
goto illegaloperand;

/* end DoMultiplyDouble */
/* End of Halfword operand from stack instruction - DoMultiplyDouble */
/* Fin. */

/* End of file automatically generated from ../alpha-emulator/ifunmath.as */
