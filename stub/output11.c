/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunarra.as
 ************************************************************************/

  /* Array operations. */
/* start Aref1Regset */


aref1regset:
  if (_trace) printf("aref1regset:\n");
  t12 = arg4;
  /* Memory Read Internal */

g29501:
		/* Base of stack cache */
  t1 = *(u64 *)&(processor->stackcachebasevma);
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;
  arg6 = (t3 * 4);   
  arg5 = LDQ_U(t3);   
		/* Stack cache offset */
  t1 = arg4 - t1;
  t4 = *(u64 *)&(processor->header_mask);
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto g29503;

g29502:
  t3 = zero + 64;   
  t4 = t4 >> (arg5 & 63);
  t3 = t3 >> (arg5 & 63);
  arg6 = (u32)arg6;   
  if (t4 & 1)   
    goto g29505;

g29510:
  /* TagType. */
  t1 = arg5 & 63;
  t2 = arg6 >> (Array_LongPrefixBitPos & 63);
  t1 = t1 - Type_HeaderI;
  if (t1 != 0)   
    goto aref1illegal;
  if (t2 & 1)   
    goto aref1exception;
		/* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t12;
  t2 = zero + Array_LengthMask;   
  t1 = arg6 & t2;
  t2 = ((u64)arg2 < (u64)t1) ? 1 : 0;   
  if (t2 == 0) 
    goto aref1bounds;
		/* store the array length [implicit fixnum] */
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;
  t10 = arg6 >> (Array_RegisterBytePackingPos & 63);
  t8 = *(u64 *)&(processor->areventcount);
  t10 = t10 << (Array_RegisterBytePackingPos & 63);
  t9 = arg4 + 1;
  t10 = t10 + t8;		// Construct the array register word 
		/* store the array register word [implicit fixnum] */
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t10;
		/* store the storage [implicit locative] */
  *(u64 *)&((ARRAYCACHEP)t7)->locat = t9;
		/* get BP into arg5 */
  arg5 = arg6 >> (Array_BytePackingPos & 63);
		/* get element type into arg6 */
  arg6 = arg6 >> (Array_ElementTypePos & 63);
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = zero;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aref1restart;   

g29503:
  if (_trace) printf("g29503:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t1 = (t1 * 8) + t2;
  arg6 = *(s32 *)t1;
		/* Read from stack cache */
  arg5 = *(s32 *)(t1 + 4);
  goto g29502;   

g29505:
  if (_trace) printf("g29505:\n");
  if ((t3 & 1) == 0)   
    goto g29504;
  arg4 = (u32)arg6;   		// Do the indirect thing 
  goto g29501;   

g29504:
  if (_trace) printf("g29504:\n");
		/* Load the memory action table for cycle */
  t4 = *(u64 *)&(processor->header);
  /* TagType. */
  t3 = arg5 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
		/* Get the memory action */
  t4 = *(s32 *)t3;

g29507:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end Aref1Regset */
/* start Aref1RecomputeArrayRegister */


aref1recomputearrayregister:
  if (_trace) printf("aref1recomputearrayregister:\n");
  t5 = *(s32 *)(arg1 + -8);
  t4 = *(s32 *)(arg1 + -4);
  t5 = (u32)t5;   
  t6 = t4 - Type_Array;
  t6 = t6 & 62;		// Strip CDR code, low bits 
  if (t6 != 0)   
    goto g29512;
  /* Memory Read Internal */

g29514:
		/* Base of stack cache */
  t8 = *(u64 *)&(processor->stackcachebasevma);
  t3 = t5 + ivory;
  t2 = *(s32 *)&processor->scovlimit;
  t6 = (t3 * 4);   
  t7 = LDQ_U(t3);   
		/* Stack cache offset */
  t8 = t5 - t8;
  t1 = *(u64 *)&(processor->header_mask);
  t2 = ((u64)t8 < (u64)t2) ? 1 : 0;   		// In range? 
  t6 = *(s32 *)t6;
  t7 = (u8)(t7 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto g29516;

g29515:
  t3 = zero + 64;   
  t1 = t1 >> (t7 & 63);
  t3 = t3 >> (t7 & 63);
  t6 = (u32)t6;   
  if (t1 & 1)   
    goto g29518;

g29523:
  /* TagType. */
  t8 = t7 & 63;
  t2 = t6 >> (Array_LongPrefixBitPos & 63);
  t8 = t8 - Type_HeaderI;
  if (t8 != 0)   
    goto g29511;
  if (t2 & 1)   
    goto g29513;
  t1 = t6 >> (Array_BytePackingPos & 63);
  t4 = *(u64 *)&(processor->areventcount);
  t1 = t1 << (Array_RegisterBytePackingPos & 63);
  t2 = t5 + 1;
  t1 = t1 + t4;		// Construct the array register word 
  *(u32 *)(arg1 + 8) = t2;
  t3 = zero + Array_LengthMask;   
  t3 = t6 & t3;
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaref1retry;   

g29513:
  if (_trace) printf("g29513:\n");
		/* Just a place to save these values */
  *(u64 *)&processor->asrf5 = arg1;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf4 = t10;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf3 = t11;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf6 = arg1;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf7 = arg2;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf8 = arg3;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf9 = arg4;
  t9 = *(s32 *)(arg1 + -8);
  arg2 = *(s32 *)(arg1 + -4);
  t9 = (u32)t9;   
  arg1 = t5;
  t4 = t7;
  t3 = t6;
  t2 = 1;
  iSP = iSP + 24;
  r0 = (u64)&&return0645;
  goto setup1dlongarray;
return0645:
  t4 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t4 != 0)   
    goto g29512;
		/* Just a place to save these values */
  arg1 = *(u64 *)&(processor->asrf5);
		/* Just a place to save these values */
  t10 = *(u64 *)&(processor->asrf4);
		/* Just a place to save these values */
  t11 = *(u64 *)&(processor->asrf3);
		/* Just a place to save these values */
  arg1 = *(u64 *)&(processor->asrf6);
		/* Just a place to save these values */
  arg2 = *(u64 *)&(processor->asrf7);
		/* Just a place to save these values */
  arg3 = *(u64 *)&(processor->asrf8);
		/* Just a place to save these values */
  arg4 = *(u64 *)&(processor->asrf9);
  t3 = *(u64 *)iSP;
		/* Pop Stack. */
  iSP = iSP - 8;
  t2 = *(u64 *)iSP;
		/* Pop Stack. */
  iSP = iSP - 8;
  t1 = *(u64 *)iSP;
		/* Pop Stack. */
  iSP = iSP - 8;
  t4 = *(u64 *)iSP;
		/* Pop Stack. */
  iSP = iSP - 8;
  iSP = iSP - 24;
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 8) = t2;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaref1retry;   

g29512:
  if (_trace) printf("g29512:\n");
  arg6 = t4;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 12;
  goto arrayexception;

g29511:
  if (_trace) printf("g29511:\n");
  arg5 = 0;
  arg2 = 12;
  goto illegaloperand;

g29516:
  if (_trace) printf("g29516:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t8 = (t8 * 8) + t2;
  t6 = *(s32 *)t8;
		/* Read from stack cache */
  t7 = *(s32 *)(t8 + 4);
  goto g29515;   

g29518:
  if (_trace) printf("g29518:\n");
  if ((t3 & 1) == 0)   
    goto g29517;
  t5 = (u32)t6;   		// Do the indirect thing 
  goto g29514;   

g29517:
  if (_trace) printf("g29517:\n");
		/* Load the memory action table for cycle */
  t1 = *(u64 *)&(processor->header);
  /* TagType. */
  t3 = t7 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t5;
  t3 = (t3 * 4) + t1;   		// Adjust for a longword load 
		/* Get the memory action */
  t1 = *(s32 *)t3;

g29520:
  /* Perform memory action */
  arg1 = t1;
  arg2 = 6;
  goto performmemoryaction;

/* end Aref1RecomputeArrayRegister */
/* start Aref1Exception */


aref1exception:
  if (_trace) printf("aref1exception:\n");
		/* Just a place to save these values */
  *(u64 *)&processor->asrf4 = arg2;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf5 = t7;
  t9 = t12;
  arg2 = arg3;
  arg1 = arg4;
  t4 = arg5;
  t3 = arg6;
  t2 = zero;
  iSP = iSP + 24;
  r0 = (u64)&&return0646;
  goto setup1dlongarray;
return0646:
		/* Just a place to save these values */
  arg2 = *(s32 *)&processor->asrf4;
		/* Just a place to save these values */
  t7 = *(u64 *)&(processor->asrf5);
		/* Length */
  t1 = *(s32 *)iSP;
		/* Length */
  t5 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;   
		/* base */
  t5 = *(u64 *)iSP;
		/* Pop Stack. */
  iSP = iSP - 8;
		/* control */
  t3 = *(u64 *)iSP;
		/* Pop Stack. */
  iSP = iSP - 8;
		/* The original array */
  t9 = *(s32 *)iSP;
		/* The original array */
  arg3 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  t9 = (u32)t9;   
  iSP = iSP - 24;
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t3;
  *(u32 *)&((ARRAYCACHEP)t7)->locat = t5;
		/* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t9;
  t9 = (u32)t5;   
  t2 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t2 != 0)   
    goto reallyaref1exc;
  t5 = ((u64)arg2 < (u64)t1) ? 1 : 0;   
  if (t5 == 0) 
    goto aref1bounds;
		/* get BP into arg5 */
  arg5 = t3 >> (Array_BytePackingPos & 63);
		/* get element type into arg6 */
  arg6 = t3 >> (Array_ElementTypePos & 63);
  arg4 = t3 >> (Array_RegisterByteOffsetPos & 63);
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = arg4 & Array_RegisterByteOffsetMask;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aref1restart;   

reallyaref1exc:
  if (_trace) printf("reallyaref1exc:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 8;
  goto arrayexception;

aref1illegal:
  if (_trace) printf("aref1illegal:\n");
  arg5 = 0;
  arg2 = 8;
  goto illegaloperand;

aref1bounds:
  if (_trace) printf("aref1bounds:\n");
  *(u64 *)&((ARRAYCACHEP)t7)->array = zero;
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;

/* end Aref1Exception */
/* start Aset1Regset */


aset1regset:
  if (_trace) printf("aset1regset:\n");
  t12 = arg4;
  /* Memory Read Internal */

g29524:
		/* Base of stack cache */
  t1 = *(u64 *)&(processor->stackcachebasevma);
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;
  arg6 = (t3 * 4);   
  arg5 = LDQ_U(t3);   
		/* Stack cache offset */
  t1 = arg4 - t1;
  t4 = *(u64 *)&(processor->header_mask);
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto g29526;

g29525:
  t3 = zero + 64;   
  t4 = t4 >> (arg5 & 63);
  t3 = t3 >> (arg5 & 63);
  arg6 = (u32)arg6;   
  if (t4 & 1)   
    goto g29528;

g29533:
  /* TagType. */
  t1 = arg5 & 63;
  t2 = arg6 >> (Array_LongPrefixBitPos & 63);
  t1 = t1 - Type_HeaderI;
  if (t1 != 0)   
    goto aset1illegal;
  if (t2 & 1)   
    goto aset1exception;
		/* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t12;
  t2 = zero + Array_LengthMask;   
  t1 = arg6 & t2;
  t2 = ((u64)arg2 < (u64)t1) ? 1 : 0;   
  if (t2 == 0) 
    goto aset1bounds;
		/* store the array length [implicit fixnum] */
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;
  t10 = arg6 >> (Array_RegisterBytePackingPos & 63);
  t8 = *(u64 *)&(processor->areventcount);
  t10 = t10 << (Array_RegisterBytePackingPos & 63);
  t9 = arg4 + 1;
  t10 = t10 + t8;		// Construct the array register word 
		/* store the array register word [implicit fixnum] */
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t10;
		/* store the storage [implicit locative] */
  *(u64 *)&((ARRAYCACHEP)t7)->locat = t9;
		/* get BP into arg5 */
  arg5 = arg6 >> (Array_BytePackingPos & 63);
		/* get element type into arg6 */
  arg6 = arg6 >> (Array_ElementTypePos & 63);
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = zero;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aset1restart;   

g29526:
  if (_trace) printf("g29526:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t1 = (t1 * 8) + t2;
  arg6 = *(s32 *)t1;
		/* Read from stack cache */
  arg5 = *(s32 *)(t1 + 4);
  goto g29525;   

g29528:
  if (_trace) printf("g29528:\n");
  if ((t3 & 1) == 0)   
    goto g29527;
  arg4 = (u32)arg6;   		// Do the indirect thing 
  goto g29524;   

g29527:
  if (_trace) printf("g29527:\n");
		/* Load the memory action table for cycle */
  t4 = *(u64 *)&(processor->header);
  /* TagType. */
  t3 = arg5 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
		/* Get the memory action */
  t4 = *(s32 *)t3;

g29530:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end Aset1Regset */
/* start Aset1RecomputeArrayRegister */


aset1recomputearrayregister:
  if (_trace) printf("aset1recomputearrayregister:\n");
  t5 = *(s32 *)(arg1 + -8);
  t4 = *(s32 *)(arg1 + -4);
  t5 = (u32)t5;   
  t6 = t4 - Type_Array;
  t6 = t6 & 62;		// Strip CDR code, low bits 
  if (t6 != 0)   
    goto g29535;
  /* Memory Read Internal */

g29537:
		/* Base of stack cache */
  t8 = *(u64 *)&(processor->stackcachebasevma);
  t3 = t5 + ivory;
  t2 = *(s32 *)&processor->scovlimit;
  t6 = (t3 * 4);   
  t7 = LDQ_U(t3);   
		/* Stack cache offset */
  t8 = t5 - t8;
  t1 = *(u64 *)&(processor->header_mask);
  t2 = ((u64)t8 < (u64)t2) ? 1 : 0;   		// In range? 
  t6 = *(s32 *)t6;
  t7 = (u8)(t7 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto g29539;

g29538:
  t3 = zero + 64;   
  t1 = t1 >> (t7 & 63);
  t3 = t3 >> (t7 & 63);
  t6 = (u32)t6;   
  if (t1 & 1)   
    goto g29541;

g29546:
  /* TagType. */
  t8 = t7 & 63;
  t2 = t6 >> (Array_LongPrefixBitPos & 63);
  t8 = t8 - Type_HeaderI;
  if (t8 != 0)   
    goto g29534;
  if (t2 & 1)   
    goto g29536;
  t1 = t6 >> (Array_BytePackingPos & 63);
  t4 = *(u64 *)&(processor->areventcount);
  t1 = t1 << (Array_RegisterBytePackingPos & 63);
  t2 = t5 + 1;
  t1 = t1 + t4;		// Construct the array register word 
  *(u32 *)(arg1 + 8) = t2;
  t3 = zero + Array_LengthMask;   
  t3 = t6 & t3;
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaset1retry;   

g29536:
  if (_trace) printf("g29536:\n");
		/* Just a place to save these values */
  *(u64 *)&processor->asrf5 = arg1;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf4 = t10;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf3 = t11;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf6 = arg1;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf7 = arg2;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf8 = arg3;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf9 = arg4;
  t9 = *(s32 *)(arg1 + -8);
  arg2 = *(s32 *)(arg1 + -4);
  t9 = (u32)t9;   
  arg1 = t5;
  t4 = t7;
  t3 = t6;
  t2 = 1;
  iSP = iSP + 24;
  r0 = (u64)&&return0647;
  goto setup1dlongarray;
return0647:
  t4 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t4 != 0)   
    goto g29535;
		/* Just a place to save these values */
  arg1 = *(u64 *)&(processor->asrf5);
		/* Just a place to save these values */
  t10 = *(u64 *)&(processor->asrf4);
		/* Just a place to save these values */
  t11 = *(u64 *)&(processor->asrf3);
		/* Just a place to save these values */
  arg1 = *(u64 *)&(processor->asrf6);
		/* Just a place to save these values */
  arg2 = *(u64 *)&(processor->asrf7);
		/* Just a place to save these values */
  arg3 = *(u64 *)&(processor->asrf8);
		/* Just a place to save these values */
  arg4 = *(u64 *)&(processor->asrf9);
  t3 = *(u64 *)iSP;
		/* Pop Stack. */
  iSP = iSP - 8;
  t2 = *(u64 *)iSP;
		/* Pop Stack. */
  iSP = iSP - 8;
  t1 = *(u64 *)iSP;
		/* Pop Stack. */
  iSP = iSP - 8;
  t4 = *(u64 *)iSP;
		/* Pop Stack. */
  iSP = iSP - 8;
  iSP = iSP - 24;
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 8) = t2;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaset1retry;   

g29535:
  if (_trace) printf("g29535:\n");
  arg6 = t4;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 3;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 12;
  goto arrayexception;

g29534:
  if (_trace) printf("g29534:\n");
  arg5 = 0;
  arg2 = 12;
  goto illegaloperand;

g29539:
  if (_trace) printf("g29539:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t8 = (t8 * 8) + t2;
  t6 = *(s32 *)t8;
		/* Read from stack cache */
  t7 = *(s32 *)(t8 + 4);
  goto g29538;   

g29541:
  if (_trace) printf("g29541:\n");
  if ((t3 & 1) == 0)   
    goto g29540;
  t5 = (u32)t6;   		// Do the indirect thing 
  goto g29537;   

g29540:
  if (_trace) printf("g29540:\n");
		/* Load the memory action table for cycle */
  t1 = *(u64 *)&(processor->header);
  /* TagType. */
  t3 = t7 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t5;
  t3 = (t3 * 4) + t1;   		// Adjust for a longword load 
		/* Get the memory action */
  t1 = *(s32 *)t3;

g29543:
  /* Perform memory action */
  arg1 = t1;
  arg2 = 6;
  goto performmemoryaction;

/* end Aset1RecomputeArrayRegister */
/* start Aset1Exception */


aset1exception:
  if (_trace) printf("aset1exception:\n");
		/* Just a place to save these values */
  *(u64 *)&processor->asrf4 = arg2;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf3 = t5;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf6 = t6;
		/* Just a place to save these values */
  *(u64 *)&processor->asrf5 = t7;
  t9 = t12;
  arg2 = arg3;
  arg1 = arg4;
  t4 = arg5;
  t3 = arg6;
  t2 = zero;
  iSP = iSP + 24;
  r0 = (u64)&&return0648;
  goto setup1dlongarray;
return0648:
  t1 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t1 != 0)   
    goto reallyaset1exc;
		/* Just a place to save these values */
  arg2 = *(s32 *)&processor->asrf4;
		/* Just a place to save these values */
  t5 = *(u64 *)&(processor->asrf3);
		/* Just a place to save these values */
  t6 = *(u64 *)&(processor->asrf6);
		/* Just a place to save these values */
  t7 = *(u64 *)&(processor->asrf5);
		/* Length */
  t1 = *(s32 *)iSP;
		/* Length */
  t2 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;   
		/* base */
  t2 = *(u64 *)iSP;
		/* Pop Stack. */
  iSP = iSP - 8;
		/* control */
  t3 = *(u64 *)iSP;
		/* Pop Stack. */
  iSP = iSP - 8;
		/* The original array */
  t9 = *(s32 *)iSP;
		/* The original array */
  arg3 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  t9 = (u32)t9;   
  iSP = iSP - 24;
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t3;
  *(u32 *)&((ARRAYCACHEP)t7)->locat = t2;
		/* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t9;
  t9 = (u32)t2;   
  t2 = ((u64)arg2 < (u64)t1) ? 1 : 0;   
  if (t2 == 0) 
    goto aset1bounds;
		/* get BP into arg5 */
  arg5 = t3 >> (Array_BytePackingPos & 63);
		/* get element type into arg6 */
  arg6 = t3 >> (Array_ElementTypePos & 63);
  arg4 = t3 >> (Array_RegisterByteOffsetPos & 63);
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = arg4 & Array_RegisterByteOffsetMask;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aset1restart;   

reallyaset1exc:
  if (_trace) printf("reallyaset1exc:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 3;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 9;
  goto arrayexception;

aset1illegal:
  if (_trace) printf("aset1illegal:\n");
  arg5 = 0;
  arg2 = 9;
  goto illegaloperand;

aset1bounds:
  if (_trace) printf("aset1bounds:\n");
  *(u64 *)&((ARRAYCACHEP)t7)->array = zero;
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;

/* end Aset1Exception */
/* start DoAloc1 */

  /* Halfword operand from stack instruction - DoAloc1 */
  /* arg2 has the preloaded 8 bit operand. */

doaloc1:
  if (_trace) printf("doaloc1:\n");
#ifdef TRACING
#endif

DoAloc1SP:
  if (_trace) printf("DoAloc1SP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoaloc1;   
#endif

DoAloc1LP:
  if (_trace) printf("DoAloc1LP:\n");
#ifdef TRACING
  goto headdoaloc1;   
#endif

DoAloc1FP:
  if (_trace) printf("DoAloc1FP:\n");

headdoaloc1:
  if (_trace) printf("headdoaloc1:\n");
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
		/* Get the operand */
  arg1 = *(u64 *)arg1;

begindoaloc1:
  if (_trace) printf("begindoaloc1:\n");
  /* arg1 has the operand, not sign extended if immediate. */
		/* Get the array tag/data */
  arg4 = *(s32 *)iSP;
		/* Get the array tag/data */
  arg3 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;   
  arg2 = (u32)arg1;   		// Index Data 
		/* Index Tag */
  arg1 = arg1 >> 32;
  t1 = arg1 - Type_Fixnum;
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto aloc1illegal;

aloc1merge:
  if (_trace) printf("aloc1merge:\n");
  t1 = arg3 - Type_Array;
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto aloc1exception;
  /* Memory Read Internal */

g29547:
		/* Base of stack cache */
  t1 = *(u64 *)&(processor->stackcachebasevma);
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;
  arg6 = (t3 * 4);   
  arg5 = LDQ_U(t3);   
		/* Stack cache offset */
  t1 = arg4 - t1;
  t4 = *(u64 *)&(processor->header_mask);
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto g29549;

g29548:
  t3 = zero + 64;   
  t4 = t4 >> (arg5 & 63);
  t3 = t3 >> (arg5 & 63);
  if (t4 & 1)   
    goto g29551;

g29556:
  /* TagType. */
  t1 = arg5 & 63;
  t2 = arg6 >> (Array_LongPrefixBitPos & 63);
  t1 = t1 - Type_HeaderI;
  if (t1 != 0)   
    goto aloc1illegal;
  if (t2 & 1)   
    goto aloc1exception;
  t2 = zero + Array_LengthMask;   
  t1 = arg6 & t2;
  t3 = ((u64)arg2 < (u64)t1) ? 1 : 0;   
  if (t3 == 0) 
    goto aloc1illegal;
		/* get element type into arg6 */
  arg6 = arg6 >> (Array_ElementTypePos & 63);
  arg4 = arg4 + 1;
  arg4 = arg4 + arg2;
  arg6 = arg6 & Array_ElementTypeMask;
  arg6 = arg6 - Array_ElementTypeObject;
  if (arg6 != 0)   
    goto aloc1notobject;
  t1 = Type_Locative;
  *(u32 *)(iSP + 8) = arg4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

aloc1exception:
  if (_trace) printf("aloc1exception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 8;
  goto arrayexception;

aloc1illegal:
  if (_trace) printf("aloc1illegal:\n");
  arg5 = 0;
  arg2 = 8;
  goto illegaloperand;

aloc1bounds:
  if (_trace) printf("aloc1bounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;

aloc1notobject:
  if (_trace) printf("aloc1notobject:\n");
  arg5 = 0;
  arg2 = 7;
  goto illegaloperand;
#ifdef TRACING
  goto DoAloc1IM;   
#endif

DoAloc1IM:
  if (_trace) printf("DoAloc1IM:\n");
		/* Get the array tag/data */
  arg4 = *(s32 *)iSP;
		/* Get the array tag/data */
  arg3 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;   
  goto aloc1merge;   

g29549:
  if (_trace) printf("g29549:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t1 = (t1 * 8) + t2;
  arg6 = *(s32 *)t1;
		/* Read from stack cache */
  arg5 = *(s32 *)(t1 + 4);
  goto g29548;   

g29551:
  if (_trace) printf("g29551:\n");
  if ((t3 & 1) == 0)   
    goto g29550;
  arg4 = (u32)arg6;   		// Do the indirect thing 
  goto g29547;   

g29550:
  if (_trace) printf("g29550:\n");
		/* Load the memory action table for cycle */
  t4 = *(u64 *)&(processor->header);
  /* TagType. */
  t3 = arg5 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
		/* Get the memory action */
  t4 = *(s32 *)t3;

g29553:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoAloc1 */
  /* End of Halfword operand from stack instruction - DoAloc1 */
  /* Array register operations. */
/* start DoSetup1DArray */

  /* Halfword operand from stack instruction - DoSetup1DArray */

dosetup1darray:
  if (_trace) printf("dosetup1darray:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoSetup1DArrayIM:
  if (_trace) printf("DoSetup1DArrayIM:\n");
  /* This sequence only sucks a moderate amount */
		/* sign extend the byte argument. */
  arg2 = arg2 << 56;

g29570:
  if (_trace) printf("g29570:\n");
		/* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindosetup1darray;   
#ifdef TRACING
#endif

DoSetup1DArraySP:
  if (_trace) printf("DoSetup1DArraySP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdosetup1darray;   
#endif

DoSetup1DArrayLP:
  if (_trace) printf("DoSetup1DArrayLP:\n");
#ifdef TRACING
  goto headdosetup1darray;   
#endif

DoSetup1DArrayFP:
  if (_trace) printf("DoSetup1DArrayFP:\n");

headdosetup1darray:
  if (_trace) printf("headdosetup1darray:\n");
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
		/* Get the operand */
  arg1 = *(u64 *)arg1;

begindosetup1darray:
  if (_trace) printf("begindosetup1darray:\n");
  /* arg1 has the operand, sign extended if immediate. */
		/* Get the tag */
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;   		// and the data 
  t2 = 0;		// Indicate not forcing 1d 
  t9 = arg1;
  t3 = arg2 - Type_Array;
  t3 = t3 & 62;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto g29558;
  /* Memory Read Internal */

g29560:
		/* Base of stack cache */
  t5 = *(u64 *)&(processor->stackcachebasevma);
  t7 = arg1 + ivory;
  t6 = *(s32 *)&processor->scovlimit;
  t3 = (t7 * 4);   
  t4 = LDQ_U(t7);   
		/* Stack cache offset */
  t5 = arg1 - t5;
  t8 = *(u64 *)&(processor->header_mask);
  t6 = ((u64)t5 < (u64)t6) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto g29562;

g29561:
  t7 = zero + 64;   
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  t3 = (u32)t3;   
  if (t8 & 1)   
    goto g29564;

g29569:
  /* TagType. */
  t5 = t4 & 63;
  t6 = t3 >> (Array_LongPrefixBitPos & 63);
  t5 = t5 - Type_HeaderI;
  if (t5 != 0)   
    goto g29557;
  if (t6 & 1)   
    goto g29559;
  t5 = arg2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  t8 = t3 >> (Array_RegisterBytePackingPos & 63);
  t7 = Type_Fixnum;
  t1 = *(u64 *)&(processor->areventcount);
  t8 = t8 << (Array_RegisterBytePackingPos & 63);
  t5 = arg1 + 1;
  t8 = t8 + t1;		// Construct the array register word 
  t6 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  t6 = zero + Array_LengthMask;   
  t6 = t3 & t6;
  t8 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

g29558:
  if (_trace) printf("g29558:\n");
  /* SetTag. */
  t6 = arg2 << 32;
  t6 = t9 | t6;
  arg6 = arg2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 71;
  goto arrayexception;

g29557:
  if (_trace) printf("g29557:\n");
  arg5 = 0;
  arg2 = 71;
  goto illegaloperand;

g29559:
  if (_trace) printf("g29559:\n");
  r0 = (u64)&&return0649;
  goto setup1dlongarray;
return0649:
  t1 = (t2 == ReturnValue_Normal) ? 1 : 0;   
  if (t1 != 0)   
    goto NEXTINSTRUCTION;
  t1 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t1 != 0)   
    goto g29558;
  t1 = (t2 == ReturnValue_IllegalOperand) ? 1 : 0;   
  if (t1 != 0)   
    goto g29557;
  goto NEXTINSTRUCTION;   

g29562:
  if (_trace) printf("g29562:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t3 = *(s32 *)t5;
		/* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g29561;   

g29564:
  if (_trace) printf("g29564:\n");
  if ((t7 & 1) == 0)   
    goto g29563;
  arg1 = (u32)t3;   		// Do the indirect thing 
  goto g29560;   

g29563:
  if (_trace) printf("g29563:\n");
		/* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
		/* Get the memory action */
  t8 = *(s32 *)t7;

g29566:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoSetup1DArray */
  /* End of Halfword operand from stack instruction - DoSetup1DArray */
/* start DoSetupForce1DArray */

  /* Halfword operand from stack instruction - DoSetupForce1DArray */

dosetupforce1darray:
  if (_trace) printf("dosetupforce1darray:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoSetupForce1DArrayIM:
  if (_trace) printf("DoSetupForce1DArrayIM:\n");
  /* This sequence only sucks a moderate amount */
		/* sign extend the byte argument. */
  arg2 = arg2 << 56;

g29584:
  if (_trace) printf("g29584:\n");
		/* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindosetupforce1darray;   
#ifdef TRACING
#endif

DoSetupForce1DArraySP:
  if (_trace) printf("DoSetupForce1DArraySP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdosetupforce1darray;   
#endif

DoSetupForce1DArrayLP:
  if (_trace) printf("DoSetupForce1DArrayLP:\n");
#ifdef TRACING
  goto headdosetupforce1darray;   
#endif

DoSetupForce1DArrayFP:
  if (_trace) printf("DoSetupForce1DArrayFP:\n");

headdosetupforce1darray:
  if (_trace) printf("headdosetupforce1darray:\n");
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
		/* Get the operand */
  arg1 = *(u64 *)arg1;

begindosetupforce1darray:
  if (_trace) printf("begindosetupforce1darray:\n");
  /* arg1 has the operand, sign extended if immediate. */
		/* Get the tag */
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;   		// and the data 
  t2 = 1;		// Indicate forcing 1d 
  t9 = arg1;
  t3 = arg2 - Type_Array;
  t3 = t3 & 62;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto g29572;
  /* Memory Read Internal */

g29574:
		/* Base of stack cache */
  t5 = *(u64 *)&(processor->stackcachebasevma);
  t7 = arg1 + ivory;
  t6 = *(s32 *)&processor->scovlimit;
  t3 = (t7 * 4);   
  t4 = LDQ_U(t7);   
		/* Stack cache offset */
  t5 = arg1 - t5;
  t8 = *(u64 *)&(processor->header_mask);
  t6 = ((u64)t5 < (u64)t6) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto g29576;

g29575:
  t7 = zero + 64;   
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  t3 = (u32)t3;   
  if (t8 & 1)   
    goto g29578;

g29583:
  /* TagType. */
  t5 = t4 & 63;
  t6 = t3 >> (Array_LongPrefixBitPos & 63);
  t5 = t5 - Type_HeaderI;
  if (t5 != 0)   
    goto g29571;
  if (t6 & 1)   
    goto g29573;
  t5 = arg2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  t8 = t3 >> (Array_RegisterBytePackingPos & 63);
  t7 = Type_Fixnum;
  t1 = *(u64 *)&(processor->areventcount);
  t8 = t8 << (Array_RegisterBytePackingPos & 63);
  t5 = arg1 + 1;
  t8 = t8 + t1;		// Construct the array register word 
  t6 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  t6 = zero + Array_LengthMask;   
  t6 = t3 & t6;
  t8 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

g29572:
  if (_trace) printf("g29572:\n");
  /* SetTag. */
  t6 = arg2 << 32;
  t6 = t9 | t6;
  arg6 = arg2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 71;
  goto arrayexception;

g29571:
  if (_trace) printf("g29571:\n");
  arg5 = 0;
  arg2 = 71;
  goto illegaloperand;

g29573:
  if (_trace) printf("g29573:\n");
  r0 = (u64)&&return0650;
  goto setup1dlongarray;
return0650:
  t1 = (t2 == ReturnValue_Normal) ? 1 : 0;   
  if (t1 != 0)   
    goto NEXTINSTRUCTION;
  t1 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t1 != 0)   
    goto g29572;
  t1 = (t2 == ReturnValue_IllegalOperand) ? 1 : 0;   
  if (t1 != 0)   
    goto g29571;
  goto NEXTINSTRUCTION;   

g29576:
  if (_trace) printf("g29576:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t3 = *(s32 *)t5;
		/* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g29575;   

g29578:
  if (_trace) printf("g29578:\n");
  if ((t7 & 1) == 0)   
    goto g29577;
  arg1 = (u32)t3;   		// Do the indirect thing 
  goto g29574;   

g29577:
  if (_trace) printf("g29577:\n");
		/* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
		/* Get the memory action */
  t8 = *(s32 *)t7;

g29580:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoSetupForce1DArray */
  /* End of Halfword operand from stack instruction - DoSetupForce1DArray */
/* start Setup1DLongArray */


setup1dlongarray:
  if (_trace) printf("setup1dlongarray:\n");
  /* Read data from the header: alength offset indirect lengths&mults */
  t1 = arg1 + 1;   		// length=array+1 
  /* Memory Read Internal */

g29594:
		/* Base of stack cache */
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;
  arg4 = (t10 * 4);   
  t6 = LDQ_U(t10);   
		/* Stack cache offset */
  t7 = t1 - t7;
  t11 = *(u64 *)&(processor->dataread_mask);
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  arg4 = *(s32 *)arg4;
  t6 = (u8)(t6 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto g29596;

g29595:
  t10 = zero + 240;   
  t11 = t11 >> (t6 & 63);
  t10 = t10 >> (t6 & 63);
  arg4 = (u32)arg4;   
  if (t11 & 1)   
    goto g29598;

g29605:
  t8 = t6 - Type_Fixnum;
  t8 = t8 & 63;		// Strip CDR code 
  if (t8 != 0)   
    goto g29585;
  t1 = t1 + 1;   		// Offset is adata+2 
  /* Memory Read Internal */

g29606:
		/* Base of stack cache */
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;
  arg3 = (t10 * 4);   
  t6 = LDQ_U(t10);   
		/* Stack cache offset */
  t7 = t1 - t7;
  t11 = *(u64 *)&(processor->dataread_mask);
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  arg3 = *(s32 *)arg3;
  t6 = (u8)(t6 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto g29608;

g29607:
  t10 = zero + 240;   
  t11 = t11 >> (t6 & 63);
  t10 = t10 >> (t6 & 63);
  arg3 = (u32)arg3;   
  if (t11 & 1)   
    goto g29610;

g29617:
  t8 = t6 - Type_Fixnum;
  t8 = t8 & 63;		// Strip CDR code 
  if (t8 != 0)   
    goto g29585;
  t1 = t1 + 1;   		// Indirect is adata+3 
  /* Memory Read Internal */

g29618:
		/* Base of stack cache */
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;
  t5 = (t10 * 4);   
  t6 = LDQ_U(t10);   
		/* Stack cache offset */
  t7 = t1 - t7;
  t11 = *(u64 *)&(processor->dataread_mask);
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;
  t6 = (u8)(t6 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto g29620;

g29619:
  t10 = zero + 240;   
  t11 = t11 >> (t6 & 63);
  t10 = t10 >> (t6 & 63);
  t5 = (u32)t5;   
  if (t11 & 1)   
    goto g29622;

g29629:
  t10 = t6 & 63;		// Strip off any CDR code bits. 
  t11 = (t10 == Type_Locative) ? 1 : 0;   

g29694:
  if (_trace) printf("g29694:\n");
  if (t11 == 0) 
    goto g29631;
  /* Here if argument TypeLocative */

g29588:
  if (_trace) printf("g29588:\n");
  t10 = arg2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t10;
  iSP = iSP + 8;
  t8 = t3 >> (Array_BytePackingPos & 63);
  t7 = Type_Fixnum;
  t1 = *(u64 *)&(processor->areventcount);
  t8 = t8 << (Array_RegisterBytePackingPos & 63);
  t8 = t8 + t1;		// Construct the array register word 
  t6 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  t8 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g29593;   

g29631:
  if (_trace) printf("g29631:\n");
  t11 = (t10 == Type_Fixnum) ? 1 : 0;   

g29695:
  if (_trace) printf("g29695:\n");
  if (t11 == 0) 
    goto g29632;
  /* Here if argument TypeFixnum */
  goto g29588;   

g29632:
  if (_trace) printf("g29632:\n");
  t11 = (t10 == Type_Array) ? 1 : 0;   

g29696:
  if (_trace) printf("g29696:\n");
  if (t11 == 0) 
    goto g29633;
  /* Here if argument TypeArray */

g29592:
  if (_trace) printf("g29592:\n");
  t1 = t3 & 7;
  t1 = (t1 == 1) ? 1 : 0;   
  t1 = t1 | t2;		// Force true if FORCE 
  if (t1 == 0) 
    goto g29585;
  t12 = t3 >> (Array_BytePackingPos & 63);
  t12 = t12 & Array_BytePackingMask;
  t2 = arg3;

g29587:
  if (_trace) printf("g29587:\n");
  /* Memory Read Internal */

g29634:
		/* Base of stack cache */
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t5 + ivory;
  t8 = *(s32 *)&processor->scovlimit;
  t4 = (t10 * 4);   
  t6 = LDQ_U(t10);   
		/* Stack cache offset */
  t7 = t5 - t7;
  t11 = *(u64 *)&(processor->header_mask);
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  t4 = *(s32 *)t4;
  t6 = (u8)(t6 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto g29636;

g29635:
  t10 = zero + 64;   
  t11 = t11 >> (t6 & 63);
  t10 = t10 >> (t6 & 63);
  t4 = (u32)t4;   
  if (t11 & 1)   
    goto g29638;

g29643:
  t10 = t4 >> (Array_BytePackingPos & 63);
  t10 = t10 & Array_BytePackingMask;
  arg1 = t12 - t10;
  t7 = t4 >> (Array_LongPrefixBitPos & 63);
  if (t7 & 1)   
    goto g29589;
  t5 = t5 + 1;		// increment beyond header 
  t8 = zero + 32767;   
  t8 = t4 & t8;
  t10 = zero - arg1;
  t10 = t8 >> (t10 & 63);
  t8 = t8 << (arg1 & 63);
  if ((s64)arg1 <= 0)   
    t8 = t10;
  t10 = arg4 + arg3;
  t7 = t10 - t8;
  if ((s64)t7 <= 0)   
    t8 = t10;
  arg4 = t8;

g29586:
  if (_trace) printf("g29586:\n");
  arg4 = arg4 - t2;
  t10 = arg2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t10;
  iSP = iSP + 8;
  t7 = Type_Fixnum;
  t8 = t3 >> (Array_RegisterBytePackingPos & 63);
  t1 = *(u64 *)&(processor->areventcount);
  t8 = t8 << (Array_RegisterBytePackingPos & 63);
		/* -1 */
  t11 = zero - 1;
		/* (LSH -1 byte-packing) */
  t11 = t11 << (t12 & 63);
  t11 = t2 & ~t11;
  t11 = t11 << (Array_RegisterByteOffsetPos & 63);
  t8 = t8 + t1;		// Construct the array register word 
  t8 = t11 + t8;		// Add in the byte offset 
  t6 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  if ((s64)arg4 <= 0)   
    arg4 = zero;
  if (arg4 == 0) 
    goto g29590;
  t1 = zero - t12;
  t1 = t2 << (t1 & 63);
  t2 = t2 >> (t12 & 63);
  if ((s64)t12 <= 0)   
    t2 = t1;
  t5 = t2 + t5;

g29590:
  if (_trace) printf("g29590:\n");
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  t8 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g29593;   

g29589:
  if (_trace) printf("g29589:\n");
  t1 = t5 + 1;		// length=array+1 
  /* Memory Read Internal */

g29644:
		/* Base of stack cache */
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;
  arg6 = (t10 * 4);   
  t4 = LDQ_U(t10);   
		/* Stack cache offset */
  t7 = t1 - t7;
  t11 = *(u64 *)&(processor->dataread_mask);
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;
  t4 = (u8)(t4 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto g29646;

g29645:
  t10 = zero + 240;   
  t11 = t11 >> (t4 & 63);
  t10 = t10 >> (t4 & 63);
  arg6 = (u32)arg6;   
  if (t11 & 1)   
    goto g29648;

g29655:
  t1 = t4 - Type_Fixnum;
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto g29585;
  t1 = t5 + 2;		// offset=array+2 
  /* Memory Read Internal */

g29656:
		/* Base of stack cache */
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;
  arg5 = (t10 * 4);   
  t4 = LDQ_U(t10);   
		/* Stack cache offset */
  t7 = t1 - t7;
  t11 = *(u64 *)&(processor->dataread_mask);
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  arg5 = *(s32 *)arg5;
  t4 = (u8)(t4 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto g29658;

g29657:
  t10 = zero + 240;   
  t11 = t11 >> (t4 & 63);
  t10 = t10 >> (t4 & 63);
  arg5 = (u32)arg5;   
  if (t11 & 1)   
    goto g29660;

g29667:
  t1 = t4 - Type_Fixnum;
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto g29585;
  t1 = t5 + 3;		// next=array+3 
  /* Memory Read Internal */

g29668:
		/* Base of stack cache */
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;
  t5 = (t10 * 4);   
  t4 = LDQ_U(t10);   
		/* Stack cache offset */
  t7 = t1 - t7;
  t11 = *(u64 *)&(processor->dataread_mask);
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto g29670;

g29669:
  t10 = zero + 240;   
  t11 = t11 >> (t4 & 63);
  t10 = t10 >> (t4 & 63);
  t5 = (u32)t5;   
  if (t11 & 1)   
    goto g29672;

g29679:
  t8 = zero - arg1;
  t8 = arg6 >> (t8 & 63);
  t10 = arg6 << (arg1 & 63);
  if ((s64)arg1 <= 0)   
    t10 = t8;
  t8 = arg4 + arg3;
  if ((s64)t10 <= 0)   
    t10 = t8;
  t7 = t10 - t8;
  if ((s64)t7 <= 0)   
    t8 = t10;
  arg4 = t8;
  t8 = t4 & 63;		// Strip off any CDR code bits. 
  t10 = (t8 == Type_Locative) ? 1 : 0;   

g29687:
  if (_trace) printf("g29687:\n");
  if (t10 == 0) 
    goto g29681;
  /* Here if argument TypeLocative */
  goto g29586;   

g29681:
  if (_trace) printf("g29681:\n");
  t10 = (t8 == Type_Fixnum) ? 1 : 0;   

g29688:
  if (_trace) printf("g29688:\n");
  if (t10 == 0) 
    goto g29682;
  /* Here if argument TypeFixnum */
  goto g29586;   

g29682:
  if (_trace) printf("g29682:\n");
  t10 = (t8 == Type_Array) ? 1 : 0;   

g29689:
  if (_trace) printf("g29689:\n");
  if (t10 == 0) 
    goto g29683;
  /* Here if argument TypeArray */

g29591:
  if (_trace) printf("g29591:\n");
  t7 = zero - arg1;
  t7 = arg5 >> (t7 & 63);
  arg3 = arg5 << (arg1 & 63);
  if ((s64)arg1 <= 0)   
    arg3 = t7;
  t2 = t2 + arg3;
  goto g29587;   

g29683:
  if (_trace) printf("g29683:\n");
  t10 = (t8 == Type_String) ? 1 : 0;   

g29690:
  if (_trace) printf("g29690:\n");
  if (t10 == 0) 
    goto g29684;
  /* Here if argument TypeString */
  goto g29591;   

g29684:
  if (_trace) printf("g29684:\n");
  /* Here for all other cases */
  goto g29585;   

g29680:
  if (_trace) printf("g29680:\n");

g29633:
  if (_trace) printf("g29633:\n");
  t11 = (t10 == Type_String) ? 1 : 0;   

g29697:
  if (_trace) printf("g29697:\n");
  if (t11 == 0) 
    goto g29691;
  /* Here if argument TypeString */
  goto g29592;   

g29691:
  if (_trace) printf("g29691:\n");
  /* Here for all other cases */
  goto g29585;   

g29630:
  if (_trace) printf("g29630:\n");

g29585:
  if (_trace) printf("g29585:\n");
  t2 = ReturnValue_Exception;
  goto *r0; /* ret */

g29593:
  if (_trace) printf("g29593:\n");
  t2 = ReturnValue_Normal;
  goto *r0; /* ret */

g29670:
  if (_trace) printf("g29670:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t5 = *(s32 *)t7;
		/* Read from stack cache */
  t4 = *(s32 *)(t7 + 4);
  goto g29669;   

g29672:
  if (_trace) printf("g29672:\n");
  if ((t10 & 1) == 0)   
    goto g29671;
  t1 = (u32)t5;   		// Do the indirect thing 
  goto g29668;   

g29671:
  if (_trace) printf("g29671:\n");
		/* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t10 = t4 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
		/* Get the memory action */
  t11 = *(s32 *)t10;

g29676:
  if (_trace) printf("g29676:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto g29675;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g29679;   
#ifndef MINIMA

g29675:
#endif
#ifdef MINIMA

g29675:
  if (_trace) printf("g29675:\n");
  t10 = t11 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t10 == 0) 
    goto g29674;
  t7 = t1 << 1;
  t10 = *(u64 *)&(processor->dbcbase);
  t7 = t7 & t8;		// Hash index 
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t10;
  t7 = (u32)t7;   		// Clear sign-extension 
  t8 = (t7 * 4) + t8;   
		/* Fetch the key */
  t7 = *(s32 *)t8;
		/* Fetch value */
  t5 = *(s32 *)(t8 + 4);
		/* Compare */
  t10 = (s32)t1 - (s32)t7;
  if (t10 != 0)   		// Trap on miss 
    goto g29678;
  t1 = (u32)t5;   		// Extract the pointer, and indirect 
  goto g29668;   		// This is another memory read tailcall. 

g29678:
  if (_trace) printf("g29678:\n");
  goto dbcachemisstrap;
#endif

g29674:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

g29658:
  if (_trace) printf("g29658:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  arg5 = *(s32 *)t7;
		/* Read from stack cache */
  t4 = *(s32 *)(t7 + 4);
  goto g29657;   

g29660:
  if (_trace) printf("g29660:\n");
  if ((t10 & 1) == 0)   
    goto g29659;
  t1 = (u32)arg5;   		// Do the indirect thing 
  goto g29656;   

g29659:
  if (_trace) printf("g29659:\n");
		/* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t10 = t4 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
		/* Get the memory action */
  t11 = *(s32 *)t10;

g29664:
  if (_trace) printf("g29664:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto g29663;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g29667;   
#ifndef MINIMA

g29663:
#endif
#ifdef MINIMA

g29663:
  if (_trace) printf("g29663:\n");
  t10 = t11 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t10 == 0) 
    goto g29662;
  t7 = t1 << 1;
  t10 = *(u64 *)&(processor->dbcbase);
  t7 = t7 & t8;		// Hash index 
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t10;
  t7 = (u32)t7;   		// Clear sign-extension 
  t8 = (t7 * 4) + t8;   
		/* Fetch the key */
  t7 = *(s32 *)t8;
		/* Fetch value */
  arg5 = *(s32 *)(t8 + 4);
		/* Compare */
  t10 = (s32)t1 - (s32)t7;
  if (t10 != 0)   		// Trap on miss 
    goto g29666;
  t1 = (u32)arg5;   		// Extract the pointer, and indirect 
  goto g29656;   		// This is another memory read tailcall. 

g29666:
  if (_trace) printf("g29666:\n");
  goto dbcachemisstrap;
#endif

g29662:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

g29646:
  if (_trace) printf("g29646:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  arg6 = *(s32 *)t7;
		/* Read from stack cache */
  t4 = *(s32 *)(t7 + 4);
  goto g29645;   

g29648:
  if (_trace) printf("g29648:\n");
  if ((t10 & 1) == 0)   
    goto g29647;
  t1 = (u32)arg6;   		// Do the indirect thing 
  goto g29644;   

g29647:
  if (_trace) printf("g29647:\n");
		/* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t10 = t4 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
		/* Get the memory action */
  t11 = *(s32 *)t10;

g29652:
  if (_trace) printf("g29652:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto g29651;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g29655;   
#ifndef MINIMA

g29651:
#endif
#ifdef MINIMA

g29651:
  if (_trace) printf("g29651:\n");
  t10 = t11 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t10 == 0) 
    goto g29650;
  t7 = t1 << 1;
  t10 = *(u64 *)&(processor->dbcbase);
  t7 = t7 & t8;		// Hash index 
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t10;
  t7 = (u32)t7;   		// Clear sign-extension 
  t8 = (t7 * 4) + t8;   
		/* Fetch the key */
  t7 = *(s32 *)t8;
		/* Fetch value */
  arg6 = *(s32 *)(t8 + 4);
		/* Compare */
  t10 = (s32)t1 - (s32)t7;
  if (t10 != 0)   		// Trap on miss 
    goto g29654;
  t1 = (u32)arg6;   		// Extract the pointer, and indirect 
  goto g29644;   		// This is another memory read tailcall. 

g29654:
  if (_trace) printf("g29654:\n");
  goto dbcachemisstrap;
#endif

g29650:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

g29636:
  if (_trace) printf("g29636:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t4 = *(s32 *)t7;
		/* Read from stack cache */
  t6 = *(s32 *)(t7 + 4);
  goto g29635;   

g29638:
  if (_trace) printf("g29638:\n");
  if ((t10 & 1) == 0)   
    goto g29637;
  t5 = (u32)t4;   		// Do the indirect thing 
  goto g29634;   

g29637:
  if (_trace) printf("g29637:\n");
		/* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->header);
  /* TagType. */
  t10 = t6 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t5;
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
		/* Get the memory action */
  t11 = *(s32 *)t10;

g29640:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 6;
  goto performmemoryaction;

g29620:
  if (_trace) printf("g29620:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t5 = *(s32 *)t7;
		/* Read from stack cache */
  t6 = *(s32 *)(t7 + 4);
  goto g29619;   

g29622:
  if (_trace) printf("g29622:\n");
  if ((t10 & 1) == 0)   
    goto g29621;
  t1 = (u32)t5;   		// Do the indirect thing 
  goto g29618;   

g29621:
  if (_trace) printf("g29621:\n");
		/* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t10 = t6 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
		/* Get the memory action */
  t11 = *(s32 *)t10;

g29626:
  if (_trace) printf("g29626:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto g29625;
  t6 = t6 & ~63L;
  t6 = t6 | Type_ExternalValueCellPointer;
  goto g29629;   
#ifndef MINIMA

g29625:
#endif
#ifdef MINIMA

g29625:
  if (_trace) printf("g29625:\n");
  t10 = t11 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t10 == 0) 
    goto g29624;
  t7 = t1 << 1;
  t10 = *(u64 *)&(processor->dbcbase);
  t7 = t7 & t8;		// Hash index 
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t10;
  t7 = (u32)t7;   		// Clear sign-extension 
  t8 = (t7 * 4) + t8;   
		/* Fetch the key */
  t7 = *(s32 *)t8;
		/* Fetch value */
  t5 = *(s32 *)(t8 + 4);
		/* Compare */
  t10 = (s32)t1 - (s32)t7;
  if (t10 != 0)   		// Trap on miss 
    goto g29628;
  t1 = (u32)t5;   		// Extract the pointer, and indirect 
  goto g29618;   		// This is another memory read tailcall. 

g29628:
  if (_trace) printf("g29628:\n");
  goto dbcachemisstrap;
#endif

g29624:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

g29608:
  if (_trace) printf("g29608:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  arg3 = *(s32 *)t7;
		/* Read from stack cache */
  t6 = *(s32 *)(t7 + 4);
  goto g29607;   

g29610:
  if (_trace) printf("g29610:\n");
  if ((t10 & 1) == 0)   
    goto g29609;
  t1 = (u32)arg3;   		// Do the indirect thing 
  goto g29606;   

g29609:
  if (_trace) printf("g29609:\n");
		/* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t10 = t6 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
		/* Get the memory action */
  t11 = *(s32 *)t10;

g29614:
  if (_trace) printf("g29614:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto g29613;
  t6 = t6 & ~63L;
  t6 = t6 | Type_ExternalValueCellPointer;
  goto g29617;   
#ifndef MINIMA

g29613:
#endif
#ifdef MINIMA

g29613:
  if (_trace) printf("g29613:\n");
  t10 = t11 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t10 == 0) 
    goto g29612;
  t7 = t1 << 1;
  t10 = *(u64 *)&(processor->dbcbase);
  t7 = t7 & t8;		// Hash index 
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t10;
  t7 = (u32)t7;   		// Clear sign-extension 
  t8 = (t7 * 4) + t8;   
		/* Fetch the key */
  t7 = *(s32 *)t8;
		/* Fetch value */
  arg3 = *(s32 *)(t8 + 4);
		/* Compare */
  t10 = (s32)t1 - (s32)t7;
  if (t10 != 0)   		// Trap on miss 
    goto g29616;
  t1 = (u32)arg3;   		// Extract the pointer, and indirect 
  goto g29606;   		// This is another memory read tailcall. 

g29616:
  if (_trace) printf("g29616:\n");
  goto dbcachemisstrap;
#endif

g29612:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

g29596:
  if (_trace) printf("g29596:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  arg4 = *(s32 *)t7;
		/* Read from stack cache */
  t6 = *(s32 *)(t7 + 4);
  goto g29595;   

g29598:
  if (_trace) printf("g29598:\n");
  if ((t10 & 1) == 0)   
    goto g29597;
  t1 = (u32)arg4;   		// Do the indirect thing 
  goto g29594;   

g29597:
  if (_trace) printf("g29597:\n");
		/* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t10 = t6 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
		/* Get the memory action */
  t11 = *(s32 *)t10;

g29602:
  if (_trace) printf("g29602:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto g29601;
  t6 = t6 & ~63L;
  t6 = t6 | Type_ExternalValueCellPointer;
  goto g29605;   
#ifndef MINIMA

g29601:
#endif
#ifdef MINIMA

g29601:
  if (_trace) printf("g29601:\n");
  t10 = t11 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t10 == 0) 
    goto g29600;
  t7 = t1 << 1;
  t10 = *(u64 *)&(processor->dbcbase);
  t7 = t7 & t8;		// Hash index 
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t10;
  t7 = (u32)t7;   		// Clear sign-extension 
  t8 = (t7 * 4) + t8;   
		/* Fetch the key */
  t7 = *(s32 *)t8;
		/* Fetch value */
  arg4 = *(s32 *)(t8 + 4);
		/* Compare */
  t10 = (s32)t1 - (s32)t7;
  if (t10 != 0)   		// Trap on miss 
    goto g29604;
  t1 = (u32)arg4;   		// Extract the pointer, and indirect 
  goto g29594;   		// This is another memory read tailcall. 

g29604:
  if (_trace) printf("g29604:\n");
  goto dbcachemisstrap;
#endif

g29600:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

/* end Setup1DLongArray */
/* start DoFastAset1 */

  /* Halfword operand from stack instruction - DoFastAset1 */
  /* arg2 has the preloaded 8 bit operand. */

dofastaset1:
  if (_trace) printf("dofastaset1:\n");
#ifdef TRACING
#endif

DoFastAset1SP:
  if (_trace) printf("DoFastAset1SP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindofastaset1;   
#endif

DoFastAset1LP:
  if (_trace) printf("DoFastAset1LP:\n");
#ifdef TRACING
  goto begindofastaset1;   
#endif

DoFastAset1FP:
  if (_trace) printf("DoFastAset1FP:\n");

begindofastaset1:
  if (_trace) printf("begindofastaset1:\n");
  /* arg1 has the operand address. */
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
		/* Index */
  arg4 = *(s32 *)iSP;
		/* Index */
  arg3 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;   
		/* value */
  t11 = *(s32 *)iSP;
		/* value */
  t10 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  t11 = (u32)t11;   
  t1 = arg3 - Type_Fixnum;
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto fastaset1iop;

fastaset1retry:
  if (_trace) printf("fastaset1retry:\n");
  arg6 = *(s32 *)arg1;
  t9 = *(s32 *)(arg1 + 8);
  t3 = *(s32 *)(arg1 + 16);
  arg6 = (u32)arg6;   
  t9 = (u32)t9;   
  t5 = arg6 << 42;
  t3 = (u32)t3;   
  t4 = *(u64 *)&(processor->areventcount);
  t5 = t5 >> 42;
  t2 = ((u64)arg4 < (u64)t3) ? 1 : 0;   
  if (t2 == 0) 
    goto fastaset1bounds;
  t6 = t4 - t5;
  if (t6 != 0)   
    goto aset1recomputearrayregister;
  t6 = arg6 >> (Array_RegisterBytePackingPos & 63);
  t7 = arg6 >> (Array_RegisterByteOffsetPos & 63);
  t8 = arg6 >> (Array_RegisterElementTypePos & 63);
  t6 = t6 & Array_RegisterBytePackingMask;
  t7 = t7 & Array_RegisterByteOffsetMask;
  t8 = t8 & Array_RegisterElementTypeMask;
  /* Element checking and foreplay. */
  /* TagType. */
  t1 = t10 & 63;
  t12 = (t8 == Array_ElementTypeCharacter) ? 1 : 0;   

g29708:
  if (_trace) printf("g29708:\n");
  if (t12 == 0) 
    goto g29704;
  /* Here if argument ArrayElementTypeCharacter */
  t2 = t1 - Type_Character;
  if (t2 == 0) 
    goto g29699;
  arg5 = 0;
  arg2 = 29;
  goto illegaloperand;

g29699:
  if (_trace) printf("g29699:\n");
  if (t6 == 0) 		// Certainly will fit if not packed! 
    goto g29698;
  t2 = 32;
		/* Compute size of byte */
  t2 = t2 >> (t6 & 63);
  t1 = ~zero;   
  t1 = t1 << (t2 & 63);
  t1 = ~t1;   		// Compute mask for byte 
  t1 = t11 & t1;
  t1 = t11 - t1;
  if (t1 == 0) 		// J. if character fits. 
    goto g29698;
  arg5 = 0;
  arg2 = 62;
  goto illegaloperand;

g29704:
  if (_trace) printf("g29704:\n");
  t12 = (t8 == Array_ElementTypeFixnum) ? 1 : 0;   

g29709:
  if (_trace) printf("g29709:\n");
  if (t12 == 0) 
    goto g29705;
  /* Here if argument ArrayElementTypeFixnum */
  t2 = t1 - Type_Fixnum;
  if (t2 == 0) 
    goto g29698;
  arg5 = 0;
  arg2 = 33;
  goto illegaloperand;

g29705:
  if (_trace) printf("g29705:\n");
  t12 = (t8 == Array_ElementTypeBoolean) ? 1 : 0;   

g29710:
  if (_trace) printf("g29710:\n");
  if (t12 == 0) 
    goto g29703;
  /* Here if argument ArrayElementTypeBoolean */
  t11 = 1;
  t1 = t1 - Type_NIL;
  if (t1 != 0)   		// J. if True 
    goto g29698;
  t11 = zero;
  goto g29698;   		// J. if False 

g29703:
  if (_trace) printf("g29703:\n");
  /* Shove it in. */

g29698:
  if (_trace) printf("g29698:\n");
  if (t6 != 0)   		// J. if packed 
    goto g29700;
  t1 = t8 - Array_ElementTypeObject;
  if (t1 != 0)   
    goto g29700;
  /* Here for the simple non packed case */
  t1 = t9 + arg4;
  /* Memory Read Internal */

g29711:
		/* Base of stack cache */
  t4 = *(u64 *)&(processor->stackcachebasevma);
  t12 = t1 + ivory;
  t5 = *(s32 *)&processor->scovlimit;
  t3 = (t12 * 4);   
  t2 = LDQ_U(t12);   
		/* Stack cache offset */
  t4 = t1 - t4;
  arg3 = *(u64 *)&(processor->datawrite_mask);
  t5 = ((u64)t4 < (u64)t5) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;
  t2 = (u8)(t2 >> ((t12&7)*8));   
  if (t5 != 0)   
    goto g29713;

g29712:
  t12 = zero + 240;   
  arg3 = arg3 >> (t2 & 63);
  t12 = t12 >> (t2 & 63);
  if (arg3 & 1)   
    goto g29715;

g29721:
  /* Merge cdr-code */
  t3 = t10 & 63;
  t2 = t2 & 192;
  t2 = t2 | t3;
  t5 = *(u64 *)&(processor->stackcachebasevma);
  t4 = t1 + ivory;
  arg3 = *(s32 *)&processor->scovlimit;
  t3 = (t4 * 4);   
  t12 = LDQ_U(t4);   
		/* Stack cache offset */
  t5 = t1 - t5;
  arg3 = ((u64)t5 < (u64)arg3) ? 1 : 0;   		// In range? 
  t5 = (t2 & 0xff) << ((t4&7)*8);   
  t12 = t12 & ~(0xffL << (t4&7)*8);

g29723:
  if (_trace) printf("g29723:\n");
  t12 = t12 | t5;
  STQ_U(t4, t12);   
  *(u32 *)t3 = t11;
  if (arg3 != 0)   		// J. if in cache 
    goto g29722;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   
  /* Here for the slow packed version */

g29700:
  if (_trace) printf("g29700:\n");
  arg4 = t7 + arg4;
		/* Convert byte index to word index */
  t1 = arg4 >> (t6 & 63);
  t1 = t1 + t9;		// Address of word containing byte 
  /* Memory Read Internal */

g29724:
		/* Base of stack cache */
  t2 = *(u64 *)&(processor->stackcachebasevma);
  t4 = t1 + ivory;
  t3 = *(s32 *)&processor->scovlimit;
  t9 = (t4 * 4);   
  arg5 = LDQ_U(t4);   
		/* Stack cache offset */
  t2 = t1 - t2;
  t5 = *(u64 *)&(processor->dataread_mask);
  t3 = ((u64)t2 < (u64)t3) ? 1 : 0;   		// In range? 
  t9 = *(s32 *)t9;
  arg5 = (u8)(arg5 >> ((t4&7)*8));   
  if (t3 != 0)   
    goto g29726;

g29725:
  t4 = zero + 240;   
  t5 = t5 >> (arg5 & 63);
  t4 = t4 >> (arg5 & 63);
  t9 = (u32)t9;   
  if (t5 & 1)   
    goto g29728;

g29735:
  /* Check fixnum element type */
  /* TagType. */
  t2 = arg5 & 63;
  t2 = t2 - Type_Fixnum;
  if (t2 != 0)   		// J. if element type not fixnum. 
    goto g29701;
  if (t6 == 0) 		// J. if unpacked fixnum element type. 
    goto g29702;
  t12 = ~zero;   
  t12 = t12 << (t6 & 63);
  t2 = zero - t6;
  t12 = arg4 & ~t12;		// Compute subword index 
  t2 = t2 + 5;
		/* Compute shift to get byte */
  t2 = t12 << (t2 & 63);
  t12 = 32;
		/* Compute size of byte */
  t12 = t12 >> (t6 & 63);
  t3 = ~zero;   
  t3 = t3 << (t12 & 63);
  t4 = ~t3;   		// Compute mask for byte 
  if (t2 == 0) 		// inserting into the low byte is easy 
    goto g29736;
  /* Inserting the byte into any byte other than the low byte */
  t5 = 64;
		/* = the left shift rotate amount */
  t12 = t5 - t2;
		/* shift selected byte into low end of word. */
  t5 = t9 >> (t2 & 63);
		/* rotate low bits into high end of word. */
  t9 = t9 << (t12 & 63);
  t5 = t3 & t5;		// Remove unwanted bits 
		/* rotate low bits back into place. */
  t9 = t9 >> (t12 & 63);
  t12 = t11 & t4;		// Strip any extra bits from element 
  t5 = t12 | t5;		// Insert new bits. 
		/* reposition bits */
  t5 = t5 << (t2 & 63);
  t9 = t9 | t5;		// Replace low order bits 
  goto g29737;   

g29736:
  if (_trace) printf("g29736:\n");
  /* Inserting the byte into the low byte */
  t9 = t9 & t3;		// Remove the old low byte 
  t12 = t11 & t4;		// Remove unwanted bits from the new byte 
  t9 = t9 | t12;		// Insert the new byte in place of the old byte 

g29737:
  if (_trace) printf("g29737:\n");
  t11 = t9;

g29702:
  if (_trace) printf("g29702:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);
  t2 = t1 + ivory;
  t12 = *(s32 *)&processor->scovlimit;
  t5 = (t2 * 4);   
  t4 = LDQ_U(t2);   
		/* Stack cache offset */
  t3 = t1 - t3;
  t12 = ((u64)t3 < (u64)t12) ? 1 : 0;   		// In range? 
  t3 = (arg5 & 0xff) << ((t2&7)*8);   
  t4 = t4 & ~(0xffL << (t2&7)*8);

g29739:
  if (_trace) printf("g29739:\n");
  t4 = t4 | t3;
  STQ_U(t2, t4);   
  *(u32 *)t5 = t11;
  if (t12 != 0)   		// J. if in cache 
    goto g29738;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

g29701:
  if (_trace) printf("g29701:\n");
  arg5 = t1;
  arg2 = 25;
  goto illegaloperand;

fastaset1iop:
  if (_trace) printf("fastaset1iop:\n");
  arg5 = 0;
  arg2 = 32;
  goto illegaloperand;

fastaset1bounds:
  if (_trace) printf("fastaset1bounds:\n");
  arg5 = 0;
  arg2 = 13;
  goto illegaloperand;

g29738:
  if (_trace) printf("g29738:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);

g29740:
  if (_trace) printf("g29740:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
		/* Stack cache offset */
  t3 = t1 - t3;
		/* reconstruct SCA */
  t2 = (t3 * 8) + t2;
		/* Store in stack */
  *(u32 *)t2 = t11;
		/* write the stack cache */
  *(u32 *)(t2 + 4) = arg5;
  goto NEXTINSTRUCTION;   

g29726:
  if (_trace) printf("g29726:\n");
  t3 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t2 = (t2 * 8) + t3;
  t9 = *(s32 *)t2;
		/* Read from stack cache */
  arg5 = *(s32 *)(t2 + 4);
  goto g29725;   

g29728:
  if (_trace) printf("g29728:\n");
  if ((t4 & 1) == 0)   
    goto g29727;
  t1 = (u32)t9;   		// Do the indirect thing 
  goto g29724;   

g29727:
  if (_trace) printf("g29727:\n");
		/* Load the memory action table for cycle */
  t5 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t4 = arg5 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  t4 = (t4 * 4) + t5;   		// Adjust for a longword load 
		/* Get the memory action */
  t5 = *(s32 *)t4;

g29732:
  if (_trace) printf("g29732:\n");
  t4 = t5 & MemoryActionTransform;
  if (t4 == 0) 
    goto g29731;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto g29735;   
#ifndef MINIMA

g29731:
#endif
#ifdef MINIMA

g29731:
  if (_trace) printf("g29731:\n");
  t4 = t5 & MemoryActionBinding;
  t3 = *(u64 *)&(processor->dbcmask);
  if (t4 == 0) 
    goto g29730;
  t2 = t1 << 1;
  t4 = *(u64 *)&(processor->dbcbase);
  t2 = t2 & t3;		// Hash index 
  t3 = 1;
  t3 = t3 << (ivorymemorydata & 63);
  t2 = (s32)t2 + (s32)t4;
  t2 = (u32)t2;   		// Clear sign-extension 
  t3 = (t2 * 4) + t3;   
		/* Fetch the key */
  t2 = *(s32 *)t3;
		/* Fetch value */
  t9 = *(s32 *)(t3 + 4);
		/* Compare */
  t4 = (s32)t1 - (s32)t2;
  if (t4 != 0)   		// Trap on miss 
    goto g29734;
  t1 = (u32)t9;   		// Extract the pointer, and indirect 
  goto g29724;   		// This is another memory read tailcall. 

g29734:
  if (_trace) printf("g29734:\n");
  goto dbcachemisstrap;
#endif

g29730:
  /* Perform memory action */
  arg1 = t5;
  arg2 = 0;
  goto performmemoryaction;

g29722:
  if (_trace) printf("g29722:\n");
  t5 = *(u64 *)&(processor->stackcachebasevma);

g29741:
  if (_trace) printf("g29741:\n");
  t4 = *(u64 *)&(processor->stackcachedata);
		/* Stack cache offset */
  t5 = t1 - t5;
		/* reconstruct SCA */
  t4 = (t5 * 8) + t4;
		/* Store in stack */
  *(u32 *)t4 = t11;
		/* write the stack cache */
  *(u32 *)(t4 + 4) = t2;
  goto NEXTINSTRUCTION;   

g29713:
  if (_trace) printf("g29713:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t4 = (t4 * 8) + t5;
  t3 = *(s32 *)t4;
		/* Read from stack cache */
  t2 = *(s32 *)(t4 + 4);
  goto g29712;   

g29715:
  if (_trace) printf("g29715:\n");
  if ((t12 & 1) == 0)   
    goto g29714;
  t1 = (u32)t3;   		// Do the indirect thing 
  goto g29711;   

g29714:
  if (_trace) printf("g29714:\n");
		/* Load the memory action table for cycle */
  arg3 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  t12 = t2 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  t12 = (t12 * 4) + arg3;   		// Adjust for a longword load 
		/* Get the memory action */
  arg3 = *(s32 *)t12;
#ifndef MINIMA

g29718:
#endif
#ifdef MINIMA

g29718:
  if (_trace) printf("g29718:\n");
  t12 = arg3 & MemoryActionBinding;
  t5 = *(u64 *)&(processor->dbcmask);
  if (t12 == 0) 
    goto g29717;
  t4 = t1 << 1;
  t12 = *(u64 *)&(processor->dbcbase);
  t4 = t4 & t5;		// Hash index 
  t5 = 1;
  t5 = t5 << (ivorymemorydata & 63);
  t4 = (s32)t4 + (s32)t12;
  t4 = (u32)t4;   		// Clear sign-extension 
  t5 = (t4 * 4) + t5;   
		/* Fetch the key */
  t4 = *(s32 *)t5;
		/* Fetch value */
  t3 = *(s32 *)(t5 + 4);
		/* Compare */
  t12 = (s32)t1 - (s32)t4;
  if (t12 != 0)   		// Trap on miss 
    goto g29720;
  t1 = (u32)t3;   		// Extract the pointer, and indirect 
  goto g29711;   		// This is another memory read tailcall. 

g29720:
  if (_trace) printf("g29720:\n");
  goto dbcachemisstrap;
#endif

g29717:
  /* Perform memory action */
  arg1 = arg3;
  arg2 = 1;
  goto performmemoryaction;
#ifdef TRACING
#endif

DoFastAset1IM:
  goto doistageerror;

/* end DoFastAset1 */
  /* End of Halfword operand from stack instruction - DoFastAset1 */
  /* Array leaders. */
/* start DoArrayLeader */

  /* Halfword operand from stack instruction - DoArrayLeader */
  /* arg2 has the preloaded 8 bit operand. */

doarrayleader:
  if (_trace) printf("doarrayleader:\n");
#ifdef TRACING
#endif

DoArrayLeaderSP:
  if (_trace) printf("DoArrayLeaderSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoarrayleader;   
#endif

DoArrayLeaderLP:
  if (_trace) printf("DoArrayLeaderLP:\n");
#ifdef TRACING
  goto headdoarrayleader;   
#endif

DoArrayLeaderFP:
  if (_trace) printf("DoArrayLeaderFP:\n");

headdoarrayleader:
  if (_trace) printf("headdoarrayleader:\n");
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
		/* Get the operand */
  arg1 = *(u64 *)arg1;

begindoarrayleader:
  if (_trace) printf("begindoarrayleader:\n");
  /* arg1 has the operand, not sign extended if immediate. */
		/* arg3=arraytag, arg4=arraydata */
  arg4 = *(s32 *)iSP;
		/* arg3=arraytag, arg4=arraydata */
  arg3 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;   
  arg2 = (u32)arg1;   		// index data 
		/* index tag */
  arg1 = arg1 >> 32;
  t1 = arg1 - Type_Fixnum;
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto arrayleaderiop;

arrayleadermerge:
  if (_trace) printf("arrayleadermerge:\n");
  t1 = arg3 - Type_Array;
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto arrayleaderexception;
  t11 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g29742:
  t3 = arg4 + ivory;
  arg5 = (t3 * 4);   
  arg6 = LDQ_U(t3);   
		/* Stack cache offset */
  t1 = arg4 - t11;
  t4 = *(u64 *)&(processor->header_mask);
  t2 = ((u64)t1 < (u64)t12) ? 1 : 0;   		// In range? 
  arg5 = *(s32 *)arg5;
  arg6 = (u8)(arg6 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto g29744;

g29743:
  t3 = zero + 64;   
  t4 = t4 >> (arg6 & 63);
  t3 = t3 >> (arg6 & 63);
  if (t4 & 1)   
    goto g29746;

g29751:
  /* TagType. */
  t1 = arg6 & 63;
  t1 = t1 - Type_HeaderI;
  if (t1 != 0)   
    goto arrayleaderiop;
  t8 = arg5 >> (Array_LeaderLengthFieldPos & 63);
  t8 = t8 & Array_LeaderLengthFieldMask;
  t1 = ((u64)arg2 < (u64)t8) ? 1 : 0;   
  if (t1 == 0) 
    goto arrayleaderbounds;
  arg2 = arg4 - arg2;
  arg2 = arg2 - 1;
  /* Memory Read Internal */

g29752:
  t3 = arg2 + ivory;
  arg5 = (t3 * 4);   
  arg6 = LDQ_U(t3);   
		/* Stack cache offset */
  t1 = arg2 - t11;
  t4 = *(u64 *)&(processor->dataread_mask);
  t2 = ((u64)t1 < (u64)t12) ? 1 : 0;   		// In range? 
  arg5 = *(s32 *)arg5;
  arg6 = (u8)(arg6 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto g29754;

g29753:
  t3 = zero + 240;   
  t4 = t4 >> (arg6 & 63);
  t3 = t3 >> (arg6 & 63);
  if (t4 & 1)   
    goto g29756;

g29763:
  t1 = arg6 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

arrayleaderexception:
  if (_trace) printf("arrayleaderexception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 10;
  goto arrayexception;

arrayleaderiop:
  if (_trace) printf("arrayleaderiop:\n");
  arg5 = 0;
  arg2 = 10;
  goto illegaloperand;

arrayleaderbounds:
  if (_trace) printf("arrayleaderbounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;
#ifdef TRACING
  goto DoArrayLeaderIM;   
#endif

DoArrayLeaderIM:
  if (_trace) printf("DoArrayLeaderIM:\n");
		/* arg3=arraytag, arg4=arraydata */
  arg4 = *(s32 *)iSP;
		/* arg3=arraytag, arg4=arraydata */
  arg3 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;   
  goto arrayleadermerge;   

g29754:
  if (_trace) printf("g29754:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t1 = (t1 * 8) + t2;
  arg5 = *(s32 *)t1;
		/* Read from stack cache */
  arg6 = *(s32 *)(t1 + 4);
  goto g29753;   

g29756:
  if (_trace) printf("g29756:\n");
  if ((t3 & 1) == 0)   
    goto g29755;
  arg2 = (u32)arg5;   		// Do the indirect thing 
  goto g29752;   

g29755:
  if (_trace) printf("g29755:\n");
		/* Load the memory action table for cycle */
  t4 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t3 = arg6 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg2;
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
		/* Get the memory action */
  t4 = *(s32 *)t3;

g29760:
  if (_trace) printf("g29760:\n");
  t3 = t4 & MemoryActionTransform;
  if (t3 == 0) 
    goto g29759;
  arg6 = arg6 & ~63L;
  arg6 = arg6 | Type_ExternalValueCellPointer;
  goto g29763;   
#ifndef MINIMA

g29759:
#endif
#ifdef MINIMA

g29759:
  if (_trace) printf("g29759:\n");
  t3 = t4 & MemoryActionBinding;
  t2 = *(u64 *)&(processor->dbcmask);
  if (t3 == 0) 
    goto g29758;
  t1 = arg2 << 1;
  t3 = *(u64 *)&(processor->dbcbase);
  t1 = t1 & t2;		// Hash index 
  t2 = 1;
  t2 = t2 << (ivorymemorydata & 63);
  t1 = (s32)t1 + (s32)t3;
  t1 = (u32)t1;   		// Clear sign-extension 
  t2 = (t1 * 4) + t2;   
		/* Fetch the key */
  t1 = *(s32 *)t2;
		/* Fetch value */
  arg5 = *(s32 *)(t2 + 4);
		/* Compare */
  t3 = (s32)arg2 - (s32)t1;
  if (t3 != 0)   		// Trap on miss 
    goto g29762;
  arg2 = (u32)arg5;   		// Extract the pointer, and indirect 
  goto g29752;   		// This is another memory read tailcall. 

g29762:
  if (_trace) printf("g29762:\n");
  goto dbcachemisstrap;
#endif

g29758:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 0;
  goto performmemoryaction;

g29744:
  if (_trace) printf("g29744:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t1 = (t1 * 8) + t2;
  arg5 = *(s32 *)t1;
		/* Read from stack cache */
  arg6 = *(s32 *)(t1 + 4);
  goto g29743;   

g29746:
  if (_trace) printf("g29746:\n");
  if ((t3 & 1) == 0)   
    goto g29745;
  arg4 = (u32)arg5;   		// Do the indirect thing 
  goto g29742;   

g29745:
  if (_trace) printf("g29745:\n");
		/* Load the memory action table for cycle */
  t4 = *(u64 *)&(processor->header);
  /* TagType. */
  t3 = arg6 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
		/* Get the memory action */
  t4 = *(s32 *)t3;

g29748:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoArrayLeader */
  /* End of Halfword operand from stack instruction - DoArrayLeader */
/* start DoStoreArrayLeader */

  /* Halfword operand from stack instruction - DoStoreArrayLeader */
  /* arg2 has the preloaded 8 bit operand. */

dostorearrayleader:
  if (_trace) printf("dostorearrayleader:\n");
#ifdef TRACING
#endif

DoStoreArrayLeaderSP:
  if (_trace) printf("DoStoreArrayLeaderSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdostorearrayleader;   
#endif

DoStoreArrayLeaderLP:
  if (_trace) printf("DoStoreArrayLeaderLP:\n");
#ifdef TRACING
  goto headdostorearrayleader;   
#endif

DoStoreArrayLeaderFP:
  if (_trace) printf("DoStoreArrayLeaderFP:\n");

headdostorearrayleader:
  if (_trace) printf("headdostorearrayleader:\n");
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
		/* Get the operand */
  arg1 = *(u64 *)arg1;

begindostorearrayleader:
  if (_trace) printf("begindostorearrayleader:\n");
  /* arg1 has the operand, not sign extended if immediate. */
		/* arg3=arraytag, arg4=arraydata */
  arg4 = *(s32 *)iSP;
		/* arg3=arraytag, arg4=arraydata */
  arg3 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;   
		/* t6=valuetag, t7=valuedata */
  t7 = *(s32 *)iSP;
		/* t6=valuetag, t7=valuedata */
  t6 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  t7 = (u32)t7;   
  arg2 = (u32)arg1;   		// index data 
		/* index tag */
  arg1 = arg1 >> 32;
  t1 = arg1 - Type_Fixnum;
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto storearrayleaderiop;

storearrayleadermerge:
  if (_trace) printf("storearrayleadermerge:\n");
  t1 = arg3 - Type_Array;
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto storearrayleaderexception;
  t11 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g29764:
  t3 = arg4 + ivory;
  arg5 = (t3 * 4);   
  arg6 = LDQ_U(t3);   
		/* Stack cache offset */
  t1 = arg4 - t11;
  t4 = *(u64 *)&(processor->header_mask);
  t2 = ((u64)t1 < (u64)t12) ? 1 : 0;   		// In range? 
  arg5 = *(s32 *)arg5;
  arg6 = (u8)(arg6 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto g29766;

g29765:
  t3 = zero + 64;   
  t4 = t4 >> (arg6 & 63);
  t3 = t3 >> (arg6 & 63);
  if (t4 & 1)   
    goto g29768;

g29773:
  /* TagType. */
  t1 = arg6 & 63;
  t1 = t1 - Type_HeaderI;
  if (t1 != 0)   
    goto storearrayleaderiop;
  t2 = arg5 >> (Array_LeaderLengthFieldPos & 63);
  t2 = t2 & Array_LeaderLengthFieldMask;
  t1 = ((u64)arg2 < (u64)t2) ? 1 : 0;   
  if (t1 == 0) 
    goto storearrayleaderbounds;
  arg2 = arg4 - arg2;
  arg2 = arg2 - 1;
  /* Memory Read Internal */

g29774:
  t5 = arg2 + ivory;
  t2 = (t5 * 4);   
  t1 = LDQ_U(t5);   
		/* Stack cache offset */
  t3 = arg2 - t11;
  t8 = *(u64 *)&(processor->datawrite_mask);
  t4 = ((u64)t3 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t5&7)*8));   
  if (t4 != 0)   
    goto g29776;

g29775:
  t5 = zero + 240;   
  t8 = t8 >> (t1 & 63);
  t5 = t5 >> (t1 & 63);
  if (t8 & 1)   
    goto g29778;

g29784:
  /* Merge cdr-code */
  t2 = t6 & 63;
  t1 = t1 & 192;
  t1 = t1 | t2;
  t3 = arg2 + ivory;
  t2 = (t3 * 4);   
  t5 = LDQ_U(t3);   
		/* Stack cache offset */
  t4 = arg2 - t11;
  t8 = ((u64)t4 < (u64)t12) ? 1 : 0;   		// In range? 
  t4 = (t1 & 0xff) << ((t3&7)*8);   
  t5 = t5 & ~(0xffL << (t3&7)*8);

g29786:
  if (_trace) printf("g29786:\n");
  t5 = t5 | t4;
  STQ_U(t3, t5);   
  *(u32 *)t2 = t7;
  if (t8 != 0)   		// J. if in cache 
    goto g29785;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

storearrayleaderexception:
  if (_trace) printf("storearrayleaderexception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 3;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 11;
  goto arrayexception;

storearrayleaderiop:
  if (_trace) printf("storearrayleaderiop:\n");
  arg5 = 0;
  arg2 = 11;
  goto illegaloperand;

storearrayleaderbounds:
  if (_trace) printf("storearrayleaderbounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;
#ifdef TRACING
  goto DoStoreArrayLeaderIM;   
#endif

DoStoreArrayLeaderIM:
  if (_trace) printf("DoStoreArrayLeaderIM:\n");
		/* arg3=arraytag, arg4=arraydata */
  arg4 = *(s32 *)iSP;
		/* arg3=arraytag, arg4=arraydata */
  arg3 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;   
		/* t6=valuetag, t7=valuedata */
  t7 = *(s32 *)iSP;
		/* t6=valuetag, t7=valuedata */
  t6 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  t7 = (u32)t7;   
  goto storearrayleadermerge;   

g29785:
  if (_trace) printf("g29785:\n");
  t3 = *(u64 *)&(processor->stackcachedata);
		/* Stack cache offset */
  t4 = arg2 - t11;
		/* reconstruct SCA */
  t3 = (t4 * 8) + t3;
		/* Store in stack */
  *(u32 *)t3 = t7;
		/* write the stack cache */
  *(u32 *)(t3 + 4) = t1;
  goto NEXTINSTRUCTION;   

g29776:
  if (_trace) printf("g29776:\n");
  t4 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t3 = (t3 * 8) + t4;
  t2 = *(s32 *)t3;
		/* Read from stack cache */
  t1 = *(s32 *)(t3 + 4);
  goto g29775;   

g29778:
  if (_trace) printf("g29778:\n");
  if ((t5 & 1) == 0)   
    goto g29777;
  arg2 = (u32)t2;   		// Do the indirect thing 
  goto g29774;   

g29777:
  if (_trace) printf("g29777:\n");
		/* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  t5 = t1 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg2;
  t5 = (t5 * 4) + t8;   		// Adjust for a longword load 
		/* Get the memory action */
  t8 = *(s32 *)t5;
#ifndef MINIMA

g29781:
#endif
#ifdef MINIMA

g29781:
  if (_trace) printf("g29781:\n");
  t5 = t8 & MemoryActionBinding;
  t4 = *(u64 *)&(processor->dbcmask);
  if (t5 == 0) 
    goto g29780;
  t3 = arg2 << 1;
  t5 = *(u64 *)&(processor->dbcbase);
  t3 = t3 & t4;		// Hash index 
  t4 = 1;
  t4 = t4 << (ivorymemorydata & 63);
  t3 = (s32)t3 + (s32)t5;
  t3 = (u32)t3;   		// Clear sign-extension 
  t4 = (t3 * 4) + t4;   
		/* Fetch the key */
  t3 = *(s32 *)t4;
		/* Fetch value */
  t2 = *(s32 *)(t4 + 4);
		/* Compare */
  t5 = (s32)arg2 - (s32)t3;
  if (t5 != 0)   		// Trap on miss 
    goto g29783;
  arg2 = (u32)t2;   		// Extract the pointer, and indirect 
  goto g29774;   		// This is another memory read tailcall. 

g29783:
  if (_trace) printf("g29783:\n");
  goto dbcachemisstrap;
#endif

g29780:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 1;
  goto performmemoryaction;

g29766:
  if (_trace) printf("g29766:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t1 = (t1 * 8) + t2;
  arg5 = *(s32 *)t1;
		/* Read from stack cache */
  arg6 = *(s32 *)(t1 + 4);
  goto g29765;   

g29768:
  if (_trace) printf("g29768:\n");
  if ((t3 & 1) == 0)   
    goto g29767;
  arg4 = (u32)arg5;   		// Do the indirect thing 
  goto g29764;   

g29767:
  if (_trace) printf("g29767:\n");
		/* Load the memory action table for cycle */
  t4 = *(u64 *)&(processor->header);
  /* TagType. */
  t3 = arg6 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
		/* Get the memory action */
  t4 = *(s32 *)t3;

g29770:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoStoreArrayLeader */
  /* End of Halfword operand from stack instruction - DoStoreArrayLeader */
/* start DoAlocLeader */

  /* Halfword operand from stack instruction - DoAlocLeader */
  /* arg2 has the preloaded 8 bit operand. */

doalocleader:
  if (_trace) printf("doalocleader:\n");
#ifdef TRACING
#endif

DoAlocLeaderSP:
  if (_trace) printf("DoAlocLeaderSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoalocleader;   
#endif

DoAlocLeaderLP:
  if (_trace) printf("DoAlocLeaderLP:\n");
#ifdef TRACING
  goto headdoalocleader;   
#endif

DoAlocLeaderFP:
  if (_trace) printf("DoAlocLeaderFP:\n");

headdoalocleader:
  if (_trace) printf("headdoalocleader:\n");
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
		/* Get the operand */
  arg1 = *(u64 *)arg1;

begindoalocleader:
  if (_trace) printf("begindoalocleader:\n");
  /* arg1 has the operand, not sign extended if immediate. */
		/* arg3=arraytag, arg4=arraydata */
  arg4 = *(s32 *)iSP;
		/* arg3=arraytag, arg4=arraydata */
  arg3 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;   
  arg2 = (u32)arg1;   		// index data 
		/* index tag */
  arg1 = arg1 >> 32;
  t1 = arg1 - Type_Fixnum;
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto alocleaderiop;

alocleadermerge:
  if (_trace) printf("alocleadermerge:\n");
  t1 = arg3 - Type_Array;
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto alocleaderexception;
  /* Memory Read Internal */

g29787:
		/* Base of stack cache */
  t1 = *(u64 *)&(processor->stackcachebasevma);
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;
  arg5 = (t3 * 4);   
  arg6 = LDQ_U(t3);   
		/* Stack cache offset */
  t1 = arg4 - t1;
  t4 = *(u64 *)&(processor->header_mask);
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;   		// In range? 
  arg5 = *(s32 *)arg5;
  arg6 = (u8)(arg6 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto g29789;

g29788:
  t3 = zero + 64;   
  t4 = t4 >> (arg6 & 63);
  t3 = t3 >> (arg6 & 63);
  if (t4 & 1)   
    goto g29791;

g29796:
  /* TagType. */
  t1 = arg6 & 63;
  t1 = t1 - Type_HeaderI;
  if (t1 != 0)   
    goto alocleaderiop;
  t9 = arg5 >> (Array_LeaderLengthFieldPos & 63);
  t9 = t9 & Array_LeaderLengthFieldMask;
  t1 = ((u64)arg2 < (u64)t9) ? 1 : 0;   
  if (t1 == 0) 
    goto alocleaderbounds;
  arg2 = arg4 - arg2;
  arg2 = arg2 - 1;
  t1 = Type_Locative;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

alocleaderexception:
  if (_trace) printf("alocleaderexception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 10;
  goto arrayexception;

alocleaderiop:
  if (_trace) printf("alocleaderiop:\n");
  arg5 = 0;
  arg2 = 10;
  goto illegaloperand;

alocleaderbounds:
  if (_trace) printf("alocleaderbounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;
#ifdef TRACING
  goto DoAlocLeaderIM;   
#endif

DoAlocLeaderIM:
  if (_trace) printf("DoAlocLeaderIM:\n");
		/* arg3=arraytag, arg4=arraydata */
  arg4 = *(s32 *)iSP;
		/* arg3=arraytag, arg4=arraydata */
  arg3 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;   
  goto alocleadermerge;   

g29789:
  if (_trace) printf("g29789:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t1 = (t1 * 8) + t2;
  arg5 = *(s32 *)t1;
		/* Read from stack cache */
  arg6 = *(s32 *)(t1 + 4);
  goto g29788;   

g29791:
  if (_trace) printf("g29791:\n");
  if ((t3 & 1) == 0)   
    goto g29790;
  arg4 = (u32)arg5;   		// Do the indirect thing 
  goto g29787;   

g29790:
  if (_trace) printf("g29790:\n");
		/* Load the memory action table for cycle */
  t4 = *(u64 *)&(processor->header);
  /* TagType. */
  t3 = arg6 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
		/* Get the memory action */
  t4 = *(s32 *)t3;

g29793:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoAlocLeader */
  /* End of Halfword operand from stack instruction - DoAlocLeader */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunarra.as */
