/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunarra.as
 ************************************************************************/

  /* Array operations. */
/* start Aref1Regset */


aref1regset:
  if (_trace) printf("aref1regset:\n");
  t12 = arg4;
  /* Memory Read Internal */

vma-memory-read10220:
  t1 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;   
  arg6 = (t3 * 4);   
  arg5 = LDQ_U(t3);   
  t1 = arg4 - t1;   		// Stack cache offset 
  t4 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read10222;

vma-memory-read10221:
  t3 = zero + 64;   
  t4 = t4 >> (arg5 & 63);   
  t3 = t3 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t4 & 1)   
    goto vma-memory-read10224;

vma-memory-read10229:
  /* TagType. */
  t1 = arg5 & 63;
  t2 = arg6 >> (Array_LongPrefixBitPos & 63);   
  t1 = t1 - Type_HeaderI;   
  if (t1 != 0)   
    goto aref1illegal;
  if (t2 & 1)   
    goto aref1exception;
		/* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t12;
  t2 = zero + Array_LengthMask;   
  t1 = arg6 & t2;
  t2 = ((u64)arg2 < (u64)t1) ? 1 : 0;   
  if (t2 == 0) 
    goto aref1bounds;
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;   		// store the array length [implicit fixnum] 
  t10 = arg6 >> (Array_RegisterBytePackingPos & 63);   
  t8 = *(u64 *)&(processor->areventcount);   
  t10 = t10 << (Array_RegisterBytePackingPos & 63);   
  t9 = arg4 + 1;
  t10 = t10 + t8;		// Construct the array register word 
		/* store the array register word [implicit fixnum] */
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t10;
  *(u64 *)&((ARRAYCACHEP)t7)->locat = t9;   		// store the storage [implicit locative] 
  arg5 = arg6 >> (Array_BytePackingPos & 63);   		// get BP into arg5 
  arg6 = arg6 >> (Array_ElementTypePos & 63);   		// get element type into arg6 
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = zero;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aref1restart;   

vma-memory-read10222:
  if (_trace) printf("vma-memory-read10222:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = (t1 * 8) + t2;  		// reconstruct SCA 
  arg6 = *(s32 *)t1;   
  arg5 = *(s32 *)(t1 + 4);   		// Read from stack cache 
  goto vma-memory-read10221;   

vma-memory-read10224:
  if (_trace) printf("vma-memory-read10224:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read10223;
  arg4 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read10220;   

vma-memory-read10223:
  if (_trace) printf("vma-memory-read10223:\n");
  t4 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
  t4 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read10226:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end Aref1Regset */
/* start Aref1RecomputeArrayRegister */


aref1recomputearrayregister:
  if (_trace) printf("aref1recomputearrayregister:\n");
  t5 = *(s32 *)(arg1 + -8);   
  t4 = *(s32 *)(arg1 + -4);   
  t5 = (u32)t5;   
  t6 = t4 - Type_Array;   
  t6 = t6 & 62;		// Strip CDR code, low bits 
  if (t6 != 0)   
    goto recompute-array-register10231;
  /* Memory Read Internal */

vma-memory-read10233:
  t8 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t3 = t5 + ivory;
  t2 = *(s32 *)&processor->scovlimit;   
  t6 = (t3 * 4);   
  t7 = LDQ_U(t3);   
  t8 = t5 - t8;   		// Stack cache offset 
  t1 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t8 < (u64)t2) ? 1 : 0;   		// In range? 
  t6 = *(s32 *)t6;   
  t7 = (u8)(t7 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read10235;

vma-memory-read10234:
  t3 = zero + 64;   
  t1 = t1 >> (t7 & 63);   
  t3 = t3 >> (t7 & 63);   
  t6 = (u32)t6;   
  if (t1 & 1)   
    goto vma-memory-read10237;

vma-memory-read10242:
  /* TagType. */
  t8 = t7 & 63;
  t2 = t6 >> (Array_LongPrefixBitPos & 63);   
  t8 = t8 - Type_HeaderI;   
  if (t8 != 0)   
    goto recompute-array-register10230;
  if (t2 & 1)   
    goto recompute-array-register10232;
  t1 = t6 >> (Array_BytePackingPos & 63);   
  t4 = *(u64 *)&(processor->areventcount);   
  t1 = t1 << (Array_RegisterBytePackingPos & 63);   
  t2 = t5 + 1;
  t1 = t1 + t4;		// Construct the array register word 
  *(u32 *)(arg1 + 8) = t2;
  t3 = zero + Array_LengthMask;   
  t3 = t6 & t3;
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaref1retry;   

recompute-array-register10232:
  if (_trace) printf("recompute-array-register10232:\n");
  *(u64 *)&processor->asrf5 = arg1;   		// Just a place to save these values 
  *(u64 *)&processor->asrf4 = t10;   		// Just a place to save these values 
  *(u64 *)&processor->asrf3 = t11;   		// Just a place to save these values 
  *(u64 *)&processor->asrf6 = arg1;   		// Just a place to save these values 
  *(u64 *)&processor->asrf7 = arg2;   		// Just a place to save these values 
  *(u64 *)&processor->asrf8 = arg3;   		// Just a place to save these values 
  *(u64 *)&processor->asrf9 = arg4;   		// Just a place to save these values 
  t9 = *(s32 *)(arg1 + -8);   
  arg2 = *(s32 *)(arg1 + -4);   
  t9 = (u32)t9;   
  arg1 = t5;
  t4 = t7;
  t3 = t6;
  t2 = 1;
  iSP = iSP + 24;
  r0 = (u64)&&return0332;
  goto setup1dlongarray;
return0332:
  t4 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t4 != 0)   
    goto recompute-array-register10231;
  arg1 = *(u64 *)&(processor->asrf5);   		// Just a place to save these values 
  t10 = *(u64 *)&(processor->asrf4);   		// Just a place to save these values 
  t11 = *(u64 *)&(processor->asrf3);   		// Just a place to save these values 
  arg1 = *(u64 *)&(processor->asrf6);   		// Just a place to save these values 
  arg2 = *(u64 *)&(processor->asrf7);   		// Just a place to save these values 
  arg3 = *(u64 *)&(processor->asrf8);   		// Just a place to save these values 
  arg4 = *(u64 *)&(processor->asrf9);   		// Just a place to save these values 
  t3 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  t2 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  t4 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  iSP = iSP - 24;   
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 8) = t2;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaref1retry;   

recompute-array-register10231:
  if (_trace) printf("recompute-array-register10231:\n");
  arg6 = t4;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 12;
  goto arrayexception;

recompute-array-register10230:
  if (_trace) printf("recompute-array-register10230:\n");
  arg5 = 0;
  arg2 = 12;
  goto illegaloperand;

vma-memory-read10235:
  if (_trace) printf("vma-memory-read10235:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + t2;  		// reconstruct SCA 
  t6 = *(s32 *)t8;   
  t7 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read10234;   

vma-memory-read10237:
  if (_trace) printf("vma-memory-read10237:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read10236;
  t5 = (u32)t6;   		// Do the indirect thing 
  goto vma-memory-read10233;   

vma-memory-read10236:
  if (_trace) printf("vma-memory-read10236:\n");
  t1 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = t7 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t5;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t1;   		// Adjust for a longword load 
  t1 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read10239:
  /* Perform memory action */
  arg1 = t1;
  arg2 = 6;
  goto performmemoryaction;

/* end Aref1RecomputeArrayRegister */
/* start Aref1Exception */


aref1exception:
  if (_trace) printf("aref1exception:\n");
  *(u64 *)&processor->asrf4 = arg2;   		// Just a place to save these values 
  *(u64 *)&processor->asrf5 = t7;   		// Just a place to save these values 
  t9 = t12;
  arg2 = arg3;
  arg1 = arg4;
  t4 = arg5;
  t3 = arg6;
  t2 = zero;
  iSP = iSP + 24;
  r0 = (u64)&&return0333;
  goto setup1dlongarray;
return0333:
  arg2 = *(s32 *)&processor->asrf4;   		// Just a place to save these values 
  t7 = *(u64 *)&(processor->asrf5);   		// Just a place to save these values 
  t1 = *(s32 *)iSP;   		// Length 
  t5 = *(s32 *)(iSP + 4);   		// Length 
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = (u32)t1;   
  t5 = *(u64 *)iSP;   		// base 
  iSP = iSP - 8;   		// Pop Stack. 
  t3 = *(u64 *)iSP;   		// control 
  iSP = iSP - 8;   		// Pop Stack. 
  t9 = *(s32 *)iSP;   		// The original array 
  arg3 = *(s32 *)(iSP + 4);   		// The original array 
  iSP = iSP - 8;   		// Pop Stack. 
  t9 = (u32)t9;   
  iSP = iSP - 24;   
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;   
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t3;
  *(u32 *)&((ARRAYCACHEP)t7)->locat = t5;
		/* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t9;
  t9 = (u32)t5;   
  t2 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t2 != 0)   
    goto reallyaref1exc;
  t5 = ((u64)arg2 < (u64)t1) ? 1 : 0;   
  if (t5 == 0) 
    goto aref1bounds;
  arg5 = t3 >> (Array_BytePackingPos & 63);   		// get BP into arg5 
  arg6 = t3 >> (Array_ElementTypePos & 63);   		// get element type into arg6 
  arg4 = t3 >> (Array_RegisterByteOffsetPos & 63);   
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = arg4 & Array_RegisterByteOffsetMask;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aref1restart;   

reallyaref1exc:
  if (_trace) printf("reallyaref1exc:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;   
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 8;
  goto arrayexception;

aref1illegal:
  if (_trace) printf("aref1illegal:\n");
  arg5 = 0;
  arg2 = 8;
  goto illegaloperand;

aref1bounds:
  if (_trace) printf("aref1bounds:\n");
  *(u64 *)&((ARRAYCACHEP)t7)->array = zero;   
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;

/* end Aref1Exception */
/* start Aset1Regset */


aset1regset:
  if (_trace) printf("aset1regset:\n");
  t12 = arg4;
  /* Memory Read Internal */

vma-memory-read10243:
  t1 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;   
  arg6 = (t3 * 4);   
  arg5 = LDQ_U(t3);   
  t1 = arg4 - t1;   		// Stack cache offset 
  t4 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read10245;

vma-memory-read10244:
  t3 = zero + 64;   
  t4 = t4 >> (arg5 & 63);   
  t3 = t3 >> (arg5 & 63);   
  arg6 = (u32)arg6;   
  if (t4 & 1)   
    goto vma-memory-read10247;

vma-memory-read10252:
  /* TagType. */
  t1 = arg5 & 63;
  t2 = arg6 >> (Array_LongPrefixBitPos & 63);   
  t1 = t1 - Type_HeaderI;   
  if (t1 != 0)   
    goto aset1illegal;
  if (t2 & 1)   
    goto aset1exception;
		/* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t12;
  t2 = zero + Array_LengthMask;   
  t1 = arg6 & t2;
  t2 = ((u64)arg2 < (u64)t1) ? 1 : 0;   
  if (t2 == 0) 
    goto aset1bounds;
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;   		// store the array length [implicit fixnum] 
  t10 = arg6 >> (Array_RegisterBytePackingPos & 63);   
  t8 = *(u64 *)&(processor->areventcount);   
  t10 = t10 << (Array_RegisterBytePackingPos & 63);   
  t9 = arg4 + 1;
  t10 = t10 + t8;		// Construct the array register word 
		/* store the array register word [implicit fixnum] */
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t10;
  *(u64 *)&((ARRAYCACHEP)t7)->locat = t9;   		// store the storage [implicit locative] 
  arg5 = arg6 >> (Array_BytePackingPos & 63);   		// get BP into arg5 
  arg6 = arg6 >> (Array_ElementTypePos & 63);   		// get element type into arg6 
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = zero;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aset1restart;   

vma-memory-read10245:
  if (_trace) printf("vma-memory-read10245:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = (t1 * 8) + t2;  		// reconstruct SCA 
  arg6 = *(s32 *)t1;   
  arg5 = *(s32 *)(t1 + 4);   		// Read from stack cache 
  goto vma-memory-read10244;   

vma-memory-read10247:
  if (_trace) printf("vma-memory-read10247:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read10246;
  arg4 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read10243;   

vma-memory-read10246:
  if (_trace) printf("vma-memory-read10246:\n");
  t4 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
  t4 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read10249:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end Aset1Regset */
/* start Aset1RecomputeArrayRegister */


aset1recomputearrayregister:
  if (_trace) printf("aset1recomputearrayregister:\n");
  t5 = *(s32 *)(arg1 + -8);   
  t4 = *(s32 *)(arg1 + -4);   
  t5 = (u32)t5;   
  t6 = t4 - Type_Array;   
  t6 = t6 & 62;		// Strip CDR code, low bits 
  if (t6 != 0)   
    goto recompute-array-register10254;
  /* Memory Read Internal */

vma-memory-read10256:
  t8 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t3 = t5 + ivory;
  t2 = *(s32 *)&processor->scovlimit;   
  t6 = (t3 * 4);   
  t7 = LDQ_U(t3);   
  t8 = t5 - t8;   		// Stack cache offset 
  t1 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t8 < (u64)t2) ? 1 : 0;   		// In range? 
  t6 = *(s32 *)t6;   
  t7 = (u8)(t7 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read10258;

vma-memory-read10257:
  t3 = zero + 64;   
  t1 = t1 >> (t7 & 63);   
  t3 = t3 >> (t7 & 63);   
  t6 = (u32)t6;   
  if (t1 & 1)   
    goto vma-memory-read10260;

vma-memory-read10265:
  /* TagType. */
  t8 = t7 & 63;
  t2 = t6 >> (Array_LongPrefixBitPos & 63);   
  t8 = t8 - Type_HeaderI;   
  if (t8 != 0)   
    goto recompute-array-register10253;
  if (t2 & 1)   
    goto recompute-array-register10255;
  t1 = t6 >> (Array_BytePackingPos & 63);   
  t4 = *(u64 *)&(processor->areventcount);   
  t1 = t1 << (Array_RegisterBytePackingPos & 63);   
  t2 = t5 + 1;
  t1 = t1 + t4;		// Construct the array register word 
  *(u32 *)(arg1 + 8) = t2;
  t3 = zero + Array_LengthMask;   
  t3 = t6 & t3;
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaset1retry;   

recompute-array-register10255:
  if (_trace) printf("recompute-array-register10255:\n");
  *(u64 *)&processor->asrf5 = arg1;   		// Just a place to save these values 
  *(u64 *)&processor->asrf4 = t10;   		// Just a place to save these values 
  *(u64 *)&processor->asrf3 = t11;   		// Just a place to save these values 
  *(u64 *)&processor->asrf6 = arg1;   		// Just a place to save these values 
  *(u64 *)&processor->asrf7 = arg2;   		// Just a place to save these values 
  *(u64 *)&processor->asrf8 = arg3;   		// Just a place to save these values 
  *(u64 *)&processor->asrf9 = arg4;   		// Just a place to save these values 
  t9 = *(s32 *)(arg1 + -8);   
  arg2 = *(s32 *)(arg1 + -4);   
  t9 = (u32)t9;   
  arg1 = t5;
  t4 = t7;
  t3 = t6;
  t2 = 1;
  iSP = iSP + 24;
  r0 = (u64)&&return0334;
  goto setup1dlongarray;
return0334:
  t4 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t4 != 0)   
    goto recompute-array-register10254;
  arg1 = *(u64 *)&(processor->asrf5);   		// Just a place to save these values 
  t10 = *(u64 *)&(processor->asrf4);   		// Just a place to save these values 
  t11 = *(u64 *)&(processor->asrf3);   		// Just a place to save these values 
  arg1 = *(u64 *)&(processor->asrf6);   		// Just a place to save these values 
  arg2 = *(u64 *)&(processor->asrf7);   		// Just a place to save these values 
  arg3 = *(u64 *)&(processor->asrf8);   		// Just a place to save these values 
  arg4 = *(u64 *)&(processor->asrf9);   		// Just a place to save these values 
  t3 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  t2 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  t4 = *(u64 *)iSP;   
  iSP = iSP - 8;   		// Pop Stack. 
  iSP = iSP - 24;   
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 8) = t2;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaset1retry;   

recompute-array-register10254:
  if (_trace) printf("recompute-array-register10254:\n");
  arg6 = t4;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 3;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 12;
  goto arrayexception;

recompute-array-register10253:
  if (_trace) printf("recompute-array-register10253:\n");
  arg5 = 0;
  arg2 = 12;
  goto illegaloperand;

vma-memory-read10258:
  if (_trace) printf("vma-memory-read10258:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t8 = (t8 * 8) + t2;  		// reconstruct SCA 
  t6 = *(s32 *)t8;   
  t7 = *(s32 *)(t8 + 4);   		// Read from stack cache 
  goto vma-memory-read10257;   

vma-memory-read10260:
  if (_trace) printf("vma-memory-read10260:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read10259;
  t5 = (u32)t6;   		// Do the indirect thing 
  goto vma-memory-read10256;   

vma-memory-read10259:
  if (_trace) printf("vma-memory-read10259:\n");
  t1 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = t7 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t5;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t1;   		// Adjust for a longword load 
  t1 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read10262:
  /* Perform memory action */
  arg1 = t1;
  arg2 = 6;
  goto performmemoryaction;

/* end Aset1RecomputeArrayRegister */
/* start Aset1Exception */


aset1exception:
  if (_trace) printf("aset1exception:\n");
  *(u64 *)&processor->asrf4 = arg2;   		// Just a place to save these values 
  *(u64 *)&processor->asrf3 = t5;   		// Just a place to save these values 
  *(u64 *)&processor->asrf6 = t6;   		// Just a place to save these values 
  *(u64 *)&processor->asrf5 = t7;   		// Just a place to save these values 
  t9 = t12;
  arg2 = arg3;
  arg1 = arg4;
  t4 = arg5;
  t3 = arg6;
  t2 = zero;
  iSP = iSP + 24;
  r0 = (u64)&&return0335;
  goto setup1dlongarray;
return0335:
  t1 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t1 != 0)   
    goto reallyaset1exc;
  arg2 = *(s32 *)&processor->asrf4;   		// Just a place to save these values 
  t5 = *(u64 *)&(processor->asrf3);   		// Just a place to save these values 
  t6 = *(u64 *)&(processor->asrf6);   		// Just a place to save these values 
  t7 = *(u64 *)&(processor->asrf5);   		// Just a place to save these values 
  t1 = *(s32 *)iSP;   		// Length 
  t2 = *(s32 *)(iSP + 4);   		// Length 
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = (u32)t1;   
  t2 = *(u64 *)iSP;   		// base 
  iSP = iSP - 8;   		// Pop Stack. 
  t3 = *(u64 *)iSP;   		// control 
  iSP = iSP - 8;   		// Pop Stack. 
  t9 = *(s32 *)iSP;   		// The original array 
  arg3 = *(s32 *)(iSP + 4);   		// The original array 
  iSP = iSP - 8;   		// Pop Stack. 
  t9 = (u32)t9;   
  iSP = iSP - 24;   
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;   
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t3;
  *(u32 *)&((ARRAYCACHEP)t7)->locat = t2;
		/* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t9;
  t9 = (u32)t2;   
  t2 = ((u64)arg2 < (u64)t1) ? 1 : 0;   
  if (t2 == 0) 
    goto aset1bounds;
  arg5 = t3 >> (Array_BytePackingPos & 63);   		// get BP into arg5 
  arg6 = t3 >> (Array_ElementTypePos & 63);   		// get element type into arg6 
  arg4 = t3 >> (Array_RegisterByteOffsetPos & 63);   
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = arg4 & Array_RegisterByteOffsetMask;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aset1restart;   

reallyaset1exc:
  if (_trace) printf("reallyaset1exc:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;   
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 3;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 9;
  goto arrayexception;

aset1illegal:
  if (_trace) printf("aset1illegal:\n");
  arg5 = 0;
  arg2 = 9;
  goto illegaloperand;

aset1bounds:
  if (_trace) printf("aset1bounds:\n");
  *(u64 *)&((ARRAYCACHEP)t7)->array = zero;   
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;

/* end Aset1Exception */
/* start DoAloc1 */

  /* Halfword operand from stack instruction - DoAloc1 */
  /* arg2 has the preloaded 8 bit operand. */

doaloc1:
  if (_trace) printf("doaloc1:\n");
#ifdef TRACING
#endif

DoAloc1SP:
  if (_trace) printf("DoAloc1SP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoaloc1;   
#endif

DoAloc1LP:
  if (_trace) printf("DoAloc1LP:\n");
#ifdef TRACING
  goto headdoaloc1;   
#endif

DoAloc1FP:
  if (_trace) printf("DoAloc1FP:\n");

headdoaloc1:
  if (_trace) printf("headdoaloc1:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoaloc1:
  if (_trace) printf("begindoaloc1:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   		// Get the array tag/data 
  arg3 = *(s32 *)(iSP + 4);   		// Get the array tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  arg2 = (u32)arg1;   		// Index Data 
  arg1 = arg1 >> 32;   		// Index Tag 
  t1 = arg1 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto aloc1illegal;

aloc1merge:
  if (_trace) printf("aloc1merge:\n");
  t1 = arg3 - Type_Array;   
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto aloc1exception;
  /* Memory Read Internal */

vma-memory-read10266:
  t1 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;   
  arg6 = (t3 * 4);   
  arg5 = LDQ_U(t3);   
  t1 = arg4 - t1;   		// Stack cache offset 
  t4 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  arg5 = (u8)(arg5 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read10268;

vma-memory-read10267:
  t3 = zero + 64;   
  t4 = t4 >> (arg5 & 63);   
  t3 = t3 >> (arg5 & 63);   
  if (t4 & 1)   
    goto vma-memory-read10270;

vma-memory-read10275:
  /* TagType. */
  t1 = arg5 & 63;
  t2 = arg6 >> (Array_LongPrefixBitPos & 63);   
  t1 = t1 - Type_HeaderI;   
  if (t1 != 0)   
    goto aloc1illegal;
  if (t2 & 1)   
    goto aloc1exception;
  t2 = zero + Array_LengthMask;   
  t1 = arg6 & t2;
  t3 = ((u64)arg2 < (u64)t1) ? 1 : 0;   
  if (t3 == 0) 
    goto aloc1illegal;
  arg6 = arg6 >> (Array_ElementTypePos & 63);   		// get element type into arg6 
  arg4 = arg4 + 1;
  arg4 = arg4 + arg2;
  arg6 = arg6 & Array_ElementTypeMask;
  arg6 = arg6 - Array_ElementTypeObject;   
  if (arg6 != 0)   
    goto aloc1notobject;
  t1 = Type_Locative;
  *(u32 *)(iSP + 8) = arg4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

aloc1exception:
  if (_trace) printf("aloc1exception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;   
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 8;
  goto arrayexception;

aloc1illegal:
  if (_trace) printf("aloc1illegal:\n");
  arg5 = 0;
  arg2 = 8;
  goto illegaloperand;

aloc1bounds:
  if (_trace) printf("aloc1bounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;

aloc1notobject:
  if (_trace) printf("aloc1notobject:\n");
  arg5 = 0;
  arg2 = 7;
  goto illegaloperand;
#ifdef TRACING
  goto DoAloc1IM;   
#endif

DoAloc1IM:
  if (_trace) printf("DoAloc1IM:\n");
  arg4 = *(s32 *)iSP;   		// Get the array tag/data 
  arg3 = *(s32 *)(iSP + 4);   		// Get the array tag/data 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  goto aloc1merge;   

vma-memory-read10268:
  if (_trace) printf("vma-memory-read10268:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = (t1 * 8) + t2;  		// reconstruct SCA 
  arg6 = *(s32 *)t1;   
  arg5 = *(s32 *)(t1 + 4);   		// Read from stack cache 
  goto vma-memory-read10267;   

vma-memory-read10270:
  if (_trace) printf("vma-memory-read10270:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read10269;
  arg4 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read10266;   

vma-memory-read10269:
  if (_trace) printf("vma-memory-read10269:\n");
  t4 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
  t4 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read10272:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoAloc1 */
  /* End of Halfword operand from stack instruction - DoAloc1 */
  /* Array register operations. */
/* start DoSetup1DArray */

  /* Halfword operand from stack instruction - DoSetup1DArray */

dosetup1darray:
  if (_trace) printf("dosetup1darray:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoSetup1DArrayIM:
  if (_trace) printf("DoSetup1DArrayIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment10289:
  if (_trace) printf("force-alignment10289:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindosetup1darray;   
#ifdef TRACING
#endif

DoSetup1DArraySP:
  if (_trace) printf("DoSetup1DArraySP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdosetup1darray;   
#endif

DoSetup1DArrayLP:
  if (_trace) printf("DoSetup1DArrayLP:\n");
#ifdef TRACING
  goto headdosetup1darray;   
#endif

DoSetup1DArrayFP:
  if (_trace) printf("DoSetup1DArrayFP:\n");

headdosetup1darray:
  if (_trace) printf("headdosetup1darray:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindosetup1darray:
  if (_trace) printf("begindosetup1darray:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg2 = arg1 >> 32;   		// Get the tag 
  arg1 = (u32)arg1;   		// and the data 
  t2 = 0;		// Indicate not forcing 1d 
  t9 = arg1;
  t3 = arg2 - Type_Array;   
  t3 = t3 & 62;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto setup-array-register10277;
  /* Memory Read Internal */

vma-memory-read10279:
  t5 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t7 = arg1 + ivory;
  t6 = *(s32 *)&processor->scovlimit;   
  t3 = (t7 * 4);   
  t4 = LDQ_U(t7);   
  t5 = arg1 - t5;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t6) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read10281;

vma-memory-read10280:
  t7 = zero + 64;   
  t8 = t8 >> (t4 & 63);   
  t7 = t7 >> (t4 & 63);   
  t3 = (u32)t3;   
  if (t8 & 1)   
    goto vma-memory-read10283;

vma-memory-read10288:
  /* TagType. */
  t5 = t4 & 63;
  t6 = t3 >> (Array_LongPrefixBitPos & 63);   
  t5 = t5 - Type_HeaderI;   
  if (t5 != 0)   
    goto setup-array-register10276;
  if (t6 & 1)   
    goto setup-array-register10278;
  t5 = arg2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  t8 = t3 >> (Array_RegisterBytePackingPos & 63);   
  t7 = Type_Fixnum;
  t1 = *(u64 *)&(processor->areventcount);   
  t8 = t8 << (Array_RegisterBytePackingPos & 63);   
  t5 = arg1 + 1;
  t8 = t8 + t1;		// Construct the array register word 
  t6 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  t6 = zero + Array_LengthMask;   
  t6 = t3 & t6;
  t8 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

setup-array-register10277:
  if (_trace) printf("setup-array-register10277:\n");
  /* SetTag. */
  t6 = arg2 << 32;   
  t6 = t9 | t6;
  arg6 = arg2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 71;
  goto arrayexception;

setup-array-register10276:
  if (_trace) printf("setup-array-register10276:\n");
  arg5 = 0;
  arg2 = 71;
  goto illegaloperand;

setup-array-register10278:
  if (_trace) printf("setup-array-register10278:\n");
  r0 = (u64)&&return0336;
  goto setup1dlongarray;
return0336:
  t1 = (t2 == ReturnValue_Normal) ? 1 : 0;   
  if (t1 != 0)   
    goto NEXTINSTRUCTION;
  t1 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t1 != 0)   
    goto setup-array-register10277;
  t1 = (t2 == ReturnValue_IllegalOperand) ? 1 : 0;   
  if (t1 != 0)   
    goto setup-array-register10276;
  goto NEXTINSTRUCTION;   

vma-memory-read10281:
  if (_trace) printf("vma-memory-read10281:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t3 = *(s32 *)t5;   
  t4 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read10280;   

vma-memory-read10283:
  if (_trace) printf("vma-memory-read10283:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read10282;
  arg1 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read10279;   

vma-memory-read10282:
  if (_trace) printf("vma-memory-read10282:\n");
  t8 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read10285:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoSetup1DArray */
  /* End of Halfword operand from stack instruction - DoSetup1DArray */
/* start DoSetupForce1DArray */

  /* Halfword operand from stack instruction - DoSetupForce1DArray */

dosetupforce1darray:
  if (_trace) printf("dosetupforce1darray:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoSetupForce1DArrayIM:
  if (_trace) printf("DoSetupForce1DArrayIM:\n");
  /* This sequence only sucks a moderate amount */
  arg2 = arg2 << 56;   		// sign extend the byte argument. 

force-alignment10303:
  if (_trace) printf("force-alignment10303:\n");
  arg2 = (s64)arg2 >> 56;   		// Rest of sign extension 
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindosetupforce1darray;   
#ifdef TRACING
#endif

DoSetupForce1DArraySP:
  if (_trace) printf("DoSetupForce1DArraySP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdosetupforce1darray;   
#endif

DoSetupForce1DArrayLP:
  if (_trace) printf("DoSetupForce1DArrayLP:\n");
#ifdef TRACING
  goto headdosetupforce1darray;   
#endif

DoSetupForce1DArrayFP:
  if (_trace) printf("DoSetupForce1DArrayFP:\n");

headdosetupforce1darray:
  if (_trace) printf("headdosetupforce1darray:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindosetupforce1darray:
  if (_trace) printf("begindosetupforce1darray:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg2 = arg1 >> 32;   		// Get the tag 
  arg1 = (u32)arg1;   		// and the data 
  t2 = 1;		// Indicate forcing 1d 
  t9 = arg1;
  t3 = arg2 - Type_Array;   
  t3 = t3 & 62;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto setup-array-register10291;
  /* Memory Read Internal */

vma-memory-read10293:
  t5 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t7 = arg1 + ivory;
  t6 = *(s32 *)&processor->scovlimit;   
  t3 = (t7 * 4);   
  t4 = LDQ_U(t7);   
  t5 = arg1 - t5;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t6) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read10295;

vma-memory-read10294:
  t7 = zero + 64;   
  t8 = t8 >> (t4 & 63);   
  t7 = t7 >> (t4 & 63);   
  t3 = (u32)t3;   
  if (t8 & 1)   
    goto vma-memory-read10297;

vma-memory-read10302:
  /* TagType. */
  t5 = t4 & 63;
  t6 = t3 >> (Array_LongPrefixBitPos & 63);   
  t5 = t5 - Type_HeaderI;   
  if (t5 != 0)   
    goto setup-array-register10290;
  if (t6 & 1)   
    goto setup-array-register10292;
  t5 = arg2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  t8 = t3 >> (Array_RegisterBytePackingPos & 63);   
  t7 = Type_Fixnum;
  t1 = *(u64 *)&(processor->areventcount);   
  t8 = t8 << (Array_RegisterBytePackingPos & 63);   
  t5 = arg1 + 1;
  t8 = t8 + t1;		// Construct the array register word 
  t6 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  t6 = zero + Array_LengthMask;   
  t6 = t3 & t6;
  t8 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t6;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

setup-array-register10291:
  if (_trace) printf("setup-array-register10291:\n");
  /* SetTag. */
  t6 = arg2 << 32;   
  t6 = t9 | t6;
  arg6 = arg2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 71;
  goto arrayexception;

setup-array-register10290:
  if (_trace) printf("setup-array-register10290:\n");
  arg5 = 0;
  arg2 = 71;
  goto illegaloperand;

setup-array-register10292:
  if (_trace) printf("setup-array-register10292:\n");
  r0 = (u64)&&return0337;
  goto setup1dlongarray;
return0337:
  t1 = (t2 == ReturnValue_Normal) ? 1 : 0;   
  if (t1 != 0)   
    goto NEXTINSTRUCTION;
  t1 = (t2 == ReturnValue_Exception) ? 1 : 0;   
  if (t1 != 0)   
    goto setup-array-register10291;
  t1 = (t2 == ReturnValue_IllegalOperand) ? 1 : 0;   
  if (t1 != 0)   
    goto setup-array-register10290;
  goto NEXTINSTRUCTION;   

vma-memory-read10295:
  if (_trace) printf("vma-memory-read10295:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t3 = *(s32 *)t5;   
  t4 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read10294;   

vma-memory-read10297:
  if (_trace) printf("vma-memory-read10297:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read10296;
  arg1 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read10293;   

vma-memory-read10296:
  if (_trace) printf("vma-memory-read10296:\n");
  t8 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read10299:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoSetupForce1DArray */
  /* End of Halfword operand from stack instruction - DoSetupForce1DArray */
/* start Setup1DLongArray */


setup1dlongarray:
  if (_trace) printf("setup1dlongarray:\n");
  /* Read data from the header: alength offset indirect lengths&mults */
  t1 = arg1 + 1;   		// length=array+1 
  /* Memory Read Internal */

vma-memory-read10313:
  t7 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  arg4 = (t10 * 4);   
  t6 = LDQ_U(t10);   
  t7 = t1 - t7;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  arg4 = *(s32 *)arg4;   
  t6 = (u8)(t6 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read10315;

vma-memory-read10314:
  t10 = zero + 240;   
  t11 = t11 >> (t6 & 63);   
  t10 = t10 >> (t6 & 63);   
  arg4 = (u32)arg4;   
  if (t11 & 1)   
    goto vma-memory-read10317;

vma-memory-read10324:
  t8 = t6 - Type_Fixnum;   
  t8 = t8 & 63;		// Strip CDR code 
  if (t8 != 0)   
    goto setup-long-array-register10304;
  t1 = t1 + 1;   		// Offset is adata+2 
  /* Memory Read Internal */

vma-memory-read10325:
  t7 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  arg3 = (t10 * 4);   
  t6 = LDQ_U(t10);   
  t7 = t1 - t7;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  arg3 = *(s32 *)arg3;   
  t6 = (u8)(t6 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read10327;

vma-memory-read10326:
  t10 = zero + 240;   
  t11 = t11 >> (t6 & 63);   
  t10 = t10 >> (t6 & 63);   
  arg3 = (u32)arg3;   
  if (t11 & 1)   
    goto vma-memory-read10329;

vma-memory-read10336:
  t8 = t6 - Type_Fixnum;   
  t8 = t8 & 63;		// Strip CDR code 
  if (t8 != 0)   
    goto setup-long-array-register10304;
  t1 = t1 + 1;   		// Indirect is adata+3 
  /* Memory Read Internal */

vma-memory-read10337:
  t7 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t5 = (t10 * 4);   
  t6 = LDQ_U(t10);   
  t7 = t1 - t7;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t6 = (u8)(t6 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read10339;

vma-memory-read10338:
  t10 = zero + 240;   
  t11 = t11 >> (t6 & 63);   
  t10 = t10 >> (t6 & 63);   
  t5 = (u32)t5;   
  if (t11 & 1)   
    goto vma-memory-read10341;

vma-memory-read10348:
  t10 = t6 & 63;		// Strip off any CDR code bits. 
  t11 = (t10 == Type_Locative) ? 1 : 0;   

force-alignment10413:
  if (_trace) printf("force-alignment10413:\n");
  if (t11 == 0) 
    goto basic-dispatch10350;
  /* Here if argument TypeLocative */

setup-long-array-register10307:
  if (_trace) printf("setup-long-array-register10307:\n");
  t10 = arg2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t10;
  iSP = iSP + 8;
  t8 = t3 >> (Array_BytePackingPos & 63);   
  t7 = Type_Fixnum;
  t1 = *(u64 *)&(processor->areventcount);   
  t8 = t8 << (Array_RegisterBytePackingPos & 63);   
  t8 = t8 + t1;		// Construct the array register word 
  t6 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  t8 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto setup-long-array-register10312;   

basic-dispatch10350:
  if (_trace) printf("basic-dispatch10350:\n");
  t11 = (t10 == Type_Fixnum) ? 1 : 0;   

force-alignment10414:
  if (_trace) printf("force-alignment10414:\n");
  if (t11 == 0) 
    goto basic-dispatch10351;
  /* Here if argument TypeFixnum */
  goto setup-long-array-register10307;   

basic-dispatch10351:
  if (_trace) printf("basic-dispatch10351:\n");
  t11 = (t10 == Type_Array) ? 1 : 0;   

force-alignment10415:
  if (_trace) printf("force-alignment10415:\n");
  if (t11 == 0) 
    goto basic-dispatch10352;
  /* Here if argument TypeArray */

setup-long-array-register10311:
  if (_trace) printf("setup-long-array-register10311:\n");
  t1 = t3 & 7;
  t1 = (t1 == 1) ? 1 : 0;   
  t1 = t1 | t2;		// Force true if FORCE 
  if (t1 == 0) 
    goto setup-long-array-register10304;
  t12 = t3 >> (Array_BytePackingPos & 63);   
  t12 = t12 & Array_BytePackingMask;
  t2 = arg3;

setup-long-array-register10306:
  if (_trace) printf("setup-long-array-register10306:\n");
  /* Memory Read Internal */

vma-memory-read10353:
  t7 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t5 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t4 = (t10 * 4);   
  t6 = LDQ_U(t10);   
  t7 = t5 - t7;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->header_mask);   
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  t4 = *(s32 *)t4;   
  t6 = (u8)(t6 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read10355;

vma-memory-read10354:
  t10 = zero + 64;   
  t11 = t11 >> (t6 & 63);   
  t10 = t10 >> (t6 & 63);   
  t4 = (u32)t4;   
  if (t11 & 1)   
    goto vma-memory-read10357;

vma-memory-read10362:
  t10 = t4 >> (Array_BytePackingPos & 63);   
  t10 = t10 & Array_BytePackingMask;
  arg1 = t12 - t10;   
  t7 = t4 >> (Array_LongPrefixBitPos & 63);   
  if (t7 & 1)   
    goto setup-long-array-register10308;
  t5 = t5 + 1;		// increment beyond header 
  t8 = zero + 32767;   
  t8 = t4 & t8;
  t10 = zero - arg1;   
  t10 = t8 >> (t10 & 63);   
  t8 = t8 << (arg1 & 63);   
  if ((s64)arg1 <= 0)   
    t8 = t10;
  t10 = arg4 + arg3;
  t7 = t10 - t8;   
  if ((s64)t7 <= 0)   
    t8 = t10;
  arg4 = t8;

setup-long-array-register10305:
  if (_trace) printf("setup-long-array-register10305:\n");
  arg4 = arg4 - t2;   
  t10 = arg2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t9;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t10;
  iSP = iSP + 8;
  t7 = Type_Fixnum;
  t8 = t3 >> (Array_RegisterBytePackingPos & 63);   
  t1 = *(u64 *)&(processor->areventcount);   
  t8 = t8 << (Array_RegisterBytePackingPos & 63);   
  t11 = zero - 1;   		// -1 
  t11 = t11 << (t12 & 63);   		// (LSH -1 byte-packing) 
  t11 = t2 & ~t11;
  t11 = t11 << (Array_RegisterByteOffsetPos & 63);   
  t8 = t8 + t1;		// Construct the array register word 
  t8 = t11 + t8;		// Add in the byte offset 
  t6 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t8;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  if ((s64)arg4 <= 0)   
    arg4 = zero;
  if (arg4 == 0) 
    goto setup-long-array-register10309;
  t1 = zero - t12;   
  t1 = t2 << (t1 & 63);   
  t2 = t2 >> (t12 & 63);   
  if ((s64)t12 <= 0)   
    t2 = t1;
  t5 = t2 + t5;

setup-long-array-register10309:
  if (_trace) printf("setup-long-array-register10309:\n");
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  t8 = t7 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg4;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto setup-long-array-register10312;   

setup-long-array-register10308:
  if (_trace) printf("setup-long-array-register10308:\n");
  t1 = t5 + 1;		// length=array+1 
  /* Memory Read Internal */

vma-memory-read10363:
  t7 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  arg6 = (t10 * 4);   
  t4 = LDQ_U(t10);   
  t7 = t1 - t7;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  arg6 = *(s32 *)arg6;   
  t4 = (u8)(t4 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read10365;

vma-memory-read10364:
  t10 = zero + 240;   
  t11 = t11 >> (t4 & 63);   
  t10 = t10 >> (t4 & 63);   
  arg6 = (u32)arg6;   
  if (t11 & 1)   
    goto vma-memory-read10367;

vma-memory-read10374:
  t1 = t4 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto setup-long-array-register10304;
  t1 = t5 + 2;		// offset=array+2 
  /* Memory Read Internal */

vma-memory-read10375:
  t7 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  arg5 = (t10 * 4);   
  t4 = LDQ_U(t10);   
  t7 = t1 - t7;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  arg5 = *(s32 *)arg5;   
  t4 = (u8)(t4 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read10377;

vma-memory-read10376:
  t10 = zero + 240;   
  t11 = t11 >> (t4 & 63);   
  t10 = t10 >> (t4 & 63);   
  arg5 = (u32)arg5;   
  if (t11 & 1)   
    goto vma-memory-read10379;

vma-memory-read10386:
  t1 = t4 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto setup-long-array-register10304;
  t1 = t5 + 3;		// next=array+3 
  /* Memory Read Internal */

vma-memory-read10387:
  t7 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;   
  t5 = (t10 * 4);   
  t4 = LDQ_U(t10);   
  t7 = t1 - t7;   		// Stack cache offset 
  t11 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t10&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read10389;

vma-memory-read10388:
  t10 = zero + 240;   
  t11 = t11 >> (t4 & 63);   
  t10 = t10 >> (t4 & 63);   
  t5 = (u32)t5;   
  if (t11 & 1)   
    goto vma-memory-read10391;

vma-memory-read10398:
  t8 = zero - arg1;   
  t8 = arg6 >> (t8 & 63);   
  t10 = arg6 << (arg1 & 63);   
  if ((s64)arg1 <= 0)   
    t10 = t8;
  t8 = arg4 + arg3;
  if ((s64)t10 <= 0)   
    t10 = t8;
  t7 = t10 - t8;   
  if ((s64)t7 <= 0)   
    t8 = t10;
  arg4 = t8;
  t8 = t4 & 63;		// Strip off any CDR code bits. 
  t10 = (t8 == Type_Locative) ? 1 : 0;   

force-alignment10406:
  if (_trace) printf("force-alignment10406:\n");
  if (t10 == 0) 
    goto basic-dispatch10400;
  /* Here if argument TypeLocative */
  goto setup-long-array-register10305;   

basic-dispatch10400:
  if (_trace) printf("basic-dispatch10400:\n");
  t10 = (t8 == Type_Fixnum) ? 1 : 0;   

force-alignment10407:
  if (_trace) printf("force-alignment10407:\n");
  if (t10 == 0) 
    goto basic-dispatch10401;
  /* Here if argument TypeFixnum */
  goto setup-long-array-register10305;   

basic-dispatch10401:
  if (_trace) printf("basic-dispatch10401:\n");
  t10 = (t8 == Type_Array) ? 1 : 0;   

force-alignment10408:
  if (_trace) printf("force-alignment10408:\n");
  if (t10 == 0) 
    goto basic-dispatch10402;
  /* Here if argument TypeArray */

setup-long-array-register10310:
  if (_trace) printf("setup-long-array-register10310:\n");
  t7 = zero - arg1;   
  t7 = arg5 >> (t7 & 63);   
  arg3 = arg5 << (arg1 & 63);   
  if ((s64)arg1 <= 0)   
    arg3 = t7;
  t2 = t2 + arg3;
  goto setup-long-array-register10306;   

basic-dispatch10402:
  if (_trace) printf("basic-dispatch10402:\n");
  t10 = (t8 == Type_String) ? 1 : 0;   

force-alignment10409:
  if (_trace) printf("force-alignment10409:\n");
  if (t10 == 0) 
    goto basic-dispatch10403;
  /* Here if argument TypeString */
  goto setup-long-array-register10310;   

basic-dispatch10403:
  if (_trace) printf("basic-dispatch10403:\n");
  /* Here for all other cases */
  goto setup-long-array-register10304;   

basic-dispatch10399:
  if (_trace) printf("basic-dispatch10399:\n");

basic-dispatch10352:
  if (_trace) printf("basic-dispatch10352:\n");
  t11 = (t10 == Type_String) ? 1 : 0;   

force-alignment10416:
  if (_trace) printf("force-alignment10416:\n");
  if (t11 == 0) 
    goto basic-dispatch10410;
  /* Here if argument TypeString */
  goto setup-long-array-register10311;   

basic-dispatch10410:
  if (_trace) printf("basic-dispatch10410:\n");
  /* Here for all other cases */
  goto setup-long-array-register10304;   

basic-dispatch10349:
  if (_trace) printf("basic-dispatch10349:\n");

setup-long-array-register10304:
  if (_trace) printf("setup-long-array-register10304:\n");
  t2 = ReturnValue_Exception;
  goto *r0; /* ret */

setup-long-array-register10312:
  if (_trace) printf("setup-long-array-register10312:\n");
  t2 = ReturnValue_Normal;
  goto *r0; /* ret */

vma-memory-read10389:
  if (_trace) printf("vma-memory-read10389:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t5 = *(s32 *)t7;   
  t4 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read10388;   

vma-memory-read10391:
  if (_trace) printf("vma-memory-read10391:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read10390;
  t1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read10387;   

vma-memory-read10390:
  if (_trace) printf("vma-memory-read10390:\n");
  t11 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read10395:
  if (_trace) printf("vma-memory-read10395:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto vma-memory-read10394;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto vma-memory-read10398;   

vma-memory-read10394:

vma-memory-read10393:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read10377:
  if (_trace) printf("vma-memory-read10377:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  arg5 = *(s32 *)t7;   
  t4 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read10376;   

vma-memory-read10379:
  if (_trace) printf("vma-memory-read10379:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read10378;
  t1 = (u32)arg5;   		// Do the indirect thing 
  goto vma-memory-read10375;   

vma-memory-read10378:
  if (_trace) printf("vma-memory-read10378:\n");
  t11 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read10383:
  if (_trace) printf("vma-memory-read10383:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto vma-memory-read10382;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto vma-memory-read10386;   

vma-memory-read10382:

vma-memory-read10381:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read10365:
  if (_trace) printf("vma-memory-read10365:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  arg6 = *(s32 *)t7;   
  t4 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read10364;   

vma-memory-read10367:
  if (_trace) printf("vma-memory-read10367:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read10366;
  t1 = (u32)arg6;   		// Do the indirect thing 
  goto vma-memory-read10363;   

vma-memory-read10366:
  if (_trace) printf("vma-memory-read10366:\n");
  t11 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read10371:
  if (_trace) printf("vma-memory-read10371:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto vma-memory-read10370;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto vma-memory-read10374;   

vma-memory-read10370:

vma-memory-read10369:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read10355:
  if (_trace) printf("vma-memory-read10355:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t4 = *(s32 *)t7;   
  t6 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read10354;   

vma-memory-read10357:
  if (_trace) printf("vma-memory-read10357:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read10356;
  t5 = (u32)t4;   		// Do the indirect thing 
  goto vma-memory-read10353;   

vma-memory-read10356:
  if (_trace) printf("vma-memory-read10356:\n");
  t11 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t5;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read10359:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 6;
  goto performmemoryaction;

vma-memory-read10339:
  if (_trace) printf("vma-memory-read10339:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t5 = *(s32 *)t7;   
  t6 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read10338;   

vma-memory-read10341:
  if (_trace) printf("vma-memory-read10341:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read10340;
  t1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read10337;   

vma-memory-read10340:
  if (_trace) printf("vma-memory-read10340:\n");
  t11 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read10345:
  if (_trace) printf("vma-memory-read10345:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto vma-memory-read10344;
  t6 = t6 & ~63L;
  t6 = t6 | Type_ExternalValueCellPointer;
  goto vma-memory-read10348;   

vma-memory-read10344:

vma-memory-read10343:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read10327:
  if (_trace) printf("vma-memory-read10327:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  arg3 = *(s32 *)t7;   
  t6 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read10326;   

vma-memory-read10329:
  if (_trace) printf("vma-memory-read10329:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read10328;
  t1 = (u32)arg3;   		// Do the indirect thing 
  goto vma-memory-read10325;   

vma-memory-read10328:
  if (_trace) printf("vma-memory-read10328:\n");
  t11 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read10333:
  if (_trace) printf("vma-memory-read10333:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto vma-memory-read10332;
  t6 = t6 & ~63L;
  t6 = t6 | Type_ExternalValueCellPointer;
  goto vma-memory-read10336;   

vma-memory-read10332:

vma-memory-read10331:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read10315:
  if (_trace) printf("vma-memory-read10315:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  arg4 = *(s32 *)t7;   
  t6 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read10314;   

vma-memory-read10317:
  if (_trace) printf("vma-memory-read10317:\n");
  if ((t10 & 1) == 0)   
    goto vma-memory-read10316;
  t1 = (u32)arg4;   		// Do the indirect thing 
  goto vma-memory-read10313;   

vma-memory-read10316:
  if (_trace) printf("vma-memory-read10316:\n");
  t11 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t10 = t6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t10 = (t10 * 4) + t11;   		// Adjust for a longword load 
  t11 = *(s32 *)t10;   		// Get the memory action 

vma-memory-read10321:
  if (_trace) printf("vma-memory-read10321:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0) 
    goto vma-memory-read10320;
  t6 = t6 & ~63L;
  t6 = t6 | Type_ExternalValueCellPointer;
  goto vma-memory-read10324;   

vma-memory-read10320:

vma-memory-read10319:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

/* end Setup1DLongArray */
/* start DoFastAset1 */

  /* Halfword operand from stack instruction - DoFastAset1 */
  /* arg2 has the preloaded 8 bit operand. */

dofastaset1:
  if (_trace) printf("dofastaset1:\n");
#ifdef TRACING
#endif

DoFastAset1SP:
  if (_trace) printf("DoFastAset1SP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto begindofastaset1;   
#endif

DoFastAset1LP:
  if (_trace) printf("DoFastAset1LP:\n");
#ifdef TRACING
  goto begindofastaset1;   
#endif

DoFastAset1FP:
  if (_trace) printf("DoFastAset1FP:\n");

begindofastaset1:
  if (_trace) printf("begindofastaset1:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg4 = *(s32 *)iSP;   		// Index 
  arg3 = *(s32 *)(iSP + 4);   		// Index 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  t11 = *(s32 *)iSP;   		// value 
  t10 = *(s32 *)(iSP + 4);   		// value 
  iSP = iSP - 8;   		// Pop Stack. 
  t11 = (u32)t11;   
  t1 = arg3 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto fastaset1iop;

fastaset1retry:
  if (_trace) printf("fastaset1retry:\n");
  arg6 = *(s32 *)arg1;   
  t9 = *(s32 *)(arg1 + 8);   
  t3 = *(s32 *)(arg1 + 16);   
  arg6 = (u32)arg6;   
  t9 = (u32)t9;   
  t5 = arg6 << 42;   
  t3 = (u32)t3;   
  t4 = *(u64 *)&(processor->areventcount);   
  t5 = t5 >> 42;   
  t2 = ((u64)arg4 < (u64)t3) ? 1 : 0;   
  if (t2 == 0) 
    goto fastaset1bounds;
  t6 = t4 - t5;   
  if (t6 != 0)   
    goto aset1recomputearrayregister;
  t6 = arg6 >> (Array_RegisterBytePackingPos & 63);   
  t7 = arg6 >> (Array_RegisterByteOffsetPos & 63);   
  t8 = arg6 >> (Array_RegisterElementTypePos & 63);   
  t6 = t6 & Array_RegisterBytePackingMask;
  t7 = t7 & Array_RegisterByteOffsetMask;
  t8 = t8 & Array_RegisterElementTypeMask;
  /* Element checking and foreplay. */
  /* TagType. */
  t1 = t10 & 63;
  t12 = (t8 == Array_ElementTypeCharacter) ? 1 : 0;   

force-alignment10427:
  if (_trace) printf("force-alignment10427:\n");
  if (t12 == 0) 
    goto basic-dispatch10423;
  /* Here if argument ArrayElementTypeCharacter */
  t2 = t1 - Type_Character;   
  if (t2 == 0) 
    goto aset-1-internal10418;
  arg5 = 0;
  arg2 = 29;
  goto illegaloperand;

aset-1-internal10418:
  if (_trace) printf("aset-1-internal10418:\n");
  if (t6 == 0) 		// Certainly will fit if not packed! 
    goto aset-1-internal10417;
  t2 = 32;
  t2 = t2 >> (t6 & 63);   		// Compute size of byte 
  t1 = ~zero;   
  t1 = t1 << (t2 & 63);   
  t1 = ~t1;   		// Compute mask for byte 
  t1 = t11 & t1;
  t1 = t11 - t1;   
  if (t1 == 0) 		// J. if character fits. 
    goto aset-1-internal10417;
  arg5 = 0;
  arg2 = 62;
  goto illegaloperand;

basic-dispatch10423:
  if (_trace) printf("basic-dispatch10423:\n");
  t12 = (t8 == Array_ElementTypeFixnum) ? 1 : 0;   

force-alignment10428:
  if (_trace) printf("force-alignment10428:\n");
  if (t12 == 0) 
    goto basic-dispatch10424;
  /* Here if argument ArrayElementTypeFixnum */
  t2 = t1 - Type_Fixnum;   
  if (t2 == 0) 
    goto aset-1-internal10417;
  arg5 = 0;
  arg2 = 33;
  goto illegaloperand;

basic-dispatch10424:
  if (_trace) printf("basic-dispatch10424:\n");
  t12 = (t8 == Array_ElementTypeBoolean) ? 1 : 0;   

force-alignment10429:
  if (_trace) printf("force-alignment10429:\n");
  if (t12 == 0) 
    goto basic-dispatch10422;
  /* Here if argument ArrayElementTypeBoolean */
  t11 = 1;
  t1 = t1 - Type_NIL;   
  if (t1 != 0)   		// J. if True 
    goto aset-1-internal10417;
  t11 = zero;
  goto aset-1-internal10417;   		// J. if False 

basic-dispatch10422:
  if (_trace) printf("basic-dispatch10422:\n");
  /* Shove it in. */

aset-1-internal10417:
  if (_trace) printf("aset-1-internal10417:\n");
  if (t6 != 0)   		// J. if packed 
    goto aset-1-internal10419;
  t1 = t8 - Array_ElementTypeObject;   
  if (t1 != 0)   
    goto aset-1-internal10419;
  /* Here for the simple non packed case */
  t1 = t9 + arg4;
  /* Memory Read Internal */

vma-memory-read10430:
  t4 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t12 = t1 + ivory;
  t5 = *(s32 *)&processor->scovlimit;   
  t3 = (t12 * 4);   
  t2 = LDQ_U(t12);   
  t4 = t1 - t4;   		// Stack cache offset 
  arg3 = *(u64 *)&(processor->datawrite_mask);   
  t5 = ((u64)t4 < (u64)t5) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t2 = (u8)(t2 >> ((t12&7)*8));   
  if (t5 != 0)   
    goto vma-memory-read10432;

vma-memory-read10431:
  t12 = zero + 240;   
  arg3 = arg3 >> (t2 & 63);   
  t12 = t12 >> (t2 & 63);   
  if (arg3 & 1)   
    goto vma-memory-read10434;

vma-memory-read10440:
  /* Merge cdr-code */
  t3 = t10 & 63;
  t2 = t2 & 192;
  t2 = t2 | t3;
  t5 = *(u64 *)&(processor->stackcachebasevma);   
  t4 = t1 + ivory;
  arg3 = *(s32 *)&processor->scovlimit;   
  t3 = (t4 * 4);   
  t12 = LDQ_U(t4);   
  t5 = t1 - t5;   		// Stack cache offset 
  arg3 = ((u64)t5 < (u64)arg3) ? 1 : 0;   		// In range? 
  t5 = (t2 & 0xff) << ((t4&7)*8);   
  t12 = t12 & ~(0xffL << (t4&7)*8);   

force-alignment10442:
  if (_trace) printf("force-alignment10442:\n");
  t12 = t12 | t5;
  STQ_U(t4, t12);   
  *(u32 *)t3 = t11;
  if (arg3 != 0)   		// J. if in cache 
    goto vma-memory-write10441;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   
  /* Here for the slow packed version */

aset-1-internal10419:
  if (_trace) printf("aset-1-internal10419:\n");
  arg4 = t7 + arg4;
  t1 = arg4 >> (t6 & 63);   		// Convert byte index to word index 
  t1 = t1 + t9;		// Address of word containing byte 
  /* Memory Read Internal */

vma-memory-read10443:
  t2 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t4 = t1 + ivory;
  t3 = *(s32 *)&processor->scovlimit;   
  t9 = (t4 * 4);   
  arg5 = LDQ_U(t4);   
  t2 = t1 - t2;   		// Stack cache offset 
  t5 = *(u64 *)&(processor->dataread_mask);   
  t3 = ((u64)t2 < (u64)t3) ? 1 : 0;   		// In range? 
  t9 = *(s32 *)t9;   
  arg5 = (u8)(arg5 >> ((t4&7)*8));   
  if (t3 != 0)   
    goto vma-memory-read10445;

vma-memory-read10444:
  t4 = zero + 240;   
  t5 = t5 >> (arg5 & 63);   
  t4 = t4 >> (arg5 & 63);   
  t9 = (u32)t9;   
  if (t5 & 1)   
    goto vma-memory-read10447;

vma-memory-read10454:
  /* Check fixnum element type */
  /* TagType. */
  t2 = arg5 & 63;
  t2 = t2 - Type_Fixnum;   
  if (t2 != 0)   		// J. if element type not fixnum. 
    goto aset-1-internal10420;
  if (t6 == 0) 		// J. if unpacked fixnum element type. 
    goto aset-1-internal10421;
  t12 = ~zero;   
  t12 = t12 << (t6 & 63);   
  t2 = zero - t6;   
  t12 = arg4 & ~t12;		// Compute subword index 
  t2 = t2 + 5;
  t2 = t12 << (t2 & 63);   		// Compute shift to get byte 
  t12 = 32;
  t12 = t12 >> (t6 & 63);   		// Compute size of byte 
  t3 = ~zero;   
  t3 = t3 << (t12 & 63);   
  t4 = ~t3;   		// Compute mask for byte 
  if (t2 == 0) 		// inserting into the low byte is easy 
    goto array-element-dpb10455;
  /* Inserting the byte into any byte other than the low byte */
  t5 = 64;
  t12 = t5 - t2;   		// = the left shift rotate amount 
  t5 = t9 >> (t2 & 63);   		// shift selected byte into low end of word. 
  t9 = t9 << (t12 & 63);   		// rotate low bits into high end of word. 
  t5 = t3 & t5;		// Remove unwanted bits 
  t9 = t9 >> (t12 & 63);   		// rotate low bits back into place. 
  t12 = t11 & t4;		// Strip any extra bits from element 
  t5 = t12 | t5;		// Insert new bits. 
  t5 = t5 << (t2 & 63);   		// reposition bits 
  t9 = t9 | t5;		// Replace low order bits 
  goto array-element-dpb10456;   

array-element-dpb10455:
  if (_trace) printf("array-element-dpb10455:\n");
  /* Inserting the byte into the low byte */
  t9 = t9 & t3;		// Remove the old low byte 
  t12 = t11 & t4;		// Remove unwanted bits from the new byte 
  t9 = t9 | t12;		// Insert the new byte in place of the old byte 

array-element-dpb10456:
  if (_trace) printf("array-element-dpb10456:\n");
  t11 = t9;

aset-1-internal10421:
  if (_trace) printf("aset-1-internal10421:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);   
  t2 = t1 + ivory;
  t12 = *(s32 *)&processor->scovlimit;   
  t5 = (t2 * 4);   
  t4 = LDQ_U(t2);   
  t3 = t1 - t3;   		// Stack cache offset 
  t12 = ((u64)t3 < (u64)t12) ? 1 : 0;   		// In range? 
  t3 = (arg5 & 0xff) << ((t2&7)*8);   
  t4 = t4 & ~(0xffL << (t2&7)*8);   

force-alignment10458:
  if (_trace) printf("force-alignment10458:\n");
  t4 = t4 | t3;
  STQ_U(t2, t4);   
  *(u32 *)t5 = t11;
  if (t12 != 0)   		// J. if in cache 
    goto vma-memory-write10457;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

aset-1-internal10420:
  if (_trace) printf("aset-1-internal10420:\n");
  arg5 = t1;
  arg2 = 25;
  goto illegaloperand;

fastaset1iop:
  if (_trace) printf("fastaset1iop:\n");
  arg5 = 0;
  arg2 = 32;
  goto illegaloperand;

fastaset1bounds:
  if (_trace) printf("fastaset1bounds:\n");
  arg5 = 0;
  arg2 = 13;
  goto illegaloperand;

vma-memory-write10457:
  if (_trace) printf("vma-memory-write10457:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment10459:
  if (_trace) printf("force-alignment10459:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t3 = t1 - t3;   		// Stack cache offset 
  t2 = (t3 * 8) + t2;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t2 = t11;
		/* write the stack cache */
  *(u32 *)(t2 + 4) = arg5;
  goto NEXTINSTRUCTION;   

vma-memory-read10445:
  if (_trace) printf("vma-memory-read10445:\n");
  t3 = *(u64 *)&(processor->stackcachedata);   
  t2 = (t2 * 8) + t3;  		// reconstruct SCA 
  t9 = *(s32 *)t2;   
  arg5 = *(s32 *)(t2 + 4);   		// Read from stack cache 
  goto vma-memory-read10444;   

vma-memory-read10447:
  if (_trace) printf("vma-memory-read10447:\n");
  if ((t4 & 1) == 0)   
    goto vma-memory-read10446;
  t1 = (u32)t9;   		// Do the indirect thing 
  goto vma-memory-read10443;   

vma-memory-read10446:
  if (_trace) printf("vma-memory-read10446:\n");
  t5 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t4 = arg5 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t4 = (t4 * 4) + t5;   		// Adjust for a longword load 
  t5 = *(s32 *)t4;   		// Get the memory action 

vma-memory-read10451:
  if (_trace) printf("vma-memory-read10451:\n");
  t4 = t5 & MemoryActionTransform;
  if (t4 == 0) 
    goto vma-memory-read10450;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto vma-memory-read10454;   

vma-memory-read10450:

vma-memory-read10449:
  /* Perform memory action */
  arg1 = t5;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-write10441:
  if (_trace) printf("vma-memory-write10441:\n");
  t5 = *(u64 *)&(processor->stackcachebasevma);   

force-alignment10460:
  if (_trace) printf("force-alignment10460:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t5 = t1 - t5;   		// Stack cache offset 
  t4 = (t5 * 8) + t4;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t4 = t11;
		/* write the stack cache */
  *(u32 *)(t4 + 4) = t2;
  goto NEXTINSTRUCTION;   

vma-memory-read10432:
  if (_trace) printf("vma-memory-read10432:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t4 = (t4 * 8) + t5;  		// reconstruct SCA 
  t3 = *(s32 *)t4;   
  t2 = *(s32 *)(t4 + 4);   		// Read from stack cache 
  goto vma-memory-read10431;   

vma-memory-read10434:
  if (_trace) printf("vma-memory-read10434:\n");
  if ((t12 & 1) == 0)   
    goto vma-memory-read10433;
  t1 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read10430;   

vma-memory-read10433:
  if (_trace) printf("vma-memory-read10433:\n");
  arg3 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t12 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t12 = (t12 * 4) + arg3;   		// Adjust for a longword load 
  arg3 = *(s32 *)t12;   		// Get the memory action 

vma-memory-read10437:

vma-memory-read10436:
  /* Perform memory action */
  arg1 = arg3;
  arg2 = 1;
  goto performmemoryaction;
#ifdef TRACING
#endif

DoFastAset1IM:
  goto doistageerror;

/* end DoFastAset1 */
  /* End of Halfword operand from stack instruction - DoFastAset1 */
  /* Array leaders. */
/* start DoArrayLeader */

  /* Halfword operand from stack instruction - DoArrayLeader */
  /* arg2 has the preloaded 8 bit operand. */

doarrayleader:
  if (_trace) printf("doarrayleader:\n");
#ifdef TRACING
#endif

DoArrayLeaderSP:
  if (_trace) printf("DoArrayLeaderSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoarrayleader;   
#endif

DoArrayLeaderLP:
  if (_trace) printf("DoArrayLeaderLP:\n");
#ifdef TRACING
  goto headdoarrayleader;   
#endif

DoArrayLeaderFP:
  if (_trace) printf("DoArrayLeaderFP:\n");

headdoarrayleader:
  if (_trace) printf("headdoarrayleader:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoarrayleader:
  if (_trace) printf("begindoarrayleader:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   		// arg3=arraytag, arg4=arraydata 
  arg3 = *(s32 *)(iSP + 4);   		// arg3=arraytag, arg4=arraydata 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  arg2 = (u32)arg1;   		// index data 
  arg1 = arg1 >> 32;   		// index tag 
  t1 = arg1 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto arrayleaderiop;

arrayleadermerge:
  if (_trace) printf("arrayleadermerge:\n");
  t1 = arg3 - Type_Array;   
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto arrayleaderexception;
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read10461:
  t3 = arg4 + ivory;
  arg5 = (t3 * 4);   
  arg6 = LDQ_U(t3);   
  t1 = arg4 - t11;   		// Stack cache offset 
  t4 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t1 < (u64)t12) ? 1 : 0;   		// In range? 
  arg5 = *(s32 *)arg5;   
  arg6 = (u8)(arg6 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read10463;

vma-memory-read10462:
  t3 = zero + 64;   
  t4 = t4 >> (arg6 & 63);   
  t3 = t3 >> (arg6 & 63);   
  if (t4 & 1)   
    goto vma-memory-read10465;

vma-memory-read10470:
  /* TagType. */
  t1 = arg6 & 63;
  t1 = t1 - Type_HeaderI;   
  if (t1 != 0)   
    goto arrayleaderiop;
  t8 = arg5 >> (Array_LeaderLengthFieldPos & 63);   
  t8 = t8 & Array_LeaderLengthFieldMask;
  t1 = ((u64)arg2 < (u64)t8) ? 1 : 0;   
  if (t1 == 0) 
    goto arrayleaderbounds;
  arg2 = arg4 - arg2;   
  arg2 = arg2 - 1;   
  /* Memory Read Internal */

vma-memory-read10471:
  t3 = arg2 + ivory;
  arg5 = (t3 * 4);   
  arg6 = LDQ_U(t3);   
  t1 = arg2 - t11;   		// Stack cache offset 
  t4 = *(u64 *)&(processor->dataread_mask);   
  t2 = ((u64)t1 < (u64)t12) ? 1 : 0;   		// In range? 
  arg5 = *(s32 *)arg5;   
  arg6 = (u8)(arg6 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read10473;

vma-memory-read10472:
  t3 = zero + 240;   
  t4 = t4 >> (arg6 & 63);   
  t3 = t3 >> (arg6 & 63);   
  if (t4 & 1)   
    goto vma-memory-read10475;

vma-memory-read10482:
  t1 = arg6 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = arg5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

arrayleaderexception:
  if (_trace) printf("arrayleaderexception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;   
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 10;
  goto arrayexception;

arrayleaderiop:
  if (_trace) printf("arrayleaderiop:\n");
  arg5 = 0;
  arg2 = 10;
  goto illegaloperand;

arrayleaderbounds:
  if (_trace) printf("arrayleaderbounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;
#ifdef TRACING
  goto DoArrayLeaderIM;   
#endif

DoArrayLeaderIM:
  if (_trace) printf("DoArrayLeaderIM:\n");
  arg4 = *(s32 *)iSP;   		// arg3=arraytag, arg4=arraydata 
  arg3 = *(s32 *)(iSP + 4);   		// arg3=arraytag, arg4=arraydata 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  goto arrayleadermerge;   

vma-memory-read10473:
  if (_trace) printf("vma-memory-read10473:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = (t1 * 8) + t2;  		// reconstruct SCA 
  arg5 = *(s32 *)t1;   
  arg6 = *(s32 *)(t1 + 4);   		// Read from stack cache 
  goto vma-memory-read10472;   

vma-memory-read10475:
  if (_trace) printf("vma-memory-read10475:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read10474;
  arg2 = (u32)arg5;   		// Do the indirect thing 
  goto vma-memory-read10471;   

vma-memory-read10474:
  if (_trace) printf("vma-memory-read10474:\n");
  t4 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = arg6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg2;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
  t4 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read10479:
  if (_trace) printf("vma-memory-read10479:\n");
  t3 = t4 & MemoryActionTransform;
  if (t3 == 0) 
    goto vma-memory-read10478;
  arg6 = arg6 & ~63L;
  arg6 = arg6 | Type_ExternalValueCellPointer;
  goto vma-memory-read10482;   

vma-memory-read10478:

vma-memory-read10477:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read10463:
  if (_trace) printf("vma-memory-read10463:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = (t1 * 8) + t2;  		// reconstruct SCA 
  arg5 = *(s32 *)t1;   
  arg6 = *(s32 *)(t1 + 4);   		// Read from stack cache 
  goto vma-memory-read10462;   

vma-memory-read10465:
  if (_trace) printf("vma-memory-read10465:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read10464;
  arg4 = (u32)arg5;   		// Do the indirect thing 
  goto vma-memory-read10461;   

vma-memory-read10464:
  if (_trace) printf("vma-memory-read10464:\n");
  t4 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = arg6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
  t4 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read10467:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoArrayLeader */
  /* End of Halfword operand from stack instruction - DoArrayLeader */
/* start DoStoreArrayLeader */

  /* Halfword operand from stack instruction - DoStoreArrayLeader */
  /* arg2 has the preloaded 8 bit operand. */

dostorearrayleader:
  if (_trace) printf("dostorearrayleader:\n");
#ifdef TRACING
#endif

DoStoreArrayLeaderSP:
  if (_trace) printf("DoStoreArrayLeaderSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdostorearrayleader;   
#endif

DoStoreArrayLeaderLP:
  if (_trace) printf("DoStoreArrayLeaderLP:\n");
#ifdef TRACING
  goto headdostorearrayleader;   
#endif

DoStoreArrayLeaderFP:
  if (_trace) printf("DoStoreArrayLeaderFP:\n");

headdostorearrayleader:
  if (_trace) printf("headdostorearrayleader:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindostorearrayleader:
  if (_trace) printf("begindostorearrayleader:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   		// arg3=arraytag, arg4=arraydata 
  arg3 = *(s32 *)(iSP + 4);   		// arg3=arraytag, arg4=arraydata 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  t7 = *(s32 *)iSP;   		// t6=valuetag, t7=valuedata 
  t6 = *(s32 *)(iSP + 4);   		// t6=valuetag, t7=valuedata 
  iSP = iSP - 8;   		// Pop Stack. 
  t7 = (u32)t7;   
  arg2 = (u32)arg1;   		// index data 
  arg1 = arg1 >> 32;   		// index tag 
  t1 = arg1 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto storearrayleaderiop;

storearrayleadermerge:
  if (_trace) printf("storearrayleadermerge:\n");
  t1 = arg3 - Type_Array;   
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto storearrayleaderexception;
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read10483:
  t3 = arg4 + ivory;
  arg5 = (t3 * 4);   
  arg6 = LDQ_U(t3);   
  t1 = arg4 - t11;   		// Stack cache offset 
  t4 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t1 < (u64)t12) ? 1 : 0;   		// In range? 
  arg5 = *(s32 *)arg5;   
  arg6 = (u8)(arg6 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read10485;

vma-memory-read10484:
  t3 = zero + 64;   
  t4 = t4 >> (arg6 & 63);   
  t3 = t3 >> (arg6 & 63);   
  if (t4 & 1)   
    goto vma-memory-read10487;

vma-memory-read10492:
  /* TagType. */
  t1 = arg6 & 63;
  t1 = t1 - Type_HeaderI;   
  if (t1 != 0)   
    goto storearrayleaderiop;
  t2 = arg5 >> (Array_LeaderLengthFieldPos & 63);   
  t2 = t2 & Array_LeaderLengthFieldMask;
  t1 = ((u64)arg2 < (u64)t2) ? 1 : 0;   
  if (t1 == 0) 
    goto storearrayleaderbounds;
  arg2 = arg4 - arg2;   
  arg2 = arg2 - 1;   
  /* Memory Read Internal */

vma-memory-read10493:
  t5 = arg2 + ivory;
  t2 = (t5 * 4);   
  t1 = LDQ_U(t5);   
  t3 = arg2 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->datawrite_mask);   
  t4 = ((u64)t3 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t5&7)*8));   
  if (t4 != 0)   
    goto vma-memory-read10495;

vma-memory-read10494:
  t5 = zero + 240;   
  t8 = t8 >> (t1 & 63);   
  t5 = t5 >> (t1 & 63);   
  if (t8 & 1)   
    goto vma-memory-read10497;

vma-memory-read10503:
  /* Merge cdr-code */
  t2 = t6 & 63;
  t1 = t1 & 192;
  t1 = t1 | t2;
  t3 = arg2 + ivory;
  t2 = (t3 * 4);   
  t5 = LDQ_U(t3);   
  t4 = arg2 - t11;   		// Stack cache offset 
  t8 = ((u64)t4 < (u64)t12) ? 1 : 0;   		// In range? 
  t4 = (t1 & 0xff) << ((t3&7)*8);   
  t5 = t5 & ~(0xffL << (t3&7)*8);   

force-alignment10505:
  if (_trace) printf("force-alignment10505:\n");
  t5 = t5 | t4;
  STQ_U(t3, t5);   
  *(u32 *)t2 = t7;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write10504;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

storearrayleaderexception:
  if (_trace) printf("storearrayleaderexception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;   
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 3;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 11;
  goto arrayexception;

storearrayleaderiop:
  if (_trace) printf("storearrayleaderiop:\n");
  arg5 = 0;
  arg2 = 11;
  goto illegaloperand;

storearrayleaderbounds:
  if (_trace) printf("storearrayleaderbounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;
#ifdef TRACING
  goto DoStoreArrayLeaderIM;   
#endif

DoStoreArrayLeaderIM:
  if (_trace) printf("DoStoreArrayLeaderIM:\n");
  arg4 = *(s32 *)iSP;   		// arg3=arraytag, arg4=arraydata 
  arg3 = *(s32 *)(iSP + 4);   		// arg3=arraytag, arg4=arraydata 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  t7 = *(s32 *)iSP;   		// t6=valuetag, t7=valuedata 
  t6 = *(s32 *)(iSP + 4);   		// t6=valuetag, t7=valuedata 
  iSP = iSP - 8;   		// Pop Stack. 
  t7 = (u32)t7;   
  goto storearrayleadermerge;   

vma-memory-write10504:
  if (_trace) printf("vma-memory-write10504:\n");
  t3 = *(u64 *)&(processor->stackcachedata);   
  t4 = arg2 - t11;   		// Stack cache offset 
  t3 = (t4 * 8) + t3;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t3 = t7;
		/* write the stack cache */
  *(u32 *)(t3 + 4) = t1;
  goto NEXTINSTRUCTION;   

vma-memory-read10495:
  if (_trace) printf("vma-memory-read10495:\n");
  t4 = *(u64 *)&(processor->stackcachedata);   
  t3 = (t3 * 8) + t4;  		// reconstruct SCA 
  t2 = *(s32 *)t3;   
  t1 = *(s32 *)(t3 + 4);   		// Read from stack cache 
  goto vma-memory-read10494;   

vma-memory-read10497:
  if (_trace) printf("vma-memory-read10497:\n");
  if ((t5 & 1) == 0)   
    goto vma-memory-read10496;
  arg2 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read10493;   

vma-memory-read10496:
  if (_trace) printf("vma-memory-read10496:\n");
  t8 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t5 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg2;   		// stash the VMA for the (likely) trap 
  t5 = (t5 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t5;   		// Get the memory action 

vma-memory-read10500:

vma-memory-read10499:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 1;
  goto performmemoryaction;

vma-memory-read10485:
  if (_trace) printf("vma-memory-read10485:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = (t1 * 8) + t2;  		// reconstruct SCA 
  arg5 = *(s32 *)t1;   
  arg6 = *(s32 *)(t1 + 4);   		// Read from stack cache 
  goto vma-memory-read10484;   

vma-memory-read10487:
  if (_trace) printf("vma-memory-read10487:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read10486;
  arg4 = (u32)arg5;   		// Do the indirect thing 
  goto vma-memory-read10483;   

vma-memory-read10486:
  if (_trace) printf("vma-memory-read10486:\n");
  t4 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = arg6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
  t4 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read10489:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoStoreArrayLeader */
  /* End of Halfword operand from stack instruction - DoStoreArrayLeader */
/* start DoAlocLeader */

  /* Halfword operand from stack instruction - DoAlocLeader */
  /* arg2 has the preloaded 8 bit operand. */

doalocleader:
  if (_trace) printf("doalocleader:\n");
#ifdef TRACING
#endif

DoAlocLeaderSP:
  if (_trace) printf("DoAlocLeaderSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoalocleader;   
#endif

DoAlocLeaderLP:
  if (_trace) printf("DoAlocLeaderLP:\n");
#ifdef TRACING
  goto headdoalocleader;   
#endif

DoAlocLeaderFP:
  if (_trace) printf("DoAlocLeaderFP:\n");

headdoalocleader:
  if (_trace) printf("headdoalocleader:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoalocleader:
  if (_trace) printf("begindoalocleader:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   		// arg3=arraytag, arg4=arraydata 
  arg3 = *(s32 *)(iSP + 4);   		// arg3=arraytag, arg4=arraydata 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  arg2 = (u32)arg1;   		// index data 
  arg1 = arg1 >> 32;   		// index tag 
  t1 = arg1 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto alocleaderiop;

alocleadermerge:
  if (_trace) printf("alocleadermerge:\n");
  t1 = arg3 - Type_Array;   
  t1 = t1 & 62;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto alocleaderexception;
  /* Memory Read Internal */

vma-memory-read10506:
  t1 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;   
  arg5 = (t3 * 4);   
  arg6 = LDQ_U(t3);   
  t1 = arg4 - t1;   		// Stack cache offset 
  t4 = *(u64 *)&(processor->header_mask);   
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;   		// In range? 
  arg5 = *(s32 *)arg5;   
  arg6 = (u8)(arg6 >> ((t3&7)*8));   
  if (t2 != 0)   
    goto vma-memory-read10508;

vma-memory-read10507:
  t3 = zero + 64;   
  t4 = t4 >> (arg6 & 63);   
  t3 = t3 >> (arg6 & 63);   
  if (t4 & 1)   
    goto vma-memory-read10510;

vma-memory-read10515:
  /* TagType. */
  t1 = arg6 & 63;
  t1 = t1 - Type_HeaderI;   
  if (t1 != 0)   
    goto alocleaderiop;
  t9 = arg5 >> (Array_LeaderLengthFieldPos & 63);   
  t9 = t9 & Array_LeaderLengthFieldMask;
  t1 = ((u64)arg2 < (u64)t9) ? 1 : 0;   
  if (t1 == 0) 
    goto alocleaderbounds;
  arg2 = arg4 - arg2;   
  arg2 = arg2 - 1;   
  t1 = Type_Locative;
  *(u32 *)(iSP + 8) = arg2;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

alocleaderexception:
  if (_trace) printf("alocleaderexception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;   
  t1 = arg2 | t1;
  arg6 = arg3;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  arg5 = 0;
  arg2 = 10;
  goto arrayexception;

alocleaderiop:
  if (_trace) printf("alocleaderiop:\n");
  arg5 = 0;
  arg2 = 10;
  goto illegaloperand;

alocleaderbounds:
  if (_trace) printf("alocleaderbounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;
#ifdef TRACING
  goto DoAlocLeaderIM;   
#endif

DoAlocLeaderIM:
  if (_trace) printf("DoAlocLeaderIM:\n");
  arg4 = *(s32 *)iSP;   		// arg3=arraytag, arg4=arraydata 
  arg3 = *(s32 *)(iSP + 4);   		// arg3=arraytag, arg4=arraydata 
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  goto alocleadermerge;   

vma-memory-read10508:
  if (_trace) printf("vma-memory-read10508:\n");
  t2 = *(u64 *)&(processor->stackcachedata);   
  t1 = (t1 * 8) + t2;  		// reconstruct SCA 
  arg5 = *(s32 *)t1;   
  arg6 = *(s32 *)(t1 + 4);   		// Read from stack cache 
  goto vma-memory-read10507;   

vma-memory-read10510:
  if (_trace) printf("vma-memory-read10510:\n");
  if ((t3 & 1) == 0)   
    goto vma-memory-read10509;
  arg4 = (u32)arg5;   		// Do the indirect thing 
  goto vma-memory-read10506;   

vma-memory-read10509:
  if (_trace) printf("vma-memory-read10509:\n");
  t4 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t3 = arg6 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t3 = (t3 * 4) + t4;   		// Adjust for a longword load 
  t4 = *(s32 *)t3;   		// Get the memory action 

vma-memory-read10512:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoAlocLeader */
  /* End of Halfword operand from stack instruction - DoAlocLeader */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunarra.as */
