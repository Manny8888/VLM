/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunmove.as
 ************************************************************************/

  /* Data movement. */
/* start DoPushNNils */

  /* Halfword operand from stack instruction - DoPushNNils */
  /* arg2 has the preloaded 8 bit operand. */

dopushnnils:
  if (_trace) printf("dopushnnils:\n");

DoPushNNilsSP:
  if (_trace) printf("DoPushNNilsSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPushNNilsLP:
  if (_trace) printf("DoPushNNilsLP:\n");

DoPushNNilsFP:
  if (_trace) printf("DoPushNNilsFP:\n");

headdopushnnils:
  if (_trace) printf("headdopushnnils:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindopushnnils:
  if (_trace) printf("begindopushnnils:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg2 = (u32)arg1;   		// Get the data 
  t1 = arg1 >> 32;   		// and the tag 
  t5 = t1 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto pushnnbadop;

DoPushNNilsIM:
  if (_trace) printf("DoPushNNilsIM:\n");
  t4 = *(s32 *)&processor->scovlimit;   		// Current stack cache limit (words) 
  t1 = zero + 128;   
  t2 = *(u64 *)&(processor->stackcachedata);   		// Alpha base of stack cache 
  t1 = t1 + arg2;		// Account for what we're about to push 
  t1 = (t1 * 8) + iSP;  		// SCA of desired end of cache 
  t2 = (t4 * 8) + t2;  		// SCA of current end of cache 
  t4 = ((s64)t1 <= (s64)t2) ? 1 : 0;   
  if (t4 == 0) 		// We're done if new SCA is within bounds 
    goto stackcacheoverflowhandler;
  arg6 = *(u64 *)&(processor->niladdress);   
  goto pushnnilsl2;   

pushnnilsl1:
  if (_trace) printf("pushnnilsl1:\n");
  *(u64 *)(iSP + 8) = arg6;   		// Push NIL 
  iSP = iSP + 8;
  arg2 = arg2 - 1;   

pushnnilsl2:
  if ((s64)arg2 > 0)   
    goto pushnnilsl1;
  goto NEXTINSTRUCTION;   

pushnnbadop:
  if (_trace) printf("pushnnbadop:\n");
  arg5 = 0;
  arg2 = 63;
  goto illegaloperand;

/* end DoPushNNils */
  /* End of Halfword operand from stack instruction - DoPushNNils */
/* start DoPushAddressSpRelative */

  /* Halfword operand from stack instruction - DoPushAddressSpRelative */
  /* arg2 has the preloaded 8 bit operand. */

dopushaddresssprelative:
  if (_trace) printf("dopushaddresssprelative:\n");

DoPushAddressSpRelativeIM:
  if (_trace) printf("DoPushAddressSpRelativeIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindopushaddresssprelative;   

DoPushAddressSpRelativeSP:
  if (_trace) printf("DoPushAddressSpRelativeSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPushAddressSpRelativeLP:
  if (_trace) printf("DoPushAddressSpRelativeLP:\n");

DoPushAddressSpRelativeFP:
  if (_trace) printf("DoPushAddressSpRelativeFP:\n");

headdopushaddresssprelative:
  if (_trace) printf("headdopushaddresssprelative:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindopushaddresssprelative:
  if (_trace) printf("begindopushaddresssprelative:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  t4 = *(u64 *)&(processor->restartsp);   		// SP before any popping 
  t1 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t6 = *(u64 *)&(processor->stackcachebasevma);   		// Base of the stack cache 
  t7 = *(u64 *)&(processor->stackcachedata);   		// THe stack cache data block 
  t2 = t1 & 63;		// Strip off any CDR code bits. 
  t3 = (t2 == Type_Fixnum) ? 1 : 0;   

force-alignment15917:
  if (_trace) printf("force-alignment15917:\n");
  if (t3 == 0) 
    goto basic-dispatch15914;
  /* Here if argument TypeFixnum */
  arg1 = (arg1 * 8) + 8;  
  t5 = t4 - arg1;   		// Compute stack relative pointer 
  t5 = t5 - t7;   		// Index into stack data 
  t5 = t5 >> 3;   		// Convert to word index 
  t5 = t6 + t5;		// Convert to an ivory word address 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t6 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  goto cachevalid;   

basic-dispatch15914:
  if (_trace) printf("basic-dispatch15914:\n");
  /* Here for all other cases */
  arg5 = 0;
  arg2 = 63;
  goto illegaloperand;

basic-dispatch15913:
  if (_trace) printf("basic-dispatch15913:\n");

/* end DoPushAddressSpRelative */
  /* End of Halfword operand from stack instruction - DoPushAddressSpRelative */
/* start DoStackBlt */

  /* Halfword operand from stack instruction - DoStackBlt */
  /* arg2 has the preloaded 8 bit operand. */

dostackblt:
  if (_trace) printf("dostackblt:\n");

DoStackBltIM:
  if (_trace) printf("DoStackBltIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindostackblt;   

DoStackBltSP:
  if (_trace) printf("DoStackBltSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoStackBltLP:
  if (_trace) printf("DoStackBltLP:\n");

DoStackBltFP:
  if (_trace) printf("DoStackBltFP:\n");

headdostackblt:
  if (_trace) printf("headdostackblt:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindostackblt:
  if (_trace) printf("begindostackblt:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  t3 = *(s32 *)iSP;   		// Destination locative 
  t2 = *(s32 *)(iSP + 4);   		// Destination locative 
  iSP = iSP - 8;   		// Pop Stack. 
  t3 = (u32)t3;   
  t1 = (u32)arg1;   
  /* Convert VMA to stack cache address */
  t4 = *(u64 *)&(processor->stackcachebasevma);   
  arg1 = *(u64 *)&(processor->stackcachedata);   
  t4 = t1 - t4;   		// stack cache base relative offset 
  arg1 = (t4 * 8) + arg1;  		// reconstruct SCA 
  t4 = *(u64 *)&(processor->stackcachebasevma);   		// Base of the stack cache 
  t5 = *(u64 *)&(processor->stackcachetopvma);   		// End ofthe stack cache 
  t1 = *(u64 *)&(processor->stackcachedata);   		// THe stack cache data block 
  t6 = t3 - t4;   		// BAse of Stack Cache. 
  t7 = t3 - t5;   		// Top of Stack Cache. 
  if ((s64)t6 < 0)   		// J. if vma below stack cache 
    goto stkbltexc;
  if ((s64)t7 >= 0)   		// J. if vma above stack cache 
    goto stkbltexc;
  t6 = (t6 * 8) + t1;  		// Compute the stackcache address 
  goto stkbltloopend;   

stkbltloop:
  if (_trace) printf("stkbltloop:\n");
  arg1 = arg1 + 8;		// Advance Source 
  t6 = t6 + 8;		// Advance destination 

stkbltloopend:
  t1 = *(u64 *)arg1;   		// Read a word from the source 
  t4 = arg1 - iSP;   
  *(u64 *)t6 = t1;   		// copy the word 
  if (t4 != 0)   		// J. if sourse not stack top 
    goto stkbltloop;
  iSP = t6;		// Update the SP to point at the last written location 
  goto NEXTINSTRUCTION;   

stkbltexc:
  if (_trace) printf("stkbltexc:\n");
  arg5 = 0;
  arg2 = 73;
  goto illegaloperand;

/* end DoStackBlt */
  /* End of Halfword operand from stack instruction - DoStackBlt */
/* start DoStackBltAddress */

  /* Halfword operand from stack instruction - DoStackBltAddress */
  /* arg2 has the preloaded 8 bit operand. */

dostackbltaddress:
  if (_trace) printf("dostackbltaddress:\n");

DoStackBltAddressSP:
  if (_trace) printf("DoStackBltAddressSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoStackBltAddressLP:
  if (_trace) printf("DoStackBltAddressLP:\n");

DoStackBltAddressFP:
  if (_trace) printf("DoStackBltAddressFP:\n");

begindostackbltaddress:
  if (_trace) printf("begindostackbltaddress:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t3 = *(s32 *)iSP;   		// Destination locative 
  t2 = *(s32 *)(iSP + 4);   		// Destination locative 
  iSP = iSP - 8;   		// Pop Stack. 
  t3 = (u32)t3;   
  t4 = *(u64 *)&(processor->stackcachebasevma);   		// Base of the stack cache 
  t5 = *(u64 *)&(processor->stackcachetopvma);   		// End ofthe stack cache 
  t1 = *(u64 *)&(processor->stackcachedata);   		// THe stack cache data block 
  t6 = t3 - t4;   		// Base of Stack Cache. 
  t7 = t3 - t5;   		// Top of Stack Cache. 
  if ((s64)t6 < 0)   		// J. if vma below stack cache 
    goto stkbltadrexc;
  if ((s64)t7 >= 0)   		// J. if vma above stack cache 
    goto stkbltadrexc;
  t6 = (t6 * 8) + t1;  		// Compute the stackcache address 
  goto stkbltaddloopend;   

stkbltaddloop:
  if (_trace) printf("stkbltaddloop:\n");
  arg1 = arg1 + 8;		// Advance Source 
  t6 = t6 + 8;		// Advance destination 

stkbltaddloopend:
  t1 = *(u64 *)arg1;   		// Read a word from the source 
  t4 = arg1 - iSP;   
  *(u64 *)t6 = t1;   		// copy the word 
  if (t4 != 0)   		// J. if sourse not stack top 
    goto stkbltaddloop;
  iSP = t6;		// Update the SP to point at the last written location 
  goto NEXTINSTRUCTION;   

stkbltadrexc:
  if (_trace) printf("stkbltadrexc:\n");
  arg5 = 0;
  arg2 = 73;
  goto illegaloperand;

DoStackBltAddressIM:
  goto doistageerror;

/* end DoStackBltAddress */
  /* End of Halfword operand from stack instruction - DoStackBltAddress */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunmove.as */
