/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifuninst.as
 ************************************************************************/

  /* Instance variable accessors.. */
/* start DoPopInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPopInstanceVariable */

dopopinstancevariable:
  if (_trace) printf("dopopinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPopInstanceVariableIM:
  if (_trace) printf("DoPopInstanceVariableIM:\n");

DoPopInstanceVariableSP:
  if (_trace) printf("DoPopInstanceVariableSP:\n");

DoPopInstanceVariableLP:
  if (_trace) printf("DoPopInstanceVariableLP:\n");

DoPopInstanceVariableFP:
  if (_trace) printf("DoPopInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
  /* Map */
  arg1 = *(s32 *)(iFP + 16);
  t1 = *(s32 *)(iFP + 20);
  arg1 = (u32)arg1;
  t4 = t1 - Type_Array;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto ivbadmap;
  /* Memory Read Internal */

g7380:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7382;

g7381:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  if (t10 & 1)
    goto g7384;

g7389:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;
  /* J. if mapping-table-index-out-of-bounds */
  if ((s64)t5 <= 0)
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

g7390:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7392;

g7391:
  t9 = zero + 240;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7394;

g7401:
  t3 = t2;
  t6 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto popiviex;
  /* Self */
  arg1 = *(s32 *)(iFP + 24);
  t6 = *(s32 *)(iFP + 28);
  arg1 = (u32)arg1;
  t5 = t6 - Type_Instance;
  /* Strip CDR code, low bits */
  t5 = t5 & 60;
  if (t5 != 0)
    goto ivbadinst;
  /* Unshifted cdr code */
  t5 = t6 & 192;
  /* Check for CDR code 1 */
  t5 = t5 - 64;
  /* J. if CDR code is not 1 */
  if (t5 != 0)
    goto g7379;

g7378:
  if (_trace) printf("g7378:\n");
  arg1 = arg1 + t3;

g7377:
  if (_trace) printf("g7377:\n");
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g7402:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g7404;

g7403:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g7406;

g7412:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g7414:
  if (_trace) printf("g7414:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g7413;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

popiviex:
  if (_trace) printf("popiviex:\n");
  t1 = zero + 8;
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

g7413:
  if (_trace) printf("g7413:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g7404:
  if (_trace) printf("g7404:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g7403;

g7406:
  if (_trace) printf("g7406:\n");
  if ((t8 & 1) == 0)
    goto g7405;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g7402;

g7405:
  if (_trace) printf("g7405:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g7409:
#endif
#ifdef MINIMA

g7409:
  if (_trace) printf("g7409:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g7408;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g7411;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g7402;

g7411:
  if (_trace) printf("g7411:\n");
  goto dbcachemisstrap;
#endif

g7408:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

g7392:
  if (_trace) printf("g7392:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7391;

g7394:
  if (_trace) printf("g7394:\n");
  if ((t9 & 1) == 0)
    goto g7393;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7390;

g7393:
  if (_trace) printf("g7393:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7398:
  if (_trace) printf("g7398:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0)
    goto g7397;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto g7401;
#ifndef MINIMA

g7397:
#endif
#ifdef MINIMA

g7397:
  if (_trace) printf("g7397:\n");
  t9 = t10 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t9 == 0)
    goto g7396;
  t7 = arg1 << 1;
  t9 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t9;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  t2 = *(s32 *)(t8 + 4);
  /* Compare */
  t9 = (s32)arg1 - (s32)t7;
  /* Trap on miss */
  if (t9 != 0)
    goto g7400;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t2;
  goto g7390;

g7400:
  if (_trace) printf("g7400:\n");
  goto dbcachemisstrap;
#endif

g7396:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

g7382:
  if (_trace) printf("g7382:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7381;

g7384:
  if (_trace) printf("g7384:\n");
  if ((t9 & 1) == 0)
    goto g7383;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7380;

g7383:
  if (_trace) printf("g7383:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7386:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

g7379:
  if (_trace) printf("g7379:\n");
  t5 = arg1;
  /* Memory Read Internal */

g7415:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7417;

g7416:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7419;

g7424:
  t5 = t5 - arg1;
  if (t5 != 0)
    goto g7378;
  /* TagType. */
  t6 = t6 & 63;
  /* Set CDR code to 1 */
  t6 = t6 | 64;
  /* Update self */
  *(u32 *)(iFP + 24) = arg1;
  /* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto g7378;

g7417:
  if (_trace) printf("g7417:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7416;

g7419:
  if (_trace) printf("g7419:\n");
  if ((t9 & 1) == 0)
    goto g7418;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7415;

g7418:
  if (_trace) printf("g7418:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7421:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoPopInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPopInstanceVariable */
/* start DoMovemInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoMovemInstanceVariable */

domoveminstancevariable:
  if (_trace) printf("domoveminstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoMovemInstanceVariableIM:
  if (_trace) printf("DoMovemInstanceVariableIM:\n");

DoMovemInstanceVariableSP:
  if (_trace) printf("DoMovemInstanceVariableSP:\n");

DoMovemInstanceVariableLP:
  if (_trace) printf("DoMovemInstanceVariableLP:\n");

DoMovemInstanceVariableFP:
  if (_trace) printf("DoMovemInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
  /* Map */
  arg1 = *(s32 *)(iFP + 16);
  t1 = *(s32 *)(iFP + 20);
  arg1 = (u32)arg1;
  t4 = t1 - Type_Array;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto ivbadmap;
  /* Memory Read Internal */

g7428:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7430;

g7429:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  if (t10 & 1)
    goto g7432;

g7437:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;
  /* J. if mapping-table-index-out-of-bounds */
  if ((s64)t5 <= 0)
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

g7438:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7440;

g7439:
  t9 = zero + 240;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7442;

g7449:
  t3 = t2;
  t6 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto movemiviex;
  /* Self */
  arg1 = *(s32 *)(iFP + 24);
  t6 = *(s32 *)(iFP + 28);
  arg1 = (u32)arg1;
  t5 = t6 - Type_Instance;
  /* Strip CDR code, low bits */
  t5 = t5 & 60;
  if (t5 != 0)
    goto ivbadinst;
  /* Unshifted cdr code */
  t5 = t6 & 192;
  /* Check for CDR code 1 */
  t5 = t5 - 64;
  /* J. if CDR code is not 1 */
  if (t5 != 0)
    goto g7427;

g7426:
  if (_trace) printf("g7426:\n");
  arg1 = arg1 + t3;

g7425:
  if (_trace) printf("g7425:\n");
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  t1 = (u32)t1;
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g7450:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g7452;

g7451:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g7454;

g7460:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g7462:
  if (_trace) printf("g7462:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g7461;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

movemiviex:
  if (_trace) printf("movemiviex:\n");
  t1 = zero + 8;
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

g7461:
  if (_trace) printf("g7461:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g7452:
  if (_trace) printf("g7452:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g7451;

g7454:
  if (_trace) printf("g7454:\n");
  if ((t8 & 1) == 0)
    goto g7453;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g7450;

g7453:
  if (_trace) printf("g7453:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g7457:
#endif
#ifdef MINIMA

g7457:
  if (_trace) printf("g7457:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g7456;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g7459;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g7450;

g7459:
  if (_trace) printf("g7459:\n");
  goto dbcachemisstrap;
#endif

g7456:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

g7440:
  if (_trace) printf("g7440:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7439;

g7442:
  if (_trace) printf("g7442:\n");
  if ((t9 & 1) == 0)
    goto g7441;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7438;

g7441:
  if (_trace) printf("g7441:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7446:
  if (_trace) printf("g7446:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0)
    goto g7445;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto g7449;
#ifndef MINIMA

g7445:
#endif
#ifdef MINIMA

g7445:
  if (_trace) printf("g7445:\n");
  t9 = t10 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t9 == 0)
    goto g7444;
  t7 = arg1 << 1;
  t9 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t9;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  t2 = *(s32 *)(t8 + 4);
  /* Compare */
  t9 = (s32)arg1 - (s32)t7;
  /* Trap on miss */
  if (t9 != 0)
    goto g7448;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t2;
  goto g7438;

g7448:
  if (_trace) printf("g7448:\n");
  goto dbcachemisstrap;
#endif

g7444:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

g7430:
  if (_trace) printf("g7430:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7429;

g7432:
  if (_trace) printf("g7432:\n");
  if ((t9 & 1) == 0)
    goto g7431;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7428;

g7431:
  if (_trace) printf("g7431:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7434:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

g7427:
  if (_trace) printf("g7427:\n");
  t5 = arg1;
  /* Memory Read Internal */

g7463:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7465;

g7464:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7467;

g7472:
  t5 = t5 - arg1;
  if (t5 != 0)
    goto g7426;
  /* TagType. */
  t6 = t6 & 63;
  /* Set CDR code to 1 */
  t6 = t6 | 64;
  /* Update self */
  *(u32 *)(iFP + 24) = arg1;
  /* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto g7426;

g7465:
  if (_trace) printf("g7465:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7464;

g7467:
  if (_trace) printf("g7467:\n");
  if ((t9 & 1) == 0)
    goto g7466;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7463;

g7466:
  if (_trace) printf("g7466:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7469:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoMovemInstanceVariable */
  /* End of Halfword operand from stack instruction - DoMovemInstanceVariable */
/* start DoPushAddressInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariable */

dopushaddressinstancevariable:
  if (_trace) printf("dopushaddressinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushAddressInstanceVariableIM:
  if (_trace) printf("DoPushAddressInstanceVariableIM:\n");

DoPushAddressInstanceVariableSP:
  if (_trace) printf("DoPushAddressInstanceVariableSP:\n");

DoPushAddressInstanceVariableLP:
  if (_trace) printf("DoPushAddressInstanceVariableLP:\n");

DoPushAddressInstanceVariableFP:
  if (_trace) printf("DoPushAddressInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
  /* Map */
  arg1 = *(s32 *)(iFP + 16);
  t1 = *(s32 *)(iFP + 20);
  arg1 = (u32)arg1;
  t4 = t1 - Type_Array;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto ivbadmap;
  /* Memory Read Internal */

g7476:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7478;

g7477:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  if (t10 & 1)
    goto g7480;

g7485:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;
  /* J. if mapping-table-index-out-of-bounds */
  if ((s64)t5 <= 0)
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

g7486:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7488;

g7487:
  t9 = zero + 240;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7490;

g7497:
  t3 = t2;
  t6 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto pushadiviex;
  /* Self */
  arg1 = *(s32 *)(iFP + 24);
  t6 = *(s32 *)(iFP + 28);
  arg1 = (u32)arg1;
  t5 = t6 - Type_Instance;
  /* Strip CDR code, low bits */
  t5 = t5 & 60;
  if (t5 != 0)
    goto ivbadinst;
  /* Unshifted cdr code */
  t5 = t6 & 192;
  /* Check for CDR code 1 */
  t5 = t5 - 64;
  /* J. if CDR code is not 1 */
  if (t5 != 0)
    goto g7475;

g7474:
  if (_trace) printf("g7474:\n");
  arg1 = arg1 + t3;

g7473:
  if (_trace) printf("g7473:\n");
  t7 = Type_Locative;
  *(u32 *)(iSP + 8) = arg1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

pushadiviex:
  if (_trace) printf("pushadiviex:\n");
  t1 = zero + 8;
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

g7488:
  if (_trace) printf("g7488:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7487;

g7490:
  if (_trace) printf("g7490:\n");
  if ((t9 & 1) == 0)
    goto g7489;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7486;

g7489:
  if (_trace) printf("g7489:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7494:
  if (_trace) printf("g7494:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0)
    goto g7493;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto g7497;
#ifndef MINIMA

g7493:
#endif
#ifdef MINIMA

g7493:
  if (_trace) printf("g7493:\n");
  t9 = t10 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t9 == 0)
    goto g7492;
  t7 = arg1 << 1;
  t9 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t9;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  t2 = *(s32 *)(t8 + 4);
  /* Compare */
  t9 = (s32)arg1 - (s32)t7;
  /* Trap on miss */
  if (t9 != 0)
    goto g7496;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t2;
  goto g7486;

g7496:
  if (_trace) printf("g7496:\n");
  goto dbcachemisstrap;
#endif

g7492:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

g7478:
  if (_trace) printf("g7478:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7477;

g7480:
  if (_trace) printf("g7480:\n");
  if ((t9 & 1) == 0)
    goto g7479;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7476;

g7479:
  if (_trace) printf("g7479:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7482:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

g7475:
  if (_trace) printf("g7475:\n");
  t5 = arg1;
  /* Memory Read Internal */

g7498:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7500;

g7499:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7502;

g7507:
  t5 = t5 - arg1;
  if (t5 != 0)
    goto g7474;
  /* TagType. */
  t6 = t6 & 63;
  /* Set CDR code to 1 */
  t6 = t6 | 64;
  /* Update self */
  *(u32 *)(iFP + 24) = arg1;
  /* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto g7474;

g7500:
  if (_trace) printf("g7500:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7499;

g7502:
  if (_trace) printf("g7502:\n");
  if ((t9 & 1) == 0)
    goto g7501;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7498;

g7501:
  if (_trace) printf("g7501:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7504:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoPushAddressInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPushAddressInstanceVariable */
/* start DoPushInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPushInstanceVariableOrdered */

dopushinstancevariableordered:
  if (_trace) printf("dopushinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushInstanceVariableOrderedIM:
  if (_trace) printf("DoPushInstanceVariableOrderedIM:\n");

DoPushInstanceVariableOrderedSP:
  if (_trace) printf("DoPushInstanceVariableOrderedSP:\n");

DoPushInstanceVariableOrderedLP:
  if (_trace) printf("DoPushInstanceVariableOrderedLP:\n");

DoPushInstanceVariableOrderedFP:
  if (_trace) printf("DoPushInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  /* Memory Read Internal */

g7508:
  t6 = arg1 + ivory;
  t1 = (t6 * 4);
  t2 = LDQ_U(t6);
  /* Stack cache offset */
  t4 = arg1 - arg5;
  t7 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t5 = ((u64)t4 < (u64)arg6) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t6&7)*8));
  if (t5 != 0)
    goto g7510;

g7509:
  t6 = zero + 240;
  t7 = t7 >> (t2 & 63);
  t6 = t6 >> (t2 & 63);
  if (t7 & 1)
    goto g7512;

g7519:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* set CDR-NEXT */
  t7 = t2 & 63;
  *(u32 *)(iSP + 8) = t1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;

g7510:
  if (_trace) printf("g7510:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t4 = (t4 * 8) + t5;
  t1 = *(s32 *)t4;
  /* Read from stack cache */
  t2 = *(s32 *)(t4 + 4);
  goto g7509;

g7512:
  if (_trace) printf("g7512:\n");
  if ((t6 & 1) == 0)
    goto g7511;
  /* Do the indirect thing */
  arg1 = (u32)t1;
  goto g7508;

g7511:
  if (_trace) printf("g7511:\n");
  /* Load the memory action table for cycle */
  t7 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t6 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t6 = (t6 * 4) + t7;
  /* Get the memory action */
  t7 = *(s32 *)t6;

g7516:
  if (_trace) printf("g7516:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0)
    goto g7515;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto g7519;
#ifndef MINIMA

g7515:
#endif
#ifdef MINIMA

g7515:
  if (_trace) printf("g7515:\n");
  t6 = t7 & MemoryActionBinding;
  t5 = *(u64 *)&(processor->dbcmask);
  if (t6 == 0)
    goto g7514;
  t4 = arg1 << 1;
  t6 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t4 = t4 & t5;
  t5 = 1;
  t5 = t5 << (ivorymemorydata & 63);
  t4 = (s32)t4 + (s32)t6;
  /* Clear sign-extension */
  t4 = (u32)t4;
  t5 = (t4 * 4) + t5;
  /* Fetch the key */
  t4 = *(s32 *)t5;
  /* Fetch value */
  t1 = *(s32 *)(t5 + 4);
  /* Compare */
  t6 = (s32)arg1 - (s32)t4;
  /* Trap on miss */
  if (t6 != 0)
    goto g7518;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t1;
  goto g7508;

g7518:
  if (_trace) printf("g7518:\n");
  goto dbcachemisstrap;
#endif

g7514:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

/* end DoPushInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPushInstanceVariableOrdered */
/* start DoPopInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPopInstanceVariableOrdered */

dopopinstancevariableordered:
  if (_trace) printf("dopopinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPopInstanceVariableOrderedIM:
  if (_trace) printf("DoPopInstanceVariableOrderedIM:\n");

DoPopInstanceVariableOrderedSP:
  if (_trace) printf("DoPopInstanceVariableOrderedSP:\n");

DoPopInstanceVariableOrderedLP:
  if (_trace) printf("DoPopInstanceVariableOrderedLP:\n");

DoPopInstanceVariableOrderedFP:
  if (_trace) printf("DoPopInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  /* Memory Read Internal */

g7520:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g7522;

g7521:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g7524;

g7530:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g7532:
  if (_trace) printf("g7532:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g7531;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

g7531:
  if (_trace) printf("g7531:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g7522:
  if (_trace) printf("g7522:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g7521;

g7524:
  if (_trace) printf("g7524:\n");
  if ((t8 & 1) == 0)
    goto g7523;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g7520;

g7523:
  if (_trace) printf("g7523:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g7527:
#endif
#ifdef MINIMA

g7527:
  if (_trace) printf("g7527:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g7526;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g7529;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g7520;

g7529:
  if (_trace) printf("g7529:\n");
  goto dbcachemisstrap;
#endif

g7526:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoPopInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPopInstanceVariableOrdered */
/* start DoMovemInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoMovemInstanceVariableOrdered */

domoveminstancevariableordered:
  if (_trace) printf("domoveminstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoMovemInstanceVariableOrderedIM:
  if (_trace) printf("DoMovemInstanceVariableOrderedIM:\n");

DoMovemInstanceVariableOrderedSP:
  if (_trace) printf("DoMovemInstanceVariableOrderedSP:\n");

DoMovemInstanceVariableOrderedLP:
  if (_trace) printf("DoMovemInstanceVariableOrderedLP:\n");

DoMovemInstanceVariableOrderedFP:
  if (_trace) printf("DoMovemInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  t1 = (u32)t1;
  /* Memory Read Internal */

g7533:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g7535;

g7534:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g7537;

g7543:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g7545:
  if (_trace) printf("g7545:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g7544;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

g7544:
  if (_trace) printf("g7544:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g7535:
  if (_trace) printf("g7535:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g7534;

g7537:
  if (_trace) printf("g7537:\n");
  if ((t8 & 1) == 0)
    goto g7536;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g7533;

g7536:
  if (_trace) printf("g7536:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g7540:
#endif
#ifdef MINIMA

g7540:
  if (_trace) printf("g7540:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g7539;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g7542;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g7533;

g7542:
  if (_trace) printf("g7542:\n");
  goto dbcachemisstrap;
#endif

g7539:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoMovemInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoMovemInstanceVariableOrdered */
/* start DoPushAddressInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariableOrdered */

dopushaddressinstancevariableordered:
  if (_trace) printf("dopushaddressinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushAddressInstanceVariableOrderedIM:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedIM:\n");

DoPushAddressInstanceVariableOrderedSP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedSP:\n");

DoPushAddressInstanceVariableOrderedLP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedLP:\n");

DoPushAddressInstanceVariableOrderedFP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  t7 = Type_Locative;
  *(u32 *)(iSP + 8) = arg1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

ivbadmap:
  if (_trace) printf("ivbadmap:\n");
  arg5 = 0;
  arg2 = 68;
  goto illegaloperand;

ivbadindex:
  if (_trace) printf("ivbadindex:\n");
  arg5 = 0;
  arg2 = 53;
  goto illegaloperand;

ivbadinst:
  if (_trace) printf("ivbadinst:\n");
  arg5 = 0;
  arg2 = 69;
  goto illegaloperand;

/* end DoPushAddressInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPushAddressInstanceVariableOrdered */
/* start DoInstanceRef */

  /* Halfword operand from stack instruction - DoInstanceRef */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceref:
  if (_trace) printf("doinstanceref:\n");
#ifdef TRACING
#endif

DoInstanceRefIM:
  if (_trace) printf("DoInstanceRefIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoinstanceref;
#ifdef TRACING
#endif

DoInstanceRefSP:
  if (_trace) printf("DoInstanceRefSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceref;
#endif

DoInstanceRefLP:
  if (_trace) printf("DoInstanceRefLP:\n");
#ifdef TRACING
  goto headdoinstanceref;
#endif

DoInstanceRefFP:
  if (_trace) printf("DoInstanceRefFP:\n");

headdoinstanceref:
  if (_trace) printf("headdoinstanceref:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoinstanceref:
  if (_trace) printf("begindoinstanceref:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;
  /* Strip CDR code, low bits */
  t1 = t1 & 60;
  if (t1 != 0)
    goto ivrefbadinst;
  t1 = arg2 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto ivrefbadoffset;
  /* Memory Read Internal */

g7546:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);
  t2 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg4 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7548;

g7547:
  t7 = zero + 64;
  t8 = t8 >> (t2 & 63);
  t7 = t7 >> (t2 & 63);
  t1 = (u32)t1;
  if (t8 & 1)
    goto g7550;

g7555:
  t1 = t1 - 1;
  /* Memory Read Internal */

g7556:
  t7 = t1 + ivory;
  t2 = (t7 * 4);
  t4 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = t1 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t2 = *(s32 *)t2;
  t4 = (u8)(t4 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7558;

g7557:
  t7 = zero + 240;
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  if (t8 & 1)
    goto g7560;

g7567:
  t5 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto ivrefbadoffset;
  /* J. if offset <0 */
  if ((s64)arg1 < 0)
    goto ivrefbadoffset;
  t4 = arg1 - t2;
  /* J. if offset out of bounds */
  if ((s64)t4 >= 0)
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  /* Memory Read Internal */

g7568:
  /* Base of stack cache */
  t4 = *(u64 *)&(processor->stackcachebasevma);
  t6 = arg5 + ivory;
  t5 = *(s32 *)&processor->scovlimit;
  t1 = (t6 * 4);
  t2 = LDQ_U(t6);
  /* Stack cache offset */
  t4 = arg5 - t4;
  t7 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t5 = ((u64)t4 < (u64)t5) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t6&7)*8));
  if (t5 != 0)
    goto g7570;

g7569:
  t6 = zero + 240;
  t7 = t7 >> (t2 & 63);
  t6 = t6 >> (t2 & 63);
  if (t7 & 1)
    goto g7572;

g7579:
  /* set CDR-NEXT */
  t2 = t2 & 63;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u32 *)iSP = t1;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t2;
  goto cachevalid;

g7570:
  if (_trace) printf("g7570:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t4 = (t4 * 8) + t5;
  t1 = *(s32 *)t4;
  /* Read from stack cache */
  t2 = *(s32 *)(t4 + 4);
  goto g7569;

g7572:
  if (_trace) printf("g7572:\n");
  if ((t6 & 1) == 0)
    goto g7571;
  /* Do the indirect thing */
  arg5 = (u32)t1;
  goto g7568;

g7571:
  if (_trace) printf("g7571:\n");
  /* Load the memory action table for cycle */
  t7 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t6 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg5;
  /* Adjust for a longword load */
  t6 = (t6 * 4) + t7;
  /* Get the memory action */
  t7 = *(s32 *)t6;

g7576:
  if (_trace) printf("g7576:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0)
    goto g7575;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto g7579;
#ifndef MINIMA

g7575:
#endif
#ifdef MINIMA

g7575:
  if (_trace) printf("g7575:\n");
  t6 = t7 & MemoryActionBinding;
  t5 = *(u64 *)&(processor->dbcmask);
  if (t6 == 0)
    goto g7574;
  t4 = arg5 << 1;
  t6 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t4 = t4 & t5;
  t5 = 1;
  t5 = t5 << (ivorymemorydata & 63);
  t4 = (s32)t4 + (s32)t6;
  /* Clear sign-extension */
  t4 = (u32)t4;
  t5 = (t4 * 4) + t5;
  /* Fetch the key */
  t4 = *(s32 *)t5;
  /* Fetch value */
  t1 = *(s32 *)(t5 + 4);
  /* Compare */
  t6 = (s32)arg5 - (s32)t4;
  /* Trap on miss */
  if (t6 != 0)
    goto g7578;
  /* Extract the pointer, and indirect */
  arg5 = (u32)t1;
  goto g7568;

g7578:
  if (_trace) printf("g7578:\n");
  goto dbcachemisstrap;
#endif

g7574:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

g7558:
  if (_trace) printf("g7558:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t2 = *(s32 *)t5;
  /* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g7557;

g7560:
  if (_trace) printf("g7560:\n");
  if ((t7 & 1) == 0)
    goto g7559;
  /* Do the indirect thing */
  t1 = (u32)t2;
  goto g7556;

g7559:
  if (_trace) printf("g7559:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7564:
  if (_trace) printf("g7564:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0)
    goto g7563;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g7567;
#ifndef MINIMA

g7563:
#endif
#ifdef MINIMA

g7563:
  if (_trace) printf("g7563:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g7562;
  t5 = t1 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t2 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)t1 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g7566;
  /* Extract the pointer, and indirect */
  t1 = (u32)t2;
  goto g7556;

g7566:
  if (_trace) printf("g7566:\n");
  goto dbcachemisstrap;
#endif

g7562:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

g7548:
  if (_trace) printf("g7548:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t1 = *(s32 *)t5;
  /* Read from stack cache */
  t2 = *(s32 *)(t5 + 4);
  goto g7547;

g7550:
  if (_trace) printf("g7550:\n");
  if ((t7 & 1) == 0)
    goto g7549;
  /* Do the indirect thing */
  arg4 = (u32)t1;
  goto g7546;

g7549:
  if (_trace) printf("g7549:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7552:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceRef */
  /* End of Halfword operand from stack instruction - DoInstanceRef */
/* start DoInstanceSet */

  /* Halfword operand from stack instruction - DoInstanceSet */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceset:
  if (_trace) printf("doinstanceset:\n");
#ifdef TRACING
#endif

DoInstanceSetIM:
  if (_trace) printf("DoInstanceSetIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoinstanceset;
#ifdef TRACING
#endif

DoInstanceSetSP:
  if (_trace) printf("DoInstanceSetSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceset;
#endif

DoInstanceSetLP:
  if (_trace) printf("DoInstanceSetLP:\n");
#ifdef TRACING
  goto headdoinstanceset;
#endif

DoInstanceSetFP:
  if (_trace) printf("DoInstanceSetFP:\n");

headdoinstanceset:
  if (_trace) printf("headdoinstanceset:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoinstanceset:
  if (_trace) printf("begindoinstanceset:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;
  /* Strip CDR code, low bits */
  t1 = t1 & 60;
  if (t1 != 0)
    goto ivrefbadinst3;
  t1 = arg2 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto ivrefbadoffset;
  /* Memory Read Internal */

g7580:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);
  t2 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg4 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7582;

g7581:
  t7 = zero + 64;
  t8 = t8 >> (t2 & 63);
  t7 = t7 >> (t2 & 63);
  t1 = (u32)t1;
  if (t8 & 1)
    goto g7584;

g7589:
  t1 = t1 - 1;
  /* Memory Read Internal */

g7590:
  t7 = t1 + ivory;
  t2 = (t7 * 4);
  t4 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = t1 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t2 = *(s32 *)t2;
  t4 = (u8)(t4 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7592;

g7591:
  t7 = zero + 240;
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  if (t8 & 1)
    goto g7594;

g7601:
  t5 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto ivrefbadoffset;
  /* J. if offset <0 */
  if ((s64)arg1 < 0)
    goto ivrefbadoffset;
  t4 = arg1 - t2;
  /* J. if offset out of bounds */
  if ((s64)t4 >= 0)
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g7602:
  t7 = arg5 + ivory;
  t4 = (t7 * 4);
  t3 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg5 - t11;
  t8 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t4 = *(s32 *)t4;
  t3 = (u8)(t3 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7604;

g7603:
  t7 = zero + 240;
  t8 = t8 >> (t3 & 63);
  t7 = t7 >> (t3 & 63);
  if (t8 & 1)
    goto g7606;

g7612:
  /* Merge cdr-code */
  t4 = t2 & 63;
  t3 = t3 & 192;
  t3 = t3 | t4;
  t5 = arg5 + ivory;
  t4 = (t5 * 4);
  t7 = LDQ_U(t5);
  /* Stack cache offset */
  t6 = arg5 - t11;
  /* In range? */
  t8 = ((u64)t6 < (u64)t12) ? 1 : 0;
  t6 = (t3 & 0xff) << ((t5&7)*8);
  t7 = t7 & ~(0xffL << (t5&7)*8);

g7614:
  if (_trace) printf("g7614:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);
  *(u32 *)t4 = t1;
  /* J. if in cache */
  if (t8 != 0)
    goto g7613;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

ivrefbadinst3:
  if (_trace) printf("ivrefbadinst3:\n");
  arg5 = 0;
  arg2 = 4;
  goto illegaloperand;

g7613:
  if (_trace) printf("g7613:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t6 = arg5 - t11;
  /* reconstruct SCA */
  t5 = (t6 * 8) + t5;
  /* Store in stack */
  *(u32 *)t5 = t1;
  /* write the stack cache */
  *(u32 *)(t5 + 4) = t3;
  goto NEXTINSTRUCTION;

g7604:
  if (_trace) printf("g7604:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t4 = *(s32 *)t5;
  /* Read from stack cache */
  t3 = *(s32 *)(t5 + 4);
  goto g7603;

g7606:
  if (_trace) printf("g7606:\n");
  if ((t7 & 1) == 0)
    goto g7605;
  /* Do the indirect thing */
  arg5 = (u32)t4;
  goto g7602;

g7605:
  if (_trace) printf("g7605:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t3 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg5;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;
#ifndef MINIMA

g7609:
#endif
#ifdef MINIMA

g7609:
  if (_trace) printf("g7609:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g7608;
  t5 = arg5 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t4 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)arg5 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g7611;
  /* Extract the pointer, and indirect */
  arg5 = (u32)t4;
  goto g7602;

g7611:
  if (_trace) printf("g7611:\n");
  goto dbcachemisstrap;
#endif

g7608:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 1;
  goto performmemoryaction;

g7592:
  if (_trace) printf("g7592:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t2 = *(s32 *)t5;
  /* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g7591;

g7594:
  if (_trace) printf("g7594:\n");
  if ((t7 & 1) == 0)
    goto g7593;
  /* Do the indirect thing */
  t1 = (u32)t2;
  goto g7590;

g7593:
  if (_trace) printf("g7593:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7598:
  if (_trace) printf("g7598:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0)
    goto g7597;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g7601;
#ifndef MINIMA

g7597:
#endif
#ifdef MINIMA

g7597:
  if (_trace) printf("g7597:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g7596;
  t5 = t1 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t2 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)t1 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g7600;
  /* Extract the pointer, and indirect */
  t1 = (u32)t2;
  goto g7590;

g7600:
  if (_trace) printf("g7600:\n");
  goto dbcachemisstrap;
#endif

g7596:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

g7582:
  if (_trace) printf("g7582:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t1 = *(s32 *)t5;
  /* Read from stack cache */
  t2 = *(s32 *)(t5 + 4);
  goto g7581;

g7584:
  if (_trace) printf("g7584:\n");
  if ((t7 & 1) == 0)
    goto g7583;
  /* Do the indirect thing */
  arg4 = (u32)t1;
  goto g7580;

g7583:
  if (_trace) printf("g7583:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7586:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceSet */
  /* End of Halfword operand from stack instruction - DoInstanceSet */
/* start DoInstanceLoc */

  /* Halfword operand from stack instruction - DoInstanceLoc */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceloc:
  if (_trace) printf("doinstanceloc:\n");
#ifdef TRACING
#endif

DoInstanceLocIM:
  if (_trace) printf("DoInstanceLocIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoinstanceloc;
#ifdef TRACING
#endif

DoInstanceLocSP:
  if (_trace) printf("DoInstanceLocSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceloc;
#endif

DoInstanceLocLP:
  if (_trace) printf("DoInstanceLocLP:\n");
#ifdef TRACING
  goto headdoinstanceloc;
#endif

DoInstanceLocFP:
  if (_trace) printf("DoInstanceLocFP:\n");

headdoinstanceloc:
  if (_trace) printf("headdoinstanceloc:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoinstanceloc:
  if (_trace) printf("begindoinstanceloc:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;
  /* Strip CDR code, low bits */
  t1 = t1 & 60;
  if (t1 != 0)
    goto ivrefbadinst;
  t1 = arg2 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto ivrefbadoffset;
  /* Memory Read Internal */

g7615:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);
  t2 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg4 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7617;

g7616:
  t7 = zero + 64;
  t8 = t8 >> (t2 & 63);
  t7 = t7 >> (t2 & 63);
  t1 = (u32)t1;
  if (t8 & 1)
    goto g7619;

g7624:
  t1 = t1 - 1;
  /* Memory Read Internal */

g7625:
  t7 = t1 + ivory;
  t2 = (t7 * 4);
  t4 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = t1 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t2 = *(s32 *)t2;
  t4 = (u8)(t4 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7627;

g7626:
  t7 = zero + 240;
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  if (t8 & 1)
    goto g7629;

g7636:
  t5 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto ivrefbadoffset;
  /* J. if offset <0 */
  if ((s64)arg1 < 0)
    goto ivrefbadoffset;
  t4 = arg1 - t2;
  /* J. if offset out of bounds */
  if ((s64)t4 >= 0)
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  t7 = Type_Locative;
  *(u32 *)iSP = arg5;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t7;
  goto NEXTINSTRUCTION;

ivrefbadinst:
  if (_trace) printf("ivrefbadinst:\n");
  arg5 = 0;
  arg2 = 3;
  goto illegaloperand;

ivrefbadoffset:
  if (_trace) printf("ivrefbadoffset:\n");
  arg5 = 0;
  arg2 = 49;
  goto illegaloperand;

g7627:
  if (_trace) printf("g7627:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t2 = *(s32 *)t5;
  /* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g7626;

g7629:
  if (_trace) printf("g7629:\n");
  if ((t7 & 1) == 0)
    goto g7628;
  /* Do the indirect thing */
  t1 = (u32)t2;
  goto g7625;

g7628:
  if (_trace) printf("g7628:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7633:
  if (_trace) printf("g7633:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0)
    goto g7632;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g7636;
#ifndef MINIMA

g7632:
#endif
#ifdef MINIMA

g7632:
  if (_trace) printf("g7632:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g7631;
  t5 = t1 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t2 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)t1 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g7635;
  /* Extract the pointer, and indirect */
  t1 = (u32)t2;
  goto g7625;

g7635:
  if (_trace) printf("g7635:\n");
  goto dbcachemisstrap;
#endif

g7631:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

g7617:
  if (_trace) printf("g7617:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t1 = *(s32 *)t5;
  /* Read from stack cache */
  t2 = *(s32 *)(t5 + 4);
  goto g7616;

g7619:
  if (_trace) printf("g7619:\n");
  if ((t7 & 1) == 0)
    goto g7618;
  /* Do the indirect thing */
  arg4 = (u32)t1;
  goto g7615;

g7618:
  if (_trace) printf("g7618:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7621:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceLoc */
  /* End of Halfword operand from stack instruction - DoInstanceLoc */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifuninst.as */
