/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifuninst.as
 ************************************************************************/

  /* Instance variable accessors.. */
/* start DoPopInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPopInstanceVariable */

dopopinstancevariable:
  if (_trace) printf("dopopinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPopInstanceVariableIM:
  if (_trace) printf("DoPopInstanceVariableIM:\n");

DoPopInstanceVariableSP:
  if (_trace) printf("DoPopInstanceVariableSP:\n");

DoPopInstanceVariableLP:
  if (_trace) printf("DoPopInstanceVariableLP:\n");

DoPopInstanceVariableFP:
  if (_trace) printf("DoPopInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
		/* Map */
  arg1 = *(s32 *)(iFP + 16);
  t1 = *(s32 *)(iFP + 20);
  arg1 = (u32)arg1;   
  t4 = t1 - Type_Array;
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto ivbadmap;
  /* Memory Read Internal */

g29049:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
		/* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto g29051;

g29050:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  if (t10 & 1)   
    goto g29053;

g29058:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;
  if ((s64)t5 <= 0)  		// J. if mapping-table-index-out-of-bounds 
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

g29059:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
		/* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->dataread_mask);
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto g29061;

g29060:
  t9 = zero + 240;   
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto g29063;

g29070:
  t3 = t2;
  t6 = t1 - Type_Fixnum;
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto popiviex;
		/* Self */
  arg1 = *(s32 *)(iFP + 24);
  t6 = *(s32 *)(iFP + 28);
  arg1 = (u32)arg1;   
  t5 = t6 - Type_Instance;
  t5 = t5 & 60;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto ivbadinst;
  t5 = t6 & 192;		// Unshifted cdr code 
		/* Check for CDR code 1 */
  t5 = t5 - 64;
  if (t5 != 0)   		// J. if CDR code is not 1 
    goto g29048;

g29047:
  if (_trace) printf("g29047:\n");
  arg1 = arg1 + t3;

g29046:
  if (_trace) printf("g29046:\n");
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;   
  arg5 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g29071:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
		/* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto g29073;

g29072:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)   
    goto g29075;

g29081:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
		/* Stack cache offset */
  t7 = arg1 - arg5;
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);

g29083:
  if (_trace) printf("g29083:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t1;
  if (t9 != 0)   		// J. if in cache 
    goto g29082;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

popiviex:
  if (_trace) printf("popiviex:\n");
  t1 = zero + 8;   
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  arg6 = t2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

g29082:
  if (_trace) printf("g29082:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
		/* Stack cache offset */
  t7 = arg1 - arg5;
		/* reconstruct SCA */
  t6 = (t7 * 8) + t6;
		/* Store in stack */
  *(u32 *)t6 = t1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

g29073:
  if (_trace) printf("g29073:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
		/* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g29072;   

g29075:
  if (_trace) printf("g29075:\n");
  if ((t8 & 1) == 0)   
    goto g29074;
  arg1 = (u32)t5;   		// Do the indirect thing 
  goto g29071;   

g29074:
  if (_trace) printf("g29074:\n");
		/* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
		/* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g29078:
#endif
#ifdef MINIMA

g29078:
  if (_trace) printf("g29078:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0) 
    goto g29077;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  t6 = t6 & t7;		// Hash index 
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  t6 = (u32)t6;   		// Clear sign-extension 
  t7 = (t6 * 4) + t7;   
		/* Fetch the key */
  t6 = *(s32 *)t7;
		/* Fetch value */
  t5 = *(s32 *)(t7 + 4);
		/* Compare */
  t8 = (s32)arg1 - (s32)t6;
  if (t8 != 0)   		// Trap on miss 
    goto g29080;
  arg1 = (u32)t5;   		// Extract the pointer, and indirect 
  goto g29071;   		// This is another memory read tailcall. 

g29080:
  if (_trace) printf("g29080:\n");
  goto dbcachemisstrap;
#endif

g29077:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

g29061:
  if (_trace) printf("g29061:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
		/* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g29060;   

g29063:
  if (_trace) printf("g29063:\n");
  if ((t9 & 1) == 0)   
    goto g29062;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto g29059;   

g29062:
  if (_trace) printf("g29062:\n");
		/* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
		/* Get the memory action */
  t10 = *(s32 *)t9;

g29067:
  if (_trace) printf("g29067:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0) 
    goto g29066;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto g29070;   
#ifndef MINIMA

g29066:
#endif
#ifdef MINIMA

g29066:
  if (_trace) printf("g29066:\n");
  t9 = t10 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t9 == 0) 
    goto g29065;
  t7 = arg1 << 1;
  t9 = *(u64 *)&(processor->dbcbase);
  t7 = t7 & t8;		// Hash index 
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t9;
  t7 = (u32)t7;   		// Clear sign-extension 
  t8 = (t7 * 4) + t8;   
		/* Fetch the key */
  t7 = *(s32 *)t8;
		/* Fetch value */
  t2 = *(s32 *)(t8 + 4);
		/* Compare */
  t9 = (s32)arg1 - (s32)t7;
  if (t9 != 0)   		// Trap on miss 
    goto g29069;
  arg1 = (u32)t2;   		// Extract the pointer, and indirect 
  goto g29059;   		// This is another memory read tailcall. 

g29069:
  if (_trace) printf("g29069:\n");
  goto dbcachemisstrap;
#endif

g29065:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

g29051:
  if (_trace) printf("g29051:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
		/* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g29050;   

g29053:
  if (_trace) printf("g29053:\n");
  if ((t9 & 1) == 0)   
    goto g29052;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto g29049;   

g29052:
  if (_trace) printf("g29052:\n");
		/* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
		/* Get the memory action */
  t10 = *(s32 *)t9;

g29055:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

g29048:
  if (_trace) printf("g29048:\n");
  t5 = arg1;
  /* Memory Read Internal */

g29084:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
		/* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto g29086;

g29085:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto g29088;

g29093:
  t5 = t5 - arg1;
  if (t5 != 0)   
    goto g29047;
  /* TagType. */
  t6 = t6 & 63;
  t6 = t6 | 64;		// Set CDR code to 1 
		/* Update self */
  *(u32 *)(iFP + 24) = arg1;
		/* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto g29047;   

g29086:
  if (_trace) printf("g29086:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
		/* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g29085;   

g29088:
  if (_trace) printf("g29088:\n");
  if ((t9 & 1) == 0)   
    goto g29087;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto g29084;   

g29087:
  if (_trace) printf("g29087:\n");
		/* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
		/* Get the memory action */
  t10 = *(s32 *)t9;

g29090:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoPopInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPopInstanceVariable */
/* start DoMovemInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoMovemInstanceVariable */

domoveminstancevariable:
  if (_trace) printf("domoveminstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoMovemInstanceVariableIM:
  if (_trace) printf("DoMovemInstanceVariableIM:\n");

DoMovemInstanceVariableSP:
  if (_trace) printf("DoMovemInstanceVariableSP:\n");

DoMovemInstanceVariableLP:
  if (_trace) printf("DoMovemInstanceVariableLP:\n");

DoMovemInstanceVariableFP:
  if (_trace) printf("DoMovemInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
		/* Map */
  arg1 = *(s32 *)(iFP + 16);
  t1 = *(s32 *)(iFP + 20);
  arg1 = (u32)arg1;   
  t4 = t1 - Type_Array;
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto ivbadmap;
  /* Memory Read Internal */

g29097:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
		/* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto g29099;

g29098:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  if (t10 & 1)   
    goto g29101;

g29106:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;
  if ((s64)t5 <= 0)  		// J. if mapping-table-index-out-of-bounds 
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

g29107:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
		/* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->dataread_mask);
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto g29109;

g29108:
  t9 = zero + 240;   
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto g29111;

g29118:
  t3 = t2;
  t6 = t1 - Type_Fixnum;
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto movemiviex;
		/* Self */
  arg1 = *(s32 *)(iFP + 24);
  t6 = *(s32 *)(iFP + 28);
  arg1 = (u32)arg1;   
  t5 = t6 - Type_Instance;
  t5 = t5 & 60;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto ivbadinst;
  t5 = t6 & 192;		// Unshifted cdr code 
		/* Check for CDR code 1 */
  t5 = t5 - 64;
  if (t5 != 0)   		// J. if CDR code is not 1 
    goto g29096;

g29095:
  if (_trace) printf("g29095:\n");
  arg1 = arg1 + t3;

g29094:
  if (_trace) printf("g29094:\n");
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  t1 = (u32)t1;   
  arg5 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g29119:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
		/* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto g29121;

g29120:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)   
    goto g29123;

g29129:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
		/* Stack cache offset */
  t7 = arg1 - arg5;
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);

g29131:
  if (_trace) printf("g29131:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t1;
  if (t9 != 0)   		// J. if in cache 
    goto g29130;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

movemiviex:
  if (_trace) printf("movemiviex:\n");
  t1 = zero + 8;   
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  arg6 = t2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

g29130:
  if (_trace) printf("g29130:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
		/* Stack cache offset */
  t7 = arg1 - arg5;
		/* reconstruct SCA */
  t6 = (t7 * 8) + t6;
		/* Store in stack */
  *(u32 *)t6 = t1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

g29121:
  if (_trace) printf("g29121:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
		/* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g29120;   

g29123:
  if (_trace) printf("g29123:\n");
  if ((t8 & 1) == 0)   
    goto g29122;
  arg1 = (u32)t5;   		// Do the indirect thing 
  goto g29119;   

g29122:
  if (_trace) printf("g29122:\n");
		/* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
		/* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g29126:
#endif
#ifdef MINIMA

g29126:
  if (_trace) printf("g29126:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0) 
    goto g29125;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  t6 = t6 & t7;		// Hash index 
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  t6 = (u32)t6;   		// Clear sign-extension 
  t7 = (t6 * 4) + t7;   
		/* Fetch the key */
  t6 = *(s32 *)t7;
		/* Fetch value */
  t5 = *(s32 *)(t7 + 4);
		/* Compare */
  t8 = (s32)arg1 - (s32)t6;
  if (t8 != 0)   		// Trap on miss 
    goto g29128;
  arg1 = (u32)t5;   		// Extract the pointer, and indirect 
  goto g29119;   		// This is another memory read tailcall. 

g29128:
  if (_trace) printf("g29128:\n");
  goto dbcachemisstrap;
#endif

g29125:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

g29109:
  if (_trace) printf("g29109:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
		/* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g29108;   

g29111:
  if (_trace) printf("g29111:\n");
  if ((t9 & 1) == 0)   
    goto g29110;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto g29107;   

g29110:
  if (_trace) printf("g29110:\n");
		/* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
		/* Get the memory action */
  t10 = *(s32 *)t9;

g29115:
  if (_trace) printf("g29115:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0) 
    goto g29114;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto g29118;   
#ifndef MINIMA

g29114:
#endif
#ifdef MINIMA

g29114:
  if (_trace) printf("g29114:\n");
  t9 = t10 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t9 == 0) 
    goto g29113;
  t7 = arg1 << 1;
  t9 = *(u64 *)&(processor->dbcbase);
  t7 = t7 & t8;		// Hash index 
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t9;
  t7 = (u32)t7;   		// Clear sign-extension 
  t8 = (t7 * 4) + t8;   
		/* Fetch the key */
  t7 = *(s32 *)t8;
		/* Fetch value */
  t2 = *(s32 *)(t8 + 4);
		/* Compare */
  t9 = (s32)arg1 - (s32)t7;
  if (t9 != 0)   		// Trap on miss 
    goto g29117;
  arg1 = (u32)t2;   		// Extract the pointer, and indirect 
  goto g29107;   		// This is another memory read tailcall. 

g29117:
  if (_trace) printf("g29117:\n");
  goto dbcachemisstrap;
#endif

g29113:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

g29099:
  if (_trace) printf("g29099:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
		/* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g29098;   

g29101:
  if (_trace) printf("g29101:\n");
  if ((t9 & 1) == 0)   
    goto g29100;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto g29097;   

g29100:
  if (_trace) printf("g29100:\n");
		/* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
		/* Get the memory action */
  t10 = *(s32 *)t9;

g29103:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

g29096:
  if (_trace) printf("g29096:\n");
  t5 = arg1;
  /* Memory Read Internal */

g29132:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
		/* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto g29134;

g29133:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto g29136;

g29141:
  t5 = t5 - arg1;
  if (t5 != 0)   
    goto g29095;
  /* TagType. */
  t6 = t6 & 63;
  t6 = t6 | 64;		// Set CDR code to 1 
		/* Update self */
  *(u32 *)(iFP + 24) = arg1;
		/* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto g29095;   

g29134:
  if (_trace) printf("g29134:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
		/* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g29133;   

g29136:
  if (_trace) printf("g29136:\n");
  if ((t9 & 1) == 0)   
    goto g29135;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto g29132;   

g29135:
  if (_trace) printf("g29135:\n");
		/* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
		/* Get the memory action */
  t10 = *(s32 *)t9;

g29138:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoMovemInstanceVariable */
  /* End of Halfword operand from stack instruction - DoMovemInstanceVariable */
/* start DoPushAddressInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariable */

dopushaddressinstancevariable:
  if (_trace) printf("dopushaddressinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushAddressInstanceVariableIM:
  if (_trace) printf("DoPushAddressInstanceVariableIM:\n");

DoPushAddressInstanceVariableSP:
  if (_trace) printf("DoPushAddressInstanceVariableSP:\n");

DoPushAddressInstanceVariableLP:
  if (_trace) printf("DoPushAddressInstanceVariableLP:\n");

DoPushAddressInstanceVariableFP:
  if (_trace) printf("DoPushAddressInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
		/* Map */
  arg1 = *(s32 *)(iFP + 16);
  t1 = *(s32 *)(iFP + 20);
  arg1 = (u32)arg1;   
  t4 = t1 - Type_Array;
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto ivbadmap;
  /* Memory Read Internal */

g29145:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
		/* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto g29147;

g29146:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  if (t10 & 1)   
    goto g29149;

g29154:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;
  if ((s64)t5 <= 0)  		// J. if mapping-table-index-out-of-bounds 
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

g29155:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
		/* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->dataread_mask);
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto g29157;

g29156:
  t9 = zero + 240;   
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto g29159;

g29166:
  t3 = t2;
  t6 = t1 - Type_Fixnum;
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto pushadiviex;
		/* Self */
  arg1 = *(s32 *)(iFP + 24);
  t6 = *(s32 *)(iFP + 28);
  arg1 = (u32)arg1;   
  t5 = t6 - Type_Instance;
  t5 = t5 & 60;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto ivbadinst;
  t5 = t6 & 192;		// Unshifted cdr code 
		/* Check for CDR code 1 */
  t5 = t5 - 64;
  if (t5 != 0)   		// J. if CDR code is not 1 
    goto g29144;

g29143:
  if (_trace) printf("g29143:\n");
  arg1 = arg1 + t3;

g29142:
  if (_trace) printf("g29142:\n");
  t7 = Type_Locative;
  *(u32 *)(iSP + 8) = arg1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

pushadiviex:
  if (_trace) printf("pushadiviex:\n");
  t1 = zero + 8;   
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  arg6 = t2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

g29157:
  if (_trace) printf("g29157:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
		/* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g29156;   

g29159:
  if (_trace) printf("g29159:\n");
  if ((t9 & 1) == 0)   
    goto g29158;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto g29155;   

g29158:
  if (_trace) printf("g29158:\n");
		/* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
		/* Get the memory action */
  t10 = *(s32 *)t9;

g29163:
  if (_trace) printf("g29163:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0) 
    goto g29162;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto g29166;   
#ifndef MINIMA

g29162:
#endif
#ifdef MINIMA

g29162:
  if (_trace) printf("g29162:\n");
  t9 = t10 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t9 == 0) 
    goto g29161;
  t7 = arg1 << 1;
  t9 = *(u64 *)&(processor->dbcbase);
  t7 = t7 & t8;		// Hash index 
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t9;
  t7 = (u32)t7;   		// Clear sign-extension 
  t8 = (t7 * 4) + t8;   
		/* Fetch the key */
  t7 = *(s32 *)t8;
		/* Fetch value */
  t2 = *(s32 *)(t8 + 4);
		/* Compare */
  t9 = (s32)arg1 - (s32)t7;
  if (t9 != 0)   		// Trap on miss 
    goto g29165;
  arg1 = (u32)t2;   		// Extract the pointer, and indirect 
  goto g29155;   		// This is another memory read tailcall. 

g29165:
  if (_trace) printf("g29165:\n");
  goto dbcachemisstrap;
#endif

g29161:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

g29147:
  if (_trace) printf("g29147:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
		/* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g29146;   

g29149:
  if (_trace) printf("g29149:\n");
  if ((t9 & 1) == 0)   
    goto g29148;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto g29145;   

g29148:
  if (_trace) printf("g29148:\n");
		/* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
		/* Get the memory action */
  t10 = *(s32 *)t9;

g29151:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

g29144:
  if (_trace) printf("g29144:\n");
  t5 = arg1;
  /* Memory Read Internal */

g29167:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
		/* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto g29169;

g29168:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto g29171;

g29176:
  t5 = t5 - arg1;
  if (t5 != 0)   
    goto g29143;
  /* TagType. */
  t6 = t6 & 63;
  t6 = t6 | 64;		// Set CDR code to 1 
		/* Update self */
  *(u32 *)(iFP + 24) = arg1;
		/* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto g29143;   

g29169:
  if (_trace) printf("g29169:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
		/* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g29168;   

g29171:
  if (_trace) printf("g29171:\n");
  if ((t9 & 1) == 0)   
    goto g29170;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto g29167;   

g29170:
  if (_trace) printf("g29170:\n");
		/* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
		/* Get the memory action */
  t10 = *(s32 *)t9;

g29173:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoPushAddressInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPushAddressInstanceVariable */
/* start DoPushInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPushInstanceVariableOrdered */

dopushinstancevariableordered:
  if (_trace) printf("dopushinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushInstanceVariableOrderedIM:
  if (_trace) printf("DoPushInstanceVariableOrderedIM:\n");

DoPushInstanceVariableOrderedSP:
  if (_trace) printf("DoPushInstanceVariableOrderedSP:\n");

DoPushInstanceVariableOrderedLP:
  if (_trace) printf("DoPushInstanceVariableOrderedLP:\n");

DoPushInstanceVariableOrderedFP:
  if (_trace) printf("DoPushInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Unmapped */
		/* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;   
  t3 = t1 - Type_Instance;
  t3 = t3 & 60;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto ivbadinst;
  arg1 = t2 + arg2;
  /* Memory Read Internal */

g29177:
  t6 = arg1 + ivory;
  t1 = (t6 * 4);   
  t2 = LDQ_U(t6);   
		/* Stack cache offset */
  t4 = arg1 - arg5;
  t7 = *(u64 *)&(processor->dataread_mask);
  t5 = ((u64)t4 < (u64)arg6) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t6&7)*8));   
  if (t5 != 0)   
    goto g29179;

g29178:
  t6 = zero + 240;   
  t7 = t7 >> (t2 & 63);
  t6 = t6 >> (t2 & 63);
  if (t7 & 1)   
    goto g29181;

g29188:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t7 = t2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;   

g29179:
  if (_trace) printf("g29179:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t4 = (t4 * 8) + t5;
  t1 = *(s32 *)t4;
		/* Read from stack cache */
  t2 = *(s32 *)(t4 + 4);
  goto g29178;   

g29181:
  if (_trace) printf("g29181:\n");
  if ((t6 & 1) == 0)   
    goto g29180;
  arg1 = (u32)t1;   		// Do the indirect thing 
  goto g29177;   

g29180:
  if (_trace) printf("g29180:\n");
		/* Load the memory action table for cycle */
  t7 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t6 = t2 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t6 = (t6 * 4) + t7;   		// Adjust for a longword load 
		/* Get the memory action */
  t7 = *(s32 *)t6;

g29185:
  if (_trace) printf("g29185:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0) 
    goto g29184;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto g29188;   
#ifndef MINIMA

g29184:
#endif
#ifdef MINIMA

g29184:
  if (_trace) printf("g29184:\n");
  t6 = t7 & MemoryActionBinding;
  t5 = *(u64 *)&(processor->dbcmask);
  if (t6 == 0) 
    goto g29183;
  t4 = arg1 << 1;
  t6 = *(u64 *)&(processor->dbcbase);
  t4 = t4 & t5;		// Hash index 
  t5 = 1;
  t5 = t5 << (ivorymemorydata & 63);
  t4 = (s32)t4 + (s32)t6;
  t4 = (u32)t4;   		// Clear sign-extension 
  t5 = (t4 * 4) + t5;   
		/* Fetch the key */
  t4 = *(s32 *)t5;
		/* Fetch value */
  t1 = *(s32 *)(t5 + 4);
		/* Compare */
  t6 = (s32)arg1 - (s32)t4;
  if (t6 != 0)   		// Trap on miss 
    goto g29187;
  arg1 = (u32)t1;   		// Extract the pointer, and indirect 
  goto g29177;   		// This is another memory read tailcall. 

g29187:
  if (_trace) printf("g29187:\n");
  goto dbcachemisstrap;
#endif

g29183:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

/* end DoPushInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPushInstanceVariableOrdered */
/* start DoPopInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPopInstanceVariableOrdered */

dopopinstancevariableordered:
  if (_trace) printf("dopopinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPopInstanceVariableOrderedIM:
  if (_trace) printf("DoPopInstanceVariableOrderedIM:\n");

DoPopInstanceVariableOrderedSP:
  if (_trace) printf("DoPopInstanceVariableOrderedSP:\n");

DoPopInstanceVariableOrderedLP:
  if (_trace) printf("DoPopInstanceVariableOrderedLP:\n");

DoPopInstanceVariableOrderedFP:
  if (_trace) printf("DoPopInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Unmapped */
		/* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;   
  t3 = t1 - Type_Instance;
  t3 = t3 & 60;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto ivbadinst;
  arg1 = t2 + arg2;
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;   
  /* Memory Read Internal */

g29189:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
		/* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto g29191;

g29190:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)   
    goto g29193;

g29199:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
		/* Stack cache offset */
  t7 = arg1 - arg5;
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);

g29201:
  if (_trace) printf("g29201:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t1;
  if (t9 != 0)   		// J. if in cache 
    goto g29200;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

g29200:
  if (_trace) printf("g29200:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
		/* Stack cache offset */
  t7 = arg1 - arg5;
		/* reconstruct SCA */
  t6 = (t7 * 8) + t6;
		/* Store in stack */
  *(u32 *)t6 = t1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

g29191:
  if (_trace) printf("g29191:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
		/* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g29190;   

g29193:
  if (_trace) printf("g29193:\n");
  if ((t8 & 1) == 0)   
    goto g29192;
  arg1 = (u32)t5;   		// Do the indirect thing 
  goto g29189;   

g29192:
  if (_trace) printf("g29192:\n");
		/* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
		/* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g29196:
#endif
#ifdef MINIMA

g29196:
  if (_trace) printf("g29196:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0) 
    goto g29195;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  t6 = t6 & t7;		// Hash index 
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  t6 = (u32)t6;   		// Clear sign-extension 
  t7 = (t6 * 4) + t7;   
		/* Fetch the key */
  t6 = *(s32 *)t7;
		/* Fetch value */
  t5 = *(s32 *)(t7 + 4);
		/* Compare */
  t8 = (s32)arg1 - (s32)t6;
  if (t8 != 0)   		// Trap on miss 
    goto g29198;
  arg1 = (u32)t5;   		// Extract the pointer, and indirect 
  goto g29189;   		// This is another memory read tailcall. 

g29198:
  if (_trace) printf("g29198:\n");
  goto dbcachemisstrap;
#endif

g29195:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoPopInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPopInstanceVariableOrdered */
/* start DoMovemInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoMovemInstanceVariableOrdered */

domoveminstancevariableordered:
  if (_trace) printf("domoveminstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoMovemInstanceVariableOrderedIM:
  if (_trace) printf("DoMovemInstanceVariableOrderedIM:\n");

DoMovemInstanceVariableOrderedSP:
  if (_trace) printf("DoMovemInstanceVariableOrderedSP:\n");

DoMovemInstanceVariableOrderedLP:
  if (_trace) printf("DoMovemInstanceVariableOrderedLP:\n");

DoMovemInstanceVariableOrderedFP:
  if (_trace) printf("DoMovemInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Unmapped */
		/* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;   
  t3 = t1 - Type_Instance;
  t3 = t3 & 60;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto ivbadinst;
  arg1 = t2 + arg2;
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  t1 = (u32)t1;   
  /* Memory Read Internal */

g29202:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
		/* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto g29204;

g29203:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)   
    goto g29206;

g29212:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
		/* Stack cache offset */
  t7 = arg1 - arg5;
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);

g29214:
  if (_trace) printf("g29214:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t1;
  if (t9 != 0)   		// J. if in cache 
    goto g29213;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

g29213:
  if (_trace) printf("g29213:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
		/* Stack cache offset */
  t7 = arg1 - arg5;
		/* reconstruct SCA */
  t6 = (t7 * 8) + t6;
		/* Store in stack */
  *(u32 *)t6 = t1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

g29204:
  if (_trace) printf("g29204:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
		/* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g29203;   

g29206:
  if (_trace) printf("g29206:\n");
  if ((t8 & 1) == 0)   
    goto g29205;
  arg1 = (u32)t5;   		// Do the indirect thing 
  goto g29202;   

g29205:
  if (_trace) printf("g29205:\n");
		/* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
		/* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g29209:
#endif
#ifdef MINIMA

g29209:
  if (_trace) printf("g29209:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0) 
    goto g29208;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  t6 = t6 & t7;		// Hash index 
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  t6 = (u32)t6;   		// Clear sign-extension 
  t7 = (t6 * 4) + t7;   
		/* Fetch the key */
  t6 = *(s32 *)t7;
		/* Fetch value */
  t5 = *(s32 *)(t7 + 4);
		/* Compare */
  t8 = (s32)arg1 - (s32)t6;
  if (t8 != 0)   		// Trap on miss 
    goto g29211;
  arg1 = (u32)t5;   		// Extract the pointer, and indirect 
  goto g29202;   		// This is another memory read tailcall. 

g29211:
  if (_trace) printf("g29211:\n");
  goto dbcachemisstrap;
#endif

g29208:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoMovemInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoMovemInstanceVariableOrdered */
/* start DoPushAddressInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariableOrdered */

dopushaddressinstancevariableordered:
  if (_trace) printf("dopushaddressinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushAddressInstanceVariableOrderedIM:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedIM:\n");

DoPushAddressInstanceVariableOrderedSP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedSP:\n");

DoPushAddressInstanceVariableOrderedLP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedLP:\n");

DoPushAddressInstanceVariableOrderedFP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  /* Locate Instance Variable Unmapped */
		/* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;   
  t3 = t1 - Type_Instance;
  t3 = t3 & 60;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto ivbadinst;
  arg1 = t2 + arg2;
  t7 = Type_Locative;
  *(u32 *)(iSP + 8) = arg1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

ivbadmap:
  if (_trace) printf("ivbadmap:\n");
  arg5 = 0;
  arg2 = 68;
  goto illegaloperand;

ivbadindex:
  if (_trace) printf("ivbadindex:\n");
  arg5 = 0;
  arg2 = 53;
  goto illegaloperand;

ivbadinst:
  if (_trace) printf("ivbadinst:\n");
  arg5 = 0;
  arg2 = 69;
  goto illegaloperand;

/* end DoPushAddressInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPushAddressInstanceVariableOrdered */
/* start DoInstanceRef */

  /* Halfword operand from stack instruction - DoInstanceRef */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceref:
  if (_trace) printf("doinstanceref:\n");
#ifdef TRACING
#endif

DoInstanceRefIM:
  if (_trace) printf("DoInstanceRefIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoinstanceref;   
#ifdef TRACING
#endif

DoInstanceRefSP:
  if (_trace) printf("DoInstanceRefSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceref;   
#endif

DoInstanceRefLP:
  if (_trace) printf("DoInstanceRefLP:\n");
#ifdef TRACING
  goto headdoinstanceref;   
#endif

DoInstanceRefFP:
  if (_trace) printf("DoInstanceRefFP:\n");

headdoinstanceref:
  if (_trace) printf("headdoinstanceref:\n");
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
		/* Get the operand */
  arg1 = *(u64 *)arg1;

begindoinstanceref:
  if (_trace) printf("begindoinstanceref:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;   
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;   
  t11 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;
  t1 = t1 & 60;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto ivrefbadinst;
  t1 = arg2 - Type_Fixnum;
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto ivrefbadoffset;
  /* Memory Read Internal */

g29215:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);   
  t2 = LDQ_U(t7);   
		/* Stack cache offset */
  t5 = arg4 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto g29217;

g29216:
  t7 = zero + 64;   
  t8 = t8 >> (t2 & 63);
  t7 = t7 >> (t2 & 63);
  t1 = (u32)t1;   
  if (t8 & 1)   
    goto g29219;

g29224:
  t1 = t1 - 1;
  /* Memory Read Internal */

g29225:
  t7 = t1 + ivory;
  t2 = (t7 * 4);   
  t4 = LDQ_U(t7);   
		/* Stack cache offset */
  t5 = t1 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto g29227;

g29226:
  t7 = zero + 240;   
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  if (t8 & 1)   
    goto g29229;

g29236:
  t5 = t4 - Type_Fixnum;
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto ivrefbadoffset;
  if ((s64)arg1 < 0)   		// J. if offset <0 
    goto ivrefbadoffset;
  t4 = arg1 - t2;
  if ((s64)t4 >= 0)   		// J. if offset out of bounds 
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  /* Memory Read Internal */

g29237:
		/* Base of stack cache */
  t4 = *(u64 *)&(processor->stackcachebasevma);
  t6 = arg5 + ivory;
  t5 = *(s32 *)&processor->scovlimit;
  t1 = (t6 * 4);   
  t2 = LDQ_U(t6);   
		/* Stack cache offset */
  t4 = arg5 - t4;
  t7 = *(u64 *)&(processor->dataread_mask);
  t5 = ((u64)t4 < (u64)t5) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t6&7)*8));   
  if (t5 != 0)   
    goto g29239;

g29238:
  t6 = zero + 240;   
  t7 = t7 >> (t2 & 63);
  t6 = t6 >> (t2 & 63);
  if (t7 & 1)   
    goto g29241;

g29248:
  t2 = t2 & 63;		// set CDR-NEXT 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u32 *)iSP = t1;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t2;
  goto cachevalid;   

g29239:
  if (_trace) printf("g29239:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t4 = (t4 * 8) + t5;
  t1 = *(s32 *)t4;
		/* Read from stack cache */
  t2 = *(s32 *)(t4 + 4);
  goto g29238;   

g29241:
  if (_trace) printf("g29241:\n");
  if ((t6 & 1) == 0)   
    goto g29240;
  arg5 = (u32)t1;   		// Do the indirect thing 
  goto g29237;   

g29240:
  if (_trace) printf("g29240:\n");
		/* Load the memory action table for cycle */
  t7 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t6 = t2 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg5;
  t6 = (t6 * 4) + t7;   		// Adjust for a longword load 
		/* Get the memory action */
  t7 = *(s32 *)t6;

g29245:
  if (_trace) printf("g29245:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0) 
    goto g29244;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto g29248;   
#ifndef MINIMA

g29244:
#endif
#ifdef MINIMA

g29244:
  if (_trace) printf("g29244:\n");
  t6 = t7 & MemoryActionBinding;
  t5 = *(u64 *)&(processor->dbcmask);
  if (t6 == 0) 
    goto g29243;
  t4 = arg5 << 1;
  t6 = *(u64 *)&(processor->dbcbase);
  t4 = t4 & t5;		// Hash index 
  t5 = 1;
  t5 = t5 << (ivorymemorydata & 63);
  t4 = (s32)t4 + (s32)t6;
  t4 = (u32)t4;   		// Clear sign-extension 
  t5 = (t4 * 4) + t5;   
		/* Fetch the key */
  t4 = *(s32 *)t5;
		/* Fetch value */
  t1 = *(s32 *)(t5 + 4);
		/* Compare */
  t6 = (s32)arg5 - (s32)t4;
  if (t6 != 0)   		// Trap on miss 
    goto g29247;
  arg5 = (u32)t1;   		// Extract the pointer, and indirect 
  goto g29237;   		// This is another memory read tailcall. 

g29247:
  if (_trace) printf("g29247:\n");
  goto dbcachemisstrap;
#endif

g29243:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

g29227:
  if (_trace) printf("g29227:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t2 = *(s32 *)t5;
		/* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g29226;   

g29229:
  if (_trace) printf("g29229:\n");
  if ((t7 & 1) == 0)   
    goto g29228;
  t1 = (u32)t2;   		// Do the indirect thing 
  goto g29225;   

g29228:
  if (_trace) printf("g29228:\n");
		/* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
		/* Get the memory action */
  t8 = *(s32 *)t7;

g29233:
  if (_trace) printf("g29233:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0) 
    goto g29232;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g29236;   
#ifndef MINIMA

g29232:
#endif
#ifdef MINIMA

g29232:
  if (_trace) printf("g29232:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0) 
    goto g29231;
  t5 = t1 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  t5 = t5 & t6;		// Hash index 
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  t5 = (u32)t5;   		// Clear sign-extension 
  t6 = (t5 * 4) + t6;   
		/* Fetch the key */
  t5 = *(s32 *)t6;
		/* Fetch value */
  t2 = *(s32 *)(t6 + 4);
		/* Compare */
  t7 = (s32)t1 - (s32)t5;
  if (t7 != 0)   		// Trap on miss 
    goto g29235;
  t1 = (u32)t2;   		// Extract the pointer, and indirect 
  goto g29225;   		// This is another memory read tailcall. 

g29235:
  if (_trace) printf("g29235:\n");
  goto dbcachemisstrap;
#endif

g29231:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

g29217:
  if (_trace) printf("g29217:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t1 = *(s32 *)t5;
		/* Read from stack cache */
  t2 = *(s32 *)(t5 + 4);
  goto g29216;   

g29219:
  if (_trace) printf("g29219:\n");
  if ((t7 & 1) == 0)   
    goto g29218;
  arg4 = (u32)t1;   		// Do the indirect thing 
  goto g29215;   

g29218:
  if (_trace) printf("g29218:\n");
		/* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  t7 = t2 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
		/* Get the memory action */
  t8 = *(s32 *)t7;

g29221:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceRef */
  /* End of Halfword operand from stack instruction - DoInstanceRef */
/* start DoInstanceSet */

  /* Halfword operand from stack instruction - DoInstanceSet */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceset:
  if (_trace) printf("doinstanceset:\n");
#ifdef TRACING
#endif

DoInstanceSetIM:
  if (_trace) printf("DoInstanceSetIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoinstanceset;   
#ifdef TRACING
#endif

DoInstanceSetSP:
  if (_trace) printf("DoInstanceSetSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceset;   
#endif

DoInstanceSetLP:
  if (_trace) printf("DoInstanceSetLP:\n");
#ifdef TRACING
  goto headdoinstanceset;   
#endif

DoInstanceSetFP:
  if (_trace) printf("DoInstanceSetFP:\n");

headdoinstanceset:
  if (_trace) printf("headdoinstanceset:\n");
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
		/* Get the operand */
  arg1 = *(u64 *)arg1;

begindoinstanceset:
  if (_trace) printf("begindoinstanceset:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;   
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;   
  t11 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;
  t1 = t1 & 60;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto ivrefbadinst3;
  t1 = arg2 - Type_Fixnum;
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto ivrefbadoffset;
  /* Memory Read Internal */

g29249:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);   
  t2 = LDQ_U(t7);   
		/* Stack cache offset */
  t5 = arg4 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto g29251;

g29250:
  t7 = zero + 64;   
  t8 = t8 >> (t2 & 63);
  t7 = t7 >> (t2 & 63);
  t1 = (u32)t1;   
  if (t8 & 1)   
    goto g29253;

g29258:
  t1 = t1 - 1;
  /* Memory Read Internal */

g29259:
  t7 = t1 + ivory;
  t2 = (t7 * 4);   
  t4 = LDQ_U(t7);   
		/* Stack cache offset */
  t5 = t1 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto g29261;

g29260:
  t7 = zero + 240;   
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  if (t8 & 1)   
    goto g29263;

g29270:
  t5 = t4 - Type_Fixnum;
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto ivrefbadoffset;
  if ((s64)arg1 < 0)   		// J. if offset <0 
    goto ivrefbadoffset;
  t4 = arg1 - t2;
  if ((s64)t4 >= 0)   		// J. if offset out of bounds 
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
		/* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;   
  t11 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g29271:
  t7 = arg5 + ivory;
  t4 = (t7 * 4);   
  t3 = LDQ_U(t7);   
		/* Stack cache offset */
  t5 = arg5 - t11;
  t8 = *(u64 *)&(processor->datawrite_mask);
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t4 = *(s32 *)t4;
  t3 = (u8)(t3 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto g29273;

g29272:
  t7 = zero + 240;   
  t8 = t8 >> (t3 & 63);
  t7 = t7 >> (t3 & 63);
  if (t8 & 1)   
    goto g29275;

g29281:
  /* Merge cdr-code */
  t4 = t2 & 63;
  t3 = t3 & 192;
  t3 = t3 | t4;
  t5 = arg5 + ivory;
  t4 = (t5 * 4);   
  t7 = LDQ_U(t5);   
		/* Stack cache offset */
  t6 = arg5 - t11;
  t8 = ((u64)t6 < (u64)t12) ? 1 : 0;   		// In range? 
  t6 = (t3 & 0xff) << ((t5&7)*8);   
  t7 = t7 & ~(0xffL << (t5&7)*8);

g29283:
  if (_trace) printf("g29283:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);   
  *(u32 *)t4 = t1;
  if (t8 != 0)   		// J. if in cache 
    goto g29282;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

ivrefbadinst3:
  if (_trace) printf("ivrefbadinst3:\n");
  arg5 = 0;
  arg2 = 4;
  goto illegaloperand;

g29282:
  if (_trace) printf("g29282:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
		/* Stack cache offset */
  t6 = arg5 - t11;
		/* reconstruct SCA */
  t5 = (t6 * 8) + t5;
		/* Store in stack */
  *(u32 *)t5 = t1;
		/* write the stack cache */
  *(u32 *)(t5 + 4) = t3;
  goto NEXTINSTRUCTION;   

g29273:
  if (_trace) printf("g29273:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t4 = *(s32 *)t5;
		/* Read from stack cache */
  t3 = *(s32 *)(t5 + 4);
  goto g29272;   

g29275:
  if (_trace) printf("g29275:\n");
  if ((t7 & 1) == 0)   
    goto g29274;
  arg5 = (u32)t4;   		// Do the indirect thing 
  goto g29271;   

g29274:
  if (_trace) printf("g29274:\n");
		/* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  t7 = t3 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg5;
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
		/* Get the memory action */
  t8 = *(s32 *)t7;
#ifndef MINIMA

g29278:
#endif
#ifdef MINIMA

g29278:
  if (_trace) printf("g29278:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0) 
    goto g29277;
  t5 = arg5 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  t5 = t5 & t6;		// Hash index 
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  t5 = (u32)t5;   		// Clear sign-extension 
  t6 = (t5 * 4) + t6;   
		/* Fetch the key */
  t5 = *(s32 *)t6;
		/* Fetch value */
  t4 = *(s32 *)(t6 + 4);
		/* Compare */
  t7 = (s32)arg5 - (s32)t5;
  if (t7 != 0)   		// Trap on miss 
    goto g29280;
  arg5 = (u32)t4;   		// Extract the pointer, and indirect 
  goto g29271;   		// This is another memory read tailcall. 

g29280:
  if (_trace) printf("g29280:\n");
  goto dbcachemisstrap;
#endif

g29277:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 1;
  goto performmemoryaction;

g29261:
  if (_trace) printf("g29261:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t2 = *(s32 *)t5;
		/* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g29260;   

g29263:
  if (_trace) printf("g29263:\n");
  if ((t7 & 1) == 0)   
    goto g29262;
  t1 = (u32)t2;   		// Do the indirect thing 
  goto g29259;   

g29262:
  if (_trace) printf("g29262:\n");
		/* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
		/* Get the memory action */
  t8 = *(s32 *)t7;

g29267:
  if (_trace) printf("g29267:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0) 
    goto g29266;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g29270;   
#ifndef MINIMA

g29266:
#endif
#ifdef MINIMA

g29266:
  if (_trace) printf("g29266:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0) 
    goto g29265;
  t5 = t1 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  t5 = t5 & t6;		// Hash index 
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  t5 = (u32)t5;   		// Clear sign-extension 
  t6 = (t5 * 4) + t6;   
		/* Fetch the key */
  t5 = *(s32 *)t6;
		/* Fetch value */
  t2 = *(s32 *)(t6 + 4);
		/* Compare */
  t7 = (s32)t1 - (s32)t5;
  if (t7 != 0)   		// Trap on miss 
    goto g29269;
  t1 = (u32)t2;   		// Extract the pointer, and indirect 
  goto g29259;   		// This is another memory read tailcall. 

g29269:
  if (_trace) printf("g29269:\n");
  goto dbcachemisstrap;
#endif

g29265:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

g29251:
  if (_trace) printf("g29251:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t1 = *(s32 *)t5;
		/* Read from stack cache */
  t2 = *(s32 *)(t5 + 4);
  goto g29250;   

g29253:
  if (_trace) printf("g29253:\n");
  if ((t7 & 1) == 0)   
    goto g29252;
  arg4 = (u32)t1;   		// Do the indirect thing 
  goto g29249;   

g29252:
  if (_trace) printf("g29252:\n");
		/* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  t7 = t2 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
		/* Get the memory action */
  t8 = *(s32 *)t7;

g29255:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceSet */
  /* End of Halfword operand from stack instruction - DoInstanceSet */
/* start DoInstanceLoc */

  /* Halfword operand from stack instruction - DoInstanceLoc */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceloc:
  if (_trace) printf("doinstanceloc:\n");
#ifdef TRACING
#endif

DoInstanceLocIM:
  if (_trace) printf("DoInstanceLocIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoinstanceloc;   
#ifdef TRACING
#endif

DoInstanceLocSP:
  if (_trace) printf("DoInstanceLocSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceloc;   
#endif

DoInstanceLocLP:
  if (_trace) printf("DoInstanceLocLP:\n");
#ifdef TRACING
  goto headdoinstanceloc;   
#endif

DoInstanceLocFP:
  if (_trace) printf("DoInstanceLocFP:\n");

headdoinstanceloc:
  if (_trace) printf("headdoinstanceloc:\n");
		/* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
		/* Get the operand */
  arg1 = *(u64 *)arg1;

begindoinstanceloc:
  if (_trace) printf("begindoinstanceloc:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;   
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;   
  t11 = *(u64 *)&(processor->stackcachebasevma);
		/* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;
  t1 = t1 & 60;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto ivrefbadinst;
  t1 = arg2 - Type_Fixnum;
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto ivrefbadoffset;
  /* Memory Read Internal */

g29284:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);   
  t2 = LDQ_U(t7);   
		/* Stack cache offset */
  t5 = arg4 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto g29286;

g29285:
  t7 = zero + 64;   
  t8 = t8 >> (t2 & 63);
  t7 = t7 >> (t2 & 63);
  t1 = (u32)t1;   
  if (t8 & 1)   
    goto g29288;

g29293:
  t1 = t1 - 1;
  /* Memory Read Internal */

g29294:
  t7 = t1 + ivory;
  t2 = (t7 * 4);   
  t4 = LDQ_U(t7);   
		/* Stack cache offset */
  t5 = t1 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto g29296;

g29295:
  t7 = zero + 240;   
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  if (t8 & 1)   
    goto g29298;

g29305:
  t5 = t4 - Type_Fixnum;
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto ivrefbadoffset;
  if ((s64)arg1 < 0)   		// J. if offset <0 
    goto ivrefbadoffset;
  t4 = arg1 - t2;
  if ((s64)t4 >= 0)   		// J. if offset out of bounds 
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  t7 = Type_Locative;
  *(u32 *)iSP = arg5;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t7;
  goto NEXTINSTRUCTION;   

ivrefbadinst:
  if (_trace) printf("ivrefbadinst:\n");
  arg5 = 0;
  arg2 = 3;
  goto illegaloperand;

ivrefbadoffset:
  if (_trace) printf("ivrefbadoffset:\n");
  arg5 = 0;
  arg2 = 49;
  goto illegaloperand;

g29296:
  if (_trace) printf("g29296:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t2 = *(s32 *)t5;
		/* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g29295;   

g29298:
  if (_trace) printf("g29298:\n");
  if ((t7 & 1) == 0)   
    goto g29297;
  t1 = (u32)t2;   		// Do the indirect thing 
  goto g29294;   

g29297:
  if (_trace) printf("g29297:\n");
		/* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
		/* Get the memory action */
  t8 = *(s32 *)t7;

g29302:
  if (_trace) printf("g29302:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0) 
    goto g29301;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g29305;   
#ifndef MINIMA

g29301:
#endif
#ifdef MINIMA

g29301:
  if (_trace) printf("g29301:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0) 
    goto g29300;
  t5 = t1 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  t5 = t5 & t6;		// Hash index 
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  t5 = (u32)t5;   		// Clear sign-extension 
  t6 = (t5 * 4) + t6;   
		/* Fetch the key */
  t5 = *(s32 *)t6;
		/* Fetch value */
  t2 = *(s32 *)(t6 + 4);
		/* Compare */
  t7 = (s32)t1 - (s32)t5;
  if (t7 != 0)   		// Trap on miss 
    goto g29304;
  t1 = (u32)t2;   		// Extract the pointer, and indirect 
  goto g29294;   		// This is another memory read tailcall. 

g29304:
  if (_trace) printf("g29304:\n");
  goto dbcachemisstrap;
#endif

g29300:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

g29286:
  if (_trace) printf("g29286:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
		/* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t1 = *(s32 *)t5;
		/* Read from stack cache */
  t2 = *(s32 *)(t5 + 4);
  goto g29285;   

g29288:
  if (_trace) printf("g29288:\n");
  if ((t7 & 1) == 0)   
    goto g29287;
  arg4 = (u32)t1;   		// Do the indirect thing 
  goto g29284;   

g29287:
  if (_trace) printf("g29287:\n");
		/* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  t7 = t2 & 63;		// Discard the CDR code 
		/* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
		/* Get the memory action */
  t8 = *(s32 *)t7;

g29290:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceLoc */
  /* End of Halfword operand from stack instruction - DoInstanceLoc */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifuninst.as */
