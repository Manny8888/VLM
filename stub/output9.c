/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifuninst.as
 ************************************************************************/

  /* Instance variable accessors.. */
/* start DoPopInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPopInstanceVariable */

dopopinstancevariable:
  if (_trace) printf("dopopinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPopInstanceVariableIM:
  if (_trace) printf("DoPopInstanceVariableIM:\n");

DoPopInstanceVariableSP:
  if (_trace) printf("DoPopInstanceVariableSP:\n");

DoPopInstanceVariableLP:
  if (_trace) printf("DoPopInstanceVariableLP:\n");

DoPopInstanceVariableFP:
  if (_trace) printf("DoPopInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Instance Variable Mapped */
  arg1 = *(s32 *)(iFP + 16);   		// Map 
  t1 = *(s32 *)(iFP + 20);   
  arg1 = (u32)arg1;   
  t4 = t1 - Type_Array;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto ivbadmap;
  /* Memory Read Internal */

vma-memory-read9768:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->header_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read9770;

vma-memory-read9769:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  if (t10 & 1)   
    goto vma-memory-read9772;

vma-memory-read9777:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;   
  if ((s64)t5 <= 0)  		// J. if mapping-table-index-out-of-bounds 
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

vma-memory-read9778:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read9780;

vma-memory-read9779:
  t9 = zero + 240;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto vma-memory-read9782;

vma-memory-read9789:
  t3 = t2;
  t6 = t1 - Type_Fixnum;   
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto popiviex;
  arg1 = *(s32 *)(iFP + 24);   		// Self 
  t6 = *(s32 *)(iFP + 28);   
  arg1 = (u32)arg1;   
  t5 = t6 - Type_Instance;   
  t5 = t5 & 60;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto ivbadinst;
  t5 = t6 & 192;		// Unshifted cdr code 
  t5 = t5 - 64;   		// Check for CDR code 1 
  if (t5 != 0)   		// J. if CDR code is not 1 
    goto locate-instance0variable-mapped9767;

locate-instance0variable-mapped9766:
  if (_trace) printf("locate-instance0variable-mapped9766:\n");
  arg1 = arg1 + t3;

locate-instance0variable-mapped9765:
  if (_trace) printf("locate-instance0variable-mapped9765:\n");
  t1 = *(s32 *)iSP;   
  t2 = *(s32 *)(iSP + 4);   
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = (u32)t1;   
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read9790:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = arg1 - arg5;   		// Stack cache offset 
  t9 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read9792;

vma-memory-read9791:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t9 & 1)   
    goto vma-memory-read9794;

vma-memory-read9800:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment9802:
  if (_trace) printf("force-alignment9802:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t1;
  if (t9 != 0)   		// J. if in cache 
    goto vma-memory-write9801;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

popiviex:
  if (_trace) printf("popiviex:\n");
  t1 = zero + 8;   
  /* SetTag. */
  t1 = t1 << 32;   
  t1 = arg2 | t1;
  arg6 = t2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

vma-memory-write9801:
  if (_trace) printf("vma-memory-write9801:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = t1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

vma-memory-read9792:
  if (_trace) printf("vma-memory-read9792:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read9791;   

vma-memory-read9794:
  if (_trace) printf("vma-memory-read9794:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read9793;
  arg1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read9790;   

vma-memory-read9793:
  if (_trace) printf("vma-memory-read9793:\n");
  t9 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
  t9 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read9797:

vma-memory-read9796:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

vma-memory-read9780:
  if (_trace) printf("vma-memory-read9780:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read9779;   

vma-memory-read9782:
  if (_trace) printf("vma-memory-read9782:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read9781;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read9778;   

vma-memory-read9781:
  if (_trace) printf("vma-memory-read9781:\n");
  t10 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read9786:
  if (_trace) printf("vma-memory-read9786:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0) 
    goto vma-memory-read9785;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto vma-memory-read9789;   

vma-memory-read9785:

vma-memory-read9784:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read9770:
  if (_trace) printf("vma-memory-read9770:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read9769;   

vma-memory-read9772:
  if (_trace) printf("vma-memory-read9772:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read9771;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read9768;   

vma-memory-read9771:
  if (_trace) printf("vma-memory-read9771:\n");
  t10 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read9774:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

locate-instance0variable-mapped9767:
  if (_trace) printf("locate-instance0variable-mapped9767:\n");
  t5 = arg1;
  /* Memory Read Internal */

vma-memory-read9803:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->header_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read9805;

vma-memory-read9804:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto vma-memory-read9807;

vma-memory-read9812:
  t5 = t5 - arg1;   
  if (t5 != 0)   
    goto locate-instance0variable-mapped9766;
  /* TagType. */
  t6 = t6 & 63;
  t6 = t6 | 64;		// Set CDR code to 1 
		/* Update self */
  *(u32 *)(iFP + 24) = arg1;
		/* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto locate-instance0variable-mapped9766;   

vma-memory-read9805:
  if (_trace) printf("vma-memory-read9805:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read9804;   

vma-memory-read9807:
  if (_trace) printf("vma-memory-read9807:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read9806;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read9803;   

vma-memory-read9806:
  if (_trace) printf("vma-memory-read9806:\n");
  t10 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read9809:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoPopInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPopInstanceVariable */
/* start DoMovemInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoMovemInstanceVariable */

domoveminstancevariable:
  if (_trace) printf("domoveminstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoMovemInstanceVariableIM:
  if (_trace) printf("DoMovemInstanceVariableIM:\n");

DoMovemInstanceVariableSP:
  if (_trace) printf("DoMovemInstanceVariableSP:\n");

DoMovemInstanceVariableLP:
  if (_trace) printf("DoMovemInstanceVariableLP:\n");

DoMovemInstanceVariableFP:
  if (_trace) printf("DoMovemInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Instance Variable Mapped */
  arg1 = *(s32 *)(iFP + 16);   		// Map 
  t1 = *(s32 *)(iFP + 20);   
  arg1 = (u32)arg1;   
  t4 = t1 - Type_Array;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto ivbadmap;
  /* Memory Read Internal */

vma-memory-read9816:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->header_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read9818;

vma-memory-read9817:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  if (t10 & 1)   
    goto vma-memory-read9820;

vma-memory-read9825:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;   
  if ((s64)t5 <= 0)  		// J. if mapping-table-index-out-of-bounds 
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

vma-memory-read9826:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read9828;

vma-memory-read9827:
  t9 = zero + 240;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto vma-memory-read9830;

vma-memory-read9837:
  t3 = t2;
  t6 = t1 - Type_Fixnum;   
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto movemiviex;
  arg1 = *(s32 *)(iFP + 24);   		// Self 
  t6 = *(s32 *)(iFP + 28);   
  arg1 = (u32)arg1;   
  t5 = t6 - Type_Instance;   
  t5 = t5 & 60;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto ivbadinst;
  t5 = t6 & 192;		// Unshifted cdr code 
  t5 = t5 - 64;   		// Check for CDR code 1 
  if (t5 != 0)   		// J. if CDR code is not 1 
    goto locate-instance0variable-mapped9815;

locate-instance0variable-mapped9814:
  if (_trace) printf("locate-instance0variable-mapped9814:\n");
  arg1 = arg1 + t3;

locate-instance0variable-mapped9813:
  if (_trace) printf("locate-instance0variable-mapped9813:\n");
  t1 = *(s32 *)iSP;   
  t2 = *(s32 *)(iSP + 4);   
  t1 = (u32)t1;   
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read9838:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = arg1 - arg5;   		// Stack cache offset 
  t9 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read9840;

vma-memory-read9839:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t9 & 1)   
    goto vma-memory-read9842;

vma-memory-read9848:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment9850:
  if (_trace) printf("force-alignment9850:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t1;
  if (t9 != 0)   		// J. if in cache 
    goto vma-memory-write9849;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

movemiviex:
  if (_trace) printf("movemiviex:\n");
  t1 = zero + 8;   
  /* SetTag. */
  t1 = t1 << 32;   
  t1 = arg2 | t1;
  arg6 = t2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 2;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

vma-memory-write9849:
  if (_trace) printf("vma-memory-write9849:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = t1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

vma-memory-read9840:
  if (_trace) printf("vma-memory-read9840:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read9839;   

vma-memory-read9842:
  if (_trace) printf("vma-memory-read9842:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read9841;
  arg1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read9838;   

vma-memory-read9841:
  if (_trace) printf("vma-memory-read9841:\n");
  t9 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
  t9 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read9845:

vma-memory-read9844:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

vma-memory-read9828:
  if (_trace) printf("vma-memory-read9828:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read9827;   

vma-memory-read9830:
  if (_trace) printf("vma-memory-read9830:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read9829;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read9826;   

vma-memory-read9829:
  if (_trace) printf("vma-memory-read9829:\n");
  t10 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read9834:
  if (_trace) printf("vma-memory-read9834:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0) 
    goto vma-memory-read9833;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto vma-memory-read9837;   

vma-memory-read9833:

vma-memory-read9832:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read9818:
  if (_trace) printf("vma-memory-read9818:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read9817;   

vma-memory-read9820:
  if (_trace) printf("vma-memory-read9820:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read9819;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read9816;   

vma-memory-read9819:
  if (_trace) printf("vma-memory-read9819:\n");
  t10 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read9822:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

locate-instance0variable-mapped9815:
  if (_trace) printf("locate-instance0variable-mapped9815:\n");
  t5 = arg1;
  /* Memory Read Internal */

vma-memory-read9851:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->header_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read9853;

vma-memory-read9852:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto vma-memory-read9855;

vma-memory-read9860:
  t5 = t5 - arg1;   
  if (t5 != 0)   
    goto locate-instance0variable-mapped9814;
  /* TagType. */
  t6 = t6 & 63;
  t6 = t6 | 64;		// Set CDR code to 1 
		/* Update self */
  *(u32 *)(iFP + 24) = arg1;
		/* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto locate-instance0variable-mapped9814;   

vma-memory-read9853:
  if (_trace) printf("vma-memory-read9853:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read9852;   

vma-memory-read9855:
  if (_trace) printf("vma-memory-read9855:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read9854;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read9851;   

vma-memory-read9854:
  if (_trace) printf("vma-memory-read9854:\n");
  t10 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read9857:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoMovemInstanceVariable */
  /* End of Halfword operand from stack instruction - DoMovemInstanceVariable */
/* start DoPushAddressInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariable */

dopushaddressinstancevariable:
  if (_trace) printf("dopushaddressinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushAddressInstanceVariableIM:
  if (_trace) printf("DoPushAddressInstanceVariableIM:\n");

DoPushAddressInstanceVariableSP:
  if (_trace) printf("DoPushAddressInstanceVariableSP:\n");

DoPushAddressInstanceVariableLP:
  if (_trace) printf("DoPushAddressInstanceVariableLP:\n");

DoPushAddressInstanceVariableFP:
  if (_trace) printf("DoPushAddressInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Instance Variable Mapped */
  arg1 = *(s32 *)(iFP + 16);   		// Map 
  t1 = *(s32 *)(iFP + 20);   
  arg1 = (u32)arg1;   
  t4 = t1 - Type_Array;   
  t4 = t4 & 63;		// Strip CDR code 
  if (t4 != 0)   
    goto ivbadmap;
  /* Memory Read Internal */

vma-memory-read9864:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->header_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read9866;

vma-memory-read9865:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  if (t10 & 1)   
    goto vma-memory-read9868;

vma-memory-read9873:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;   
  if ((s64)t5 <= 0)  		// J. if mapping-table-index-out-of-bounds 
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

vma-memory-read9874:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->dataread_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read9876;

vma-memory-read9875:
  t9 = zero + 240;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto vma-memory-read9878;

vma-memory-read9885:
  t3 = t2;
  t6 = t1 - Type_Fixnum;   
  t6 = t6 & 63;		// Strip CDR code 
  if (t6 != 0)   
    goto pushadiviex;
  arg1 = *(s32 *)(iFP + 24);   		// Self 
  t6 = *(s32 *)(iFP + 28);   
  arg1 = (u32)arg1;   
  t5 = t6 - Type_Instance;   
  t5 = t5 & 60;		// Strip CDR code, low bits 
  if (t5 != 0)   
    goto ivbadinst;
  t5 = t6 & 192;		// Unshifted cdr code 
  t5 = t5 - 64;   		// Check for CDR code 1 
  if (t5 != 0)   		// J. if CDR code is not 1 
    goto locate-instance0variable-mapped9863;

locate-instance0variable-mapped9862:
  if (_trace) printf("locate-instance0variable-mapped9862:\n");
  arg1 = arg1 + t3;

locate-instance0variable-mapped9861:
  if (_trace) printf("locate-instance0variable-mapped9861:\n");
  t7 = Type_Locative;
  *(u32 *)(iSP + 8) = arg1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

pushadiviex:
  if (_trace) printf("pushadiviex:\n");
  t1 = zero + 8;   
  /* SetTag. */
  t1 = t1 << 32;   
  t1 = arg2 | t1;
  arg6 = t2;		// arg6 = tag to dispatch on 
  arg3 = 0;		// arg3 = stackp 
  arg1 = 1;		// arg1 = instruction arity 
  arg4 = 0;		// arg4 = arithmeticp 
  goto exception;

vma-memory-read9876:
  if (_trace) printf("vma-memory-read9876:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read9875;   

vma-memory-read9878:
  if (_trace) printf("vma-memory-read9878:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read9877;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read9874;   

vma-memory-read9877:
  if (_trace) printf("vma-memory-read9877:\n");
  t10 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read9882:
  if (_trace) printf("vma-memory-read9882:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0) 
    goto vma-memory-read9881;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto vma-memory-read9885;   

vma-memory-read9881:

vma-memory-read9880:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read9866:
  if (_trace) printf("vma-memory-read9866:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read9865;   

vma-memory-read9868:
  if (_trace) printf("vma-memory-read9868:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read9867;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read9864;   

vma-memory-read9867:
  if (_trace) printf("vma-memory-read9867:\n");
  t10 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read9870:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

locate-instance0variable-mapped9863:
  if (_trace) printf("locate-instance0variable-mapped9863:\n");
  t5 = arg1;
  /* Memory Read Internal */

vma-memory-read9886:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);   
  t1 = LDQ_U(t9);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t10 = *(u64 *)&(processor->header_mask);   
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t1 = (u8)(t1 >> ((t9&7)*8));   
  if (t8 != 0)   
    goto vma-memory-read9888;

vma-memory-read9887:
  t9 = zero + 64;   
  t10 = t10 >> (t1 & 63);   
  t9 = t9 >> (t1 & 63);   
  t2 = (u32)t2;   
  if (t10 & 1)   
    goto vma-memory-read9890;

vma-memory-read9895:
  t5 = t5 - arg1;   
  if (t5 != 0)   
    goto locate-instance0variable-mapped9862;
  /* TagType. */
  t6 = t6 & 63;
  t6 = t6 | 64;		// Set CDR code to 1 
		/* Update self */
  *(u32 *)(iFP + 24) = arg1;
		/* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto locate-instance0variable-mapped9862;   

vma-memory-read9888:
  if (_trace) printf("vma-memory-read9888:\n");
  t8 = *(u64 *)&(processor->stackcachedata);   
  t7 = (t7 * 8) + t8;  		// reconstruct SCA 
  t2 = *(s32 *)t7;   
  t1 = *(s32 *)(t7 + 4);   		// Read from stack cache 
  goto vma-memory-read9887;   

vma-memory-read9890:
  if (_trace) printf("vma-memory-read9890:\n");
  if ((t9 & 1) == 0)   
    goto vma-memory-read9889;
  arg1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read9886;   

vma-memory-read9889:
  if (_trace) printf("vma-memory-read9889:\n");
  t10 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t9 = t1 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t9 = (t9 * 4) + t10;   		// Adjust for a longword load 
  t10 = *(s32 *)t9;   		// Get the memory action 

vma-memory-read9892:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoPushAddressInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPushAddressInstanceVariable */
/* start DoPushInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPushInstanceVariableOrdered */

dopushinstancevariableordered:
  if (_trace) printf("dopushinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushInstanceVariableOrderedIM:
  if (_trace) printf("DoPushInstanceVariableOrderedIM:\n");

DoPushInstanceVariableOrderedSP:
  if (_trace) printf("DoPushInstanceVariableOrderedSP:\n");

DoPushInstanceVariableOrderedLP:
  if (_trace) printf("DoPushInstanceVariableOrderedLP:\n");

DoPushInstanceVariableOrderedFP:
  if (_trace) printf("DoPushInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Instance Variable Unmapped */
  t2 = *(s32 *)(iFP + 24);   		// self 
  t1 = *(s32 *)(iFP + 28);   
  t2 = (u32)t2;   
  t3 = t1 - Type_Instance;   
  t3 = t3 & 60;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto ivbadinst;
  arg1 = t2 + arg2;
  /* Memory Read Internal */

vma-memory-read9896:
  t6 = arg1 + ivory;
  t1 = (t6 * 4);   
  t2 = LDQ_U(t6);   
  t4 = arg1 - arg5;   		// Stack cache offset 
  t7 = *(u64 *)&(processor->dataread_mask);   
  t5 = ((u64)t4 < (u64)arg6) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;   
  t2 = (u8)(t2 >> ((t6&7)*8));   
  if (t5 != 0)   
    goto vma-memory-read9898;

vma-memory-read9897:
  t6 = zero + 240;   
  t7 = t7 >> (t2 & 63);   
  t6 = t6 >> (t2 & 63);   
  if (t7 & 1)   
    goto vma-memory-read9900;

vma-memory-read9907:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t7 = t2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;   

vma-memory-read9898:
  if (_trace) printf("vma-memory-read9898:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t4 = (t4 * 8) + t5;  		// reconstruct SCA 
  t1 = *(s32 *)t4;   
  t2 = *(s32 *)(t4 + 4);   		// Read from stack cache 
  goto vma-memory-read9897;   

vma-memory-read9900:
  if (_trace) printf("vma-memory-read9900:\n");
  if ((t6 & 1) == 0)   
    goto vma-memory-read9899;
  arg1 = (u32)t1;   		// Do the indirect thing 
  goto vma-memory-read9896;   

vma-memory-read9899:
  if (_trace) printf("vma-memory-read9899:\n");
  t7 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t6 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t6 = (t6 * 4) + t7;   		// Adjust for a longword load 
  t7 = *(s32 *)t6;   		// Get the memory action 

vma-memory-read9904:
  if (_trace) printf("vma-memory-read9904:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0) 
    goto vma-memory-read9903;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto vma-memory-read9907;   

vma-memory-read9903:

vma-memory-read9902:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

/* end DoPushInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPushInstanceVariableOrdered */
/* start DoPopInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPopInstanceVariableOrdered */

dopopinstancevariableordered:
  if (_trace) printf("dopopinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPopInstanceVariableOrderedIM:
  if (_trace) printf("DoPopInstanceVariableOrderedIM:\n");

DoPopInstanceVariableOrderedSP:
  if (_trace) printf("DoPopInstanceVariableOrderedSP:\n");

DoPopInstanceVariableOrderedLP:
  if (_trace) printf("DoPopInstanceVariableOrderedLP:\n");

DoPopInstanceVariableOrderedFP:
  if (_trace) printf("DoPopInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Instance Variable Unmapped */
  t2 = *(s32 *)(iFP + 24);   		// self 
  t1 = *(s32 *)(iFP + 28);   
  t2 = (u32)t2;   
  t3 = t1 - Type_Instance;   
  t3 = t3 & 60;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto ivbadinst;
  arg1 = t2 + arg2;
  t1 = *(s32 *)iSP;   
  t2 = *(s32 *)(iSP + 4);   
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = (u32)t1;   
  /* Memory Read Internal */

vma-memory-read9908:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = arg1 - arg5;   		// Stack cache offset 
  t9 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read9910;

vma-memory-read9909:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t9 & 1)   
    goto vma-memory-read9912;

vma-memory-read9918:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment9920:
  if (_trace) printf("force-alignment9920:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t1;
  if (t9 != 0)   		// J. if in cache 
    goto vma-memory-write9919;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

vma-memory-write9919:
  if (_trace) printf("vma-memory-write9919:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = t1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

vma-memory-read9910:
  if (_trace) printf("vma-memory-read9910:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read9909;   

vma-memory-read9912:
  if (_trace) printf("vma-memory-read9912:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read9911;
  arg1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read9908;   

vma-memory-read9911:
  if (_trace) printf("vma-memory-read9911:\n");
  t9 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
  t9 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read9915:

vma-memory-read9914:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoPopInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPopInstanceVariableOrdered */
/* start DoMovemInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoMovemInstanceVariableOrdered */

domoveminstancevariableordered:
  if (_trace) printf("domoveminstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoMovemInstanceVariableOrderedIM:
  if (_trace) printf("DoMovemInstanceVariableOrderedIM:\n");

DoMovemInstanceVariableOrderedSP:
  if (_trace) printf("DoMovemInstanceVariableOrderedSP:\n");

DoMovemInstanceVariableOrderedLP:
  if (_trace) printf("DoMovemInstanceVariableOrderedLP:\n");

DoMovemInstanceVariableOrderedFP:
  if (_trace) printf("DoMovemInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Instance Variable Unmapped */
  t2 = *(s32 *)(iFP + 24);   		// self 
  t1 = *(s32 *)(iFP + 28);   
  t2 = (u32)t2;   
  t3 = t1 - Type_Instance;   
  t3 = t3 & 60;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto ivbadinst;
  arg1 = t2 + arg2;
  t1 = *(s32 *)iSP;   
  t2 = *(s32 *)(iSP + 4);   
  t1 = (u32)t1;   
  /* Memory Read Internal */

vma-memory-read9921:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = arg1 - arg5;   		// Stack cache offset 
  t9 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read9923;

vma-memory-read9922:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t9 & 1)   
    goto vma-memory-read9925;

vma-memory-read9931:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment9933:
  if (_trace) printf("force-alignment9933:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t1;
  if (t9 != 0)   		// J. if in cache 
    goto vma-memory-write9932;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

vma-memory-write9932:
  if (_trace) printf("vma-memory-write9932:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = arg1 - arg5;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = t1;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

vma-memory-read9923:
  if (_trace) printf("vma-memory-read9923:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read9922;   

vma-memory-read9925:
  if (_trace) printf("vma-memory-read9925:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read9924;
  arg1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read9921;   

vma-memory-read9924:
  if (_trace) printf("vma-memory-read9924:\n");
  t9 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
  t9 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read9928:

vma-memory-read9927:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoMovemInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoMovemInstanceVariableOrdered */
/* start DoPushAddressInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariableOrdered */

dopushaddressinstancevariableordered:
  if (_trace) printf("dopushaddressinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushAddressInstanceVariableOrderedIM:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedIM:\n");

DoPushAddressInstanceVariableOrderedSP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedSP:\n");

DoPushAddressInstanceVariableOrderedLP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedLP:\n");

DoPushAddressInstanceVariableOrderedFP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));   
  /* arg1 has operand preloaded. */
  /* Locate Instance Variable Unmapped */
  t2 = *(s32 *)(iFP + 24);   		// self 
  t1 = *(s32 *)(iFP + 28);   
  t2 = (u32)t2;   
  t3 = t1 - Type_Instance;   
  t3 = t3 & 60;		// Strip CDR code, low bits 
  if (t3 != 0)   
    goto ivbadinst;
  arg1 = t2 + arg2;
  t7 = Type_Locative;
  *(u32 *)(iSP + 8) = arg1;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;   

ivbadmap:
  if (_trace) printf("ivbadmap:\n");
  arg5 = 0;
  arg2 = 68;
  goto illegaloperand;

ivbadindex:
  if (_trace) printf("ivbadindex:\n");
  arg5 = 0;
  arg2 = 53;
  goto illegaloperand;

ivbadinst:
  if (_trace) printf("ivbadinst:\n");
  arg5 = 0;
  arg2 = 69;
  goto illegaloperand;

/* end DoPushAddressInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPushAddressInstanceVariableOrdered */
/* start DoInstanceRef */

  /* Halfword operand from stack instruction - DoInstanceRef */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceref:
  if (_trace) printf("doinstanceref:\n");
#ifdef TRACING
#endif

DoInstanceRefIM:
  if (_trace) printf("DoInstanceRefIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoinstanceref;   
#ifdef TRACING
#endif

DoInstanceRefSP:
  if (_trace) printf("DoInstanceRefSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceref;   
#endif

DoInstanceRefLP:
  if (_trace) printf("DoInstanceRefLP:\n");
#ifdef TRACING
  goto headdoinstanceref;   
#endif

DoInstanceRefFP:
  if (_trace) printf("DoInstanceRefFP:\n");

headdoinstanceref:
  if (_trace) printf("headdoinstanceref:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoinstanceref:
  if (_trace) printf("begindoinstanceref:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   
  arg3 = *(s32 *)(iSP + 4);   
  arg4 = (u32)arg4;   
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;   
  t1 = t1 & 60;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto ivrefbadinst;
  t1 = arg2 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto ivrefbadoffset;
  /* Memory Read Internal */

vma-memory-read9934:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);   
  t2 = LDQ_U(t7);   
  t5 = arg4 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;   
  t2 = (u8)(t2 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9936;

vma-memory-read9935:
  t7 = zero + 64;   
  t8 = t8 >> (t2 & 63);   
  t7 = t7 >> (t2 & 63);   
  t1 = (u32)t1;   
  if (t8 & 1)   
    goto vma-memory-read9938;

vma-memory-read9943:
  t1 = t1 - 1;   
  /* Memory Read Internal */

vma-memory-read9944:
  t7 = t1 + ivory;
  t2 = (t7 * 4);   
  t4 = LDQ_U(t7);   
  t5 = t1 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9946;

vma-memory-read9945:
  t7 = zero + 240;   
  t8 = t8 >> (t4 & 63);   
  t7 = t7 >> (t4 & 63);   
  if (t8 & 1)   
    goto vma-memory-read9948;

vma-memory-read9955:
  t5 = t4 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto ivrefbadoffset;
  if ((s64)arg1 < 0)   		// J. if offset <0 
    goto ivrefbadoffset;
  t4 = arg1 - t2;   
  if ((s64)t4 >= 0)   		// J. if offset out of bounds 
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  /* Memory Read Internal */

vma-memory-read9956:
  t4 = *(u64 *)&(processor->stackcachebasevma);   		// Base of stack cache 
  t6 = arg5 + ivory;
  t5 = *(s32 *)&processor->scovlimit;   
  t1 = (t6 * 4);   
  t2 = LDQ_U(t6);   
  t4 = arg5 - t4;   		// Stack cache offset 
  t7 = *(u64 *)&(processor->dataread_mask);   
  t5 = ((u64)t4 < (u64)t5) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;   
  t2 = (u8)(t2 >> ((t6&7)*8));   
  if (t5 != 0)   
    goto vma-memory-read9958;

vma-memory-read9957:
  t6 = zero + 240;   
  t7 = t7 >> (t2 & 63);   
  t6 = t6 >> (t2 & 63);   
  if (t7 & 1)   
    goto vma-memory-read9960;

vma-memory-read9967:
  t2 = t2 & 63;		// set CDR-NEXT 
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  *(u32 *)iSP = t1;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t2;
  goto cachevalid;   

vma-memory-read9958:
  if (_trace) printf("vma-memory-read9958:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t4 = (t4 * 8) + t5;  		// reconstruct SCA 
  t1 = *(s32 *)t4;   
  t2 = *(s32 *)(t4 + 4);   		// Read from stack cache 
  goto vma-memory-read9957;   

vma-memory-read9960:
  if (_trace) printf("vma-memory-read9960:\n");
  if ((t6 & 1) == 0)   
    goto vma-memory-read9959;
  arg5 = (u32)t1;   		// Do the indirect thing 
  goto vma-memory-read9956;   

vma-memory-read9959:
  if (_trace) printf("vma-memory-read9959:\n");
  t7 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t6 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg5;   		// stash the VMA for the (likely) trap 
  t6 = (t6 * 4) + t7;   		// Adjust for a longword load 
  t7 = *(s32 *)t6;   		// Get the memory action 

vma-memory-read9964:
  if (_trace) printf("vma-memory-read9964:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0) 
    goto vma-memory-read9963;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto vma-memory-read9967;   

vma-memory-read9963:

vma-memory-read9962:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read9946:
  if (_trace) printf("vma-memory-read9946:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t2 = *(s32 *)t5;   
  t4 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read9945;   

vma-memory-read9948:
  if (_trace) printf("vma-memory-read9948:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9947;
  t1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read9944;   

vma-memory-read9947:
  if (_trace) printf("vma-memory-read9947:\n");
  t8 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read9952:
  if (_trace) printf("vma-memory-read9952:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0) 
    goto vma-memory-read9951;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto vma-memory-read9955;   

vma-memory-read9951:

vma-memory-read9950:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read9936:
  if (_trace) printf("vma-memory-read9936:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t1 = *(s32 *)t5;   
  t2 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read9935;   

vma-memory-read9938:
  if (_trace) printf("vma-memory-read9938:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9937;
  arg4 = (u32)t1;   		// Do the indirect thing 
  goto vma-memory-read9934;   

vma-memory-read9937:
  if (_trace) printf("vma-memory-read9937:\n");
  t8 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read9940:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceRef */
  /* End of Halfword operand from stack instruction - DoInstanceRef */
/* start DoInstanceSet */

  /* Halfword operand from stack instruction - DoInstanceSet */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceset:
  if (_trace) printf("doinstanceset:\n");
#ifdef TRACING
#endif

DoInstanceSetIM:
  if (_trace) printf("DoInstanceSetIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoinstanceset;   
#ifdef TRACING
#endif

DoInstanceSetSP:
  if (_trace) printf("DoInstanceSetSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceset;   
#endif

DoInstanceSetLP:
  if (_trace) printf("DoInstanceSetLP:\n");
#ifdef TRACING
  goto headdoinstanceset;   
#endif

DoInstanceSetFP:
  if (_trace) printf("DoInstanceSetFP:\n");

headdoinstanceset:
  if (_trace) printf("headdoinstanceset:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoinstanceset:
  if (_trace) printf("begindoinstanceset:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   
  arg3 = *(s32 *)(iSP + 4);   
  iSP = iSP - 8;   		// Pop Stack. 
  arg4 = (u32)arg4;   
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;   
  t1 = t1 & 60;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto ivrefbadinst3;
  t1 = arg2 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto ivrefbadoffset;
  /* Memory Read Internal */

vma-memory-read9968:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);   
  t2 = LDQ_U(t7);   
  t5 = arg4 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;   
  t2 = (u8)(t2 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9970;

vma-memory-read9969:
  t7 = zero + 64;   
  t8 = t8 >> (t2 & 63);   
  t7 = t7 >> (t2 & 63);   
  t1 = (u32)t1;   
  if (t8 & 1)   
    goto vma-memory-read9972;

vma-memory-read9977:
  t1 = t1 - 1;   
  /* Memory Read Internal */

vma-memory-read9978:
  t7 = t1 + ivory;
  t2 = (t7 * 4);   
  t4 = LDQ_U(t7);   
  t5 = t1 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9980;

vma-memory-read9979:
  t7 = zero + 240;   
  t8 = t8 >> (t4 & 63);   
  t7 = t7 >> (t4 & 63);   
  if (t8 & 1)   
    goto vma-memory-read9982;

vma-memory-read9989:
  t5 = t4 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto ivrefbadoffset;
  if ((s64)arg1 < 0)   		// J. if offset <0 
    goto ivrefbadoffset;
  t4 = arg1 - t2;   
  if ((s64)t4 >= 0)   		// J. if offset out of bounds 
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  t1 = *(s32 *)iSP;   
  t2 = *(s32 *)(iSP + 4);   
  iSP = iSP - 8;   		// Pop Stack. 
  t1 = (u32)t1;   
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read9990:
  t7 = arg5 + ivory;
  t4 = (t7 * 4);   
  t3 = LDQ_U(t7);   
  t5 = arg5 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->datawrite_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t4 = *(s32 *)t4;   
  t3 = (u8)(t3 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read9992;

vma-memory-read9991:
  t7 = zero + 240;   
  t8 = t8 >> (t3 & 63);   
  t7 = t7 >> (t3 & 63);   
  if (t8 & 1)   
    goto vma-memory-read9994;

vma-memory-read10000:
  /* Merge cdr-code */
  t4 = t2 & 63;
  t3 = t3 & 192;
  t3 = t3 | t4;
  t5 = arg5 + ivory;
  t4 = (t5 * 4);   
  t7 = LDQ_U(t5);   
  t6 = arg5 - t11;   		// Stack cache offset 
  t8 = ((u64)t6 < (u64)t12) ? 1 : 0;   		// In range? 
  t6 = (t3 & 0xff) << ((t5&7)*8);   
  t7 = t7 & ~(0xffL << (t5&7)*8);   

force-alignment10002:
  if (_trace) printf("force-alignment10002:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);   
  *(u32 *)t4 = t1;
  if (t8 != 0)   		// J. if in cache 
    goto vma-memory-write10001;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

ivrefbadinst3:
  if (_trace) printf("ivrefbadinst3:\n");
  arg5 = 0;
  arg2 = 4;
  goto illegaloperand;

vma-memory-write10001:
  if (_trace) printf("vma-memory-write10001:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t6 = arg5 - t11;   		// Stack cache offset 
  t5 = (t6 * 8) + t5;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t5 = t1;
		/* write the stack cache */
  *(u32 *)(t5 + 4) = t3;
  goto NEXTINSTRUCTION;   

vma-memory-read9992:
  if (_trace) printf("vma-memory-read9992:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t4 = *(s32 *)t5;   
  t3 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read9991;   

vma-memory-read9994:
  if (_trace) printf("vma-memory-read9994:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9993;
  arg5 = (u32)t4;   		// Do the indirect thing 
  goto vma-memory-read9990;   

vma-memory-read9993:
  if (_trace) printf("vma-memory-read9993:\n");
  t8 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t3 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg5;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read9997:

vma-memory-read9996:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 1;
  goto performmemoryaction;

vma-memory-read9980:
  if (_trace) printf("vma-memory-read9980:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t2 = *(s32 *)t5;   
  t4 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read9979;   

vma-memory-read9982:
  if (_trace) printf("vma-memory-read9982:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9981;
  t1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read9978;   

vma-memory-read9981:
  if (_trace) printf("vma-memory-read9981:\n");
  t8 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read9986:
  if (_trace) printf("vma-memory-read9986:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0) 
    goto vma-memory-read9985;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto vma-memory-read9989;   

vma-memory-read9985:

vma-memory-read9984:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read9970:
  if (_trace) printf("vma-memory-read9970:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t1 = *(s32 *)t5;   
  t2 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read9969;   

vma-memory-read9972:
  if (_trace) printf("vma-memory-read9972:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read9971;
  arg4 = (u32)t1;   		// Do the indirect thing 
  goto vma-memory-read9968;   

vma-memory-read9971:
  if (_trace) printf("vma-memory-read9971:\n");
  t8 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read9974:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceSet */
  /* End of Halfword operand from stack instruction - DoInstanceSet */
/* start DoInstanceLoc */

  /* Halfword operand from stack instruction - DoInstanceLoc */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceloc:
  if (_trace) printf("doinstanceloc:\n");
#ifdef TRACING
#endif

DoInstanceLocIM:
  if (_trace) printf("DoInstanceLocIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);   
  goto begindoinstanceloc;   
#ifdef TRACING
#endif

DoInstanceLocSP:
  if (_trace) printf("DoInstanceLocSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceloc;   
#endif

DoInstanceLocLP:
  if (_trace) printf("DoInstanceLocLP:\n");
#ifdef TRACING
  goto headdoinstanceloc;   
#endif

DoInstanceLocFP:
  if (_trace) printf("DoInstanceLocFP:\n");

headdoinstanceloc:
  if (_trace) printf("headdoinstanceloc:\n");
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  arg1 = *(u64 *)arg1;   		// Get the operand 

begindoinstanceloc:
  if (_trace) printf("begindoinstanceloc:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;   
  arg3 = *(s32 *)(iSP + 4);   
  arg4 = (u32)arg4;   
  arg2 = arg1 >> 32;   
  arg1 = (u32)arg1;   
  t11 = *(u64 *)&(processor->stackcachebasevma);   
  t12 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;   
  t1 = t1 & 60;		// Strip CDR code, low bits 
  if (t1 != 0)   
    goto ivrefbadinst;
  t1 = arg2 - Type_Fixnum;   
  t1 = t1 & 63;		// Strip CDR code 
  if (t1 != 0)   
    goto ivrefbadoffset;
  /* Memory Read Internal */

vma-memory-read10003:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);   
  t2 = LDQ_U(t7);   
  t5 = arg4 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->header_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t1 = *(s32 *)t1;   
  t2 = (u8)(t2 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read10005;

vma-memory-read10004:
  t7 = zero + 64;   
  t8 = t8 >> (t2 & 63);   
  t7 = t7 >> (t2 & 63);   
  t1 = (u32)t1;   
  if (t8 & 1)   
    goto vma-memory-read10007;

vma-memory-read10012:
  t1 = t1 - 1;   
  /* Memory Read Internal */

vma-memory-read10013:
  t7 = t1 + ivory;
  t2 = (t7 * 4);   
  t4 = LDQ_U(t7);   
  t5 = t1 - t11;   		// Stack cache offset 
  t8 = *(u64 *)&(processor->dataread_mask);   
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;   		// In range? 
  t2 = *(s32 *)t2;   
  t4 = (u8)(t4 >> ((t7&7)*8));   
  if (t6 != 0)   
    goto vma-memory-read10015;

vma-memory-read10014:
  t7 = zero + 240;   
  t8 = t8 >> (t4 & 63);   
  t7 = t7 >> (t4 & 63);   
  if (t8 & 1)   
    goto vma-memory-read10017;

vma-memory-read10024:
  t5 = t4 - Type_Fixnum;   
  t5 = t5 & 63;		// Strip CDR code 
  if (t5 != 0)   
    goto ivrefbadoffset;
  if ((s64)arg1 < 0)   		// J. if offset <0 
    goto ivrefbadoffset;
  t4 = arg1 - t2;   
  if ((s64)t4 >= 0)   		// J. if offset out of bounds 
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  t7 = Type_Locative;
  *(u32 *)iSP = arg5;
		/* write the stack cache */
  *(u32 *)(iSP + 4) = t7;
  goto NEXTINSTRUCTION;   

ivrefbadinst:
  if (_trace) printf("ivrefbadinst:\n");
  arg5 = 0;
  arg2 = 3;
  goto illegaloperand;

ivrefbadoffset:
  if (_trace) printf("ivrefbadoffset:\n");
  arg5 = 0;
  arg2 = 49;
  goto illegaloperand;

vma-memory-read10015:
  if (_trace) printf("vma-memory-read10015:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t2 = *(s32 *)t5;   
  t4 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read10014;   

vma-memory-read10017:
  if (_trace) printf("vma-memory-read10017:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read10016;
  t1 = (u32)t2;   		// Do the indirect thing 
  goto vma-memory-read10013;   

vma-memory-read10016:
  if (_trace) printf("vma-memory-read10016:\n");
  t8 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read10021:
  if (_trace) printf("vma-memory-read10021:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0) 
    goto vma-memory-read10020;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto vma-memory-read10024;   

vma-memory-read10020:

vma-memory-read10019:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

vma-memory-read10005:
  if (_trace) printf("vma-memory-read10005:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t5 = (t5 * 8) + t6;  		// reconstruct SCA 
  t1 = *(s32 *)t5;   
  t2 = *(s32 *)(t5 + 4);   		// Read from stack cache 
  goto vma-memory-read10004;   

vma-memory-read10007:
  if (_trace) printf("vma-memory-read10007:\n");
  if ((t7 & 1) == 0)   
    goto vma-memory-read10006;
  arg4 = (u32)t1;   		// Do the indirect thing 
  goto vma-memory-read10003;   

vma-memory-read10006:
  if (_trace) printf("vma-memory-read10006:\n");
  t8 = *(u64 *)&(processor->header);   		// Load the memory action table for cycle 
  /* TagType. */
  t7 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = arg4;   		// stash the VMA for the (likely) trap 
  t7 = (t7 * 4) + t8;   		// Adjust for a longword load 
  t8 = *(s32 *)t7;   		// Get the memory action 

vma-memory-read10009:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceLoc */
  /* End of Halfword operand from stack instruction - DoInstanceLoc */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifuninst.as */
