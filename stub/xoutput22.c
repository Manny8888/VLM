/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifuntrap.as
 ************************************************************************/

/* start DECODEFAULT */


decodefault:
  if (_trace) printf("decodefault:\n");
  /* We come here when a memory access faults to figure out why */
  /* retrieve the trapping VMA */
  t1 = *(u64 *)&(processor->vma);
  /* Per-page attributes table */
  t3 = *(u64 *)&(processor->vmattributetable);
  /* Index into the attributes table */
  t2 = t1 >> (MemoryPage_AddressShift & 63);
  /* Address of the page's attributes */
  t3 = t2 + t3;
  /* Get the quadword with the page's attributes */
  t2 = LDQ_U(t3);
  /* Stash the VMA */
  *(u64 *)&processor->vma = t1;
  /* Extract the page's attributes */
  t2 = (u8)(t2 >> ((t3&7)*8));
  /* Non-existent page */
  if (t2 == 0)
    goto pagenotresident;
  t3 = t2 & VMAttribute_AccessFault;
  /* Access fault */
  if (t3 != 0)
    goto pagefaultrequesthandler;
  t3 = t2 & VMAttribute_TransportFault;
  /* Transport fault */
  if (t3 != 0)
    goto transporttrap;
  t3 = t2 & VMAttribute_WriteFault;
  /* Write fault */
  if (t3 != 0)
    goto pagewritefault;
  goto buserror;

/* end DECODEFAULT */
/* start HANDLEUNWINDPROTECT */


handleunwindprotect:
  if (_trace) printf("handleunwindprotect:\n");
  t4 = *(s32 *)&processor->catchblock;
  t4 = (u32)t4;
  /* Convert VMA to stack cache address */
  t2 = *(u64 *)&(processor->stackcachebasevma);
  t3 = *(u64 *)&(processor->stackcachedata);
  /* stack cache base relative offset */
  t2 = t4 - t2;
  /* reconstruct SCA */
  t3 = (t2 * 8) + t3;
  t6 = *(s32 *)(t3 + 16);
  t5 = *(s32 *)(t3 + 20);
  t6 = (u32)t6;
  t2 = *(s32 *)(t3 + 8);
  t1 = *(s32 *)(t3 + 12);
  t2 = (u32)t2;
  /* Restore SP */
  iSP = *(u64 *)&(processor->restartsp);
  t1 = *(u64 *)&(processor->bindingstackpointer);
#ifdef MINIMA
  t4 = t1 >> 32;
#endif
  t3 = (s32)t1 - (s32)t2;
  /* J. if binding level= binding stack */
  if (t3 == 0)
    goto g3472;
#ifdef MINIMA
  /* BSP not a locative -> Deep-bound */
  t3 = t4 - Type_Locative;
  /* Strip CDR code */
  t3 = t3 & 63;
  if (t3 != 0)
    goto dbunwindframetrap;
#endif

g3473:
  if (_trace) printf("g3473:\n");
  t1 = *(u64 *)&(processor->bindingstackpointer);
  t4 = *(s32 *)&processor->control;
  /* vma only */
  t1 = (u32)t1;
  arg1 = (512) << 16;
  t5 = t1 - 1;
  t3 = t4 & arg1;
  /* Turn off the bit */
  t4 = t4 & ~arg1;
  if (t3 != 0)
    goto g3474;
  /* Get the SP, ->op2 */
  t4 = *(u64 *)&(processor->restartsp);
  arg5 = 0;
  arg2 = 20;
  goto illegaloperand;

g3474:
  if (_trace) printf("g3474:\n");
  /* Memory Read Internal */

g3475:
  /* Base of stack cache */
  t8 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t1 + ivory;
  t9 = *(s32 *)&processor->scovlimit;
  t6 = (t10 * 4);
  t7 = LDQ_U(t10);
  /* Stack cache offset */
  t8 = t1 - t8;
  t11 = *(u64 *)&(processor->bindread_mask);
  /* In range? */
  t9 = ((u64)t8 < (u64)t9) ? 1 : 0;
  t6 = *(s32 *)t6;
  t7 = (u8)(t7 >> ((t10&7)*8));
  if (t9 != 0)
    goto g3477;

g3476:
  t10 = zero + 224;
  t11 = t11 >> (t7 & 63);
  t10 = t10 >> (t7 & 63);
  if (t11 & 1)
    goto g3479;

g3484:
  /* Memory Read Internal */

g3485:
  /* Base of stack cache */
  t8 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t5 + ivory;
  t9 = *(s32 *)&processor->scovlimit;
  arg1 = (t10 * 4);
  t3 = LDQ_U(t10);
  /* Stack cache offset */
  t8 = t5 - t8;
  t11 = *(u64 *)&(processor->bindread_mask);
  /* In range? */
  t9 = ((u64)t8 < (u64)t9) ? 1 : 0;
  arg1 = *(s32 *)arg1;
  t3 = (u8)(t3 >> ((t10&7)*8));
  if (t9 != 0)
    goto g3487;

g3486:
  t10 = zero + 224;
  t11 = t11 >> (t3 & 63);
  t10 = t10 >> (t3 & 63);
  arg1 = (u32)arg1;
  if (t11 & 1)
    goto g3489;

g3494:
  /* Memory Read Internal */

g3495:
  /* Base of stack cache */
  t10 = *(u64 *)&(processor->stackcachebasevma);
  t12 = arg1 + ivory;
  t11 = *(s32 *)&processor->scovlimit;
  t9 = (t12 * 4);
  t8 = LDQ_U(t12);
  /* Stack cache offset */
  t10 = arg1 - t10;
  /* In range? */
  t11 = ((u64)t10 < (u64)t11) ? 1 : 0;
  t9 = *(s32 *)t9;
  t8 = (u8)(t8 >> ((t12&7)*8));
  if (t11 != 0)
    goto g3497;

g3496:
  t10 = *(u64 *)&(processor->bindwrite_mask);
  t12 = zero + 224;
  t10 = t10 >> (t8 & 63);
  t12 = t12 >> (t8 & 63);
  if (t10 & 1)
    goto g3499;

g3504:
  /* Merge cdr-code */
  t9 = t7 & 63;
  t8 = t8 & 192;
  t8 = t8 | t9;
  t10 = arg1 + ivory;
  t9 = (t10 * 4);
  t12 = LDQ_U(t10);
  t11 = (t8 & 0xff) << ((t10&7)*8);
  t12 = t12 & ~(0xffL << (t10&7)*8);

g3507:
  if (_trace) printf("g3507:\n");
  t12 = t12 | t11;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  STQ_U(t10, t12);
  t10 = *(s32 *)&processor->scovlimit;
  /* Stack cache offset */
  t11 = arg1 - t11;
  /* In range? */
  t10 = ((u64)t11 < (u64)t10) ? 1 : 0;
  *(u32 *)t9 = t6;
  /* J. if in cache */
  if (t10 != 0)
    goto g3506;

g3505:
  /* Get the old cleanup-bindings bit */
  t3 = t3 & 64;
  t3 = t3 << 19;
  t1 = t1 - 2;
  /* vma only */
  *(u32 *)&processor->bindingstackpointer = t1;
  t4 = t4 | t3;
  *(u32 *)&processor->control = t4;
  t1 = *(u64 *)&(processor->bindingstackpointer);
  t3 = (s32)t1 - (s32)t2;
  /* J. if binding level/= binding stack */
  if (t3 != 0)
    goto g3473;
  t2 = *(s32 *)&processor->interruptreg;
  t3 = t2 & 2;
  t3 = (t3 == 2) ? 1 : 0;
  t2 = t2 | t3;
  *(u32 *)&processor->interruptreg = t2;
  if (t2 == 0)
    goto g3472;
  *(u64 *)&processor->stop_interpreter = t2;

g3472:
  if (_trace) printf("g3472:\n");
  /* Convert PC to a real continuation. */
  t3 = iPC & 1;
  /* convert PC to a real word address. */
  t1 = iPC >> 1;
  t3 = t3 + Type_EvenPC;
  arg1 = *(s32 *)&processor->control;
  t2 = arg1 >> 17;
  t2 = t2 | 128;
  t2 = t2 & 192;
  /* TagType. */
  t3 = t3 & 63;
  t3 = t3 | t2;
  *(u32 *)(iSP + 8) = t1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  iSP = iSP + 8;
  /* Load catch-block PC */
  t4 = *(s32 *)&processor->catchblock;
  t4 = (u32)t4;
  /* Convert VMA to stack cache address */
  t2 = *(u64 *)&(processor->stackcachebasevma);
  t3 = *(u64 *)&(processor->stackcachedata);
  /* stack cache base relative offset */
  t2 = t4 - t2;
  /* reconstruct SCA */
  t3 = (t2 * 8) + t3;
  t6 = *(s32 *)t3;
  t5 = *(s32 *)(t3 + 4);
  t6 = (u32)t6;
  /* Convert real continuation to PC. */
  iPC = t5 & 1;
  iPC = t6 + iPC;
  iPC = t6 + iPC;
  t1 = (128) << 16;
  arg1 = arg1 | t1;
  t10 = *(s32 *)(t3 + 16);
  t5 = *(s32 *)(t3 + 20);
  t10 = (u32)t10;
  /* This is the  extra-arg bit */
  t6 = t5 & 128;
  t8 = *(s32 *)&processor->extraandcatch;
  /* This is the  cleanup-catch bit */
  t7 = t5 & 64;
  /* Shift bit into place for cr */
  t6 = t6 << 1;
  /* Shift extra arg bit into place for cr */
  t7 = t7 << 20;
  arg1 = arg1 & ~t8;
  t6 = t6 | t7;
  /* update the bits extra-arg/cleanupcatch */
  arg1 = arg1 | t6;
  *(u32 *)&processor->control = arg1;
  /* TagType. */
  t5 = t5 & 63;
  t5 = t5 << 32;
  t5 = t5 | t10;
  *(u64 *)&processor->catchblock = t5;
  goto interpretinstructionforbranch;
#ifdef MINIMA

dbunwindframetrap:
  if (_trace) printf("dbunwindframetrap:\n");
  goto dbunwindframetrap;
#endif

g3506:
  if (_trace) printf("g3506:\n");
  t10 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t10 = (t11 * 8) + t10;
  /* Store in stack */
  *(u32 *)t10 = t6;
  /* write the stack cache */
  *(u32 *)(t10 + 4) = t8;
  goto g3505;

g3497:
  if (_trace) printf("g3497:\n");
  t11 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t10 = (t10 * 8) + t11;
  t9 = *(s32 *)t10;
  /* Read from stack cache */
  t8 = *(s32 *)(t10 + 4);
  goto g3496;

g3499:
  if (_trace) printf("g3499:\n");
  if ((t12 & 1) == 0)
    goto g3498;
  /* Do the indirect thing */
  arg1 = (u32)t9;
  goto g3495;

g3498:
  if (_trace) printf("g3498:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->bindwrite);
  /* TagType. */
  /* Discard the CDR code */
  t12 = t8 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t12 = (t12 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t12;

g3501:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 3;
  goto performmemoryaction;

g3487:
  if (_trace) printf("g3487:\n");
  t9 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t8 = (t8 * 8) + t9;
  arg1 = *(s32 *)t8;
  /* Read from stack cache */
  t3 = *(s32 *)(t8 + 4);
  goto g3486;

g3489:
  if (_trace) printf("g3489:\n");
  if ((t10 & 1) == 0)
    goto g3488;
  /* Do the indirect thing */
  t5 = (u32)arg1;
  goto g3485;

g3488:
  if (_trace) printf("g3488:\n");
  /* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->bindread);
  /* TagType. */
  /* Discard the CDR code */
  t10 = t3 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t5;
  /* Adjust for a longword load */
  t10 = (t10 * 4) + t11;
  /* Get the memory action */
  t11 = *(s32 *)t10;

g3491:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 2;
  goto performmemoryaction;

g3477:
  if (_trace) printf("g3477:\n");
  t9 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t8 = (t8 * 8) + t9;
  t6 = *(s32 *)t8;
  /* Read from stack cache */
  t7 = *(s32 *)(t8 + 4);
  goto g3476;

g3479:
  if (_trace) printf("g3479:\n");
  if ((t10 & 1) == 0)
    goto g3478;
  /* Do the indirect thing */
  t1 = (u32)t6;
  goto g3475;

g3478:
  if (_trace) printf("g3478:\n");
  /* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->bindread);
  /* TagType. */
  /* Discard the CDR code */
  t10 = t7 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t10 = (t10 * 4) + t11;
  /* Get the memory action */
  t11 = *(s32 *)t10;

g3481:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 2;
  goto performmemoryaction;

/* end HANDLEUNWINDPROTECT */
/* start PERFORMMEMORYACTION */


performmemoryaction:
  if (_trace) printf("performmemoryaction:\n");
  /* We get here when a memory action that will trap is detected. */
  /* ARG1 contains the memory action code with the Transport bit removed. */
  /* ARG2 contains the memory cycle so we can generate the proper microstate. */
  t1 = (arg1 == MemoryActionTrap) ? 1 : 0;

g3536:
  if (_trace) printf("g3536:\n");
  if (t1 == 0)
    goto g3509;
  /* Here if argument MemoryActionTrap */
  /* Get the failing VMA */
  t1 = *(u64 *)&(processor->vma);
  t2 = (arg2 == Cycle_DataRead) ? 1 : 0;

g3523:
  if (_trace) printf("g3523:\n");
  if (t2 == 0)
    goto g3511;
  /* Here if argument CycleDataRead */
  arg5 = t1;
  arg2 = 57;
  goto illegaloperand;

g3511:
  if (_trace) printf("g3511:\n");
  t2 = (arg2 == Cycle_DataWrite) ? 1 : 0;

g3524:
  if (_trace) printf("g3524:\n");
  if (t2 == 0)
    goto g3512;
  /* Here if argument CycleDataWrite */
  arg5 = t1;
  arg2 = 58;
  goto illegaloperand;

g3512:
  if (_trace) printf("g3512:\n");
  t2 = (arg2 == Cycle_BindRead) ? 1 : 0;

g3525:
  if (_trace) printf("g3525:\n");
  if (t2 != 0)
    goto g3514;
  t2 = (arg2 == Cycle_BindReadNoMonitor) ? 1 : 0;

g3526:
  if (_trace) printf("g3526:\n");
  if (t2 == 0)
    goto g3513;

g3514:
  if (_trace) printf("g3514:\n");
  /* Here if argument (CycleBindRead CycleBindReadNoMonitor) */
  arg5 = t1;
  arg2 = 54;
  goto illegaloperand;

g3513:
  if (_trace) printf("g3513:\n");
  t2 = (arg2 == Cycle_BindWrite) ? 1 : 0;

g3527:
  if (_trace) printf("g3527:\n");
  if (t2 != 0)
    goto g3516;
  t2 = (arg2 == Cycle_BindWriteNoMonitor) ? 1 : 0;

g3528:
  if (_trace) printf("g3528:\n");
  if (t2 == 0)
    goto g3515;

g3516:
  if (_trace) printf("g3516:\n");
  /* Here if argument (CycleBindWrite CycleBindWriteNoMonitor) */
  arg5 = t1;
  arg2 = 55;
  goto illegaloperand;

g3515:
  if (_trace) printf("g3515:\n");
  t2 = (arg2 == Cycle_Header) ? 1 : 0;

g3529:
  if (_trace) printf("g3529:\n");
  if (t2 != 0)
    goto g3518;
  t2 = (arg2 == Cycle_StructureOffset) ? 1 : 0;

g3530:
  if (_trace) printf("g3530:\n");
  if (t2 == 0)
    goto g3517;

g3518:
  if (_trace) printf("g3518:\n");
  /* Here if argument (CycleHeader CycleStructureOffset) */
  arg5 = t1;
  arg2 = 59;
  goto illegaloperand;

g3517:
  if (_trace) printf("g3517:\n");
  t2 = (arg2 == Cycle_Scavenge) ? 1 : 0;

g3531:
  if (_trace) printf("g3531:\n");
  if (t2 != 0)
    goto g3520;
  t2 = (arg2 == Cycle_GCCopy) ? 1 : 0;

g3532:
  if (_trace) printf("g3532:\n");
  if (t2 == 0)
    goto g3519;

g3520:
  if (_trace) printf("g3520:\n");
  /* Here if argument (CycleScavenge CycleGCCopy) */
  arg5 = t1;
  arg2 = 60;
  goto illegaloperand;

g3519:
  if (_trace) printf("g3519:\n");
  t2 = (arg2 == Cycle_Cdr) ? 1 : 0;

g3533:
  if (_trace) printf("g3533:\n");
  if (t2 == 0)
    goto g3510;
  /* Here if argument CycleCdr */
  arg5 = t1;
  arg2 = 56;
  goto illegaloperand;

g3510:
  if (_trace) printf("g3510:\n");

g3509:
  if (_trace) printf("g3509:\n");
  t1 = (arg1 == MemoryActionMonitor) ? 1 : 0;

g3537:
  if (_trace) printf("g3537:\n");
  if (t1 == 0)
    goto g3508;
  /* Here if argument MemoryActionMonitor */
  goto monitortrap;

g3508:
  if (_trace) printf("g3508:\n");

/* end PERFORMMEMORYACTION */
/* start OutOfLineExceptions */


outoflineexceptions:
  if (_trace) printf("outoflineexceptions:\n");

ldbexception:
  if (_trace) printf("ldbexception:\n");
  /* arg6 = tag to dispatch on */
  arg6 = arg3;
  /* arg3 = stackp */
  arg3 = 1;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto numericexception;

rplacaexception:
  if (_trace) printf("rplacaexception:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto listexception;

rplacdexception:
  if (_trace) printf("rplacdexception:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto listexception;

pushivexception:
  if (_trace) printf("pushivexception:\n");
  t1 = zero + 8;
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

incrementexception:
  if (_trace) printf("incrementexception:\n");
  /* arg6 = tag to dispatch on */
  arg6 = arg2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto unarynumericexception;

decrementexception:
  if (_trace) printf("decrementexception:\n");
  /* arg6 = tag to dispatch on */
  arg6 = arg2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto unarynumericexception;

/* end OutOfLineExceptions */
/* start NUMERICEXCEPTION */


numericexception:
  if (_trace) printf("numericexception:\n");
  t1 = arg6 - Type_Fixnum;
  /* Strip CDR code, low bits */
  t1 = t1 & 56;
  if (t1 != 0)
    goto notnumeric;
  goto exception;

notnumeric:
  if (_trace) printf("notnumeric:\n");
  arg5 = 0;
  arg2 = 16;
  goto illegaloperand;

/* end NUMERICEXCEPTION */
/* start UNARYNUMERICEXCEPTION */


unarynumericexception:
  if (_trace) printf("unarynumericexception:\n");
  t1 = arg6 - Type_Fixnum;
  /* Strip CDR code, low bits */
  t1 = t1 & 56;
  if (t1 != 0)
    goto unarynotnumeric;
  goto exception;

unarynotnumeric:
  if (_trace) printf("unarynotnumeric:\n");
  arg5 = 0;
  arg2 = 81;
  goto illegaloperand;

/* end UNARYNUMERICEXCEPTION */
/* start LISTEXCEPTION */


listexception:
  if (_trace) printf("listexception:\n");
  t1 = arg6 - Type_List;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto notlist1;
  goto exception;

notlist1:
  if (_trace) printf("notlist1:\n");
  t1 = arg6 - Type_ListInstance;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto notlist2;
  goto exception;

notlist2:
  if (_trace) printf("notlist2:\n");
  arg5 = 0;
  arg2 = 26;
  goto illegaloperand;

/* end LISTEXCEPTION */
/* start ARRAYEXCEPTION */


arrayexception:
  if (_trace) printf("arrayexception:\n");
  t1 = arg6 - Type_Array;
  /* Strip CDR code, low bits */
  t1 = t1 & 62;
  if (t1 != 0)
    goto notarray1;
  goto exception;

notarray1:
  if (_trace) printf("notarray1:\n");
  t1 = arg6 - Type_ArrayInstance;
  /* Strip CDR code, low bits */
  t1 = t1 & 62;
  if (t1 != 0)
    goto notarray2;
  goto exception;

notarray2:
  if (_trace) printf("notarray2:\n");
  goto spareexception;

/* end ARRAYEXCEPTION */
/* start SPAREEXCEPTION */


spareexception:
  if (_trace) printf("spareexception:\n");
  t1 = arg6 - Type_SparePointer1;
  /* Strip CDR code, low bits */
  t1 = t1 & 62;
  if (t1 != 0)
    goto notspare1;
  goto exception;

notspare1:
  if (_trace) printf("notspare1:\n");

notspare2:
  if (_trace) printf("notspare2:\n");
  t1 = arg6 - Type_SpareNumber;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto notspare3;
  goto exception;

notspare3:
  if (_trace) printf("notspare3:\n");
  goto illegaloperand;

/* end SPAREEXCEPTION */
/* start EXCEPTION */


exception:
  if (_trace) printf("exception:\n");
  /* J. if arithmetic exception */
  if (arg4 != 0)
    goto arithmeticexception;
  t2 = *(u64 *)&(processor->linkage);
  /* fix the stack pointer */
  iSP = *(u64 *)&(processor->restartsp);
  /* fetch the real opcode */
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->instruction);
  if (t2 != 0)
    goto nativeexception;
  /* J. if arguments stacked */
  if (arg3 != 0)
    goto g3539;
  /* Get original operand */
  t1 = (u16)(arg2 >> ((4&7)*8));
  /* t3 is non-zero iff SP|POP operand */
  t3 = (t1 == 512) ? 1 : 0;
  /* SP|POP operand recovered by restoring SP */
  if (t3 != 0)
    goto g3539;
  /* Assume FP mode */
  arg5 = iFP;
  /* SP mode constant */
  t3 = iSP + -2040;
  /* Get the mode bits */
  t4 = (u8)(arg2 >> ((5&7)*8));
  /* Extract (8-bit, unsigned) operand */
  t2 = (u8)(arg2 >> ((4&7)*8));
  /* t4 = -2 FP, -1 LP, 0 SP, 1 Imm */
  t4 = t4 - 2;
  /* LP or Immediate mode */
  if (t4 & 1)
   arg5 = iLP;
  /* SP mode */
  if (t4 == 0)
    arg5 = t3;
  /* Compute operand address */
  arg5 = (t2 * 8) + arg5;
  /* Not immediate mode */
  if ((s64)t4 <= 0)
    goto g3540;
  t1 = t2 << 56;
  t3 = arg2 >> 16;
  t1 = (s64)t1 >> 56;
  /* Immediate mode constant */
  arg5 = (u64)&processor->immediate_arg;
  /* Signed immediate */
  if ((t3 & 1) == 0)
   t2 = t1;
  *(u32 *)&processor->immediate_arg = t2;

g3540:
  if (_trace) printf("g3540:\n");
  t1 = zero + -32768;
  t1 = t1 + ((2) << 16);
  t2 = arg2 & t1;
  t3 = (t1 == t2) ? 1 : 0;
  /* J. if not address-format operand */
  if (t3 == 0)
    goto g3541;
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);
  t1 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t2 = arg5 - t2;
  /* convert byte address to word address */
  t2 = t2 >> 3;
  /* reconstruct VMA */
  t1 = t2 + t1;
  t2 = Type_Locative;
  /* SetTag. */
  arg5 = t2 << 32;
  arg5 = t1 | arg5;
  goto g3542;

g3541:
  if (_trace) printf("g3541:\n");
  /* Fetch the arg */
  arg5 = *(u64 *)arg5;

g3542:
  if (_trace) printf("g3542:\n");
  *(u64 *)(iSP + 8) = arg5;
  iSP = iSP + 8;

g3539:
  if (_trace) printf("g3539:\n");
  /* Shift opcode into position */
  arg2 = arg2 >> 10;
  /* Just 8-bits of opcode */
  arg2 = arg2 & 255;
  t11 = arg2 + TrapVector_InstructionException;
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + TrapVector_InstructionException;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  t12 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  goto handleexception;

/* end EXCEPTION */
/* start ARITHMETICEXCEPTION */


arithmeticexception:
  if (_trace) printf("arithmeticexception:\n");
  t2 = *(u64 *)&(processor->linkage);
  /* fix the stack pointer */
  iSP = *(u64 *)&(processor->restartsp);
  /* fetch the real opcode */
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->instruction);
  if (t2 != 0)
    goto nativeexception;
  /* Get original operand */
  t1 = (u16)(arg2 >> ((4&7)*8));
  /* t3 is non-zero iff SP|POP operand */
  t3 = (t1 == 512) ? 1 : 0;
  /* SP|POP operand recovered by restoring SP */
  if (t3 != 0)
    goto g3544;
  /* Assume FP mode */
  arg5 = iFP;
  /* SP mode constant */
  t3 = iSP + -2040;
  /* Get the mode bits */
  t4 = (u8)(arg2 >> ((5&7)*8));
  /* Extract (8-bit, unsigned) operand */
  t2 = (u8)(arg2 >> ((4&7)*8));
  /* t4 = -2 FP, -1 LP, 0 SP, 1 Imm */
  t4 = t4 - 2;
  /* LP or Immediate mode */
  if (t4 & 1)
   arg5 = iLP;
  /* SP mode */
  if (t4 == 0)
    arg5 = t3;
  /* Compute operand address */
  arg5 = (t2 * 8) + arg5;
  /* Not immediate mode */
  if ((s64)t4 <= 0)
    goto g3545;
  t1 = t2 << 56;
  t3 = arg2 >> 16;
  t1 = (s64)t1 >> 56;
  /* Immediate mode constant */
  arg5 = (u64)&processor->immediate_arg;
  /* Signed immediate */
  if ((t3 & 1) == 0)
   t2 = t1;
  *(u32 *)&processor->immediate_arg = t2;

g3545:
  if (_trace) printf("g3545:\n");
  t1 = zero + -32768;
  t1 = t1 + ((2) << 16);
  t2 = arg2 & t1;
  t3 = (t1 == t2) ? 1 : 0;
  /* J. if not address-format operand */
  if (t3 == 0)
    goto g3546;
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);
  t1 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t2 = arg5 - t2;
  /* convert byte address to word address */
  t2 = t2 >> 3;
  /* reconstruct VMA */
  t1 = t2 + t1;
  t2 = Type_Locative;
  /* SetTag. */
  arg5 = t2 << 32;
  arg5 = t1 | arg5;
  goto g3547;

g3546:
  if (_trace) printf("g3546:\n");
  /* Fetch the arg */
  arg5 = *(u64 *)arg5;

g3547:
  if (_trace) printf("g3547:\n");
  *(u64 *)(iSP + 8) = arg5;
  iSP = iSP + 8;

g3544:
  if (_trace) printf("g3544:\n");
  /* Get unary/nary bit of opcode */
  t4 = arg2 >> 17;
  /* Assume unary */
  arg1 = 1;
  t11 = zero;
  t2 = iSP;
  /* J. if not binary arithmetic dispatch */
  if ((t4 & 1) == 0)
    goto g3543;
  /* Nary -> Binary */
  arg1 = 2;
  t11 = *(s32 *)(iSP + 4);
  t2 = t2 - 8;
  /* low three bits has opcode tag for op2 */
  t11 = t11 & 7;

g3543:
  if (_trace) printf("g3543:\n");
  /* Shift opcode into position */
  arg2 = arg2 >> 4;
  t2 = *(s32 *)(t2 + 4);
  /* five bits from the opcode */
  arg2 = arg2 & 1984;
  t2 = t2 & 7;
  t11 = (t2 * 8) + t11;
  t11 = arg2 | t11;
  t11 = t11 + TrapVector_ArithmeticInstructionException;
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + TrapVector_ArithmeticInstructionException;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  t12 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  goto handleexception;

/* end ARITHMETICEXCEPTION */
/* start LOOPEXCEPTION */


loopexception:
  if (_trace) printf("loopexception:\n");
  t2 = *(u64 *)&(processor->linkage);
  /* fix the stack pointer */
  iSP = *(u64 *)&(processor->restartsp);
  /* fetch the real opcode */
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->instruction);
  if (t2 != 0)
    goto nativeexception;
  /* J. if arguments stacked */
  if (arg3 != 0)
    goto g3549;
  /* Get original operand */
  t1 = (u16)(arg2 >> ((4&7)*8));
  /* t3 is non-zero iff SP|POP operand */
  t3 = (t1 == 512) ? 1 : 0;
  /* SP|POP operand recovered by restoring SP */
  if (t3 != 0)
    goto g3549;
  /* Assume FP mode */
  arg5 = iFP;
  /* SP mode constant */
  t3 = iSP + -2040;
  /* Get the mode bits */
  t4 = (u8)(arg2 >> ((5&7)*8));
  /* Extract (8-bit, unsigned) operand */
  t2 = (u8)(arg2 >> ((4&7)*8));
  /* t4 = -2 FP, -1 LP, 0 SP, 1 Imm */
  t4 = t4 - 2;
  /* LP or Immediate mode */
  if (t4 & 1)
   arg5 = iLP;
  /* SP mode */
  if (t4 == 0)
    arg5 = t3;
  /* Compute operand address */
  arg5 = (t2 * 8) + arg5;
  /* Not immediate mode */
  if ((s64)t4 <= 0)
    goto g3550;
  t1 = t2 << 56;
  t3 = arg2 >> 16;
  t1 = (s64)t1 >> 56;
  /* Immediate mode constant */
  arg5 = (u64)&processor->immediate_arg;
  /* Signed immediate */
  if ((t3 & 1) == 0)
   t2 = t1;
  *(u32 *)&processor->immediate_arg = t2;

g3550:
  if (_trace) printf("g3550:\n");
  t1 = zero + -32768;
  t1 = t1 + ((2) << 16);
  t2 = arg2 & t1;
  t3 = (t1 == t2) ? 1 : 0;
  /* J. if not address-format operand */
  if (t3 == 0)
    goto g3551;
  /* Convert stack cache address to VMA */
  t2 = *(u64 *)&(processor->stackcachedata);
  t1 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t2 = arg5 - t2;
  /* convert byte address to word address */
  t2 = t2 >> 3;
  /* reconstruct VMA */
  t1 = t2 + t1;
  t2 = Type_Locative;
  /* SetTag. */
  arg5 = t2 << 32;
  arg5 = t1 | arg5;
  goto g3552;

g3551:
  if (_trace) printf("g3551:\n");
  /* Fetch the arg */
  arg5 = *(u64 *)arg5;

g3552:
  if (_trace) printf("g3552:\n");
  *(u64 *)(iSP + 8) = arg5;
  iSP = iSP + 8;

g3549:
  if (_trace) printf("g3549:\n");
  /* Shift opcode into position */
  arg2 = arg2 >> 10;
  /* Just 8-bits of opcode */
  arg2 = arg2 & 255;
  t11 = arg2 + TrapVector_InstructionException;
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + TrapVector_InstructionException;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  t12 = arg5;
  goto handleexception;

/* end LOOPEXCEPTION */
/* start HandleException */


handleexception:
  if (_trace) printf("handleexception:\n");
  /* save old frame pointer */
  t1 = iFP;
  t4 = *(s32 *)&processor->control;
  t9 = *(u64 *)&(processor->fepmodetrapvecaddress);
  t8 = *(u64 *)&(processor->trapvecbase);
  t5 = (-16384) << 16;
  t6 = t4 >> 30;
  /* Set trap mode to 3 */
  t5 = t4 | t5;
  t6 = t6 & 3;
  *(u32 *)&processor->control = t5;
  t7 = t6 - 3;
  t8 = t8 + t11;
  if (t7 == 0)
    t8 = t9;
  /* Record TVI for tracing (if enabled) */
  *(u64 *)&processor->tvi = t8;
  /* Memory Read Internal */

g3556:
  /* Base of stack cache */
  t9 = *(u64 *)&(processor->stackcachebasevma);
  t6 = t8 + ivory;
  t7 = *(s32 *)&processor->scovlimit;
  t3 = (t6 * 4);
  t2 = LDQ_U(t6);
  /* Stack cache offset */
  t9 = t8 - t9;
  t5 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t7 = ((u64)t9 < (u64)t7) ? 1 : 0;
  t3 = *(s32 *)t3;
  t2 = (u8)(t2 >> ((t6&7)*8));
  if (t7 != 0)
    goto g3558;

g3557:
  t6 = zero + 240;
  t5 = t5 >> (t2 & 63);
  t6 = t6 >> (t2 & 63);
  t3 = (u32)t3;
  if (t5 & 1)
    goto g3560;

g3567:
  t5 = t2 - Type_EvenPC;
  /* Strip CDR code, low bits */
  t5 = t5 & 62;
  if (t5 != 0)
    goto g3555;
  /* Restore the cr */
  *(u32 *)&processor->control = t4;
  /* Current stack cache limit (words) */
  t8 = *(s32 *)&processor->scovlimit;
  t5 = zero + 128;
  /* Alpha base of stack cache */
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Account for what we're about to push */
  t5 = t5 + 8;
  /* SCA of desired end of cache */
  t5 = (t5 * 8) + iSP;
  /* SCA of current end of cache */
  t6 = (t8 * 8) + t6;
  t8 = ((s64)t5 <= (s64)t6) ? 1 : 0;
  /* We're done if new SCA is within bounds */
  if (t8 == 0)
    goto g3568;
  iFP = (arg1 * 8) + zero;
  iFP = iSP - iFP;
  iFP = iFP + 8;
  if (arg1 == 0)
    goto g3553;
  t5 = *(u64 *)iSP;
  *(u64 *)(iSP + 32) = t5;
  arg1 = arg1 - 1;
  if (arg1 == 0)
    goto g3553;
  t5 = *(u64 *)(iSP + -8);
  *(u64 *)(iSP + 24) = t5;
  arg1 = arg1 - 1;
  if (arg1 == 0)
    goto g3553;
  t5 = *(u64 *)(iSP + -16);
  *(u64 *)(iSP + 16) = t5;
  arg1 = arg1 - 1;
  if (arg1 == 0)
    goto g3553;
  t5 = *(u64 *)(iSP + -24);
  *(u64 *)(iSP + 8) = t5;
  arg1 = arg1 - 1;

g3553:
  if (_trace) printf("g3553:\n");
  iSP = iSP + 32;
  t5 = *(s32 *)&processor->continuation;
  t7 = *((s32 *)(&processor->continuation)+1);
  t5 = (u32)t5;
  t8 = (8192) << 16;
  t4 = (u32)t4;
  t7 = t7 | 192;
  *(u32 *)iFP = t5;
  /* write the stack cache */
  *(u32 *)(iFP + 4) = t7;
  t8 = t4 & t8;
  t8 = t8 >> 2;
  t6 = Type_Fixnum+0xC0;
  t8 = t4 | t8;
  *(u32 *)(iFP + 8) = t8;
  /* write the stack cache */
  *(u32 *)(iFP + 12) = t6;
  iLP = iSP + 8;
  t6 = Type_Fixnum;
  t8 = t11;
  *(u32 *)(iFP + 16) = t8;
  /* write the stack cache */
  *(u32 *)(iFP + 20) = t6;
  /* Convert PC to a real continuation. */
  t6 = iPC & 1;
  /* convert PC to a real word address. */
  t8 = iPC >> 1;
  t6 = t6 + Type_EvenPC;
  *(u32 *)(iFP + 24) = t8;
  /* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  /* Get CR mask */
  t7 = *(u64 *)&(processor->fccrtrapmask);
  /* 1<<18! */
  t5 = (ValueDisposition_Value*4) << 16;
  /* Arg size */
  t6 = iLP - iFP;
  /* Caller Frame Size */
  t8 = iFP - t1;
  /* Arg size in words */
  t6 = t6 >> 3;
  /* Caller Frame Size in words in place */
  t8 = t8 << 6;
  t5 = t5 | t6;
  t5 = t5 | t8;
  /* TagCdr. */
  t9 = t2 >> 6;
  t6 = t4 >> 30;
  t8 = t9 - t6;
  if ((s64)t8 >= 0)
    t6 = t9;
  t6 = t6 << 30;
  /* Mask off unwanted bits */
  t4 = t4 & t7;
  /* Add trap mode */
  t4 = t4 | t6;
  /* Add argsize, apply, disposition, caller FS */
  t4 = t4 | t5;
  *(u32 *)&processor->control = t4;
  /* Convert PC to a real continuation. */
  t6 = t12 & 1;
  /* convert PC to a real word address. */
  t8 = t12 >> 1;
  t6 = t6 + Type_EvenPC;
  *(u64 *)&processor->continuationcp = zero;
  *((u32 *)(&processor->continuation)+1) = t6;
  *(u32 *)&processor->continuation = t8;
  /* Convert real continuation to PC. */
  iPC = t2 & 1;
  iPC = t3 + iPC;
  iPC = t3 + iPC;
  /* Save current trap mode */
  t6 = t4 >> 30;
  /* Isolate trap mode */
  t4 = t4 >> 30;
  /* Limit for emulator mode */
  t8 = *(s32 *)&processor->cslimit;
  /* Limit for extra stack and higher modes */
  t9 = *(s32 *)&processor->csextralimit;
  /* Get the right limit for the current trap mode */
  if (t4)
    t8 = t9;
  /* Might have been sign extended */
  t8 = (u32)t8;
  /* Convert stack cache address to VMA */
  t9 = *(u64 *)&(processor->stackcachedata);
  t4 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t9 = iSP - t9;
  /* convert byte address to word address */
  t9 = t9 >> 3;
  /* reconstruct VMA */
  t4 = t9 + t4;
  /* Check for overflow */
  t9 = ((s64)t4 < (s64)t8) ? 1 : 0;
  /* Jump if overflow */
  if (t9 == 0)
    goto g3554;
  /* Convert a halfword address into a CP pointer. */
  /* Get third byte into bottom */
  iCP = iPC >> (CacheLine_RShift & 63);
  /* get the base of the icache */
  t9 = *(u64 *)&(processor->icachebase);
  t8 = zero + -1;
  t8 = t8 + ((4) << 16);
  /* Now third byte is zero-shifted */
  iCP = iCP << (CacheLine_LShift & 63);
  iCP = iPC + iCP;
  iCP = iCP & t8;
  /* temp=cpos*32 */
  t8 = iCP << 5;
  /* cpos=cpos*16 */
  iCP = iCP << 4;
  /* temp2=base+cpos*32 */
  t9 = t9 + t8;
  /* cpos=base+cpos*48 */
  iCP = t9 + iCP;
  goto cachevalid;

g3554:
  if (_trace) printf("g3554:\n");
  /* Take the overflow if in emulator mode */
  if (t6 == 0)
    goto stackoverflow;
  goto fatalstackoverflow;

g3568:
  if (_trace) printf("g3568:\n");
  arg2 = 8;
  goto stackcacheoverflowhandler;

g3558:
  if (_trace) printf("g3558:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t9 = (t9 * 8) + t7;
  t3 = *(s32 *)t9;
  /* Read from stack cache */
  t2 = *(s32 *)(t9 + 4);
  goto g3557;

g3560:
  if (_trace) printf("g3560:\n");
  if ((t6 & 1) == 0)
    goto g3559;
  /* Do the indirect thing */
  t8 = (u32)t3;
  goto g3556;

g3559:
  if (_trace) printf("g3559:\n");
  /* Load the memory action table for cycle */
  t5 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t6 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t8;
  /* Adjust for a longword load */
  t6 = (t6 * 4) + t5;
  /* Get the memory action */
  t5 = *(s32 *)t6;

g3564:
  if (_trace) printf("g3564:\n");
  t6 = t5 & MemoryActionTransform;
  if (t6 == 0)
    goto g3563;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto g3567;
#ifndef MINIMA

g3563:
#endif
#ifdef MINIMA

g3563:
  if (_trace) printf("g3563:\n");
  t6 = t5 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t6 == 0)
    goto g3562;
  t9 = t8 << 1;
  t6 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t9 = t9 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t9 = (s32)t9 + (s32)t6;
  /* Clear sign-extension */
  t9 = (u32)t9;
  t7 = (t9 * 4) + t7;
  /* Fetch the key */
  t9 = *(s32 *)t7;
  /* Fetch value */
  t3 = *(s32 *)(t7 + 4);
  /* Compare */
  t6 = (s32)t8 - (s32)t9;
  /* Trap on miss */
  if (t6 != 0)
    goto g3566;
  /* Extract the pointer, and indirect */
  t8 = (u32)t3;
  goto g3556;

g3566:
  if (_trace) printf("g3566:\n");
  goto dbcachemisstrap;
#endif

g3562:
  /* Perform memory action */
  arg1 = t5;
  arg2 = 0;
  goto performmemoryaction;

g3555:
  if (_trace) printf("g3555:\n");
  goto illegaltrapvector;

/* end HandleException */
/* start STACKOVERFLOW */


stackoverflow:
  if (_trace) printf("stackoverflow:\n");
  *(u64 *)&processor->restartsp = iSP;
  /* save old frame pointer */
  t1 = iFP;
  t4 = *(s32 *)&processor->control;
  t9 = *(u64 *)&(processor->fepmodetrapvecaddress);
  t8 = *(u64 *)&(processor->trapvecbase);
  t5 = (-16384) << 16;
  t6 = t4 >> 30;
  /* Set trap mode to 3 */
  t5 = t4 | t5;
  t6 = t6 & 3;
  *(u32 *)&processor->control = t5;
  t7 = t6 - 3;
  t8 = t8 + TrapVector_StackOverflow;
  if (t7 == 0)
    t8 = t9;
  /* Record TVI for tracing (if enabled) */
  *(u64 *)&processor->tvi = t8;
  /* Memory Read Internal */

g3572:
  /* Base of stack cache */
  t9 = *(u64 *)&(processor->stackcachebasevma);
  t6 = t8 + ivory;
  t7 = *(s32 *)&processor->scovlimit;
  t3 = (t6 * 4);
  t2 = LDQ_U(t6);
  /* Stack cache offset */
  t9 = t8 - t9;
  t5 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t7 = ((u64)t9 < (u64)t7) ? 1 : 0;
  t3 = *(s32 *)t3;
  t2 = (u8)(t2 >> ((t6&7)*8));
  if (t7 != 0)
    goto g3574;

g3573:
  t6 = zero + 240;
  t5 = t5 >> (t2 & 63);
  t6 = t6 >> (t2 & 63);
  t3 = (u32)t3;
  if (t5 & 1)
    goto g3576;

g3583:
  t5 = t2 - Type_EvenPC;
  /* Strip CDR code, low bits */
  t5 = t5 & 62;
  if (t5 != 0)
    goto g3571;
  /* Restore the cr */
  *(u32 *)&processor->control = t4;
  /* Current stack cache limit (words) */
  t8 = *(s32 *)&processor->scovlimit;
  t5 = zero + 128;
  /* Alpha base of stack cache */
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Account for what we're about to push */
  t5 = t5 + 8;
  /* SCA of desired end of cache */
  t5 = (t5 * 8) + iSP;
  /* SCA of current end of cache */
  t6 = (t8 * 8) + t6;
  t8 = ((s64)t5 <= (s64)t6) ? 1 : 0;
  /* We're done if new SCA is within bounds */
  if (t8 == 0)
    goto g3584;
  iFP = (zero * 8) + zero;
  iFP = iSP - iFP;
  iFP = iFP + 8;
  if (zero == 0)
    goto g3569;
  t5 = *(u64 *)iSP;
  *(u64 *)(iSP + 32) = t5;
  if (zero == 0)
    goto g3569;
  t5 = *(u64 *)(iSP + -8);
  *(u64 *)(iSP + 24) = t5;
  if (zero == 0)
    goto g3569;
  t5 = *(u64 *)(iSP + -16);
  *(u64 *)(iSP + 16) = t5;
  if (zero == 0)
    goto g3569;
  t5 = *(u64 *)(iSP + -24);
  *(u64 *)(iSP + 8) = t5;

g3569:
  if (_trace) printf("g3569:\n");
  iSP = iSP + 32;
  t5 = *(s32 *)&processor->continuation;
  t7 = *((s32 *)(&processor->continuation)+1);
  t5 = (u32)t5;
  t8 = (8192) << 16;
  t4 = (u32)t4;
  t7 = t7 | 192;
  *(u32 *)iFP = t5;
  /* write the stack cache */
  *(u32 *)(iFP + 4) = t7;
  t8 = t4 & t8;
  t8 = t8 >> 2;
  t6 = Type_Fixnum+0xC0;
  t8 = t4 | t8;
  *(u32 *)(iFP + 8) = t8;
  /* write the stack cache */
  *(u32 *)(iFP + 12) = t6;
  iLP = iSP + 8;
  t6 = Type_Fixnum;
  t8 = TrapVector_StackOverflow;
  *(u32 *)(iFP + 16) = t8;
  /* write the stack cache */
  *(u32 *)(iFP + 20) = t6;
  /* Convert PC to a real continuation. */
  t6 = iPC & 1;
  /* convert PC to a real word address. */
  t8 = iPC >> 1;
  t6 = t6 + Type_EvenPC;
  *(u32 *)(iFP + 24) = t8;
  /* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  /* Get CR mask */
  t7 = *(u64 *)&(processor->fccrtrapmask);
  /* 1<<18! */
  t5 = (ValueDisposition_Value*4) << 16;
  /* Arg size */
  t6 = iLP - iFP;
  /* Caller Frame Size */
  t8 = iFP - t1;
  /* Arg size in words */
  t6 = t6 >> 3;
  /* Caller Frame Size in words in place */
  t8 = t8 << 6;
  t5 = t5 | t6;
  t5 = t5 | t8;
  /* TagCdr. */
  t9 = t2 >> 6;
  t6 = t4 >> 30;
  t8 = t9 - t6;
  if ((s64)t8 >= 0)
    t6 = t9;
  t6 = t6 << 30;
  /* Mask off unwanted bits */
  t4 = t4 & t7;
  /* Add trap mode */
  t4 = t4 | t6;
  /* Add argsize, apply, disposition, caller FS */
  t4 = t4 | t5;
  *(u32 *)&processor->control = t4;
  /* Convert PC to a real continuation. */
  t6 = iPC & 1;
  /* convert PC to a real word address. */
  t8 = iPC >> 1;
  t6 = t6 + Type_EvenPC;
  *(u64 *)&processor->continuationcp = zero;
  *((u32 *)(&processor->continuation)+1) = t6;
  *(u32 *)&processor->continuation = t8;
  /* Convert real continuation to PC. */
  iPC = t2 & 1;
  iPC = t3 + iPC;
  iPC = t3 + iPC;
  /* Save current trap mode */
  t6 = t4 >> 30;
  /* Isolate trap mode */
  t4 = t4 >> 30;
  /* Limit for emulator mode */
  t8 = *(s32 *)&processor->cslimit;
  /* Limit for extra stack and higher modes */
  t9 = *(s32 *)&processor->csextralimit;
  /* Get the right limit for the current trap mode */
  if (t4)
    t8 = t9;
  /* Might have been sign extended */
  t8 = (u32)t8;
  /* Convert stack cache address to VMA */
  t9 = *(u64 *)&(processor->stackcachedata);
  t4 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t9 = iSP - t9;
  /* convert byte address to word address */
  t9 = t9 >> 3;
  /* reconstruct VMA */
  t4 = t9 + t4;
  /* Check for overflow */
  t9 = ((s64)t4 < (s64)t8) ? 1 : 0;
  /* Jump if overflow */
  if (t9 == 0)
    goto g3570;
  /* Convert a halfword address into a CP pointer. */
  /* Get third byte into bottom */
  iCP = iPC >> (CacheLine_RShift & 63);
  /* get the base of the icache */
  t9 = *(u64 *)&(processor->icachebase);
  t8 = zero + -1;
  t8 = t8 + ((4) << 16);
  /* Now third byte is zero-shifted */
  iCP = iCP << (CacheLine_LShift & 63);
  iCP = iPC + iCP;
  iCP = iCP & t8;
  /* temp=cpos*32 */
  t8 = iCP << 5;
  /* cpos=cpos*16 */
  iCP = iCP << 4;
  /* temp2=base+cpos*32 */
  t9 = t9 + t8;
  /* cpos=base+cpos*48 */
  iCP = t9 + iCP;
  goto cachevalid;

g3570:
  if (_trace) printf("g3570:\n");
  /* Take the overflow if in emulator mode */
  if (t6 == 0)
    goto stackoverflow;
  goto fatalstackoverflow;

g3584:
  if (_trace) printf("g3584:\n");
  arg2 = 8;
  goto stackcacheoverflowhandler;

g3574:
  if (_trace) printf("g3574:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t9 = (t9 * 8) + t7;
  t3 = *(s32 *)t9;
  /* Read from stack cache */
  t2 = *(s32 *)(t9 + 4);
  goto g3573;

g3576:
  if (_trace) printf("g3576:\n");
  if ((t6 & 1) == 0)
    goto g3575;
  /* Do the indirect thing */
  t8 = (u32)t3;
  goto g3572;

g3575:
  if (_trace) printf("g3575:\n");
  /* Load the memory action table for cycle */
  t5 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t6 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t8;
  /* Adjust for a longword load */
  t6 = (t6 * 4) + t5;
  /* Get the memory action */
  t5 = *(s32 *)t6;

g3580:
  if (_trace) printf("g3580:\n");
  t6 = t5 & MemoryActionTransform;
  if (t6 == 0)
    goto g3579;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto g3583;
#ifndef MINIMA

g3579:
#endif
#ifdef MINIMA

g3579:
  if (_trace) printf("g3579:\n");
  t6 = t5 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t6 == 0)
    goto g3578;
  t9 = t8 << 1;
  t6 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t9 = t9 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t9 = (s32)t9 + (s32)t6;
  /* Clear sign-extension */
  t9 = (u32)t9;
  t7 = (t9 * 4) + t7;
  /* Fetch the key */
  t9 = *(s32 *)t7;
  /* Fetch value */
  t3 = *(s32 *)(t7 + 4);
  /* Compare */
  t6 = (s32)t8 - (s32)t9;
  /* Trap on miss */
  if (t6 != 0)
    goto g3582;
  /* Extract the pointer, and indirect */
  t8 = (u32)t3;
  goto g3572;

g3582:
  if (_trace) printf("g3582:\n");
  goto dbcachemisstrap;
#endif

g3578:
  /* Perform memory action */
  arg1 = t5;
  arg2 = 0;
  goto performmemoryaction;

g3571:
  if (_trace) printf("g3571:\n");
  goto illegaltrapvector;

/* end STACKOVERFLOW */
/* start StartPreTrap */


startpretrap:
  if (_trace) printf("startpretrap:\n");
  t2 = *(u64 *)&(processor->linkage);
  if (t2 != 0)
    goto nativeexception;
  t4 = *(s32 *)&processor->control;
  t9 = *(u64 *)&(processor->fepmodetrapvecaddress);
  t8 = *(u64 *)&(processor->trapvecbase);
  t5 = (-16384) << 16;
  t6 = t4 >> 30;
  /* Set trap mode to 3 */
  t5 = t4 | t5;
  t6 = t6 & 3;
  *(u32 *)&processor->control = t5;
  t7 = t6 - 3;
  t8 = t8 + t10;
  if (t7 == 0)
    t8 = t9;
  /* Record TVI for tracing (if enabled) */
  *(u64 *)&processor->tvi = t8;
  /* Memory Read Internal */

g3586:
  /* Base of stack cache */
  t9 = *(u64 *)&(processor->stackcachebasevma);
  t6 = t8 + ivory;
  t7 = *(s32 *)&processor->scovlimit;
  t3 = (t6 * 4);
  t2 = LDQ_U(t6);
  /* Stack cache offset */
  t9 = t8 - t9;
  t5 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t7 = ((u64)t9 < (u64)t7) ? 1 : 0;
  t3 = *(s32 *)t3;
  t2 = (u8)(t2 >> ((t6&7)*8));
  if (t7 != 0)
    goto g3588;

g3587:
  t6 = zero + 240;
  t5 = t5 >> (t2 & 63);
  t6 = t6 >> (t2 & 63);
  t3 = (u32)t3;
  if (t5 & 1)
    goto g3590;

g3597:
  t5 = t2 - Type_EvenPC;
  /* Strip CDR code, low bits */
  t5 = t5 & 62;
  if (t5 != 0)
    goto g3585;
  /* Restore the cr */
  *(u32 *)&processor->control = t4;
  iSP = *(u64 *)&(processor->restartsp);
  /* Current stack cache limit (words) */
  t7 = *(s32 *)&processor->scovlimit;
  t4 = zero + 128;
  /* Alpha base of stack cache */
  t5 = *(u64 *)&(processor->stackcachedata);
  /* Account for what we're about to push */
  t4 = t4 + 8;
  /* SCA of desired end of cache */
  t4 = (t4 * 8) + iSP;
  /* SCA of current end of cache */
  t5 = (t7 * 8) + t5;
  t7 = ((s64)t4 <= (s64)t5) ? 1 : 0;
  /* We're done if new SCA is within bounds */
  if (t7 == 0)
    goto g3598;
  t5 = *(s32 *)&processor->continuation;
  t4 = *((s32 *)(&processor->continuation)+1);
  t5 = (u32)t5;
  t7 = *(s32 *)&processor->control;
  t7 = (u32)t7;
  t4 = t4 | 192;
  *(u32 *)(iSP + 8) = t5;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  t6 = Type_Fixnum+0xC0;
  *(u32 *)(iSP + 8) = t7;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  t6 = t10;
  t8 = Type_Fixnum;
  *(u32 *)(iSP + 8) = t6;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  /* Convert PC to a real continuation. */
  t6 = iPC & 1;
  /* convert PC to a real word address. */
  t8 = iPC >> 1;
  t6 = t6 + Type_EvenPC;
  *((u32 *)(&processor->continuation)+1) = t6;
  *(u32 *)&processor->continuation = t8;
  *(u64 *)&processor->continuationcp = iCP;
  /* set CDR-NEXT */
  t9 = t6 & 63;
  *(u32 *)(iSP + 8) = t8;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t9;
  iSP = iSP + 8;
  goto *r0; /* ret */

g3598:
  if (_trace) printf("g3598:\n");
  arg2 = 8;
  goto stackcacheoverflowhandler;

g3588:
  if (_trace) printf("g3588:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t9 = (t9 * 8) + t7;
  t3 = *(s32 *)t9;
  /* Read from stack cache */
  t2 = *(s32 *)(t9 + 4);
  goto g3587;

g3590:
  if (_trace) printf("g3590:\n");
  if ((t6 & 1) == 0)
    goto g3589;
  /* Do the indirect thing */
  t8 = (u32)t3;
  goto g3586;

g3589:
  if (_trace) printf("g3589:\n");
  /* Load the memory action table for cycle */
  t5 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t6 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t8;
  /* Adjust for a longword load */
  t6 = (t6 * 4) + t5;
  /* Get the memory action */
  t5 = *(s32 *)t6;

g3594:
  if (_trace) printf("g3594:\n");
  t6 = t5 & MemoryActionTransform;
  if (t6 == 0)
    goto g3593;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto g3597;
#ifndef MINIMA

g3593:
#endif
#ifdef MINIMA

g3593:
  if (_trace) printf("g3593:\n");
  t6 = t5 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t6 == 0)
    goto g3592;
  t9 = t8 << 1;
  t6 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t9 = t9 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t9 = (s32)t9 + (s32)t6;
  /* Clear sign-extension */
  t9 = (u32)t9;
  t7 = (t9 * 4) + t7;
  /* Fetch the key */
  t9 = *(s32 *)t7;
  /* Fetch value */
  t3 = *(s32 *)(t7 + 4);
  /* Compare */
  t6 = (s32)t8 - (s32)t9;
  /* Trap on miss */
  if (t6 != 0)
    goto g3596;
  /* Extract the pointer, and indirect */
  t8 = (u32)t3;
  goto g3586;

g3596:
  if (_trace) printf("g3596:\n");
  goto dbcachemisstrap;
#endif

g3592:
  /* Perform memory action */
  arg1 = t5;
  arg2 = 0;
  goto performmemoryaction;

g3585:
  if (_trace) printf("g3585:\n");
  goto illegaltrapvector;

/* end StartPreTrap */
/* start FinishPreTrap */


finishpretrap:
  if (_trace) printf("finishpretrap:\n");
  iFP = *(u64 *)&(processor->restartsp);
  /* iFP now points to the start of our new frame */
  iFP = iFP + 8;
  /* Points beyond the last argument */
  iLP = iSP + 8;
  /* Get CR mask */
  t4 = *(u64 *)&(processor->fccrtrapmask);
  /* 1<<18! */
  t5 = (ValueDisposition_Value*4) << 16;
  /* Arg size */
  t6 = iLP - iFP;
  /* Caller Frame Size */
  t8 = iFP - t1;
  /* Arg size in words */
  t6 = t6 >> 3;
  /* Caller Frame Size in words in place */
  t8 = t8 << 6;
  t5 = t5 | t6;
  t5 = t5 | t8;
  /* TagCdr. */
  t9 = t2 >> 6;
  t6 = t7 >> 30;
  t8 = t9 - t6;
  if ((s64)t8 >= 0)
    t6 = t9;
  t6 = t6 << 30;
  /* Mask off unwanted bits */
  t7 = t7 & t4;
  /* Add trap mode */
  t7 = t7 | t6;
  /* Add argsize, apply, disposition, caller FS */
  t7 = t7 | t5;
  *(u32 *)&processor->control = t7;
  /* Convert real continuation to PC. */
  iPC = t2 & 1;
  iPC = t3 + iPC;
  iPC = t3 + iPC;
  /* Check for stack overflow */
  /* Isolate trap mode */
  t7 = t7 >> 30;
  /* Limit for emulator mode */
  t8 = *(s32 *)&processor->cslimit;
  /* Limit for extra stack and higher modes */
  t9 = *(s32 *)&processor->csextralimit;
  /* Get the right limit for the current trap mode */
  if (t7)
    t8 = t9;
  /* Might have been sign extended */
  t8 = (u32)t8;
  /* Convert stack cache address to VMA */
  t9 = *(u64 *)&(processor->stackcachedata);
  t7 = *(u64 *)&(processor->stackcachebasevma);
  /* stack cache base relative offset */
  t9 = iSP - t9;
  /* convert byte address to word address */
  t9 = t9 >> 3;
  /* reconstruct VMA */
  t7 = t9 + t7;
  /* Check for overflow */
  t9 = ((s64)t7 < (s64)t8) ? 1 : 0;
  /* Jump if overflow */
  if (t9 == 0)
    goto stackoverflow;
  /* Convert a halfword address into a CP pointer. */
  /* Get third byte into bottom */
  iCP = iPC >> (CacheLine_RShift & 63);
  /* get the base of the icache */
  t9 = *(u64 *)&(processor->icachebase);
  t8 = zero + -1;
  t8 = t8 + ((4) << 16);
  /* Now third byte is zero-shifted */
  iCP = iCP << (CacheLine_LShift & 63);
  iCP = iPC + iCP;
  iCP = iCP & t8;
  /* temp=cpos*32 */
  t8 = iCP << 5;
  /* cpos=cpos*16 */
  iCP = iCP << 4;
  /* temp2=base+cpos*32 */
  t9 = t9 + t8;
  /* cpos=base+cpos*48 */
  iCP = t9 + iCP;
  goto cachevalid;

/* end FinishPreTrap */
/* start ILLEGALOPERAND */


illegaloperand:
  if (_trace) printf("illegaloperand:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + trapmetererror;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_Error;
  r0 = (u64)&&return0091;
  goto startpretrap;
return0091:
  t11 = Type_Fixnum;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t11;
  iSP = iSP + 8;
  t11 = Type_Locative;
  *(u32 *)(iSP + 8) = arg5;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t11;
  iSP = iSP + 8;
  goto finishpretrap;

/* end ILLEGALOPERAND */
/* start RESETTRAP */


resettrap:
  if (_trace) printf("resettrap:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + TrapVector_Reset;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_Reset;
  r0 = (u64)&&return0092;
  goto startpretrap;
return0092:
  goto finishpretrap;

/* end RESETTRAP */
/* start PULLAPPLYARGSTRAP */


pullapplyargstrap:
  if (_trace) printf("pullapplyargstrap:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + TrapVector_PullApplyArgs;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  t12 = *(s32 *)iSP;
  t11 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t12 = (u32)t12;
  *(u64 *)&processor->restartsp = iSP;
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_PullApplyArgs;
  r0 = (u64)&&return0093;
  goto startpretrap;
return0093:
  arg2 = Type_Fixnum;
  *(u32 *)(iSP + 8) = arg1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = arg2;
  iSP = iSP + 8;
  /* set CDR-NEXT */
  arg2 = t11 & 63;
  *(u32 *)(iSP + 8) = t12;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = arg2;
  iSP = iSP + 8;
  goto finishpretrap;

/* end PULLAPPLYARGSTRAP */
/* start TRACETRAP */


tracetrap:
  if (_trace) printf("tracetrap:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + TrapVector_Trace;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_Trace;
  r0 = (u64)&&return0094;
  goto startpretrap;
return0094:
  goto finishpretrap;

/* end TRACETRAP */
/* start PREEMPTREQUESTTRAP */


preemptrequesttrap:
  if (_trace) printf("preemptrequesttrap:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + TrapVector_PreemptRequest;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_PreemptRequest;
  r0 = (u64)&&return0095;
  goto startpretrap;
return0095:
  goto finishpretrap;

/* end PREEMPTREQUESTTRAP */
/* start HIGHPRIORITYSEQUENCEBREAK */


highprioritysequencebreak:
  if (_trace) printf("highprioritysequencebreak:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + TrapVector_HighPrioritySequenceBreak;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_HighPrioritySequenceBreak;
  r0 = (u64)&&return0096;
  goto startpretrap;
return0096:
  goto finishpretrap;

/* end HIGHPRIORITYSEQUENCEBREAK */
/* start LOWPRIORITYSEQUENCEBREAK */


lowprioritysequencebreak:
  if (_trace) printf("lowprioritysequencebreak:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + TrapVector_LowPrioritySequenceBreak;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_LowPrioritySequenceBreak;
  r0 = (u64)&&return0097;
  goto startpretrap;
return0097:
  goto finishpretrap;

/* end LOWPRIORITYSEQUENCEBREAK */
/* start DBUNWINDFRAMETRAP */


dbunwindframetrap:
  if (_trace) printf("dbunwindframetrap:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + TrapVector_DBUnwindFrame;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_DBUnwindFrame;
  r0 = (u64)&&return0098;
  goto startpretrap;
return0098:
  t11 = *(u64 *)&(processor->bindingstackpointer);
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;

/* end DBUNWINDFRAMETRAP */
/* start DBUNWINDCATCHTRAP */


dbunwindcatchtrap:
  if (_trace) printf("dbunwindcatchtrap:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + TrapVector_DBUnwindCatch;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_DBUnwindCatch;
  r0 = (u64)&&return0099;
  goto startpretrap;
return0099:
  t11 = *(u64 *)&(processor->bindingstackpointer);
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;

/* end DBUNWINDCATCHTRAP */
/* start TRANSPORTTRAP */


transporttrap:
  if (_trace) printf("transporttrap:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + trapmetertransport;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* Preserve VMA against reading trap vector */
  t11 = *(u64 *)&(processor->vma);
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_Transport;
  r0 = (u64)&&return0100;
  goto startpretrap;
return0100:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;

/* end TRANSPORTTRAP */
/* start MONITORTRAP */


monitortrap:
  if (_trace) printf("monitortrap:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + trapmetermonitor;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* Preserve VMA against reading trap vector */
  t11 = *(u64 *)&(processor->vma);
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_Monitor;
  r0 = (u64)&&return0101;
  goto startpretrap;
return0101:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;

/* end MONITORTRAP */
/* start PAGENOTRESIDENT */


pagenotresident:
  if (_trace) printf("pagenotresident:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + trapmeterpagenotresident;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* Preserve VMA against reading trap vector */
  t11 = *(u64 *)&(processor->vma);
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_PageNotResident;
  r0 = (u64)&&return0102;
  goto startpretrap;
return0102:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;

/* end PAGENOTRESIDENT */
/* start PAGEFAULTREQUESTHANDLER */


pagefaultrequesthandler:
  if (_trace) printf("pagefaultrequesthandler:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + trapmeterpagefaultrequest;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* Preserve VMA against reading trap vector */
  t11 = *(u64 *)&(processor->vma);
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_PageFaultRequest;
  r0 = (u64)&&return0103;
  goto startpretrap;
return0103:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;

/* end PAGEFAULTREQUESTHANDLER */
/* start PAGEWRITEFAULT */


pagewritefault:
  if (_trace) printf("pagewritefault:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + trapmeterpagewritefault;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* Preserve VMA against reading trap vector */
  t11 = *(u64 *)&(processor->vma);
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_PageWriteFault;
  r0 = (u64)&&return0104;
  goto startpretrap;
return0104:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;

/* end PAGEWRITEFAULT */
#ifdef MINIMA
/* start DBCACHEMISSTRAP */


dbcachemisstrap:
  if (_trace) printf("dbcachemisstrap:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + trapmeterdbcachemiss;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* Preserve VMA against reading trap vector */
  t11 = *(u64 *)&(processor->vma);
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = trapvectordbcachemiss;
  r0 = (u64)&&return0105;
  goto startpretrap;
return0105:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;

/* end DBCACHEMISSTRAP */
#endif
  /* The following handlers should never be invoked. */
/* start UNCORRECTABLEMEMORYERROR */


uncorrectablememoryerror:
  if (_trace) printf("uncorrectablememoryerror:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + trapmeteruncorrectablememoryerror;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* Preserve VMA against reading trap vector */
  t11 = *(u64 *)&(processor->vma);
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_UncorrectableMemoryError;
  r0 = (u64)&&return0106;
  goto startpretrap;
return0106:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;

/* end UNCORRECTABLEMEMORYERROR */
/* start BUSERROR */


buserror:
  if (_trace) printf("buserror:\n");
#ifdef TRAPMETERING
  /* pointer to trap data vector */
  t1 = *(u64 *)&(processor->trapmeterdata);
  /* get the vector index */
  t2 = zero + trapmetermemorybuserror;
  t1 = (t2 * 8) + t1;
  /* get the old value */
  t2 = *(u64 *)t1;
  /* increment it */
  t2 = t2 + 1;
  /* and store it back */
  *(u64 *)t1 = t2;
#endif
  /* Preserve VMA against reading trap vector */
  t11 = *(u64 *)&(processor->vma);
  /* save old frame pointer */
  t1 = iFP;
  /* save the trap vector index */
  t10 = TrapVector_MemoryBusError;
  r0 = (u64)&&return0107;
  goto startpretrap;
return0107:
  t12 = Type_Locative;
  *(u32 *)(iSP + 8) = t11;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t12;
  iSP = iSP + 8;
  goto finishpretrap;

/* end BUSERROR */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifuntrap.as */
