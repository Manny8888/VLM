/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifuninst.as
 ************************************************************************/

  /* Instance variable accessors.. */
/* start DoPopInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPopInstanceVariable */

dopopinstancevariable:
  if (_trace) printf("dopopinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPopInstanceVariableIM:
  if (_trace) printf("DoPopInstanceVariableIM:\n");

DoPopInstanceVariableSP:
  if (_trace) printf("DoPopInstanceVariableSP:\n");

DoPopInstanceVariableLP:
  if (_trace) printf("DoPopInstanceVariableLP:\n");

DoPopInstanceVariableFP:
  if (_trace) printf("DoPopInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
  /* Map */
  arg1 = *(s32 *)(iFP + 16);
  t1 = *(s32 *)(iFP + 20);
  arg1 = (u32)arg1;
  t4 = t1 - Type_Array;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto ivbadmap;
  /* Memory Read Internal */

g4673:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g4675;

g4674:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  if (t10 & 1)
    goto g4677;

g4682:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;
  /* J. if mapping-table-index-out-of-bounds */
  if ((s64)t5 <= 0)
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

g4683:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g4685;

g4684:
  t9 = zero + 240;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g4687;

g4694:
  t3 = t2;
  t6 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto popiviex;
  /* Self */
  arg1 = *(s32 *)(iFP + 24);
  t6 = *(s32 *)(iFP + 28);
  arg1 = (u32)arg1;
  t5 = t6 - Type_Instance;
  /* Strip CDR code, low bits */
  t5 = t5 & 60;
  if (t5 != 0)
    goto ivbadinst;
  /* Unshifted cdr code */
  t5 = t6 & 192;
  /* Check for CDR code 1 */
  t5 = t5 - 64;
  /* J. if CDR code is not 1 */
  if (t5 != 0)
    goto g4672;

g4671:
  if (_trace) printf("g4671:\n");
  arg1 = arg1 + t3;

g4670:
  if (_trace) printf("g4670:\n");
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g4695:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g4697;

g4696:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g4699;

g4705:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g4707:
  if (_trace) printf("g4707:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g4706;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

popiviex:
  if (_trace) printf("popiviex:\n");
  t1 = zero + 8;
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

g4706:
  if (_trace) printf("g4706:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g4697:
  if (_trace) printf("g4697:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g4696;

g4699:
  if (_trace) printf("g4699:\n");
  if ((t8 & 1) == 0)
    goto g4698;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g4695;

g4698:
  if (_trace) printf("g4698:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g4702:
#endif
#ifdef MINIMA

g4702:
  if (_trace) printf("g4702:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g4701;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g4704;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g4695;

g4704:
  if (_trace) printf("g4704:\n");
  goto dbcachemisstrap;
#endif

g4701:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

g4685:
  if (_trace) printf("g4685:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g4684;

g4687:
  if (_trace) printf("g4687:\n");
  if ((t9 & 1) == 0)
    goto g4686;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g4683;

g4686:
  if (_trace) printf("g4686:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g4691:
  if (_trace) printf("g4691:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0)
    goto g4690;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto g4694;
#ifndef MINIMA

g4690:
#endif
#ifdef MINIMA

g4690:
  if (_trace) printf("g4690:\n");
  t9 = t10 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t9 == 0)
    goto g4689;
  t7 = arg1 << 1;
  t9 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t9;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  t2 = *(s32 *)(t8 + 4);
  /* Compare */
  t9 = (s32)arg1 - (s32)t7;
  /* Trap on miss */
  if (t9 != 0)
    goto g4693;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t2;
  goto g4683;

g4693:
  if (_trace) printf("g4693:\n");
  goto dbcachemisstrap;
#endif

g4689:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

g4675:
  if (_trace) printf("g4675:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g4674;

g4677:
  if (_trace) printf("g4677:\n");
  if ((t9 & 1) == 0)
    goto g4676;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g4673;

g4676:
  if (_trace) printf("g4676:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g4679:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

g4672:
  if (_trace) printf("g4672:\n");
  t5 = arg1;
  /* Memory Read Internal */

g4708:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g4710;

g4709:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g4712;

g4717:
  t5 = t5 - arg1;
  if (t5 != 0)
    goto g4671;
  /* TagType. */
  t6 = t6 & 63;
  /* Set CDR code to 1 */
  t6 = t6 | 64;
  /* Update self */
  *(u32 *)(iFP + 24) = arg1;
  /* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto g4671;

g4710:
  if (_trace) printf("g4710:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g4709;

g4712:
  if (_trace) printf("g4712:\n");
  if ((t9 & 1) == 0)
    goto g4711;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g4708;

g4711:
  if (_trace) printf("g4711:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g4714:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoPopInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPopInstanceVariable */
/* start DoMovemInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoMovemInstanceVariable */

domoveminstancevariable:
  if (_trace) printf("domoveminstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoMovemInstanceVariableIM:
  if (_trace) printf("DoMovemInstanceVariableIM:\n");

DoMovemInstanceVariableSP:
  if (_trace) printf("DoMovemInstanceVariableSP:\n");

DoMovemInstanceVariableLP:
  if (_trace) printf("DoMovemInstanceVariableLP:\n");

DoMovemInstanceVariableFP:
  if (_trace) printf("DoMovemInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
  /* Map */
  arg1 = *(s32 *)(iFP + 16);
  t1 = *(s32 *)(iFP + 20);
  arg1 = (u32)arg1;
  t4 = t1 - Type_Array;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto ivbadmap;
  /* Memory Read Internal */

g4721:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g4723;

g4722:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  if (t10 & 1)
    goto g4725;

g4730:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;
  /* J. if mapping-table-index-out-of-bounds */
  if ((s64)t5 <= 0)
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

g4731:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g4733;

g4732:
  t9 = zero + 240;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g4735;

g4742:
  t3 = t2;
  t6 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto movemiviex;
  /* Self */
  arg1 = *(s32 *)(iFP + 24);
  t6 = *(s32 *)(iFP + 28);
  arg1 = (u32)arg1;
  t5 = t6 - Type_Instance;
  /* Strip CDR code, low bits */
  t5 = t5 & 60;
  if (t5 != 0)
    goto ivbadinst;
  /* Unshifted cdr code */
  t5 = t6 & 192;
  /* Check for CDR code 1 */
  t5 = t5 - 64;
  /* J. if CDR code is not 1 */
  if (t5 != 0)
    goto g4720;

g4719:
  if (_trace) printf("g4719:\n");
  arg1 = arg1 + t3;

g4718:
  if (_trace) printf("g4718:\n");
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  t1 = (u32)t1;
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g4743:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g4745;

g4744:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g4747;

g4753:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g4755:
  if (_trace) printf("g4755:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g4754;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

movemiviex:
  if (_trace) printf("movemiviex:\n");
  t1 = zero + 8;
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

g4754:
  if (_trace) printf("g4754:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g4745:
  if (_trace) printf("g4745:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g4744;

g4747:
  if (_trace) printf("g4747:\n");
  if ((t8 & 1) == 0)
    goto g4746;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g4743;

g4746:
  if (_trace) printf("g4746:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g4750:
#endif
#ifdef MINIMA

g4750:
  if (_trace) printf("g4750:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g4749;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g4752;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g4743;

g4752:
  if (_trace) printf("g4752:\n");
  goto dbcachemisstrap;
#endif

g4749:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

g4733:
  if (_trace) printf("g4733:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g4732;

g4735:
  if (_trace) printf("g4735:\n");
  if ((t9 & 1) == 0)
    goto g4734;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g4731;

g4734:
  if (_trace) printf("g4734:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g4739:
  if (_trace) printf("g4739:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0)
    goto g4738;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto g4742;
#ifndef MINIMA

g4738:
#endif
#ifdef MINIMA

g4738:
  if (_trace) printf("g4738:\n");
  t9 = t10 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t9 == 0)
    goto g4737;
  t7 = arg1 << 1;
  t9 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t9;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  t2 = *(s32 *)(t8 + 4);
  /* Compare */
  t9 = (s32)arg1 - (s32)t7;
  /* Trap on miss */
  if (t9 != 0)
    goto g4741;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t2;
  goto g4731;

g4741:
  if (_trace) printf("g4741:\n");
  goto dbcachemisstrap;
#endif

g4737:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

g4723:
  if (_trace) printf("g4723:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g4722;

g4725:
  if (_trace) printf("g4725:\n");
  if ((t9 & 1) == 0)
    goto g4724;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g4721;

g4724:
  if (_trace) printf("g4724:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g4727:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

g4720:
  if (_trace) printf("g4720:\n");
  t5 = arg1;
  /* Memory Read Internal */

g4756:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g4758;

g4757:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g4760;

g4765:
  t5 = t5 - arg1;
  if (t5 != 0)
    goto g4719;
  /* TagType. */
  t6 = t6 & 63;
  /* Set CDR code to 1 */
  t6 = t6 | 64;
  /* Update self */
  *(u32 *)(iFP + 24) = arg1;
  /* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto g4719;

g4758:
  if (_trace) printf("g4758:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g4757;

g4760:
  if (_trace) printf("g4760:\n");
  if ((t9 & 1) == 0)
    goto g4759;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g4756;

g4759:
  if (_trace) printf("g4759:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g4762:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoMovemInstanceVariable */
  /* End of Halfword operand from stack instruction - DoMovemInstanceVariable */
/* start DoPushAddressInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariable */

dopushaddressinstancevariable:
  if (_trace) printf("dopushaddressinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushAddressInstanceVariableIM:
  if (_trace) printf("DoPushAddressInstanceVariableIM:\n");

DoPushAddressInstanceVariableSP:
  if (_trace) printf("DoPushAddressInstanceVariableSP:\n");

DoPushAddressInstanceVariableLP:
  if (_trace) printf("DoPushAddressInstanceVariableLP:\n");

DoPushAddressInstanceVariableFP:
  if (_trace) printf("DoPushAddressInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
  /* Map */
  arg1 = *(s32 *)(iFP + 16);
  t1 = *(s32 *)(iFP + 20);
  arg1 = (u32)arg1;
  t4 = t1 - Type_Array;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto ivbadmap;
  /* Memory Read Internal */

g4769:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g4771;

g4770:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  if (t10 & 1)
    goto g4773;

g4778:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;
  /* J. if mapping-table-index-out-of-bounds */
  if ((s64)t5 <= 0)
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

g4779:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g4781;

g4780:
  t9 = zero + 240;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g4783;

g4790:
  t3 = t2;
  t6 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto pushadiviex;
  /* Self */
  arg1 = *(s32 *)(iFP + 24);
  t6 = *(s32 *)(iFP + 28);
  arg1 = (u32)arg1;
  t5 = t6 - Type_Instance;
  /* Strip CDR code, low bits */
  t5 = t5 & 60;
  if (t5 != 0)
    goto ivbadinst;
  /* Unshifted cdr code */
  t5 = t6 & 192;
  /* Check for CDR code 1 */
  t5 = t5 - 64;
  /* J. if CDR code is not 1 */
  if (t5 != 0)
    goto g4768;

g4767:
  if (_trace) printf("g4767:\n");
  arg1 = arg1 + t3;

g4766:
  if (_trace) printf("g4766:\n");
  t7 = Type_Locative;
  *(u32 *)(iSP + 8) = arg1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

pushadiviex:
  if (_trace) printf("pushadiviex:\n");
  t1 = zero + 8;
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

g4781:
  if (_trace) printf("g4781:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g4780;

g4783:
  if (_trace) printf("g4783:\n");
  if ((t9 & 1) == 0)
    goto g4782;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g4779;

g4782:
  if (_trace) printf("g4782:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g4787:
  if (_trace) printf("g4787:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0)
    goto g4786;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto g4790;
#ifndef MINIMA

g4786:
#endif
#ifdef MINIMA

g4786:
  if (_trace) printf("g4786:\n");
  t9 = t10 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t9 == 0)
    goto g4785;
  t7 = arg1 << 1;
  t9 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t9;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  t2 = *(s32 *)(t8 + 4);
  /* Compare */
  t9 = (s32)arg1 - (s32)t7;
  /* Trap on miss */
  if (t9 != 0)
    goto g4789;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t2;
  goto g4779;

g4789:
  if (_trace) printf("g4789:\n");
  goto dbcachemisstrap;
#endif

g4785:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

g4771:
  if (_trace) printf("g4771:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g4770;

g4773:
  if (_trace) printf("g4773:\n");
  if ((t9 & 1) == 0)
    goto g4772;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g4769;

g4772:
  if (_trace) printf("g4772:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g4775:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

g4768:
  if (_trace) printf("g4768:\n");
  t5 = arg1;
  /* Memory Read Internal */

g4791:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g4793;

g4792:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g4795;

g4800:
  t5 = t5 - arg1;
  if (t5 != 0)
    goto g4767;
  /* TagType. */
  t6 = t6 & 63;
  /* Set CDR code to 1 */
  t6 = t6 | 64;
  /* Update self */
  *(u32 *)(iFP + 24) = arg1;
  /* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto g4767;

g4793:
  if (_trace) printf("g4793:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g4792;

g4795:
  if (_trace) printf("g4795:\n");
  if ((t9 & 1) == 0)
    goto g4794;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g4791;

g4794:
  if (_trace) printf("g4794:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g4797:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoPushAddressInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPushAddressInstanceVariable */
/* start DoPushInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPushInstanceVariableOrdered */

dopushinstancevariableordered:
  if (_trace) printf("dopushinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushInstanceVariableOrderedIM:
  if (_trace) printf("DoPushInstanceVariableOrderedIM:\n");

DoPushInstanceVariableOrderedSP:
  if (_trace) printf("DoPushInstanceVariableOrderedSP:\n");

DoPushInstanceVariableOrderedLP:
  if (_trace) printf("DoPushInstanceVariableOrderedLP:\n");

DoPushInstanceVariableOrderedFP:
  if (_trace) printf("DoPushInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  /* Memory Read Internal */

g4801:
  t6 = arg1 + ivory;
  t1 = (t6 * 4);
  t2 = LDQ_U(t6);
  /* Stack cache offset */
  t4 = arg1 - arg5;
  t7 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t5 = ((u64)t4 < (u64)arg6) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t6&7)*8));
  if (t5 != 0)
    goto g4803;

g4802:
  t6 = zero + 240;
  t7 = t7 >> (t2 & 63);
  t6 = t6 >> (t2 & 63);
  if (t7 & 1)
    goto g4805;

g4812:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* set CDR-NEXT */
  t7 = t2 & 63;
  *(u32 *)(iSP + 8) = t1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;

g4803:
  if (_trace) printf("g4803:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t4 = (t4 * 8) + t5;
  t1 = *(s32 *)t4;
  /* Read from stack cache */
  t2 = *(s32 *)(t4 + 4);
  goto g4802;

g4805:
  if (_trace) printf("g4805:\n");
  if ((t6 & 1) == 0)
    goto g4804;
  /* Do the indirect thing */
  arg1 = (u32)t1;
  goto g4801;

g4804:
  if (_trace) printf("g4804:\n");
  /* Load the memory action table for cycle */
  t7 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t6 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t6 = (t6 * 4) + t7;
  /* Get the memory action */
  t7 = *(s32 *)t6;

g4809:
  if (_trace) printf("g4809:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0)
    goto g4808;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto g4812;
#ifndef MINIMA

g4808:
#endif
#ifdef MINIMA

g4808:
  if (_trace) printf("g4808:\n");
  t6 = t7 & MemoryActionBinding;
  t5 = *(u64 *)&(processor->dbcmask);
  if (t6 == 0)
    goto g4807;
  t4 = arg1 << 1;
  t6 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t4 = t4 & t5;
  t5 = 1;
  t5 = t5 << (ivorymemorydata & 63);
  t4 = (s32)t4 + (s32)t6;
  /* Clear sign-extension */
  t4 = (u32)t4;
  t5 = (t4 * 4) + t5;
  /* Fetch the key */
  t4 = *(s32 *)t5;
  /* Fetch value */
  t1 = *(s32 *)(t5 + 4);
  /* Compare */
  t6 = (s32)arg1 - (s32)t4;
  /* Trap on miss */
  if (t6 != 0)
    goto g4811;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t1;
  goto g4801;

g4811:
  if (_trace) printf("g4811:\n");
  goto dbcachemisstrap;
#endif

g4807:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

/* end DoPushInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPushInstanceVariableOrdered */
/* start DoPopInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPopInstanceVariableOrdered */

dopopinstancevariableordered:
  if (_trace) printf("dopopinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPopInstanceVariableOrderedIM:
  if (_trace) printf("DoPopInstanceVariableOrderedIM:\n");

DoPopInstanceVariableOrderedSP:
  if (_trace) printf("DoPopInstanceVariableOrderedSP:\n");

DoPopInstanceVariableOrderedLP:
  if (_trace) printf("DoPopInstanceVariableOrderedLP:\n");

DoPopInstanceVariableOrderedFP:
  if (_trace) printf("DoPopInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  /* Memory Read Internal */

g4813:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g4815;

g4814:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g4817;

g4823:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g4825:
  if (_trace) printf("g4825:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g4824;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

g4824:
  if (_trace) printf("g4824:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g4815:
  if (_trace) printf("g4815:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g4814;

g4817:
  if (_trace) printf("g4817:\n");
  if ((t8 & 1) == 0)
    goto g4816;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g4813;

g4816:
  if (_trace) printf("g4816:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g4820:
#endif
#ifdef MINIMA

g4820:
  if (_trace) printf("g4820:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g4819;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g4822;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g4813;

g4822:
  if (_trace) printf("g4822:\n");
  goto dbcachemisstrap;
#endif

g4819:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoPopInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPopInstanceVariableOrdered */
/* start DoMovemInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoMovemInstanceVariableOrdered */

domoveminstancevariableordered:
  if (_trace) printf("domoveminstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoMovemInstanceVariableOrderedIM:
  if (_trace) printf("DoMovemInstanceVariableOrderedIM:\n");

DoMovemInstanceVariableOrderedSP:
  if (_trace) printf("DoMovemInstanceVariableOrderedSP:\n");

DoMovemInstanceVariableOrderedLP:
  if (_trace) printf("DoMovemInstanceVariableOrderedLP:\n");

DoMovemInstanceVariableOrderedFP:
  if (_trace) printf("DoMovemInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  t1 = (u32)t1;
  /* Memory Read Internal */

g4826:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g4828;

g4827:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g4830;

g4836:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g4838:
  if (_trace) printf("g4838:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g4837;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

g4837:
  if (_trace) printf("g4837:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g4828:
  if (_trace) printf("g4828:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g4827;

g4830:
  if (_trace) printf("g4830:\n");
  if ((t8 & 1) == 0)
    goto g4829;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g4826;

g4829:
  if (_trace) printf("g4829:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g4833:
#endif
#ifdef MINIMA

g4833:
  if (_trace) printf("g4833:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g4832;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g4835;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g4826;

g4835:
  if (_trace) printf("g4835:\n");
  goto dbcachemisstrap;
#endif

g4832:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoMovemInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoMovemInstanceVariableOrdered */
/* start DoPushAddressInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariableOrdered */

dopushaddressinstancevariableordered:
  if (_trace) printf("dopushaddressinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushAddressInstanceVariableOrderedIM:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedIM:\n");

DoPushAddressInstanceVariableOrderedSP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedSP:\n");

DoPushAddressInstanceVariableOrderedLP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedLP:\n");

DoPushAddressInstanceVariableOrderedFP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  t7 = Type_Locative;
  *(u32 *)(iSP + 8) = arg1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

ivbadmap:
  if (_trace) printf("ivbadmap:\n");
  arg5 = 0;
  arg2 = 68;
  goto illegaloperand;

ivbadindex:
  if (_trace) printf("ivbadindex:\n");
  arg5 = 0;
  arg2 = 53;
  goto illegaloperand;

ivbadinst:
  if (_trace) printf("ivbadinst:\n");
  arg5 = 0;
  arg2 = 69;
  goto illegaloperand;

/* end DoPushAddressInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPushAddressInstanceVariableOrdered */
/* start DoInstanceRef */

  /* Halfword operand from stack instruction - DoInstanceRef */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceref:
  if (_trace) printf("doinstanceref:\n");
#ifdef TRACING
#endif

DoInstanceRefIM:
  if (_trace) printf("DoInstanceRefIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoinstanceref;
#ifdef TRACING
#endif

DoInstanceRefSP:
  if (_trace) printf("DoInstanceRefSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceref;
#endif

DoInstanceRefLP:
  if (_trace) printf("DoInstanceRefLP:\n");
#ifdef TRACING
  goto headdoinstanceref;
#endif

DoInstanceRefFP:
  if (_trace) printf("DoInstanceRefFP:\n");

headdoinstanceref:
  if (_trace) printf("headdoinstanceref:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoinstanceref:
  if (_trace) printf("begindoinstanceref:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;
  /* Strip CDR code, low bits */
  t1 = t1 & 60;
  if (t1 != 0)
    goto ivrefbadinst;
  t1 = arg2 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto ivrefbadoffset;
  /* Memory Read Internal */

g4839:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);
  t2 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg4 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t7&7)*8));
  if (t6 != 0)
    goto g4841;

g4840:
  t7 = zero + 64;
  t8 = t8 >> (t2 & 63);
  t7 = t7 >> (t2 & 63);
  t1 = (u32)t1;
  if (t8 & 1)
    goto g4843;

g4848:
  t1 = t1 - 1;
  /* Memory Read Internal */

g4849:
  t7 = t1 + ivory;
  t2 = (t7 * 4);
  t4 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = t1 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t2 = *(s32 *)t2;
  t4 = (u8)(t4 >> ((t7&7)*8));
  if (t6 != 0)
    goto g4851;

g4850:
  t7 = zero + 240;
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  if (t8 & 1)
    goto g4853;

g4860:
  t5 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto ivrefbadoffset;
  /* J. if offset <0 */
  if ((s64)arg1 < 0)
    goto ivrefbadoffset;
  t4 = arg1 - t2;
  /* J. if offset out of bounds */
  if ((s64)t4 >= 0)
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  /* Memory Read Internal */

g4861:
  /* Base of stack cache */
  t4 = *(u64 *)&(processor->stackcachebasevma);
  t6 = arg5 + ivory;
  t5 = *(s32 *)&processor->scovlimit;
  t1 = (t6 * 4);
  t2 = LDQ_U(t6);
  /* Stack cache offset */
  t4 = arg5 - t4;
  t7 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t5 = ((u64)t4 < (u64)t5) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t6&7)*8));
  if (t5 != 0)
    goto g4863;

g4862:
  t6 = zero + 240;
  t7 = t7 >> (t2 & 63);
  t6 = t6 >> (t2 & 63);
  if (t7 & 1)
    goto g4865;

g4872:
  /* set CDR-NEXT */
  t2 = t2 & 63;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u32 *)iSP = t1;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t2;
  goto cachevalid;

g4863:
  if (_trace) printf("g4863:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t4 = (t4 * 8) + t5;
  t1 = *(s32 *)t4;
  /* Read from stack cache */
  t2 = *(s32 *)(t4 + 4);
  goto g4862;

g4865:
  if (_trace) printf("g4865:\n");
  if ((t6 & 1) == 0)
    goto g4864;
  /* Do the indirect thing */
  arg5 = (u32)t1;
  goto g4861;

g4864:
  if (_trace) printf("g4864:\n");
  /* Load the memory action table for cycle */
  t7 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t6 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg5;
  /* Adjust for a longword load */
  t6 = (t6 * 4) + t7;
  /* Get the memory action */
  t7 = *(s32 *)t6;

g4869:
  if (_trace) printf("g4869:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0)
    goto g4868;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto g4872;
#ifndef MINIMA

g4868:
#endif
#ifdef MINIMA

g4868:
  if (_trace) printf("g4868:\n");
  t6 = t7 & MemoryActionBinding;
  t5 = *(u64 *)&(processor->dbcmask);
  if (t6 == 0)
    goto g4867;
  t4 = arg5 << 1;
  t6 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t4 = t4 & t5;
  t5 = 1;
  t5 = t5 << (ivorymemorydata & 63);
  t4 = (s32)t4 + (s32)t6;
  /* Clear sign-extension */
  t4 = (u32)t4;
  t5 = (t4 * 4) + t5;
  /* Fetch the key */
  t4 = *(s32 *)t5;
  /* Fetch value */
  t1 = *(s32 *)(t5 + 4);
  /* Compare */
  t6 = (s32)arg5 - (s32)t4;
  /* Trap on miss */
  if (t6 != 0)
    goto g4871;
  /* Extract the pointer, and indirect */
  arg5 = (u32)t1;
  goto g4861;

g4871:
  if (_trace) printf("g4871:\n");
  goto dbcachemisstrap;
#endif

g4867:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

g4851:
  if (_trace) printf("g4851:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t2 = *(s32 *)t5;
  /* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g4850;

g4853:
  if (_trace) printf("g4853:\n");
  if ((t7 & 1) == 0)
    goto g4852;
  /* Do the indirect thing */
  t1 = (u32)t2;
  goto g4849;

g4852:
  if (_trace) printf("g4852:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g4857:
  if (_trace) printf("g4857:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0)
    goto g4856;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g4860;
#ifndef MINIMA

g4856:
#endif
#ifdef MINIMA

g4856:
  if (_trace) printf("g4856:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g4855;
  t5 = t1 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t2 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)t1 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g4859;
  /* Extract the pointer, and indirect */
  t1 = (u32)t2;
  goto g4849;

g4859:
  if (_trace) printf("g4859:\n");
  goto dbcachemisstrap;
#endif

g4855:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

g4841:
  if (_trace) printf("g4841:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t1 = *(s32 *)t5;
  /* Read from stack cache */
  t2 = *(s32 *)(t5 + 4);
  goto g4840;

g4843:
  if (_trace) printf("g4843:\n");
  if ((t7 & 1) == 0)
    goto g4842;
  /* Do the indirect thing */
  arg4 = (u32)t1;
  goto g4839;

g4842:
  if (_trace) printf("g4842:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g4845:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceRef */
  /* End of Halfword operand from stack instruction - DoInstanceRef */
/* start DoInstanceSet */

  /* Halfword operand from stack instruction - DoInstanceSet */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceset:
  if (_trace) printf("doinstanceset:\n");
#ifdef TRACING
#endif

DoInstanceSetIM:
  if (_trace) printf("DoInstanceSetIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoinstanceset;
#ifdef TRACING
#endif

DoInstanceSetSP:
  if (_trace) printf("DoInstanceSetSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceset;
#endif

DoInstanceSetLP:
  if (_trace) printf("DoInstanceSetLP:\n");
#ifdef TRACING
  goto headdoinstanceset;
#endif

DoInstanceSetFP:
  if (_trace) printf("DoInstanceSetFP:\n");

headdoinstanceset:
  if (_trace) printf("headdoinstanceset:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoinstanceset:
  if (_trace) printf("begindoinstanceset:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;
  /* Strip CDR code, low bits */
  t1 = t1 & 60;
  if (t1 != 0)
    goto ivrefbadinst3;
  t1 = arg2 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto ivrefbadoffset;
  /* Memory Read Internal */

g4873:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);
  t2 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg4 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t7&7)*8));
  if (t6 != 0)
    goto g4875;

g4874:
  t7 = zero + 64;
  t8 = t8 >> (t2 & 63);
  t7 = t7 >> (t2 & 63);
  t1 = (u32)t1;
  if (t8 & 1)
    goto g4877;

g4882:
  t1 = t1 - 1;
  /* Memory Read Internal */

g4883:
  t7 = t1 + ivory;
  t2 = (t7 * 4);
  t4 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = t1 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t2 = *(s32 *)t2;
  t4 = (u8)(t4 >> ((t7&7)*8));
  if (t6 != 0)
    goto g4885;

g4884:
  t7 = zero + 240;
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  if (t8 & 1)
    goto g4887;

g4894:
  t5 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto ivrefbadoffset;
  /* J. if offset <0 */
  if ((s64)arg1 < 0)
    goto ivrefbadoffset;
  t4 = arg1 - t2;
  /* J. if offset out of bounds */
  if ((s64)t4 >= 0)
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g4895:
  t7 = arg5 + ivory;
  t4 = (t7 * 4);
  t3 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg5 - t11;
  t8 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t4 = *(s32 *)t4;
  t3 = (u8)(t3 >> ((t7&7)*8));
  if (t6 != 0)
    goto g4897;

g4896:
  t7 = zero + 240;
  t8 = t8 >> (t3 & 63);
  t7 = t7 >> (t3 & 63);
  if (t8 & 1)
    goto g4899;

g4905:
  /* Merge cdr-code */
  t4 = t2 & 63;
  t3 = t3 & 192;
  t3 = t3 | t4;
  t5 = arg5 + ivory;
  t4 = (t5 * 4);
  t7 = LDQ_U(t5);
  /* Stack cache offset */
  t6 = arg5 - t11;
  /* In range? */
  t8 = ((u64)t6 < (u64)t12) ? 1 : 0;
  t6 = (t3 & 0xff) << ((t5&7)*8);
  t7 = t7 & ~(0xffL << (t5&7)*8);

g4907:
  if (_trace) printf("g4907:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);
  *(u32 *)t4 = t1;
  /* J. if in cache */
  if (t8 != 0)
    goto g4906;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

ivrefbadinst3:
  if (_trace) printf("ivrefbadinst3:\n");
  arg5 = 0;
  arg2 = 4;
  goto illegaloperand;

g4906:
  if (_trace) printf("g4906:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t6 = arg5 - t11;
  /* reconstruct SCA */
  t5 = (t6 * 8) + t5;
  /* Store in stack */
  *(u32 *)t5 = t1;
  /* write the stack cache */
  *(u32 *)(t5 + 4) = t3;
  goto NEXTINSTRUCTION;

g4897:
  if (_trace) printf("g4897:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t4 = *(s32 *)t5;
  /* Read from stack cache */
  t3 = *(s32 *)(t5 + 4);
  goto g4896;

g4899:
  if (_trace) printf("g4899:\n");
  if ((t7 & 1) == 0)
    goto g4898;
  /* Do the indirect thing */
  arg5 = (u32)t4;
  goto g4895;

g4898:
  if (_trace) printf("g4898:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t3 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg5;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;
#ifndef MINIMA

g4902:
#endif
#ifdef MINIMA

g4902:
  if (_trace) printf("g4902:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g4901;
  t5 = arg5 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t4 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)arg5 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g4904;
  /* Extract the pointer, and indirect */
  arg5 = (u32)t4;
  goto g4895;

g4904:
  if (_trace) printf("g4904:\n");
  goto dbcachemisstrap;
#endif

g4901:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 1;
  goto performmemoryaction;

g4885:
  if (_trace) printf("g4885:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t2 = *(s32 *)t5;
  /* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g4884;

g4887:
  if (_trace) printf("g4887:\n");
  if ((t7 & 1) == 0)
    goto g4886;
  /* Do the indirect thing */
  t1 = (u32)t2;
  goto g4883;

g4886:
  if (_trace) printf("g4886:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g4891:
  if (_trace) printf("g4891:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0)
    goto g4890;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g4894;
#ifndef MINIMA

g4890:
#endif
#ifdef MINIMA

g4890:
  if (_trace) printf("g4890:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g4889;
  t5 = t1 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t2 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)t1 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g4893;
  /* Extract the pointer, and indirect */
  t1 = (u32)t2;
  goto g4883;

g4893:
  if (_trace) printf("g4893:\n");
  goto dbcachemisstrap;
#endif

g4889:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

g4875:
  if (_trace) printf("g4875:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t1 = *(s32 *)t5;
  /* Read from stack cache */
  t2 = *(s32 *)(t5 + 4);
  goto g4874;

g4877:
  if (_trace) printf("g4877:\n");
  if ((t7 & 1) == 0)
    goto g4876;
  /* Do the indirect thing */
  arg4 = (u32)t1;
  goto g4873;

g4876:
  if (_trace) printf("g4876:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g4879:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceSet */
  /* End of Halfword operand from stack instruction - DoInstanceSet */
/* start DoInstanceLoc */

  /* Halfword operand from stack instruction - DoInstanceLoc */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceloc:
  if (_trace) printf("doinstanceloc:\n");
#ifdef TRACING
#endif

DoInstanceLocIM:
  if (_trace) printf("DoInstanceLocIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoinstanceloc;
#ifdef TRACING
#endif

DoInstanceLocSP:
  if (_trace) printf("DoInstanceLocSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceloc;
#endif

DoInstanceLocLP:
  if (_trace) printf("DoInstanceLocLP:\n");
#ifdef TRACING
  goto headdoinstanceloc;
#endif

DoInstanceLocFP:
  if (_trace) printf("DoInstanceLocFP:\n");

headdoinstanceloc:
  if (_trace) printf("headdoinstanceloc:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoinstanceloc:
  if (_trace) printf("begindoinstanceloc:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;
  /* Strip CDR code, low bits */
  t1 = t1 & 60;
  if (t1 != 0)
    goto ivrefbadinst;
  t1 = arg2 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto ivrefbadoffset;
  /* Memory Read Internal */

g4908:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);
  t2 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg4 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t7&7)*8));
  if (t6 != 0)
    goto g4910;

g4909:
  t7 = zero + 64;
  t8 = t8 >> (t2 & 63);
  t7 = t7 >> (t2 & 63);
  t1 = (u32)t1;
  if (t8 & 1)
    goto g4912;

g4917:
  t1 = t1 - 1;
  /* Memory Read Internal */

g4918:
  t7 = t1 + ivory;
  t2 = (t7 * 4);
  t4 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = t1 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t2 = *(s32 *)t2;
  t4 = (u8)(t4 >> ((t7&7)*8));
  if (t6 != 0)
    goto g4920;

g4919:
  t7 = zero + 240;
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  if (t8 & 1)
    goto g4922;

g4929:
  t5 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto ivrefbadoffset;
  /* J. if offset <0 */
  if ((s64)arg1 < 0)
    goto ivrefbadoffset;
  t4 = arg1 - t2;
  /* J. if offset out of bounds */
  if ((s64)t4 >= 0)
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  t7 = Type_Locative;
  *(u32 *)iSP = arg5;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t7;
  goto NEXTINSTRUCTION;

ivrefbadinst:
  if (_trace) printf("ivrefbadinst:\n");
  arg5 = 0;
  arg2 = 3;
  goto illegaloperand;

ivrefbadoffset:
  if (_trace) printf("ivrefbadoffset:\n");
  arg5 = 0;
  arg2 = 49;
  goto illegaloperand;

g4920:
  if (_trace) printf("g4920:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t2 = *(s32 *)t5;
  /* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g4919;

g4922:
  if (_trace) printf("g4922:\n");
  if ((t7 & 1) == 0)
    goto g4921;
  /* Do the indirect thing */
  t1 = (u32)t2;
  goto g4918;

g4921:
  if (_trace) printf("g4921:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g4926:
  if (_trace) printf("g4926:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0)
    goto g4925;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g4929;
#ifndef MINIMA

g4925:
#endif
#ifdef MINIMA

g4925:
  if (_trace) printf("g4925:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g4924;
  t5 = t1 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t2 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)t1 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g4928;
  /* Extract the pointer, and indirect */
  t1 = (u32)t2;
  goto g4918;

g4928:
  if (_trace) printf("g4928:\n");
  goto dbcachemisstrap;
#endif

g4924:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

g4910:
  if (_trace) printf("g4910:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t1 = *(s32 *)t5;
  /* Read from stack cache */
  t2 = *(s32 *)(t5 + 4);
  goto g4909;

g4912:
  if (_trace) printf("g4912:\n");
  if ((t7 & 1) == 0)
    goto g4911;
  /* Do the indirect thing */
  arg4 = (u32)t1;
  goto g4908;

g4911:
  if (_trace) printf("g4911:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g4914:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceLoc */
  /* End of Halfword operand from stack instruction - DoInstanceLoc */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifuninst.as */
