/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunlexi.as
 ************************************************************************/

  /* Lexical variable accessors. */
/* start DoPushLexicalVarN */

  /* Halfword operand from stack instruction - DoPushLexicalVarN */
  /* arg2 has the preloaded 8 bit operand. */

dopushlexicalvarn:
  if (_trace) printf("dopushlexicalvarn:\n");

DoPushLexicalVarNSP:
  if (_trace) printf("DoPushLexicalVarNSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPushLexicalVarNLP:
  if (_trace) printf("DoPushLexicalVarNLP:\n");

DoPushLexicalVarNFP:
  if (_trace) printf("DoPushLexicalVarNFP:\n");

begindopushlexicalvarn:
  if (_trace) printf("begindopushlexicalvarn:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t4 = arg3 >> 10;   		// Position the opcode 
  t1 = *(s32 *)arg1;   
  t2 = *(s32 *)(arg1 + 4);   
  t4 = t4 & 7;		// Get the lexical var number 
  t1 = (u32)t1;   
  /* TagType. */
  t3 = t2 & 63;
  t3 = t3 - Type_List;   
  t3 = t3 & ~4L;
  t1 = t1 + t4;		// Compute the address of the lexical variable. 
  if (t3 != 0)   
    goto pushlexvariop;
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read16212:
  t6 = t1 + ivory;
  t3 = (t6 * 4);   
  t2 = LDQ_U(t6);   
  t4 = t1 - arg5;   		// Stack cache offset 
  t7 = *(u64 *)&(processor->dataread_mask);   
  t5 = ((u64)t4 < (u64)arg6) ? 1 : 0;   		// In range? 
  t3 = *(s32 *)t3;   
  t2 = (u8)(t2 >> ((t6&7)*8));   
  if (t5 != 0)   
    goto vma-memory-read16214;

vma-memory-read16213:
  t6 = zero + 240;   
  t7 = t7 >> (t2 & 63);   
  t6 = t6 >> (t2 & 63);   
  if (t7 & 1)   
    goto vma-memory-read16216;

vma-memory-read16223:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);   
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);   
  t4 = t2 & 63;		// set CDR-NEXT 
  *(u32 *)(iSP + 8) = t3;
		/* write the stack cache */
  *(u32 *)(iSP + 12) = t4;
  iSP = iSP + 8;
  goto cachevalid;   

pushlexvariop:
  if (_trace) printf("pushlexvariop:\n");
  arg5 = 0;
  arg2 = 82;
  goto illegaloperand;

vma-memory-read16214:
  if (_trace) printf("vma-memory-read16214:\n");
  t5 = *(u64 *)&(processor->stackcachedata);   
  t4 = (t4 * 8) + t5;  		// reconstruct SCA 
  t3 = *(s32 *)t4;   
  t2 = *(s32 *)(t4 + 4);   		// Read from stack cache 
  goto vma-memory-read16213;   

vma-memory-read16216:
  if (_trace) printf("vma-memory-read16216:\n");
  if ((t6 & 1) == 0)   
    goto vma-memory-read16215;
  t1 = (u32)t3;   		// Do the indirect thing 
  goto vma-memory-read16212;   

vma-memory-read16215:
  if (_trace) printf("vma-memory-read16215:\n");
  t7 = *(u64 *)&(processor->dataread);   		// Load the memory action table for cycle 
  /* TagType. */
  t6 = t2 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t6 = (t6 * 4) + t7;   		// Adjust for a longword load 
  t7 = *(s32 *)t6;   		// Get the memory action 

vma-memory-read16220:
  if (_trace) printf("vma-memory-read16220:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0) 
    goto vma-memory-read16219;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto vma-memory-read16223;   

vma-memory-read16219:

vma-memory-read16218:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

DoPushLexicalVarNIM:
  goto doistageerror;

/* end DoPushLexicalVarN */
  /* End of Halfword operand from stack instruction - DoPushLexicalVarN */
/* start DoPopLexicalVarN */

  /* Halfword operand from stack instruction - DoPopLexicalVarN */
  /* arg2 has the preloaded 8 bit operand. */

dopoplexicalvarn:
  if (_trace) printf("dopoplexicalvarn:\n");

DoPopLexicalVarNSP:
  if (_trace) printf("DoPopLexicalVarNSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoPopLexicalVarNLP:
  if (_trace) printf("DoPopLexicalVarNLP:\n");

DoPopLexicalVarNFP:
  if (_trace) printf("DoPopLexicalVarNFP:\n");

begindopoplexicalvarn:
  if (_trace) printf("begindopoplexicalvarn:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t4 = arg3 >> 10;   		// Position the opcode 
  t1 = *(s32 *)arg1;   
  t2 = *(s32 *)(arg1 + 4);   
  t4 = t4 & 7;		// Get the lexical var number 
  t1 = (u32)t1;   
  /* TagType. */
  t3 = t2 & 63;
  t3 = t3 - Type_List;   
  t3 = t3 & ~4L;
  t1 = t1 + t4;		// Compute the address of the lexical variable. 
  if (t3 != 0)   
    goto poplexvariop;
  t3 = *(s32 *)iSP;   
  t2 = *(s32 *)(iSP + 4);   
  iSP = iSP - 8;   		// Pop Stack. 
  t3 = (u32)t3;   
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read16224:
  t8 = t1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = t1 - arg5;   		// Stack cache offset 
  t9 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read16226;

vma-memory-read16225:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t9 & 1)   
    goto vma-memory-read16228;

vma-memory-read16234:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = t1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = t1 - arg5;   		// Stack cache offset 
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment16236:
  if (_trace) printf("force-alignment16236:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t3;
  if (t9 != 0)   		// J. if in cache 
    goto vma-memory-write16235;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

poplexvariop:
  if (_trace) printf("poplexvariop:\n");
  arg5 = 0;
  arg2 = 17;
  goto illegaloperand;

vma-memory-write16235:
  if (_trace) printf("vma-memory-write16235:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = t1 - arg5;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = t3;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

vma-memory-read16226:
  if (_trace) printf("vma-memory-read16226:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read16225;   

vma-memory-read16228:
  if (_trace) printf("vma-memory-read16228:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read16227;
  t1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read16224;   

vma-memory-read16227:
  if (_trace) printf("vma-memory-read16227:\n");
  t9 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
  t9 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read16231:

vma-memory-read16230:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

DoPopLexicalVarNIM:
  goto doistageerror;

/* end DoPopLexicalVarN */
  /* End of Halfword operand from stack instruction - DoPopLexicalVarN */
/* start DoMovemLexicalVarN */

  /* Halfword operand from stack instruction - DoMovemLexicalVarN */
  /* arg2 has the preloaded 8 bit operand. */

domovemlexicalvarn:
  if (_trace) printf("domovemlexicalvarn:\n");

DoMovemLexicalVarNSP:
  if (_trace) printf("DoMovemLexicalVarNSP:\n");
  arg1 = arg5;		// Assume SP mode 
  if (arg2 == 0)   		// SP-pop mode 
    arg1 = iSP;
  if (arg2 == 0)   		// Adjust SP if SP-pop mode 
    iSP = arg4;

DoMovemLexicalVarNLP:
  if (_trace) printf("DoMovemLexicalVarNLP:\n");

DoMovemLexicalVarNFP:
  if (_trace) printf("DoMovemLexicalVarNFP:\n");

begindomovemlexicalvarn:
  if (_trace) printf("begindomovemlexicalvarn:\n");
  /* arg1 has the operand address. */
  arg1 = (arg2 * 8) + arg1;  		// Compute operand address 
  t4 = arg3 >> 10;   		// Position the opcode 
  t1 = *(s32 *)arg1;   
  t2 = *(s32 *)(arg1 + 4);   
  t4 = t4 & 7;		// Get the lexical var number 
  t1 = (u32)t1;   
  /* TagType. */
  t3 = t2 & 63;
  t3 = t3 - Type_List;   
  t3 = t3 & ~4L;
  t1 = t1 + t4;		// Compute the address of the lexical variable. 
  if (t3 != 0)   
    goto movemlexvariop;
  t3 = *(s32 *)iSP;   
  t2 = *(s32 *)(iSP + 4);   
  t3 = (u32)t3;   
  arg5 = *(u64 *)&(processor->stackcachebasevma);   
  arg6 = *(s32 *)&processor->scovlimit;   		// Size of the stack cache (words) 
  /* Memory Read Internal */

vma-memory-read16237:
  t8 = t1 + ivory;
  t5 = (t8 * 4);   
  t4 = LDQ_U(t8);   
  t6 = t1 - arg5;   		// Stack cache offset 
  t9 = *(u64 *)&(processor->datawrite_mask);   
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;   		// In range? 
  t5 = *(s32 *)t5;   
  t4 = (u8)(t4 >> ((t8&7)*8));   
  if (t7 != 0)   
    goto vma-memory-read16239;

vma-memory-read16238:
  t8 = zero + 240;   
  t9 = t9 >> (t4 & 63);   
  t8 = t8 >> (t4 & 63);   
  if (t9 & 1)   
    goto vma-memory-read16241;

vma-memory-read16247:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = t1 + ivory;
  t5 = (t6 * 4);   
  t8 = LDQ_U(t6);   
  t7 = t1 - arg5;   		// Stack cache offset 
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;   		// In range? 
  t7 = (t4 & 0xff) << ((t6&7)*8);   
  t8 = t8 & ~(0xffL << (t6&7)*8);   

force-alignment16249:
  if (_trace) printf("force-alignment16249:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);   
  *(u32 *)t5 = t3;
  if (t9 != 0)   		// J. if in cache 
    goto vma-memory-write16248;
  goto NEXTINSTRUCTION;   
  goto NEXTINSTRUCTION;   

movemlexvariop:
  if (_trace) printf("movemlexvariop:\n");
  arg5 = 0;
  arg2 = 17;
  goto illegaloperand;

vma-memory-write16248:
  if (_trace) printf("vma-memory-write16248:\n");
  t6 = *(u64 *)&(processor->stackcachedata);   
  t7 = t1 - arg5;   		// Stack cache offset 
  t6 = (t7 * 8) + t6;  		// reconstruct SCA 
		/* Store in stack */
  *(u32 *)t6 = t3;
		/* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;   

vma-memory-read16239:
  if (_trace) printf("vma-memory-read16239:\n");
  t7 = *(u64 *)&(processor->stackcachedata);   
  t6 = (t6 * 8) + t7;  		// reconstruct SCA 
  t5 = *(s32 *)t6;   
  t4 = *(s32 *)(t6 + 4);   		// Read from stack cache 
  goto vma-memory-read16238;   

vma-memory-read16241:
  if (_trace) printf("vma-memory-read16241:\n");
  if ((t8 & 1) == 0)   
    goto vma-memory-read16240;
  t1 = (u32)t5;   		// Do the indirect thing 
  goto vma-memory-read16237;   

vma-memory-read16240:
  if (_trace) printf("vma-memory-read16240:\n");
  t9 = *(u64 *)&(processor->datawrite);   		// Load the memory action table for cycle 
  /* TagType. */
  t8 = t4 & 63;		// Discard the CDR code 
  *(u64 *)&processor->vma = t1;   		// stash the VMA for the (likely) trap 
  t8 = (t8 * 4) + t9;   		// Adjust for a longword load 
  t9 = *(s32 *)t8;   		// Get the memory action 

vma-memory-read16244:

vma-memory-read16243:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

DoMovemLexicalVarNIM:
  goto doistageerror;

/* end DoMovemLexicalVarN */
  /* End of Halfword operand from stack instruction - DoMovemLexicalVarN */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunlexi.as */
