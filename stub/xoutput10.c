/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunmath.as
 ************************************************************************/

  /* Arithmetic. */
/* start DoUnaryMinus */

  /* Halfword operand from stack instruction - DoUnaryMinus */
  /* arg2 has the preloaded 8 bit operand. */

dounaryminus:
  if (_trace) printf("dounaryminus:\n");
#ifdef TRACING
#endif

DoUnaryMinusSP:
  if (_trace) printf("DoUnaryMinusSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindounaryminus;
#endif

DoUnaryMinusLP:
  if (_trace) printf("DoUnaryMinusLP:\n");
#ifdef TRACING
  goto begindounaryminus;
#endif

DoUnaryMinusFP:
  if (_trace) printf("DoUnaryMinusFP:\n");

begindounaryminus:
  if (_trace) printf("begindounaryminus:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* tag of ARG2 */
  arg5 = *(s32 *)(arg1 + 4);
  arg6 = *(s32 *)arg1;
  t2 = *(u64 *)&(processor->mostnegativefixnum);
  LDS(1, f1, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t5 = arg5 & 63;
  t4 = (t5 == Type_Fixnum) ? 1 : 0;

g4935:
  if (_trace) printf("g4935:\n");
  if (t4 == 0)
    goto g4931;
  /* Here if argument TypeFixnum */
  t2 = (s32)arg6 - (s32)t2;
  arg2 = (s32)zero - (s32)arg6;
  if (t2 == 0)
    goto unaryminusexc;
  iPC = t6;
  /* Semi-cheat, we know t5 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
  /* Push the data */
  *(u32 *)(iSP + 8) = arg2;
  iSP = iSP + 8;
  goto cachevalid;

g4931:
  if (_trace) printf("g4931:\n");
  t4 = (t5 == Type_SingleFloat) ? 1 : 0;

g4936:
  if (_trace) printf("g4936:\n");
  if (t4 == 0)
    goto g4932;
  /* Here if argument TypeSingleFloat */
  /* NIL */
  SUBS(0, f0, 3, f31, 1, f1); /* subs */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  iPC = t6;
  /* Semi-cheat, we know t5 has CDRNext/TypeSingleFloat */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
  /* Push the data */
  STS( (u32 *)(iSP + 8), 0, f0 );
  iSP = iSP + 8;
  goto cachevalid;

g4932:
  if (_trace) printf("g4932:\n");
  /* Here for all other cases */

unaryminusexc:
  if (_trace) printf("unaryminusexc:\n");
  /* arg6 = tag to dispatch on */
  arg6 = arg5;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto unarynumericexception;

g4930:
  if (_trace) printf("g4930:\n");
#ifdef TRACING
  goto DoUnaryMinusIM;
#endif

DoUnaryMinusIM:
  if (_trace) printf("DoUnaryMinusIM:\n");
  /* Negate the 8 bit immediate operand */
  arg2 = (s32)zero - (s32)arg2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t7 = Type_Fixnum;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;

/* end DoUnaryMinus */
  /* End of Halfword operand from stack instruction - DoUnaryMinus */
/* start DoMultiply */

  /* Halfword operand from stack instruction - DoMultiply */
  /* arg2 has the preloaded 8 bit operand. */

domultiply:
  if (_trace) printf("domultiply:\n");
#ifdef TRACING
#endif

DoMultiplySP:
  if (_trace) printf("DoMultiplySP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindomultiply;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindomultiply;
#endif

DoMultiplyLP:
  if (_trace) printf("DoMultiplyLP:\n");
#ifdef TRACING
  goto begindomultiply;
#endif

DoMultiplyFP:
  if (_trace) printf("DoMultiplyFP:\n");

begindomultiply:
  if (_trace) printf("begindomultiply:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  LDS(1, f1, *(u32 *)iSP );
  /* ARG1 tag */
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  /* ARG1 data */
  t2 = (s32)arg6;
  /* ARG2 data */
  t4 = *(s32 *)arg1;
  LDS(2, f2, *(u32 *)arg1 );
  /* NIL */
  /* Strip off any CDR code bits. */
  t9 = t1 & 63;
  /* Strip off any CDR code bits. */
  t11 = t3 & 63;
  t10 = (t9 == Type_Fixnum) ? 1 : 0;

g4976:
  if (_trace) printf("g4976:\n");
  if (t10 == 0)
    goto g4947;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g4953:
  if (_trace) printf("g4953:\n");
  if (t12 == 0)
    goto g4949;
  /* Here if argument TypeFixnum */
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* compute 64-bit result */
  /* compute 64-bit result */
  t5 = (s64)((s32)t2 * (s64)(s32)t4); /* mull/v */
  if (t5 >> 32)
    exception();
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  /* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t9;
  iPC = t6;
  *(u32 *)iSP = t5;
  iCP = t7;
  goto cachevalid;

g4949:
  if (_trace) printf("g4949:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g4954:
  if (_trace) printf("g4954:\n");
  if (t12 == 0)
    goto g4950;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g4937;

g4950:
  if (_trace) printf("g4950:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g4955:
  if (_trace) printf("g4955:\n");
  if (t12 == 0)
    goto g4944;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g4940;

g4948:
  if (_trace) printf("g4948:\n");

g4947:
  if (_trace) printf("g4947:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;

g4977:
  if (_trace) printf("g4977:\n");
  if (t10 == 0)
    goto g4956;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g4962:
  if (_trace) printf("g4962:\n");
  if (t12 == 0)
    goto g4958;
  /* Here if argument TypeSingleFloat */

g4937:
  if (_trace) printf("g4937:\n");
  MULS(0, f0, 1, f1, 2, f2); /* muls */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  goto cachevalid;

g4958:
  if (_trace) printf("g4958:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g4963:
  if (_trace) printf("g4963:\n");
  if (t12 == 0)
    goto g4959;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g4937;

g4959:
  if (_trace) printf("g4959:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g4964:
  if (_trace) printf("g4964:\n");
  if (t12 == 0)
    goto g4944;
  /* Here if argument TypeDoubleFloat */

g4940:
  if (_trace) printf("g4940:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  goto g4941;

g4957:
  if (_trace) printf("g4957:\n");

g4956:
  if (_trace) printf("g4956:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;

g4978:
  if (_trace) printf("g4978:\n");
  if (t10 == 0)
    goto g4965;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g4971:
  if (_trace) printf("g4971:\n");
  if (t12 == 0)
    goto g4967;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  r0 = (u64)&&return0162;
  goto fetchdoublefloat;
return0162:
  LDT(1, f1, processor->fp0);

g4941:
  if (_trace) printf("g4941:\n");
  arg2 = (u32)t4;
  r0 = (u64)&&return0163;
  goto fetchdoublefloat;
return0163:
  LDT(2, f2, processor->fp0);

g4938:
  if (_trace) printf("g4938:\n");
  MULT(0, f0, 1, f1, 2, f2);
  STT( (u64 *)&processor->fp0, 0, f0 );
  r0 = (u64)&&return0164;
  goto consdoublefloat;
return0164:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto cachevalid;

g4967:
  if (_trace) printf("g4967:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g4972:
  if (_trace) printf("g4972:\n");
  if (t12 == 0)
    goto g4968;
  /* Here if argument TypeSingleFloat */

g4939:
  if (_trace) printf("g4939:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  r0 = (u64)&&return0165;
  goto fetchdoublefloat;
return0165:
  LDT(1, f1, processor->fp0);
  goto g4938;

g4968:
  if (_trace) printf("g4968:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g4973:
  if (_trace) printf("g4973:\n");
  if (t12 == 0)
    goto g4944;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g4939;

g4966:
  if (_trace) printf("g4966:\n");

g4965:
  if (_trace) printf("g4965:\n");
  /* Here for all other cases */

g4943:
  if (_trace) printf("g4943:\n");

domulovfl:
  if (_trace) printf("domulovfl:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
  goto g4945;

g4944:
  if (_trace) printf("g4944:\n");
  t1 = t3;
  goto domulovfl;

g4945:
  if (_trace) printf("g4945:\n");

g4946:
  if (_trace) printf("g4946:\n");
#ifdef TRACING
  goto DoMultiplyIM;
#endif

DoMultiplyIM:
  if (_trace) printf("DoMultiplyIM:\n");
  arg2 = arg2 << 56;
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* get ARG1 tag/data */
  t2 = (s32)arg6;
  arg2 = (s64)arg2 >> 56;
  /* Strip off any CDR code bits. */
  t11 = t1 & 63;
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g4983:
  if (_trace) printf("g4983:\n");
  if (t12 == 0)
    goto g4980;
  /* Here if argument TypeFixnum */
  /* compute 64-bit result */
  t3 = t2 * arg2;
  t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* compute 32-bit sign-extended result */
  t10 = (s32)t3;
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* is it the same as the 64-bit result? */
  t10 = (t3 == t10) ? 1 : 0;
  /* if not, we overflowed */
  if (t10 == 0)
    goto domulovfl;
  /* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t11;
  iPC = t4;
  *(u32 *)iSP = t3;
  iCP = t5;
  goto cachevalid;

g4980:
  if (_trace) printf("g4980:\n");
  /* Here for all other cases */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;
  arg2 = zero;
  goto begindomultiply;

g4979:
  if (_trace) printf("g4979:\n");

/* end DoMultiply */
  /* End of Halfword operand from stack instruction - DoMultiply */
/* start BinaryArithmeticDivisionPrelude */


binaryarithmeticdivisionprelude:
  if (_trace) printf("binaryarithmeticdivisionprelude:\n");
  sp = sp + -8;
  LDS(1, f1, *(u32 *)iSP );
  /* ARG1 data */
  t2 = (s32)arg6;
  /* ARG2 data */
  t4 = *(s32 *)arg1;
  /* ARG1 tag */
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  LDS(2, f2, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t9 = t1 & 63;
  /* Strip off any CDR code bits. */
  t11 = t3 & 63;
  t10 = (t9 == Type_Fixnum) ? 1 : 0;

g5021:
  if (_trace) printf("g5021:\n");
  if (t10 == 0)
    goto g4994;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g5000:
  if (_trace) printf("g5000:\n");
  if (t12 == 0)
    goto g4996;
  /* Here if argument TypeFixnum */
  CVTLQ(1, f1, f31, 1, f1);
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(1, f1, f31, 1, f1);
  CVTQT(2, f2, f31, 2, f2);

g4995:
  if (_trace) printf("g4995:\n");

g4993:
  if (_trace) printf("g4993:\n");

g4984:
  if (_trace) printf("g4984:\n");
  sp = sp + 8;
  goto *r0; /* ret */

g4994:
  if (_trace) printf("g4994:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;

g5022:
  if (_trace) printf("g5022:\n");
  if (t10 == 0)
    goto g5001;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g5007:
  if (_trace) printf("g5007:\n");
  if (t12 != 0)
    goto g4984;

g5003:
  if (_trace) printf("g5003:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g5008:
  if (_trace) printf("g5008:\n");
  if (t12 == 0)
    goto g5004;
  /* Here if argument TypeFixnum */
  /* contagion */
  t3 = t1;
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g4984;

g5004:
  if (_trace) printf("g5004:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g5009:
  if (_trace) printf("g5009:\n");
  if (t12 == 0)
    goto g4991;
  /* Here if argument TypeDoubleFloat */

g4986:
  if (_trace) printf("g4986:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  goto g4987;

g5002:
  if (_trace) printf("g5002:\n");

g5001:
  if (_trace) printf("g5001:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;

g5023:
  if (_trace) printf("g5023:\n");
  if (t10 == 0)
    goto g5010;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g5016:
  if (_trace) printf("g5016:\n");
  if (t12 == 0)
    goto g5012;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  *(u64 *)sp = r0;
  r0 = (u64)&&return0166;
  goto fetchdoublefloat;
return0166:
  r0 = *(u64 *)sp;
  LDT(1, f1, processor->fp0);

g4987:
  if (_trace) printf("g4987:\n");
  arg2 = (u32)t4;
  *(u64 *)sp = r0;
  r0 = (u64)&&return0167;
  goto fetchdoublefloat;
return0167:
  r0 = *(u64 *)sp;
  LDT(2, f2, processor->fp0);
  goto g4984;

g5012:
  if (_trace) printf("g5012:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g5017:
  if (_trace) printf("g5017:\n");
  if (t12 == 0)
    goto g5013;
  /* Here if argument TypeSingleFloat */

g4985:
  if (_trace) printf("g4985:\n");
  /* contagion */
  t3 = t1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  *(u64 *)sp = r0;
  r0 = (u64)&&return0168;
  goto fetchdoublefloat;
return0168:
  r0 = *(u64 *)sp;
  LDT(1, f1, processor->fp0);
  goto g4984;

g5013:
  if (_trace) printf("g5013:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g5018:
  if (_trace) printf("g5018:\n");
  if (t12 == 0)
    goto g4991;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g4985;

g5011:
  if (_trace) printf("g5011:\n");

g5010:
  if (_trace) printf("g5010:\n");
  /* Here for all other cases */

g4990:
  if (_trace) printf("g4990:\n");

g4988:
  if (_trace) printf("g4988:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
  goto g4992;

g4991:
  if (_trace) printf("g4991:\n");
  t1 = t3;
  goto g4988;

g4992:
  if (_trace) printf("g4992:\n");

g4996:
  if (_trace) printf("g4996:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g5024:
  if (_trace) printf("g5024:\n");
  if (t12 == 0)
    goto g4997;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g4984;

g4997:
  if (_trace) printf("g4997:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g5025:
  if (_trace) printf("g5025:\n");
  if (t12 == 0)
    goto g4991;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g4986;

/* end BinaryArithmeticDivisionPrelude */
/* start DoQuotient */

  /* Halfword operand from stack instruction - DoQuotient */
  /* arg2 has the preloaded 8 bit operand. */

doquotient:
  if (_trace) printf("doquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoQuotientIM:
  if (_trace) printf("DoQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindoquotient;
#ifdef TRACING
#endif

DoQuotientSP:
  if (_trace) printf("DoQuotientSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindoquotient;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindoquotient;
#endif

DoQuotientLP:
  if (_trace) printf("DoQuotientLP:\n");
#ifdef TRACING
  goto begindoquotient;
#endif

DoQuotientFP:
  if (_trace) printf("DoQuotientFP:\n");

begindoquotient:
  if (_trace) printf("begindoquotient:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0169;
  goto binaryarithmeticdivisionprelude;
return0169:
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g5031:
  if (_trace) printf("g5031:\n");
  if (t9 == 0)
    goto g5027;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );

g5026:
  if (_trace) printf("g5026:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g5027:
  if (_trace) printf("g5027:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g5032:
  if (_trace) printf("g5032:\n");
  if (t9 == 0)
    goto g5028;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  goto g5026;

g5028:
  if (_trace) printf("g5028:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g5033:
  if (_trace) printf("g5033:\n");
  if (t9 == 0)
    goto g5026;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);
  STT( (u64 *)&processor->fp0, 0, f0 );
  r0 = (u64)&&return0170;
  goto consdoublefloat;
return0170:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto g5026;

/* end DoQuotient */
  /* End of Halfword operand from stack instruction - DoQuotient */
/* start DoRationalQuotient */

  /* Halfword operand from stack instruction - DoRationalQuotient */
  /* arg2 has the preloaded 8 bit operand. */

dorationalquotient:
  if (_trace) printf("dorationalquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoRationalQuotientIM:
  if (_trace) printf("DoRationalQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindorationalquotient;
#ifdef TRACING
#endif

DoRationalQuotientSP:
  if (_trace) printf("DoRationalQuotientSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindorationalquotient;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindorationalquotient;
#endif

DoRationalQuotientLP:
  if (_trace) printf("DoRationalQuotientLP:\n");
#ifdef TRACING
  goto begindorationalquotient;
#endif

DoRationalQuotientFP:
  if (_trace) printf("DoRationalQuotientFP:\n");

begindorationalquotient:
  if (_trace) printf("begindorationalquotient:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0171;
  goto binaryarithmeticdivisionprelude;
return0171:
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g5039:
  if (_trace) printf("g5039:\n");
  if (t9 == 0)
    goto g5035;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQSVI(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );

g5034:
  if (_trace) printf("g5034:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g5035:
  if (_trace) printf("g5035:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g5040:
  if (_trace) printf("g5040:\n");
  if (t9 == 0)
    goto g5036;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  goto g5034;

g5036:
  if (_trace) printf("g5036:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g5041:
  if (_trace) printf("g5041:\n");
  if (t9 == 0)
    goto g5034;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);
  STT( (u64 *)&processor->fp0, 0, f0 );
  r0 = (u64)&&return0172;
  goto consdoublefloat;
return0172:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto g5034;

/* end DoRationalQuotient */
  /* End of Halfword operand from stack instruction - DoRationalQuotient */
/* start DoFloor */

  /* Halfword operand from stack instruction - DoFloor */
  /* arg2 has the preloaded 8 bit operand. */

dofloor:
  if (_trace) printf("dofloor:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoFloorIM:
  if (_trace) printf("DoFloorIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindofloor;
#ifdef TRACING
#endif

DoFloorSP:
  if (_trace) printf("DoFloorSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindofloor;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindofloor;
#endif

DoFloorLP:
  if (_trace) printf("DoFloorLP:\n");
#ifdef TRACING
  goto begindofloor;
#endif

DoFloorFP:
  if (_trace) printf("DoFloorFP:\n");

begindofloor:
  if (_trace) printf("begindofloor:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0173;
  goto binaryarithmeticdivisionprelude;
return0173:
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);
  SUBT(3, f3, 1, f1, 3, f3);
  CVTQLV(0, f0, f31, 0, f0);
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g5047:
  if (_trace) printf("g5047:\n");
  if (t9 == 0)
    goto g5043;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;

g5042:
  if (_trace) printf("g5042:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g5043:
  if (_trace) printf("g5043:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g5048:
  if (_trace) printf("g5048:\n");
  if (t9 == 0)
    goto g5044;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;
  goto g5042;

g5044:
  if (_trace) printf("g5044:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g5049:
  if (_trace) printf("g5049:\n");
  if (t9 == 0)
    goto g5042;
  /* Here if argument TypeDoubleFloat */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  STT( (u64 *)&processor->fp0, 3, f3 );
  r0 = (u64)&&return0174;
  goto consdoublefloat;
return0174:
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g5042;

/* end DoFloor */
  /* End of Halfword operand from stack instruction - DoFloor */
/* start DoCeiling */

  /* Halfword operand from stack instruction - DoCeiling */
  /* arg2 has the preloaded 8 bit operand. */

doceiling:
  if (_trace) printf("doceiling:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoCeilingIM:
  if (_trace) printf("DoCeilingIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindoceiling;
#ifdef TRACING
#endif

DoCeilingSP:
  if (_trace) printf("DoCeilingSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindoceiling;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindoceiling;
#endif

DoCeilingLP:
  if (_trace) printf("DoCeilingLP:\n");
#ifdef TRACING
  goto begindoceiling;
#endif

DoCeilingFP:
  if (_trace) printf("DoCeilingFP:\n");

begindoceiling:
  if (_trace) printf("begindoceiling:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0175;
  goto binaryarithmeticdivisionprelude;
return0175:
  CPYSN(2, f2, 2, f2, 2, f2);
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQVM(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  CPYSN(0, f0, 3, f3, 3, f3);
  CVTTQ(0, f0, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);
  SUBT(3, f3, 1, f1, 3, f3);
  CVTQLV(0, f0, f31, 0, f0);
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g5055:
  if (_trace) printf("g5055:\n");
  if (t9 == 0)
    goto g5051;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;

g5050:
  if (_trace) printf("g5050:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g5051:
  if (_trace) printf("g5051:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g5056:
  if (_trace) printf("g5056:\n");
  if (t9 == 0)
    goto g5052;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;
  goto g5050;

g5052:
  if (_trace) printf("g5052:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g5057:
  if (_trace) printf("g5057:\n");
  if (t9 == 0)
    goto g5050;
  /* Here if argument TypeDoubleFloat */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  STT( (u64 *)&processor->fp0, 3, f3 );
  r0 = (u64)&&return0176;
  goto consdoublefloat;
return0176:
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g5050;

/* end DoCeiling */
  /* End of Halfword operand from stack instruction - DoCeiling */
/* start DoTruncate */

  /* Halfword operand from stack instruction - DoTruncate */
  /* arg2 has the preloaded 8 bit operand. */

dotruncate:
  if (_trace) printf("dotruncate:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoTruncateIM:
  if (_trace) printf("DoTruncateIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindotruncate;
#ifdef TRACING
#endif

DoTruncateSP:
  if (_trace) printf("DoTruncateSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindotruncate;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindotruncate;
#endif

DoTruncateLP:
  if (_trace) printf("DoTruncateLP:\n");
#ifdef TRACING
  goto begindotruncate;
#endif

DoTruncateFP:
  if (_trace) printf("DoTruncateFP:\n");

begindotruncate:
  if (_trace) printf("begindotruncate:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0177;
  goto binaryarithmeticdivisionprelude;
return0177:
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);
  SUBT(3, f3, 1, f1, 3, f3);
  CVTQLV(0, f0, f31, 0, f0);
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g5063:
  if (_trace) printf("g5063:\n");
  if (t9 == 0)
    goto g5059;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;

g5058:
  if (_trace) printf("g5058:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g5059:
  if (_trace) printf("g5059:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g5064:
  if (_trace) printf("g5064:\n");
  if (t9 == 0)
    goto g5060;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;
  goto g5058;

g5060:
  if (_trace) printf("g5060:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g5065:
  if (_trace) printf("g5065:\n");
  if (t9 == 0)
    goto g5058;
  /* Here if argument TypeDoubleFloat */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  STT( (u64 *)&processor->fp0, 3, f3 );
  r0 = (u64)&&return0178;
  goto consdoublefloat;
return0178:
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g5058;

/* end DoTruncate */
  /* End of Halfword operand from stack instruction - DoTruncate */
/* start DoRound */

  /* Halfword operand from stack instruction - DoRound */
  /* arg2 has the preloaded 8 bit operand. */

doround:
  if (_trace) printf("doround:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoRoundIM:
  if (_trace) printf("DoRoundIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindoround;
#ifdef TRACING
#endif

DoRoundSP:
  if (_trace) printf("DoRoundSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindoround;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindoround;
#endif

DoRoundLP:
  if (_trace) printf("DoRoundLP:\n");
#ifdef TRACING
  goto begindoround;
#endif

DoRoundFP:
  if (_trace) printf("DoRoundFP:\n");

begindoround:
  if (_trace) printf("begindoround:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0179;
  goto binaryarithmeticdivisionprelude;
return0179:
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQV(0, f0, f31, 0, f0);
  CVTQT(3, f3, f31, 0, f0);
  MULT(3, f3, 3, f3, 2, f2);
  SUBT(3, f3, 1, f1, 3, f3);
  CVTQLV(0, f0, f31, 0, f0);
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g5071:
  if (_trace) printf("g5071:\n");
  if (t9 == 0)
    goto g5067;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;

g5066:
  if (_trace) printf("g5066:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g5067:
  if (_trace) printf("g5067:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g5072:
  if (_trace) printf("g5072:\n");
  if (t9 == 0)
    goto g5068;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;
  goto g5066;

g5068:
  if (_trace) printf("g5068:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g5073:
  if (_trace) printf("g5073:\n");
  if (t9 == 0)
    goto g5066;
  /* Here if argument TypeDoubleFloat */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  STT( (u64 *)&processor->fp0, 3, f3 );
  r0 = (u64)&&return0180;
  goto consdoublefloat;
return0180:
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g5066;

/* end DoRound */
  /* End of Halfword operand from stack instruction - DoRound */
  /* Other arithmetic. */
/* start DoMax */

  /* Halfword operand from stack instruction - DoMax */
  /* arg2 has the preloaded 8 bit operand. */

domax:
  if (_trace) printf("domax:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMaxIM:
  if (_trace) printf("DoMaxIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindomax;
#ifdef TRACING
#endif

DoMaxSP:
  if (_trace) printf("DoMaxSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindomax;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindomax;
#endif

DoMaxLP:
  if (_trace) printf("DoMaxLP:\n");
#ifdef TRACING
  goto begindomax;
#endif

DoMaxFP:
  if (_trace) printf("DoMaxFP:\n");

begindomax:
  if (_trace) printf("begindomax:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  LDS(1, f1, *(u32 *)iSP );
  /* ARG1 tag */
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  /* ARG1 data */
  t2 = (s32)arg6;
  /* ARG2 data */
  t4 = *(s32 *)arg1;
  LDS(2, f2, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t9 = t1 & 63;
  /* Strip off any CDR code bits. */
  t11 = t3 & 63;
  t10 = (t9 == Type_Fixnum) ? 1 : 0;

g5097:
  if (_trace) printf("g5097:\n");
  if (t10 == 0)
    goto g5081;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g5086:
  if (_trace) printf("g5086:\n");
  if (t12 == 0)
    goto g5083;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if ((s64)t5 > 0)
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;

g5083:
  if (_trace) printf("g5083:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g5087:
  if (_trace) printf("g5087:\n");
  if (t12 == 0)
    goto g5078;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto g5075;

g5082:
  if (_trace) printf("g5082:\n");

g5081:
  if (_trace) printf("g5081:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;

g5098:
  if (_trace) printf("g5098:\n");
  if (t10 == 0)
    goto g5088;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g5093:
  if (_trace) printf("g5093:\n");
  if (t12 == 0)
    goto g5090;
  /* Here if argument TypeSingleFloat */

g5075:
  if (_trace) printf("g5075:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if (FLTU64(0, f0) > 0.0)
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );
  goto cachevalid;

g5090:
  if (_trace) printf("g5090:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g5094:
  if (_trace) printf("g5094:\n");
  if (t12 == 0)
    goto g5078;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto g5075;

g5089:
  if (_trace) printf("g5089:\n");

g5088:
  if (_trace) printf("g5088:\n");
  /* Here for all other cases */

g5077:
  if (_trace) printf("g5077:\n");

g5074:
  if (_trace) printf("g5074:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
  goto g5079;

g5078:
  if (_trace) printf("g5078:\n");
  t1 = t3;
  goto g5074;

g5079:
  if (_trace) printf("g5079:\n");

g5080:
  if (_trace) printf("g5080:\n");

/* end DoMax */
  /* End of Halfword operand from stack instruction - DoMax */
/* start DoMin */

  /* Halfword operand from stack instruction - DoMin */
  /* arg2 has the preloaded 8 bit operand. */

domin:
  if (_trace) printf("domin:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMinIM:
  if (_trace) printf("DoMinIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindomin;
#ifdef TRACING
#endif

DoMinSP:
  if (_trace) printf("DoMinSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindomin;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindomin;
#endif

DoMinLP:
  if (_trace) printf("DoMinLP:\n");
#ifdef TRACING
  goto begindomin;
#endif

DoMinFP:
  if (_trace) printf("DoMinFP:\n");

begindomin:
  if (_trace) printf("begindomin:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  LDS(1, f1, *(u32 *)iSP );
  /* ARG1 tag */
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  /* ARG1 data */
  t2 = (s32)arg6;
  /* ARG2 data */
  t4 = *(s32 *)arg1;
  LDS(2, f2, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t9 = t1 & 63;
  /* Strip off any CDR code bits. */
  t11 = t3 & 63;
  t10 = (t9 == Type_Fixnum) ? 1 : 0;

g5122:
  if (_trace) printf("g5122:\n");
  if (t10 == 0)
    goto g5106;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g5111:
  if (_trace) printf("g5111:\n");
  if (t12 == 0)
    goto g5108;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if ((s64)t5 < 0)
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;

g5108:
  if (_trace) printf("g5108:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g5112:
  if (_trace) printf("g5112:\n");
  if (t12 == 0)
    goto g5103;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto g5100;

g5107:
  if (_trace) printf("g5107:\n");

g5106:
  if (_trace) printf("g5106:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;

g5123:
  if (_trace) printf("g5123:\n");
  if (t10 == 0)
    goto g5113;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g5118:
  if (_trace) printf("g5118:\n");
  if (t12 == 0)
    goto g5115;
  /* Here if argument TypeSingleFloat */

g5100:
  if (_trace) printf("g5100:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if (FLTU64(0, f0) < 0.0)
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );
  goto cachevalid;

g5115:
  if (_trace) printf("g5115:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g5119:
  if (_trace) printf("g5119:\n");
  if (t12 == 0)
    goto g5103;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto g5100;

g5114:
  if (_trace) printf("g5114:\n");

g5113:
  if (_trace) printf("g5113:\n");
  /* Here for all other cases */

g5102:
  if (_trace) printf("g5102:\n");

g5099:
  if (_trace) printf("g5099:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
  goto g5104;

g5103:
  if (_trace) printf("g5103:\n");
  t1 = t3;
  goto g5099;

g5104:
  if (_trace) printf("g5104:\n");

g5105:
  if (_trace) printf("g5105:\n");

/* end DoMin */
  /* End of Halfword operand from stack instruction - DoMin */
/* start DoMultiplyDouble */

  /* Halfword operand from stack instruction - DoMultiplyDouble */

domultiplydouble:
  if (_trace) printf("domultiplydouble:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMultiplyDoubleIM:
  if (_trace) printf("DoMultiplyDoubleIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g5124:
  if (_trace) printf("g5124:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindomultiplydouble;
#ifdef TRACING
#endif

DoMultiplyDoubleSP:
  if (_trace) printf("DoMultiplyDoubleSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdomultiplydouble;
#endif

DoMultiplyDoubleLP:
  if (_trace) printf("DoMultiplyDoubleLP:\n");
#ifdef TRACING
  goto headdomultiplydouble;
#endif

DoMultiplyDoubleFP:
  if (_trace) printf("DoMultiplyDoubleFP:\n");

headdomultiplydouble:
  if (_trace) printf("headdomultiplydouble:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindomultiplydouble:
  if (_trace) printf("begindomultiplydouble:\n");
  /* arg1 has the operand, sign extended if immediate. */
  /* ARG2 tag */
  t2 = arg1 >> 32;
  /* ARG1 data, sign extended */
  t3 = *(s32 *)iSP;
  /* ARG2 data, sign extended */
  t4 = (s32)arg1 + (s32)0;
  /* ARG1 tag */
  t1 = *(s32 *)(iSP + 4);
  /* TagType. */
  /* Strip CDR code if any. */
  t1 = t1 & 63;
  t1 = t1 - Type_Fixnum;
  /* TagType. */
  /* Strip CDR code if any. */
  t2 = t2 & 63;
  /* Perform the 63 bit multiply. */
  t5 = t3 * t4;
  t2 = t2 - Type_Fixnum;
  if (t1 != 0)
    goto muldexc;
  if (t2 != 0)
    goto muldexc;
  /* Get the low 32 bit half. */
  t6 = (u32)t5;
  /* Get the high 32 bit half. */
  t5 = (u32)(t5 >> ((4&7)*8));
  /* Put the result back on the stack */
  *(u32 *)iSP = t6;
  t1 = Type_Fixnum;
  /* Push high order half */
  *(u32 *)(iSP + 8) = t5;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

muldexc:
  if (_trace) printf("muldexc:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end DoMultiplyDouble */
  /* End of Halfword operand from stack instruction - DoMultiplyDouble */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunmath.as */
