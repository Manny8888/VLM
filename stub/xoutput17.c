/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunbits.as
 ************************************************************************/

  /* Bits. */
/* start DoLogand */

  /* Halfword operand from stack instruction - DoLogand */
  /* arg2 has the preloaded 8 bit operand. */

dologand:
  if (_trace) printf("dologand:\n");
#ifdef TRACING
#endif

DoLogandSP:
  if (_trace) printf("DoLogandSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdologand;
#endif

DoLogandLP:
  if (_trace) printf("DoLogandLP:\n");
#ifdef TRACING
  goto headdologand;
#endif

DoLogandFP:
  if (_trace) printf("DoLogandFP:\n");

headdologand:
  if (_trace) printf("headdologand:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindologand:
  if (_trace) printf("begindologand:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  /* Get tag from ARG1 */
  t3 = *(s32 *)(iSP + 4);
  /* Grab data for ARG1 */
  t4 = *(s32 *)iSP;
  /* Get tag from ARG2 */
  t1 = (u8)(arg1 >> ((4&7)*8));
  t6 = t3 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto g5759;
  t6 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto g5760;
  /* Here we know that both args are fixnums! */
  /* Do the operation */
  t4 = t4 & arg1;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  r31 = r31 | r31;
  /* Strip high bits */
  t4 = (u32)t4;
  t1 = Type_Fixnum;
  /* Push result */
  *(u32 *)iSP = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;

g5759:
  if (_trace) printf("g5759:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t3;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;

g5760:
  if (_trace) printf("g5760:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
#ifdef TRACING
  goto DoLogandIM;
#endif

DoLogandIM:
  if (_trace) printf("DoLogandIM:\n");
  /* Get tag from ARG1 */
  t3 = *(s32 *)(iSP + 4);
  arg2 = arg2 << 56;
  /* Grab data for ARG1 */
  t4 = *(s32 *)iSP;
  arg2 = (s64)arg2 >> 56;
  t6 = t3 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto g5761;
  /* Here we know that both args are fixnums! */
  /* Do the operation */
  t4 = t4 & arg2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  r31 = r31 | r31;
  /* Strip high bits */
  t4 = (u32)t4;
  t1 = Type_Fixnum;
  /* Push result */
  *(u32 *)iSP = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;

g5761:
  if (_trace) printf("g5761:\n");
  arg1 = Type_Fixnum;
  arg2 = (u32)arg2;
  /* SetTag. */
  t1 = arg1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t3;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;

/* end DoLogand */
  /* End of Halfword operand from stack instruction - DoLogand */
/* start DoLogior */

  /* Halfword operand from stack instruction - DoLogior */
  /* arg2 has the preloaded 8 bit operand. */

dologior:
  if (_trace) printf("dologior:\n");
#ifdef TRACING
#endif

DoLogiorSP:
  if (_trace) printf("DoLogiorSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdologior;
#endif

DoLogiorLP:
  if (_trace) printf("DoLogiorLP:\n");
#ifdef TRACING
  goto headdologior;
#endif

DoLogiorFP:
  if (_trace) printf("DoLogiorFP:\n");

headdologior:
  if (_trace) printf("headdologior:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindologior:
  if (_trace) printf("begindologior:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  /* Get tag from ARG1 */
  t3 = *(s32 *)(iSP + 4);
  /* Grab data for ARG1 */
  t4 = *(s32 *)iSP;
  /* Get tag from ARG2 */
  t1 = (u8)(arg1 >> ((4&7)*8));
  t6 = t3 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto g5762;
  t6 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto g5763;
  /* Here we know that both args are fixnums! */
  /* Do the operation */
  t4 = t4 | arg1;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  r31 = r31 | r31;
  /* Strip high bits */
  t4 = (u32)t4;
  t1 = Type_Fixnum;
  /* Push result */
  *(u32 *)iSP = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;

g5762:
  if (_trace) printf("g5762:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t3;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;

g5763:
  if (_trace) printf("g5763:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
#ifdef TRACING
  goto DoLogiorIM;
#endif

DoLogiorIM:
  if (_trace) printf("DoLogiorIM:\n");
  /* Get tag from ARG1 */
  t3 = *(s32 *)(iSP + 4);
  arg2 = arg2 << 56;
  /* Grab data for ARG1 */
  t4 = *(s32 *)iSP;
  arg2 = (s64)arg2 >> 56;
  t6 = t3 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto g5764;
  /* Here we know that both args are fixnums! */
  /* Do the operation */
  t4 = t4 | arg2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  r31 = r31 | r31;
  /* Strip high bits */
  t4 = (u32)t4;
  t1 = Type_Fixnum;
  /* Push result */
  *(u32 *)iSP = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;

g5764:
  if (_trace) printf("g5764:\n");
  arg1 = Type_Fixnum;
  arg2 = (u32)arg2;
  /* SetTag. */
  t1 = arg1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t3;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;

/* end DoLogior */
  /* End of Halfword operand from stack instruction - DoLogior */
/* start DoLogxor */

  /* Halfword operand from stack instruction - DoLogxor */
  /* arg2 has the preloaded 8 bit operand. */

dologxor:
  if (_trace) printf("dologxor:\n");
#ifdef TRACING
#endif

DoLogxorSP:
  if (_trace) printf("DoLogxorSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdologxor;
#endif

DoLogxorLP:
  if (_trace) printf("DoLogxorLP:\n");
#ifdef TRACING
  goto headdologxor;
#endif

DoLogxorFP:
  if (_trace) printf("DoLogxorFP:\n");

headdologxor:
  if (_trace) printf("headdologxor:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindologxor:
  if (_trace) printf("begindologxor:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  /* Get tag from ARG1 */
  t3 = *(s32 *)(iSP + 4);
  /* Grab data for ARG1 */
  t4 = *(s32 *)iSP;
  /* Get tag from ARG2 */
  t1 = (u8)(arg1 >> ((4&7)*8));
  t6 = t3 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto g5765;
  t6 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto g5766;
  /* Here we know that both args are fixnums! */
  /* Do the operation */
  t4 = t4 ^ arg1;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  r31 = r31 | r31;
  /* Strip high bits */
  t4 = (u32)t4;
  t1 = Type_Fixnum;
  /* Push result */
  *(u32 *)iSP = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;

g5765:
  if (_trace) printf("g5765:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t3;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;

g5766:
  if (_trace) printf("g5766:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
#ifdef TRACING
  goto DoLogxorIM;
#endif

DoLogxorIM:
  if (_trace) printf("DoLogxorIM:\n");
  /* Get tag from ARG1 */
  t3 = *(s32 *)(iSP + 4);
  arg2 = arg2 << 56;
  /* Grab data for ARG1 */
  t4 = *(s32 *)iSP;
  arg2 = (s64)arg2 >> 56;
  t6 = t3 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto g5767;
  /* Here we know that both args are fixnums! */
  /* Do the operation */
  t4 = t4 ^ arg2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  r31 = r31 | r31;
  /* Strip high bits */
  t4 = (u32)t4;
  t1 = Type_Fixnum;
  /* Push result */
  *(u32 *)iSP = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t1;
  goto cachevalid;

g5767:
  if (_trace) printf("g5767:\n");
  arg1 = Type_Fixnum;
  arg2 = (u32)arg2;
  /* SetTag. */
  t1 = arg1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t3;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;

/* end DoLogxor */
  /* End of Halfword operand from stack instruction - DoLogxor */
/* start DoAsh */

  /* Halfword operand from stack instruction - DoAsh */

doash:
  if (_trace) printf("doash:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoAshIM:
  if (_trace) printf("DoAshIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g5781:
  if (_trace) printf("g5781:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoash;
#ifdef TRACING
#endif

DoAshSP:
  if (_trace) printf("DoAshSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoash;
#endif

DoAshLP:
  if (_trace) printf("DoAshLP:\n");
#ifdef TRACING
  goto headdoash;
#endif

DoAshFP:
  if (_trace) printf("DoAshFP:\n");

headdoash:
  if (_trace) printf("headdoash:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoash:
  if (_trace) printf("begindoash:\n");
  /* arg1 has the operand, sign extended if immediate. */
  /* Get ARG1. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;
  /* Get ARG2's tag. */
  arg2 = arg1 >> 32;
  /* Sign extended the rotation amount. */
  arg1 = (s32)arg1;
  /* Strip off any CDR code bits. */
  t1 = arg2 & 63;
  /* Strip off any CDR code bits. */
  t3 = arg3 & 63;
  t2 = (t1 == Type_Fixnum) ? 1 : 0;

g5780:
  if (_trace) printf("g5780:\n");
  if (t2 == 0)
    goto g5773;
  /* Here if argument TypeFixnum */
  t4 = (t3 == Type_Fixnum) ? 1 : 0;

g5777:
  if (_trace) printf("g5777:\n");
  if (t4 == 0)
    goto g5770;
  /* Here if argument TypeFixnum */
  /* B. if ash of zero -- trivial case */
  if (arg4 == 0)
    goto zerash;
  /* B. if negative ash. */
  if ((s64)arg1 <= 0)
    goto negash;
  /* Sign extend ARG1 before shifting. */
  arg4 = (s32)arg4;
  arg5 = arg1 - 32;
  if ((s64)arg5 > 0)
    goto ashovexc;
  /* Shift Left */
  arg5 = arg4 << (arg1 & 63);
  arg6 = arg4 ^ arg5;
  /* arg6<0>=1 if overflow, 0 otherwise */
  arg6 = arg6 >> 31;
  /* TagType. */
  arg2 = arg2 & 63;
  /* J. if overflow */
  if (arg6 != 0)
    goto ashovexc;
  *(u32 *)iSP = arg5;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = arg2;
  goto NEXTINSTRUCTION;

negash:
  if (_trace) printf("negash:\n");
  arg1 = zero - arg1;
  /* Sign extend ARG1 before shifting. */
  arg4 = (s32)arg4;
  /* Shift Right */
  arg5 = (s64)arg4 >> $27(arg1 & 63);
  /* TagType. */
  arg2 = arg2 & 63;
  *(u32 *)iSP = arg5;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = arg2;
  goto NEXTINSTRUCTION;

zerash:
  if (_trace) printf("zerash:\n");
  arg5 = Type_Fixnum;
  *(u32 *)iSP = arg4;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = arg5;
  goto NEXTINSTRUCTION;

g5774:
  if (_trace) printf("g5774:\n");

g5773:
  if (_trace) printf("g5773:\n");
  /* Here for all other cases */

g5769:
  if (_trace) printf("g5769:\n");
  arg1 = (u32)arg1;
  /* SetTag. */
  t2 = arg2 << 32;
  t2 = arg1 | t2;
  /* arg6 = tag to dispatch on */
  arg6 = arg2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
  goto g5771;

g5770:
  if (_trace) printf("g5770:\n");
  arg1 = (u32)arg1;
  /* SetTag. */
  t2 = arg2 << 32;
  t2 = arg1 | t2;
  /* arg6 = tag to dispatch on */
  arg6 = arg3;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;

g5771:
  if (_trace) printf("g5771:\n");

g5772:
  if (_trace) printf("g5772:\n");

ashovexc:
  if (_trace) printf("ashovexc:\n");
  arg1 = (u32)arg1;
  /* SetTag. */
  t1 = arg2 << 32;
  t1 = arg1 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = arg2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto exception;

/* end DoAsh */
  /* End of Halfword operand from stack instruction - DoAsh */
/* start DoRot */

  /* Halfword operand from stack instruction - DoRot */
  /* arg2 has the preloaded 8 bit operand. */

dorot:
  if (_trace) printf("dorot:\n");
#ifdef TRACING
#endif

DoRotSP:
  if (_trace) printf("DoRotSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindorot;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindorot;
#endif

DoRotLP:
  if (_trace) printf("DoRotLP:\n");
#ifdef TRACING
  goto begindorot;
#endif

DoRotFP:
  if (_trace) printf("DoRotFP:\n");

begindorot:
  if (_trace) printf("begindorot:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;

g5783:
  if (_trace) printf("g5783:\n");
  /* Arg1 on the stack */
  t4 = (u32)(arg6 >> ((4&7)*8));
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Arg1 on the stack */
  t1 = (u32)arg6;
  /* Arg2 from operand */
  t5 = *(s32 *)(arg1 + 4);
  /* Strip CDR code if any. */
  t4 = t4 & 63;
  /* Arg2 from operand */
  t2 = *(s32 *)arg1;
  t4 = t4 - Type_Fixnum;
  t8 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Strip CDR code if any. */
  t5 = t5 & 63;
  if (t4 != 0)
    goto g5782;
  t2 = (u32)t2;
  t5 = t5 - Type_Fixnum;

g5784:
  if (_trace) printf("g5784:\n");
  if (t5 != 0)
    goto g5782;
  /* Get low 5 bits of the rotation */
  t2 = t2 & 31;
  /* Shift left to get new high bits */
  t3 = t1 << (t2 & 63);
  /* Get new low bits */
  t6 = (u32)(t3 >> ((4&7)*8));
  /* Glue two parts of shifted operand together */
  t3 = t3 | t6;

g5785:
  if (_trace) printf("g5785:\n");
  iPC = t7;
  /* Put the result back on the stack */
  *(u32 *)iSP = t3;
  iCP = t8;
  goto cachevalid;
#ifdef TRACING
  goto DoRotIM;
#endif

DoRotIM:
  if (_trace) printf("DoRotIM:\n");
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;
  goto g5783;

g5782:
  if (_trace) printf("g5782:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end DoRot */
  /* End of Halfword operand from stack instruction - DoRot */
/* start DoLsh */

  /* Halfword operand from stack instruction - DoLsh */
  /* arg2 has the preloaded 8 bit operand. */

dolsh:
  if (_trace) printf("dolsh:\n");
#ifdef TRACING
#endif

DoLshSP:
  if (_trace) printf("DoLshSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindolsh;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindolsh;
#endif

DoLshLP:
  if (_trace) printf("DoLshLP:\n");
#ifdef TRACING
  goto begindolsh;
#endif

DoLshFP:
  if (_trace) printf("DoLshFP:\n");

begindolsh:
  if (_trace) printf("begindolsh:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;

g5787:
  if (_trace) printf("g5787:\n");
  /* Arg1 on the stack */
  t4 = (u32)(arg6 >> ((4&7)*8));
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Arg1 on the stack */
  t1 = (u32)arg6;
  /* Arg2 from operand */
  t5 = *(s32 *)(arg1 + 4);
  /* Strip CDR code if any. */
  t4 = t4 & 63;
  /* Arg2 from operand */
  t2 = *(s32 *)arg1;
  t4 = t4 - Type_Fixnum;
  t8 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Strip CDR code if any. */
  t5 = t5 & 63;
  if (t4 != 0)
    goto g5786;
  t5 = t5 - Type_Fixnum;

g5788:
  if (_trace) printf("g5788:\n");
  if (t5 != 0)
    goto g5786;
  /* B. if negative lsh. */
  if ((s64)t2 < 0)
    goto neglsh;
  t3 = t2 - 32;
  if ((s64)t3 >= 0)
    goto returnzero;
  /* Shift Left */
  t3 = t1 << (t2 & 63);
  goto lshdone;

neglsh:
  if (_trace) printf("neglsh:\n");
  t2 = zero - t2;
  t3 = t2 - 32;
  if ((s64)t3 >= 0)
    goto returnzero;
  /* Shift Right */
  t3 = t1 >> (t2 & 63);
  goto lshdone;

returnzero:
  if (_trace) printf("returnzero:\n");
  t3 = t3 & ~t3;

lshdone:
  if (_trace) printf("lshdone:\n");

g5789:
  if (_trace) printf("g5789:\n");
  iPC = t7;
  /* Put the result back on the stack */
  *(u32 *)iSP = t3;
  iCP = t8;
  goto cachevalid;
#ifdef TRACING
  goto DoLshIM;
#endif

DoLshIM:
  if (_trace) printf("DoLshIM:\n");
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g5790:
  if (_trace) printf("g5790:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;
  goto g5787;

g5786:
  if (_trace) printf("g5786:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end DoLsh */
  /* End of Halfword operand from stack instruction - DoLsh */
/* start Do32BitPlus */

  /* Halfword operand from stack instruction - Do32BitPlus */
  /* arg2 has the preloaded 8 bit operand. */

do32bitplus:
  if (_trace) printf("do32bitplus:\n");
#ifdef TRACING
#endif

Do32BitPlusSP:
  if (_trace) printf("Do32BitPlusSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindo32bitplus;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindo32bitplus;
#endif

Do32BitPlusLP:
  if (_trace) printf("Do32BitPlusLP:\n");
#ifdef TRACING
  goto begindo32bitplus;
#endif

Do32BitPlusFP:
  if (_trace) printf("Do32BitPlusFP:\n");

begindo32bitplus:
  if (_trace) printf("begindo32bitplus:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;

g5792:
  if (_trace) printf("g5792:\n");
  /* Arg1 on the stack */
  t4 = (u32)(arg6 >> ((4&7)*8));
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Arg1 on the stack */
  t1 = (u32)arg6;
  /* Arg2 from operand */
  t5 = *(s32 *)(arg1 + 4);
  /* Strip CDR code if any. */
  t4 = t4 & 63;
  /* Arg2 from operand */
  t2 = *(s32 *)arg1;
  t4 = t4 - Type_Fixnum;
  t8 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Strip CDR code if any. */
  t5 = t5 & 63;
  if (t4 != 0)
    goto g5791;
  t2 = (u32)t2;
  t5 = t5 - Type_Fixnum;

g5793:
  if (_trace) printf("g5793:\n");
  if (t5 != 0)
    goto g5791;
  /* Perform the 32 bit Add. */
  t3 = t1 + t2;

g5794:
  if (_trace) printf("g5794:\n");
  iPC = t7;
  /* Put the result back on the stack */
  *(u32 *)iSP = t3;
  iCP = t8;
  goto cachevalid;
#ifdef TRACING
  goto Do32BitPlusIM;
#endif

Do32BitPlusIM:
  if (_trace) printf("Do32BitPlusIM:\n");
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;
  goto g5792;

g5791:
  if (_trace) printf("g5791:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end Do32BitPlus */
  /* End of Halfword operand from stack instruction - Do32BitPlus */
/* start Do32BitDifference */

  /* Halfword operand from stack instruction - Do32BitDifference */
  /* arg2 has the preloaded 8 bit operand. */

do32bitdifference:
  if (_trace) printf("do32bitdifference:\n");
#ifdef TRACING
#endif

Do32BitDifferenceSP:
  if (_trace) printf("Do32BitDifferenceSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindo32bitdifference;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindo32bitdifference;
#endif

Do32BitDifferenceLP:
  if (_trace) printf("Do32BitDifferenceLP:\n");
#ifdef TRACING
  goto begindo32bitdifference;
#endif

Do32BitDifferenceFP:
  if (_trace) printf("Do32BitDifferenceFP:\n");

begindo32bitdifference:
  if (_trace) printf("begindo32bitdifference:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;

g5796:
  if (_trace) printf("g5796:\n");
  /* Arg1 on the stack */
  t4 = (u32)(arg6 >> ((4&7)*8));
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Arg1 on the stack */
  t1 = (u32)arg6;
  /* Arg2 from operand */
  t5 = *(s32 *)(arg1 + 4);
  /* Strip CDR code if any. */
  t4 = t4 & 63;
  /* Arg2 from operand */
  t2 = *(s32 *)arg1;
  t4 = t4 - Type_Fixnum;
  t8 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Strip CDR code if any. */
  t5 = t5 & 63;
  if (t4 != 0)
    goto g5795;
  t2 = (u32)t2;
  t5 = t5 - Type_Fixnum;

g5797:
  if (_trace) printf("g5797:\n");
  if (t5 != 0)
    goto g5795;
  /* Perform the 32 bit Difference. */
  t3 = t1 - t2;

g5798:
  if (_trace) printf("g5798:\n");
  iPC = t7;
  /* Put the result back on the stack */
  *(u32 *)iSP = t3;
  iCP = t8;
  goto cachevalid;
#ifdef TRACING
  goto Do32BitDifferenceIM;
#endif

Do32BitDifferenceIM:
  if (_trace) printf("Do32BitDifferenceIM:\n");
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;
  goto g5796;

g5795:
  if (_trace) printf("g5795:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end Do32BitDifference */
  /* End of Halfword operand from stack instruction - Do32BitDifference */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunbits.as */
