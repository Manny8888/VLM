/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * ANY CHANGES MADE TO THIS FILE WILL BE LOST
 *
 * File translated:      ../alpha-emulator/ifunarra.as
 ************************************************************************/

  /* Array operations. */
/* start Aref1Regset */


aref1regset:
  if (_trace) printf("aref1regset:\n");
  t12 = arg4;
  /* Memory Read Internal */

g5125:
  /* Base of stack cache */
  t1 = *(u64 *)&(processor->stackcachebasevma);
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;
  arg6 = (t3 * 4);
  arg5 = LDQ_U(t3);
  /* Stack cache offset */
  t1 = arg4 - t1;
  t4 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t3&7)*8));
  if (t2 != 0)
    goto g5127;

g5126:
  t3 = zero + 64;
  t4 = t4 >> (arg5 & 63);
  t3 = t3 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t4 & 1)
    goto g5129;

g5134:
  /* TagType. */
  t1 = arg5 & 63;
  t2 = arg6 >> (Array_LongPrefixBitPos & 63);
  t1 = t1 - Type_HeaderI;
  if (t1 != 0)
    goto aref1illegal;
  if (t2 & 1)
    goto aref1exception;
  /* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t12;
  t2 = zero + Array_LengthMask;
  t1 = arg6 & t2;
  t2 = ((u64)arg2 < (u64)t1) ? 1 : 0;
  if (t2 == 0)
    goto aref1bounds;
  /* store the array length [implicit fixnum] */
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;
  t10 = arg6 >> (Array_RegisterBytePackingPos & 63);
  t8 = *(u64 *)&(processor->areventcount);
  t10 = t10 << (Array_RegisterBytePackingPos & 63);
  t9 = arg4 + 1;
  /* Construct the array register word */
  t10 = t10 + t8;
  /* store the array register word [implicit fixnum] */
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t10;
  /* store the storage [implicit locative] */
  *(u64 *)&((ARRAYCACHEP)t7)->locat = t9;
  /* get BP into arg5 */
  arg5 = arg6 >> (Array_BytePackingPos & 63);
  /* get element type into arg6 */
  arg6 = arg6 >> (Array_ElementTypePos & 63);
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = zero;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aref1restart;

g5127:
  if (_trace) printf("g5127:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t1 = (t1 * 8) + t2;
  arg6 = *(s32 *)t1;
  /* Read from stack cache */
  arg5 = *(s32 *)(t1 + 4);
  goto g5126;

g5129:
  if (_trace) printf("g5129:\n");
  if ((t3 & 1) == 0)
    goto g5128;
  /* Do the indirect thing */
  arg4 = (u32)arg6;
  goto g5125;

g5128:
  if (_trace) printf("g5128:\n");
  /* Load the memory action table for cycle */
  t4 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t3 = arg5 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t3 = (t3 * 4) + t4;
  /* Get the memory action */
  t4 = *(s32 *)t3;

g5131:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end Aref1Regset */
/* start Aref1RecomputeArrayRegister */


aref1recomputearrayregister:
  if (_trace) printf("aref1recomputearrayregister:\n");
  t5 = *(s32 *)(arg1 + -8);
  t4 = *(s32 *)(arg1 + -4);
  t5 = (u32)t5;
  t6 = t4 - Type_Array;
  /* Strip CDR code, low bits */
  t6 = t6 & 62;
  if (t6 != 0)
    goto g5136;
  /* Memory Read Internal */

g5138:
  /* Base of stack cache */
  t8 = *(u64 *)&(processor->stackcachebasevma);
  t3 = t5 + ivory;
  t2 = *(s32 *)&processor->scovlimit;
  t6 = (t3 * 4);
  t7 = LDQ_U(t3);
  /* Stack cache offset */
  t8 = t5 - t8;
  t1 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t2 = ((u64)t8 < (u64)t2) ? 1 : 0;
  t6 = *(s32 *)t6;
  t7 = (u8)(t7 >> ((t3&7)*8));
  if (t2 != 0)
    goto g5140;

g5139:
  t3 = zero + 64;
  t1 = t1 >> (t7 & 63);
  t3 = t3 >> (t7 & 63);
  t6 = (u32)t6;
  if (t1 & 1)
    goto g5142;

g5147:
  /* TagType. */
  t8 = t7 & 63;
  t2 = t6 >> (Array_LongPrefixBitPos & 63);
  t8 = t8 - Type_HeaderI;
  if (t8 != 0)
    goto g5135;
  if (t2 & 1)
    goto g5137;
  t1 = t6 >> (Array_BytePackingPos & 63);
  t4 = *(u64 *)&(processor->areventcount);
  t1 = t1 << (Array_RegisterBytePackingPos & 63);
  t2 = t5 + 1;
  /* Construct the array register word */
  t1 = t1 + t4;
  *(u32 *)(arg1 + 8) = t2;
  t3 = zero + Array_LengthMask;
  t3 = t6 & t3;
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaref1retry;

g5137:
  if (_trace) printf("g5137:\n");
  /* Just a place to save these values */
  *(u64 *)&processor->asrf5 = arg1;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf4 = t10;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf3 = t11;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf6 = arg1;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf7 = arg2;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf8 = arg3;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf9 = arg4;
  t9 = *(s32 *)(arg1 + -8);
  arg2 = *(s32 *)(arg1 + -4);
  t9 = (u32)t9;
  arg1 = t5;
  t4 = t7;
  t3 = t6;
  t2 = 1;
  iSP = iSP + 24;
  r0 = (u64)&&return0181;
  goto setup1dlongarray;
return0181:
  t4 = (t2 == ReturnValue_Exception) ? 1 : 0;
  if (t4 != 0)
    goto g5136;
  /* Just a place to save these values */
  arg1 = *(u64 *)&(processor->asrf5);
  /* Just a place to save these values */
  t10 = *(u64 *)&(processor->asrf4);
  /* Just a place to save these values */
  t11 = *(u64 *)&(processor->asrf3);
  /* Just a place to save these values */
  arg1 = *(u64 *)&(processor->asrf6);
  /* Just a place to save these values */
  arg2 = *(u64 *)&(processor->asrf7);
  /* Just a place to save these values */
  arg3 = *(u64 *)&(processor->asrf8);
  /* Just a place to save these values */
  arg4 = *(u64 *)&(processor->asrf9);
  t3 = *(u64 *)iSP;
  /* Pop Stack. */
  iSP = iSP - 8;
  t2 = *(u64 *)iSP;
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = *(u64 *)iSP;
  /* Pop Stack. */
  iSP = iSP - 8;
  t4 = *(u64 *)iSP;
  /* Pop Stack. */
  iSP = iSP - 8;
  iSP = iSP - 24;
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 8) = t2;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaref1retry;

g5136:
  if (_trace) printf("g5136:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t4;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  arg5 = 0;
  arg2 = 12;
  goto arrayexception;

g5135:
  if (_trace) printf("g5135:\n");
  arg5 = 0;
  arg2 = 12;
  goto illegaloperand;

g5140:
  if (_trace) printf("g5140:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t8 = (t8 * 8) + t2;
  t6 = *(s32 *)t8;
  /* Read from stack cache */
  t7 = *(s32 *)(t8 + 4);
  goto g5139;

g5142:
  if (_trace) printf("g5142:\n");
  if ((t3 & 1) == 0)
    goto g5141;
  /* Do the indirect thing */
  t5 = (u32)t6;
  goto g5138;

g5141:
  if (_trace) printf("g5141:\n");
  /* Load the memory action table for cycle */
  t1 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t3 = t7 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t5;
  /* Adjust for a longword load */
  t3 = (t3 * 4) + t1;
  /* Get the memory action */
  t1 = *(s32 *)t3;

g5144:
  /* Perform memory action */
  arg1 = t1;
  arg2 = 6;
  goto performmemoryaction;

/* end Aref1RecomputeArrayRegister */
/* start Aref1Exception */


aref1exception:
  if (_trace) printf("aref1exception:\n");
  /* Just a place to save these values */
  *(u64 *)&processor->asrf4 = arg2;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf5 = t7;
  t9 = t12;
  arg2 = arg3;
  arg1 = arg4;
  t4 = arg5;
  t3 = arg6;
  t2 = zero;
  iSP = iSP + 24;
  r0 = (u64)&&return0182;
  goto setup1dlongarray;
return0182:
  /* Just a place to save these values */
  arg2 = *(s32 *)&processor->asrf4;
  /* Just a place to save these values */
  t7 = *(u64 *)&(processor->asrf5);
  /* Length */
  t1 = *(s32 *)iSP;
  /* Length */
  t5 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  /* base */
  t5 = *(u64 *)iSP;
  /* Pop Stack. */
  iSP = iSP - 8;
  /* control */
  t3 = *(u64 *)iSP;
  /* Pop Stack. */
  iSP = iSP - 8;
  /* The original array */
  t9 = *(s32 *)iSP;
  /* The original array */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t9 = (u32)t9;
  iSP = iSP - 24;
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t3;
  *(u32 *)&((ARRAYCACHEP)t7)->locat = t5;
  /* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t9;
  t9 = (u32)t5;
  t2 = (t2 == ReturnValue_Exception) ? 1 : 0;
  if (t2 != 0)
    goto reallyaref1exc;
  t5 = ((u64)arg2 < (u64)t1) ? 1 : 0;
  if (t5 == 0)
    goto aref1bounds;
  /* get BP into arg5 */
  arg5 = t3 >> (Array_BytePackingPos & 63);
  /* get element type into arg6 */
  arg6 = t3 >> (Array_ElementTypePos & 63);
  arg4 = t3 >> (Array_RegisterByteOffsetPos & 63);
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = arg4 & Array_RegisterByteOffsetMask;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aref1restart;

reallyaref1exc:
  if (_trace) printf("reallyaref1exc:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = arg3;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  arg5 = 0;
  arg2 = 8;
  goto arrayexception;

aref1illegal:
  if (_trace) printf("aref1illegal:\n");
  arg5 = 0;
  arg2 = 8;
  goto illegaloperand;

aref1bounds:
  if (_trace) printf("aref1bounds:\n");
  *(u64 *)&((ARRAYCACHEP)t7)->array = zero;
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;

/* end Aref1Exception */
/* start Aset1Regset */


aset1regset:
  if (_trace) printf("aset1regset:\n");
  t12 = arg4;
  /* Memory Read Internal */

g5148:
  /* Base of stack cache */
  t1 = *(u64 *)&(processor->stackcachebasevma);
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;
  arg6 = (t3 * 4);
  arg5 = LDQ_U(t3);
  /* Stack cache offset */
  t1 = arg4 - t1;
  t4 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t3&7)*8));
  if (t2 != 0)
    goto g5150;

g5149:
  t3 = zero + 64;
  t4 = t4 >> (arg5 & 63);
  t3 = t3 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t4 & 1)
    goto g5152;

g5157:
  /* TagType. */
  t1 = arg5 & 63;
  t2 = arg6 >> (Array_LongPrefixBitPos & 63);
  t1 = t1 - Type_HeaderI;
  if (t1 != 0)
    goto aset1illegal;
  if (t2 & 1)
    goto aset1exception;
  /* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t12;
  t2 = zero + Array_LengthMask;
  t1 = arg6 & t2;
  t2 = ((u64)arg2 < (u64)t1) ? 1 : 0;
  if (t2 == 0)
    goto aset1bounds;
  /* store the array length [implicit fixnum] */
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;
  t10 = arg6 >> (Array_RegisterBytePackingPos & 63);
  t8 = *(u64 *)&(processor->areventcount);
  t10 = t10 << (Array_RegisterBytePackingPos & 63);
  t9 = arg4 + 1;
  /* Construct the array register word */
  t10 = t10 + t8;
  /* store the array register word [implicit fixnum] */
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t10;
  /* store the storage [implicit locative] */
  *(u64 *)&((ARRAYCACHEP)t7)->locat = t9;
  /* get BP into arg5 */
  arg5 = arg6 >> (Array_BytePackingPos & 63);
  /* get element type into arg6 */
  arg6 = arg6 >> (Array_ElementTypePos & 63);
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = zero;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aset1restart;

g5150:
  if (_trace) printf("g5150:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t1 = (t1 * 8) + t2;
  arg6 = *(s32 *)t1;
  /* Read from stack cache */
  arg5 = *(s32 *)(t1 + 4);
  goto g5149;

g5152:
  if (_trace) printf("g5152:\n");
  if ((t3 & 1) == 0)
    goto g5151;
  /* Do the indirect thing */
  arg4 = (u32)arg6;
  goto g5148;

g5151:
  if (_trace) printf("g5151:\n");
  /* Load the memory action table for cycle */
  t4 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t3 = arg5 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t3 = (t3 * 4) + t4;
  /* Get the memory action */
  t4 = *(s32 *)t3;

g5154:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end Aset1Regset */
/* start Aset1RecomputeArrayRegister */


aset1recomputearrayregister:
  if (_trace) printf("aset1recomputearrayregister:\n");
  t5 = *(s32 *)(arg1 + -8);
  t4 = *(s32 *)(arg1 + -4);
  t5 = (u32)t5;
  t6 = t4 - Type_Array;
  /* Strip CDR code, low bits */
  t6 = t6 & 62;
  if (t6 != 0)
    goto g5159;
  /* Memory Read Internal */

g5161:
  /* Base of stack cache */
  t8 = *(u64 *)&(processor->stackcachebasevma);
  t3 = t5 + ivory;
  t2 = *(s32 *)&processor->scovlimit;
  t6 = (t3 * 4);
  t7 = LDQ_U(t3);
  /* Stack cache offset */
  t8 = t5 - t8;
  t1 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t2 = ((u64)t8 < (u64)t2) ? 1 : 0;
  t6 = *(s32 *)t6;
  t7 = (u8)(t7 >> ((t3&7)*8));
  if (t2 != 0)
    goto g5163;

g5162:
  t3 = zero + 64;
  t1 = t1 >> (t7 & 63);
  t3 = t3 >> (t7 & 63);
  t6 = (u32)t6;
  if (t1 & 1)
    goto g5165;

g5170:
  /* TagType. */
  t8 = t7 & 63;
  t2 = t6 >> (Array_LongPrefixBitPos & 63);
  t8 = t8 - Type_HeaderI;
  if (t8 != 0)
    goto g5158;
  if (t2 & 1)
    goto g5160;
  t1 = t6 >> (Array_BytePackingPos & 63);
  t4 = *(u64 *)&(processor->areventcount);
  t1 = t1 << (Array_RegisterBytePackingPos & 63);
  t2 = t5 + 1;
  /* Construct the array register word */
  t1 = t1 + t4;
  *(u32 *)(arg1 + 8) = t2;
  t3 = zero + Array_LengthMask;
  t3 = t6 & t3;
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaset1retry;

g5160:
  if (_trace) printf("g5160:\n");
  /* Just a place to save these values */
  *(u64 *)&processor->asrf5 = arg1;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf4 = t10;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf3 = t11;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf6 = arg1;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf7 = arg2;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf8 = arg3;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf9 = arg4;
  t9 = *(s32 *)(arg1 + -8);
  arg2 = *(s32 *)(arg1 + -4);
  t9 = (u32)t9;
  arg1 = t5;
  t4 = t7;
  t3 = t6;
  t2 = 1;
  iSP = iSP + 24;
  r0 = (u64)&&return0183;
  goto setup1dlongarray;
return0183:
  t4 = (t2 == ReturnValue_Exception) ? 1 : 0;
  if (t4 != 0)
    goto g5159;
  /* Just a place to save these values */
  arg1 = *(u64 *)&(processor->asrf5);
  /* Just a place to save these values */
  t10 = *(u64 *)&(processor->asrf4);
  /* Just a place to save these values */
  t11 = *(u64 *)&(processor->asrf3);
  /* Just a place to save these values */
  arg1 = *(u64 *)&(processor->asrf6);
  /* Just a place to save these values */
  arg2 = *(u64 *)&(processor->asrf7);
  /* Just a place to save these values */
  arg3 = *(u64 *)&(processor->asrf8);
  /* Just a place to save these values */
  arg4 = *(u64 *)&(processor->asrf9);
  t3 = *(u64 *)iSP;
  /* Pop Stack. */
  iSP = iSP - 8;
  t2 = *(u64 *)iSP;
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = *(u64 *)iSP;
  /* Pop Stack. */
  iSP = iSP - 8;
  t4 = *(u64 *)iSP;
  /* Pop Stack. */
  iSP = iSP - 8;
  iSP = iSP - 24;
  *(u32 *)arg1 = t1;
  *(u32 *)(arg1 + 8) = t2;
  *(u32 *)(arg1 + 16) = t3;
  goto fastaset1retry;

g5159:
  if (_trace) printf("g5159:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t4;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 3;
  /* arg4 = arithmeticp */
  arg4 = 0;
  arg5 = 0;
  arg2 = 12;
  goto arrayexception;

g5158:
  if (_trace) printf("g5158:\n");
  arg5 = 0;
  arg2 = 12;
  goto illegaloperand;

g5163:
  if (_trace) printf("g5163:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t8 = (t8 * 8) + t2;
  t6 = *(s32 *)t8;
  /* Read from stack cache */
  t7 = *(s32 *)(t8 + 4);
  goto g5162;

g5165:
  if (_trace) printf("g5165:\n");
  if ((t3 & 1) == 0)
    goto g5164;
  /* Do the indirect thing */
  t5 = (u32)t6;
  goto g5161;

g5164:
  if (_trace) printf("g5164:\n");
  /* Load the memory action table for cycle */
  t1 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t3 = t7 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t5;
  /* Adjust for a longword load */
  t3 = (t3 * 4) + t1;
  /* Get the memory action */
  t1 = *(s32 *)t3;

g5167:
  /* Perform memory action */
  arg1 = t1;
  arg2 = 6;
  goto performmemoryaction;

/* end Aset1RecomputeArrayRegister */
/* start Aset1Exception */


aset1exception:
  if (_trace) printf("aset1exception:\n");
  /* Just a place to save these values */
  *(u64 *)&processor->asrf4 = arg2;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf3 = t5;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf6 = t6;
  /* Just a place to save these values */
  *(u64 *)&processor->asrf5 = t7;
  t9 = t12;
  arg2 = arg3;
  arg1 = arg4;
  t4 = arg5;
  t3 = arg6;
  t2 = zero;
  iSP = iSP + 24;
  r0 = (u64)&&return0184;
  goto setup1dlongarray;
return0184:
  t1 = (t2 == ReturnValue_Exception) ? 1 : 0;
  if (t1 != 0)
    goto reallyaset1exc;
  /* Just a place to save these values */
  arg2 = *(s32 *)&processor->asrf4;
  /* Just a place to save these values */
  t5 = *(u64 *)&(processor->asrf3);
  /* Just a place to save these values */
  t6 = *(u64 *)&(processor->asrf6);
  /* Just a place to save these values */
  t7 = *(u64 *)&(processor->asrf5);
  /* Length */
  t1 = *(s32 *)iSP;
  /* Length */
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  /* base */
  t2 = *(u64 *)iSP;
  /* Pop Stack. */
  iSP = iSP - 8;
  /* control */
  t3 = *(u64 *)iSP;
  /* Pop Stack. */
  iSP = iSP - 8;
  /* The original array */
  t9 = *(s32 *)iSP;
  /* The original array */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t9 = (u32)t9;
  iSP = iSP - 24;
  *(u64 *)&((ARRAYCACHEP)t7)->length = t1;
  *(u32 *)&((ARRAYCACHEP)t7)->arword = t3;
  *(u32 *)&((ARRAYCACHEP)t7)->locat = t2;
  /* store the array */
  *(u32 *)&((ARRAYCACHEP)t7)->array = t9;
  t9 = (u32)t2;
  t2 = ((u64)arg2 < (u64)t1) ? 1 : 0;
  if (t2 == 0)
    goto aset1bounds;
  /* get BP into arg5 */
  arg5 = t3 >> (Array_BytePackingPos & 63);
  /* get element type into arg6 */
  arg6 = t3 >> (Array_ElementTypePos & 63);
  arg4 = t3 >> (Array_RegisterByteOffsetPos & 63);
  arg5 = arg5 & Array_BytePackingMask;
  arg4 = arg4 & Array_RegisterByteOffsetMask;
  arg6 = arg6 & Array_ElementTypeMask;
  goto aset1restart;

reallyaset1exc:
  if (_trace) printf("reallyaset1exc:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = arg3;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 3;
  /* arg4 = arithmeticp */
  arg4 = 0;
  arg5 = 0;
  arg2 = 9;
  goto arrayexception;

aset1illegal:
  if (_trace) printf("aset1illegal:\n");
  arg5 = 0;
  arg2 = 9;
  goto illegaloperand;

aset1bounds:
  if (_trace) printf("aset1bounds:\n");
  *(u64 *)&((ARRAYCACHEP)t7)->array = zero;
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;

/* end Aset1Exception */
/* start DoAloc1 */

  /* Halfword operand from stack instruction - DoAloc1 */
  /* arg2 has the preloaded 8 bit operand. */

doaloc1:
  if (_trace) printf("doaloc1:\n");
#ifdef TRACING
#endif

DoAloc1SP:
  if (_trace) printf("DoAloc1SP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoaloc1;
#endif

DoAloc1LP:
  if (_trace) printf("DoAloc1LP:\n");
#ifdef TRACING
  goto headdoaloc1;
#endif

DoAloc1FP:
  if (_trace) printf("DoAloc1FP:\n");

headdoaloc1:
  if (_trace) printf("headdoaloc1:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoaloc1:
  if (_trace) printf("begindoaloc1:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  /* Get the array tag/data */
  arg4 = *(s32 *)iSP;
  /* Get the array tag/data */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  /* Index Data */
  arg2 = (u32)arg1;
  /* Index Tag */
  arg1 = arg1 >> 32;
  t1 = arg1 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto aloc1illegal;

aloc1merge:
  if (_trace) printf("aloc1merge:\n");
  t1 = arg3 - Type_Array;
  /* Strip CDR code, low bits */
  t1 = t1 & 62;
  if (t1 != 0)
    goto aloc1exception;
  /* Memory Read Internal */

g5171:
  /* Base of stack cache */
  t1 = *(u64 *)&(processor->stackcachebasevma);
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;
  arg6 = (t3 * 4);
  arg5 = LDQ_U(t3);
  /* Stack cache offset */
  t1 = arg4 - t1;
  t4 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t3&7)*8));
  if (t2 != 0)
    goto g5173;

g5172:
  t3 = zero + 64;
  t4 = t4 >> (arg5 & 63);
  t3 = t3 >> (arg5 & 63);
  if (t4 & 1)
    goto g5175;

g5180:
  /* TagType. */
  t1 = arg5 & 63;
  t2 = arg6 >> (Array_LongPrefixBitPos & 63);
  t1 = t1 - Type_HeaderI;
  if (t1 != 0)
    goto aloc1illegal;
  if (t2 & 1)
    goto aloc1exception;
  t2 = zero + Array_LengthMask;
  t1 = arg6 & t2;
  t3 = ((u64)arg2 < (u64)t1) ? 1 : 0;
  if (t3 == 0)
    goto aloc1illegal;
  /* get element type into arg6 */
  arg6 = arg6 >> (Array_ElementTypePos & 63);
  arg4 = arg4 + 1;
  arg4 = arg4 + arg2;
  arg6 = arg6 & Array_ElementTypeMask;
  arg6 = arg6 - Array_ElementTypeObject;
  if (arg6 != 0)
    goto aloc1notobject;
  t1 = Type_Locative;
  *(u32 *)(iSP + 8) = arg4;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

aloc1exception:
  if (_trace) printf("aloc1exception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = arg3;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  arg5 = 0;
  arg2 = 8;
  goto arrayexception;

aloc1illegal:
  if (_trace) printf("aloc1illegal:\n");
  arg5 = 0;
  arg2 = 8;
  goto illegaloperand;

aloc1bounds:
  if (_trace) printf("aloc1bounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;

aloc1notobject:
  if (_trace) printf("aloc1notobject:\n");
  arg5 = 0;
  arg2 = 7;
  goto illegaloperand;
#ifdef TRACING
  goto DoAloc1IM;
#endif

DoAloc1IM:
  if (_trace) printf("DoAloc1IM:\n");
  /* Get the array tag/data */
  arg4 = *(s32 *)iSP;
  /* Get the array tag/data */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  goto aloc1merge;

g5173:
  if (_trace) printf("g5173:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t1 = (t1 * 8) + t2;
  arg6 = *(s32 *)t1;
  /* Read from stack cache */
  arg5 = *(s32 *)(t1 + 4);
  goto g5172;

g5175:
  if (_trace) printf("g5175:\n");
  if ((t3 & 1) == 0)
    goto g5174;
  /* Do the indirect thing */
  arg4 = (u32)arg6;
  goto g5171;

g5174:
  if (_trace) printf("g5174:\n");
  /* Load the memory action table for cycle */
  t4 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t3 = arg5 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t3 = (t3 * 4) + t4;
  /* Get the memory action */
  t4 = *(s32 *)t3;

g5177:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoAloc1 */
  /* End of Halfword operand from stack instruction - DoAloc1 */
  /* Array register operations. */
/* start DoSetup1DArray */

  /* Halfword operand from stack instruction - DoSetup1DArray */

dosetup1darray:
  if (_trace) printf("dosetup1darray:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoSetup1DArrayIM:
  if (_trace) printf("DoSetup1DArrayIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g5194:
  if (_trace) printf("g5194:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindosetup1darray;
#ifdef TRACING
#endif

DoSetup1DArraySP:
  if (_trace) printf("DoSetup1DArraySP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdosetup1darray;
#endif

DoSetup1DArrayLP:
  if (_trace) printf("DoSetup1DArrayLP:\n");
#ifdef TRACING
  goto headdosetup1darray;
#endif

DoSetup1DArrayFP:
  if (_trace) printf("DoSetup1DArrayFP:\n");

headdosetup1darray:
  if (_trace) printf("headdosetup1darray:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindosetup1darray:
  if (_trace) printf("begindosetup1darray:\n");
  /* arg1 has the operand, sign extended if immediate. */
  /* Get the tag */
  arg2 = arg1 >> 32;
  /* and the data */
  arg1 = (u32)arg1;
  /* Indicate not forcing 1d */
  t2 = 0;
  t9 = arg1;
  t3 = arg2 - Type_Array;
  /* Strip CDR code, low bits */
  t3 = t3 & 62;
  if (t3 != 0)
    goto g5182;
  /* Memory Read Internal */

g5184:
  /* Base of stack cache */
  t5 = *(u64 *)&(processor->stackcachebasevma);
  t7 = arg1 + ivory;
  t6 = *(s32 *)&processor->scovlimit;
  t3 = (t7 * 4);
  t4 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg1 - t5;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t6) ? 1 : 0;
  t3 = *(s32 *)t3;
  t4 = (u8)(t4 >> ((t7&7)*8));
  if (t6 != 0)
    goto g5186;

g5185:
  t7 = zero + 64;
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  t3 = (u32)t3;
  if (t8 & 1)
    goto g5188;

g5193:
  /* TagType. */
  t5 = t4 & 63;
  t6 = t3 >> (Array_LongPrefixBitPos & 63);
  t5 = t5 - Type_HeaderI;
  if (t5 != 0)
    goto g5181;
  if (t6 & 1)
    goto g5183;
  /* set CDR-NEXT */
  t5 = arg2 & 63;
  *(u32 *)(iSP + 8) = t9;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  t8 = t3 >> (Array_RegisterBytePackingPos & 63);
  t7 = Type_Fixnum;
  t1 = *(u64 *)&(processor->areventcount);
  t8 = t8 << (Array_RegisterBytePackingPos & 63);
  t5 = arg1 + 1;
  /* Construct the array register word */
  t8 = t8 + t1;
  /* set CDR-NEXT */
  t6 = t7 & 63;
  *(u32 *)(iSP + 8) = t8;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  t6 = zero + Array_LengthMask;
  t6 = t3 & t6;
  /* set CDR-NEXT */
  t8 = t7 & 63;
  *(u32 *)(iSP + 8) = t6;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

g5182:
  if (_trace) printf("g5182:\n");
  /* SetTag. */
  t6 = arg2 << 32;
  t6 = t9 | t6;
  /* arg6 = tag to dispatch on */
  arg6 = arg2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 0;
  arg5 = 0;
  arg2 = 71;
  goto arrayexception;

g5181:
  if (_trace) printf("g5181:\n");
  arg5 = 0;
  arg2 = 71;
  goto illegaloperand;

g5183:
  if (_trace) printf("g5183:\n");
  r0 = (u64)&&return0185;
  goto setup1dlongarray;
return0185:
  t1 = (t2 == ReturnValue_Normal) ? 1 : 0;
  if (t1 != 0)
    goto NEXTINSTRUCTION;
  t1 = (t2 == ReturnValue_Exception) ? 1 : 0;
  if (t1 != 0)
    goto g5182;
  t1 = (t2 == ReturnValue_IllegalOperand) ? 1 : 0;
  if (t1 != 0)
    goto g5181;
  goto NEXTINSTRUCTION;

g5186:
  if (_trace) printf("g5186:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t3 = *(s32 *)t5;
  /* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g5185;

g5188:
  if (_trace) printf("g5188:\n");
  if ((t7 & 1) == 0)
    goto g5187;
  /* Do the indirect thing */
  arg1 = (u32)t3;
  goto g5184;

g5187:
  if (_trace) printf("g5187:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g5190:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoSetup1DArray */
  /* End of Halfword operand from stack instruction - DoSetup1DArray */
/* start DoSetupForce1DArray */

  /* Halfword operand from stack instruction - DoSetupForce1DArray */

dosetupforce1darray:
  if (_trace) printf("dosetupforce1darray:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoSetupForce1DArrayIM:
  if (_trace) printf("DoSetupForce1DArrayIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g5208:
  if (_trace) printf("g5208:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindosetupforce1darray;
#ifdef TRACING
#endif

DoSetupForce1DArraySP:
  if (_trace) printf("DoSetupForce1DArraySP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdosetupforce1darray;
#endif

DoSetupForce1DArrayLP:
  if (_trace) printf("DoSetupForce1DArrayLP:\n");
#ifdef TRACING
  goto headdosetupforce1darray;
#endif

DoSetupForce1DArrayFP:
  if (_trace) printf("DoSetupForce1DArrayFP:\n");

headdosetupforce1darray:
  if (_trace) printf("headdosetupforce1darray:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindosetupforce1darray:
  if (_trace) printf("begindosetupforce1darray:\n");
  /* arg1 has the operand, sign extended if immediate. */
  /* Get the tag */
  arg2 = arg1 >> 32;
  /* and the data */
  arg1 = (u32)arg1;
  /* Indicate forcing 1d */
  t2 = 1;
  t9 = arg1;
  t3 = arg2 - Type_Array;
  /* Strip CDR code, low bits */
  t3 = t3 & 62;
  if (t3 != 0)
    goto g5196;
  /* Memory Read Internal */

g5198:
  /* Base of stack cache */
  t5 = *(u64 *)&(processor->stackcachebasevma);
  t7 = arg1 + ivory;
  t6 = *(s32 *)&processor->scovlimit;
  t3 = (t7 * 4);
  t4 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg1 - t5;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t6) ? 1 : 0;
  t3 = *(s32 *)t3;
  t4 = (u8)(t4 >> ((t7&7)*8));
  if (t6 != 0)
    goto g5200;

g5199:
  t7 = zero + 64;
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  t3 = (u32)t3;
  if (t8 & 1)
    goto g5202;

g5207:
  /* TagType. */
  t5 = t4 & 63;
  t6 = t3 >> (Array_LongPrefixBitPos & 63);
  t5 = t5 - Type_HeaderI;
  if (t5 != 0)
    goto g5195;
  if (t6 & 1)
    goto g5197;
  /* set CDR-NEXT */
  t5 = arg2 & 63;
  *(u32 *)(iSP + 8) = t9;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  t8 = t3 >> (Array_RegisterBytePackingPos & 63);
  t7 = Type_Fixnum;
  t1 = *(u64 *)&(processor->areventcount);
  t8 = t8 << (Array_RegisterBytePackingPos & 63);
  t5 = arg1 + 1;
  /* Construct the array register word */
  t8 = t8 + t1;
  /* set CDR-NEXT */
  t6 = t7 & 63;
  *(u32 *)(iSP + 8) = t8;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  t6 = zero + Array_LengthMask;
  t6 = t3 & t6;
  /* set CDR-NEXT */
  t8 = t7 & 63;
  *(u32 *)(iSP + 8) = t6;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

g5196:
  if (_trace) printf("g5196:\n");
  /* SetTag. */
  t6 = arg2 << 32;
  t6 = t9 | t6;
  /* arg6 = tag to dispatch on */
  arg6 = arg2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 0;
  arg5 = 0;
  arg2 = 71;
  goto arrayexception;

g5195:
  if (_trace) printf("g5195:\n");
  arg5 = 0;
  arg2 = 71;
  goto illegaloperand;

g5197:
  if (_trace) printf("g5197:\n");
  r0 = (u64)&&return0186;
  goto setup1dlongarray;
return0186:
  t1 = (t2 == ReturnValue_Normal) ? 1 : 0;
  if (t1 != 0)
    goto NEXTINSTRUCTION;
  t1 = (t2 == ReturnValue_Exception) ? 1 : 0;
  if (t1 != 0)
    goto g5196;
  t1 = (t2 == ReturnValue_IllegalOperand) ? 1 : 0;
  if (t1 != 0)
    goto g5195;
  goto NEXTINSTRUCTION;

g5200:
  if (_trace) printf("g5200:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t3 = *(s32 *)t5;
  /* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g5199;

g5202:
  if (_trace) printf("g5202:\n");
  if ((t7 & 1) == 0)
    goto g5201;
  /* Do the indirect thing */
  arg1 = (u32)t3;
  goto g5198;

g5201:
  if (_trace) printf("g5201:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g5204:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoSetupForce1DArray */
  /* End of Halfword operand from stack instruction - DoSetupForce1DArray */
/* start Setup1DLongArray */


setup1dlongarray:
  if (_trace) printf("setup1dlongarray:\n");
  /* Read data from the header: alength offset indirect lengths&mults */
  /* length=array+1 */
  t1 = arg1 + 1;
  /* Memory Read Internal */

g5218:
  /* Base of stack cache */
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;
  arg4 = (t10 * 4);
  t6 = LDQ_U(t10);
  /* Stack cache offset */
  t7 = t1 - t7;
  t11 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;
  arg4 = *(s32 *)arg4;
  t6 = (u8)(t6 >> ((t10&7)*8));
  if (t8 != 0)
    goto g5220;

g5219:
  t10 = zero + 240;
  t11 = t11 >> (t6 & 63);
  t10 = t10 >> (t6 & 63);
  arg4 = (u32)arg4;
  if (t11 & 1)
    goto g5222;

g5229:
  t8 = t6 - Type_Fixnum;
  /* Strip CDR code */
  t8 = t8 & 63;
  if (t8 != 0)
    goto g5209;
  /* Offset is adata+2 */
  t1 = t1 + 1;
  /* Memory Read Internal */

g5230:
  /* Base of stack cache */
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;
  arg3 = (t10 * 4);
  t6 = LDQ_U(t10);
  /* Stack cache offset */
  t7 = t1 - t7;
  t11 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;
  arg3 = *(s32 *)arg3;
  t6 = (u8)(t6 >> ((t10&7)*8));
  if (t8 != 0)
    goto g5232;

g5231:
  t10 = zero + 240;
  t11 = t11 >> (t6 & 63);
  t10 = t10 >> (t6 & 63);
  arg3 = (u32)arg3;
  if (t11 & 1)
    goto g5234;

g5241:
  t8 = t6 - Type_Fixnum;
  /* Strip CDR code */
  t8 = t8 & 63;
  if (t8 != 0)
    goto g5209;
  /* Indirect is adata+3 */
  t1 = t1 + 1;
  /* Memory Read Internal */

g5242:
  /* Base of stack cache */
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;
  t5 = (t10 * 4);
  t6 = LDQ_U(t10);
  /* Stack cache offset */
  t7 = t1 - t7;
  t11 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;
  t5 = *(s32 *)t5;
  t6 = (u8)(t6 >> ((t10&7)*8));
  if (t8 != 0)
    goto g5244;

g5243:
  t10 = zero + 240;
  t11 = t11 >> (t6 & 63);
  t10 = t10 >> (t6 & 63);
  t5 = (u32)t5;
  if (t11 & 1)
    goto g5246;

g5253:
  /* Strip off any CDR code bits. */
  t10 = t6 & 63;
  t11 = (t10 == Type_Locative) ? 1 : 0;

g5318:
  if (_trace) printf("g5318:\n");
  if (t11 == 0)
    goto g5255;
  /* Here if argument TypeLocative */

g5212:
  if (_trace) printf("g5212:\n");
  /* set CDR-NEXT */
  t10 = arg2 & 63;
  *(u32 *)(iSP + 8) = t9;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t10;
  iSP = iSP + 8;
  t8 = t3 >> (Array_BytePackingPos & 63);
  t7 = Type_Fixnum;
  t1 = *(u64 *)&(processor->areventcount);
  t8 = t8 << (Array_RegisterBytePackingPos & 63);
  /* Construct the array register word */
  t8 = t8 + t1;
  /* set CDR-NEXT */
  t6 = t7 & 63;
  *(u32 *)(iSP + 8) = t8;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  /* set CDR-NEXT */
  t8 = t7 & 63;
  *(u32 *)(iSP + 8) = arg4;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g5217;

g5255:
  if (_trace) printf("g5255:\n");
  t11 = (t10 == Type_Fixnum) ? 1 : 0;

g5319:
  if (_trace) printf("g5319:\n");
  if (t11 == 0)
    goto g5256;
  /* Here if argument TypeFixnum */
  goto g5212;

g5256:
  if (_trace) printf("g5256:\n");
  t11 = (t10 == Type_Array) ? 1 : 0;

g5320:
  if (_trace) printf("g5320:\n");
  if (t11 == 0)
    goto g5257;
  /* Here if argument TypeArray */

g5216:
  if (_trace) printf("g5216:\n");
  t1 = t3 & 7;
  t1 = (t1 == 1) ? 1 : 0;
  /* Force true if FORCE */
  t1 = t1 | t2;
  if (t1 == 0)
    goto g5209;
  t12 = t3 >> (Array_BytePackingPos & 63);
  t12 = t12 & Array_BytePackingMask;
  t2 = arg3;

g5211:
  if (_trace) printf("g5211:\n");
  /* Memory Read Internal */

g5258:
  /* Base of stack cache */
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t5 + ivory;
  t8 = *(s32 *)&processor->scovlimit;
  t4 = (t10 * 4);
  t6 = LDQ_U(t10);
  /* Stack cache offset */
  t7 = t5 - t7;
  t11 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;
  t4 = *(s32 *)t4;
  t6 = (u8)(t6 >> ((t10&7)*8));
  if (t8 != 0)
    goto g5260;

g5259:
  t10 = zero + 64;
  t11 = t11 >> (t6 & 63);
  t10 = t10 >> (t6 & 63);
  t4 = (u32)t4;
  if (t11 & 1)
    goto g5262;

g5267:
  t10 = t4 >> (Array_BytePackingPos & 63);
  t10 = t10 & Array_BytePackingMask;
  arg1 = t12 - t10;
  t7 = t4 >> (Array_LongPrefixBitPos & 63);
  if (t7 & 1)
    goto g5213;
  /* increment beyond header */
  t5 = t5 + 1;
  t8 = zero + 32767;
  t8 = t4 & t8;
  t10 = zero - arg1;
  t10 = t8 >> (t10 & 63);
  t8 = t8 << (arg1 & 63);
  if ((s64)arg1 <= 0)
    t8 = t10;
  t10 = arg4 + arg3;
  t7 = t10 - t8;
  if ((s64)t7 <= 0)
    t8 = t10;
  arg4 = t8;

g5210:
  if (_trace) printf("g5210:\n");
  arg4 = arg4 - t2;
  /* set CDR-NEXT */
  t10 = arg2 & 63;
  *(u32 *)(iSP + 8) = t9;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t10;
  iSP = iSP + 8;
  t7 = Type_Fixnum;
  t8 = t3 >> (Array_RegisterBytePackingPos & 63);
  t1 = *(u64 *)&(processor->areventcount);
  t8 = t8 << (Array_RegisterBytePackingPos & 63);
  /* -1 */
  t11 = zero - 1;
  /* (LSH -1 byte-packing) */
  t11 = t11 << (t12 & 63);
  t11 = t2 & ~t11;
  t11 = t11 << (Array_RegisterByteOffsetPos & 63);
  /* Construct the array register word */
  t8 = t8 + t1;
  /* Add in the byte offset */
  t8 = t11 + t8;
  /* set CDR-NEXT */
  t6 = t7 & 63;
  *(u32 *)(iSP + 8) = t8;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t6;
  iSP = iSP + 8;
  if ((s64)arg4 <= 0)
    arg4 = zero;
  if (arg4 == 0)
    goto g5214;
  t1 = zero - t12;
  t1 = t2 << (t1 & 63);
  t2 = t2 >> (t12 & 63);
  if ((s64)t12 <= 0)
    t2 = t1;
  t5 = t2 + t5;

g5214:
  if (_trace) printf("g5214:\n");
  t8 = Type_Locative;
  *(u32 *)(iSP + 8) = t5;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  /* set CDR-NEXT */
  t8 = t7 & 63;
  *(u32 *)(iSP + 8) = arg4;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g5217;

g5213:
  if (_trace) printf("g5213:\n");
  /* length=array+1 */
  t1 = t5 + 1;
  /* Memory Read Internal */

g5268:
  /* Base of stack cache */
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;
  arg6 = (t10 * 4);
  t4 = LDQ_U(t10);
  /* Stack cache offset */
  t7 = t1 - t7;
  t11 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  t4 = (u8)(t4 >> ((t10&7)*8));
  if (t8 != 0)
    goto g5270;

g5269:
  t10 = zero + 240;
  t11 = t11 >> (t4 & 63);
  t10 = t10 >> (t4 & 63);
  arg6 = (u32)arg6;
  if (t11 & 1)
    goto g5272;

g5279:
  t1 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto g5209;
  /* offset=array+2 */
  t1 = t5 + 2;
  /* Memory Read Internal */

g5280:
  /* Base of stack cache */
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;
  arg5 = (t10 * 4);
  t4 = LDQ_U(t10);
  /* Stack cache offset */
  t7 = t1 - t7;
  t11 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;
  arg5 = *(s32 *)arg5;
  t4 = (u8)(t4 >> ((t10&7)*8));
  if (t8 != 0)
    goto g5282;

g5281:
  t10 = zero + 240;
  t11 = t11 >> (t4 & 63);
  t10 = t10 >> (t4 & 63);
  arg5 = (u32)arg5;
  if (t11 & 1)
    goto g5284;

g5291:
  t1 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto g5209;
  /* next=array+3 */
  t1 = t5 + 3;
  /* Memory Read Internal */

g5292:
  /* Base of stack cache */
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t10 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;
  t5 = (t10 * 4);
  t4 = LDQ_U(t10);
  /* Stack cache offset */
  t7 = t1 - t7;
  t11 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)t8) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t10&7)*8));
  if (t8 != 0)
    goto g5294;

g5293:
  t10 = zero + 240;
  t11 = t11 >> (t4 & 63);
  t10 = t10 >> (t4 & 63);
  t5 = (u32)t5;
  if (t11 & 1)
    goto g5296;

g5303:
  t8 = zero - arg1;
  t8 = arg6 >> (t8 & 63);
  t10 = arg6 << (arg1 & 63);
  if ((s64)arg1 <= 0)
    t10 = t8;
  t8 = arg4 + arg3;
  if ((s64)t10 <= 0)
    t10 = t8;
  t7 = t10 - t8;
  if ((s64)t7 <= 0)
    t8 = t10;
  arg4 = t8;
  /* Strip off any CDR code bits. */
  t8 = t4 & 63;
  t10 = (t8 == Type_Locative) ? 1 : 0;

g5311:
  if (_trace) printf("g5311:\n");
  if (t10 == 0)
    goto g5305;
  /* Here if argument TypeLocative */
  goto g5210;

g5305:
  if (_trace) printf("g5305:\n");
  t10 = (t8 == Type_Fixnum) ? 1 : 0;

g5312:
  if (_trace) printf("g5312:\n");
  if (t10 == 0)
    goto g5306;
  /* Here if argument TypeFixnum */
  goto g5210;

g5306:
  if (_trace) printf("g5306:\n");
  t10 = (t8 == Type_Array) ? 1 : 0;

g5313:
  if (_trace) printf("g5313:\n");
  if (t10 == 0)
    goto g5307;
  /* Here if argument TypeArray */

g5215:
  if (_trace) printf("g5215:\n");
  t7 = zero - arg1;
  t7 = arg5 >> (t7 & 63);
  arg3 = arg5 << (arg1 & 63);
  if ((s64)arg1 <= 0)
    arg3 = t7;
  t2 = t2 + arg3;
  goto g5211;

g5307:
  if (_trace) printf("g5307:\n");
  t10 = (t8 == Type_String) ? 1 : 0;

g5314:
  if (_trace) printf("g5314:\n");
  if (t10 == 0)
    goto g5308;
  /* Here if argument TypeString */
  goto g5215;

g5308:
  if (_trace) printf("g5308:\n");
  /* Here for all other cases */
  goto g5209;

g5304:
  if (_trace) printf("g5304:\n");

g5257:
  if (_trace) printf("g5257:\n");
  t11 = (t10 == Type_String) ? 1 : 0;

g5321:
  if (_trace) printf("g5321:\n");
  if (t11 == 0)
    goto g5315;
  /* Here if argument TypeString */
  goto g5216;

g5315:
  if (_trace) printf("g5315:\n");
  /* Here for all other cases */
  goto g5209;

g5254:
  if (_trace) printf("g5254:\n");

g5209:
  if (_trace) printf("g5209:\n");
  t2 = ReturnValue_Exception;
  goto *r0; /* ret */

g5217:
  if (_trace) printf("g5217:\n");
  t2 = ReturnValue_Normal;
  goto *r0; /* ret */

g5294:
  if (_trace) printf("g5294:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t5 = *(s32 *)t7;
  /* Read from stack cache */
  t4 = *(s32 *)(t7 + 4);
  goto g5293;

g5296:
  if (_trace) printf("g5296:\n");
  if ((t10 & 1) == 0)
    goto g5295;
  /* Do the indirect thing */
  t1 = (u32)t5;
  goto g5292;

g5295:
  if (_trace) printf("g5295:\n");
  /* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t10 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t10 = (t10 * 4) + t11;
  /* Get the memory action */
  t11 = *(s32 *)t10;

g5300:
  if (_trace) printf("g5300:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0)
    goto g5299;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g5303;
#ifndef MINIMA

g5299:
#endif
#ifdef MINIMA

g5299:
  if (_trace) printf("g5299:\n");
  t10 = t11 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t10 == 0)
    goto g5298;
  t7 = t1 << 1;
  t10 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t10;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  t5 = *(s32 *)(t8 + 4);
  /* Compare */
  t10 = (s32)t1 - (s32)t7;
  /* Trap on miss */
  if (t10 != 0)
    goto g5302;
  /* Extract the pointer, and indirect */
  t1 = (u32)t5;
  goto g5292;

g5302:
  if (_trace) printf("g5302:\n");
  goto dbcachemisstrap;
#endif

g5298:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

g5282:
  if (_trace) printf("g5282:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  arg5 = *(s32 *)t7;
  /* Read from stack cache */
  t4 = *(s32 *)(t7 + 4);
  goto g5281;

g5284:
  if (_trace) printf("g5284:\n");
  if ((t10 & 1) == 0)
    goto g5283;
  /* Do the indirect thing */
  t1 = (u32)arg5;
  goto g5280;

g5283:
  if (_trace) printf("g5283:\n");
  /* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t10 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t10 = (t10 * 4) + t11;
  /* Get the memory action */
  t11 = *(s32 *)t10;

g5288:
  if (_trace) printf("g5288:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0)
    goto g5287;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g5291;
#ifndef MINIMA

g5287:
#endif
#ifdef MINIMA

g5287:
  if (_trace) printf("g5287:\n");
  t10 = t11 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t10 == 0)
    goto g5286;
  t7 = t1 << 1;
  t10 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t10;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  arg5 = *(s32 *)(t8 + 4);
  /* Compare */
  t10 = (s32)t1 - (s32)t7;
  /* Trap on miss */
  if (t10 != 0)
    goto g5290;
  /* Extract the pointer, and indirect */
  t1 = (u32)arg5;
  goto g5280;

g5290:
  if (_trace) printf("g5290:\n");
  goto dbcachemisstrap;
#endif

g5286:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

g5270:
  if (_trace) printf("g5270:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  arg6 = *(s32 *)t7;
  /* Read from stack cache */
  t4 = *(s32 *)(t7 + 4);
  goto g5269;

g5272:
  if (_trace) printf("g5272:\n");
  if ((t10 & 1) == 0)
    goto g5271;
  /* Do the indirect thing */
  t1 = (u32)arg6;
  goto g5268;

g5271:
  if (_trace) printf("g5271:\n");
  /* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t10 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t10 = (t10 * 4) + t11;
  /* Get the memory action */
  t11 = *(s32 *)t10;

g5276:
  if (_trace) printf("g5276:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0)
    goto g5275;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g5279;
#ifndef MINIMA

g5275:
#endif
#ifdef MINIMA

g5275:
  if (_trace) printf("g5275:\n");
  t10 = t11 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t10 == 0)
    goto g5274;
  t7 = t1 << 1;
  t10 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t10;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  arg6 = *(s32 *)(t8 + 4);
  /* Compare */
  t10 = (s32)t1 - (s32)t7;
  /* Trap on miss */
  if (t10 != 0)
    goto g5278;
  /* Extract the pointer, and indirect */
  t1 = (u32)arg6;
  goto g5268;

g5278:
  if (_trace) printf("g5278:\n");
  goto dbcachemisstrap;
#endif

g5274:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

g5260:
  if (_trace) printf("g5260:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t4 = *(s32 *)t7;
  /* Read from stack cache */
  t6 = *(s32 *)(t7 + 4);
  goto g5259;

g5262:
  if (_trace) printf("g5262:\n");
  if ((t10 & 1) == 0)
    goto g5261;
  /* Do the indirect thing */
  t5 = (u32)t4;
  goto g5258;

g5261:
  if (_trace) printf("g5261:\n");
  /* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t10 = t6 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t5;
  /* Adjust for a longword load */
  t10 = (t10 * 4) + t11;
  /* Get the memory action */
  t11 = *(s32 *)t10;

g5264:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 6;
  goto performmemoryaction;

g5244:
  if (_trace) printf("g5244:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t5 = *(s32 *)t7;
  /* Read from stack cache */
  t6 = *(s32 *)(t7 + 4);
  goto g5243;

g5246:
  if (_trace) printf("g5246:\n");
  if ((t10 & 1) == 0)
    goto g5245;
  /* Do the indirect thing */
  t1 = (u32)t5;
  goto g5242;

g5245:
  if (_trace) printf("g5245:\n");
  /* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t10 = t6 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t10 = (t10 * 4) + t11;
  /* Get the memory action */
  t11 = *(s32 *)t10;

g5250:
  if (_trace) printf("g5250:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0)
    goto g5249;
  t6 = t6 & ~63L;
  t6 = t6 | Type_ExternalValueCellPointer;
  goto g5253;
#ifndef MINIMA

g5249:
#endif
#ifdef MINIMA

g5249:
  if (_trace) printf("g5249:\n");
  t10 = t11 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t10 == 0)
    goto g5248;
  t7 = t1 << 1;
  t10 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t10;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  t5 = *(s32 *)(t8 + 4);
  /* Compare */
  t10 = (s32)t1 - (s32)t7;
  /* Trap on miss */
  if (t10 != 0)
    goto g5252;
  /* Extract the pointer, and indirect */
  t1 = (u32)t5;
  goto g5242;

g5252:
  if (_trace) printf("g5252:\n");
  goto dbcachemisstrap;
#endif

g5248:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

g5232:
  if (_trace) printf("g5232:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  arg3 = *(s32 *)t7;
  /* Read from stack cache */
  t6 = *(s32 *)(t7 + 4);
  goto g5231;

g5234:
  if (_trace) printf("g5234:\n");
  if ((t10 & 1) == 0)
    goto g5233;
  /* Do the indirect thing */
  t1 = (u32)arg3;
  goto g5230;

g5233:
  if (_trace) printf("g5233:\n");
  /* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t10 = t6 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t10 = (t10 * 4) + t11;
  /* Get the memory action */
  t11 = *(s32 *)t10;

g5238:
  if (_trace) printf("g5238:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0)
    goto g5237;
  t6 = t6 & ~63L;
  t6 = t6 | Type_ExternalValueCellPointer;
  goto g5241;
#ifndef MINIMA

g5237:
#endif
#ifdef MINIMA

g5237:
  if (_trace) printf("g5237:\n");
  t10 = t11 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t10 == 0)
    goto g5236;
  t7 = t1 << 1;
  t10 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t10;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  arg3 = *(s32 *)(t8 + 4);
  /* Compare */
  t10 = (s32)t1 - (s32)t7;
  /* Trap on miss */
  if (t10 != 0)
    goto g5240;
  /* Extract the pointer, and indirect */
  t1 = (u32)arg3;
  goto g5230;

g5240:
  if (_trace) printf("g5240:\n");
  goto dbcachemisstrap;
#endif

g5236:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

g5220:
  if (_trace) printf("g5220:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  arg4 = *(s32 *)t7;
  /* Read from stack cache */
  t6 = *(s32 *)(t7 + 4);
  goto g5219;

g5222:
  if (_trace) printf("g5222:\n");
  if ((t10 & 1) == 0)
    goto g5221;
  /* Do the indirect thing */
  t1 = (u32)arg4;
  goto g5218;

g5221:
  if (_trace) printf("g5221:\n");
  /* Load the memory action table for cycle */
  t11 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t10 = t6 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t10 = (t10 * 4) + t11;
  /* Get the memory action */
  t11 = *(s32 *)t10;

g5226:
  if (_trace) printf("g5226:\n");
  t10 = t11 & MemoryActionTransform;
  if (t10 == 0)
    goto g5225;
  t6 = t6 & ~63L;
  t6 = t6 | Type_ExternalValueCellPointer;
  goto g5229;
#ifndef MINIMA

g5225:
#endif
#ifdef MINIMA

g5225:
  if (_trace) printf("g5225:\n");
  t10 = t11 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t10 == 0)
    goto g5224;
  t7 = t1 << 1;
  t10 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t10;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  arg4 = *(s32 *)(t8 + 4);
  /* Compare */
  t10 = (s32)t1 - (s32)t7;
  /* Trap on miss */
  if (t10 != 0)
    goto g5228;
  /* Extract the pointer, and indirect */
  t1 = (u32)arg4;
  goto g5218;

g5228:
  if (_trace) printf("g5228:\n");
  goto dbcachemisstrap;
#endif

g5224:
  /* Perform memory action */
  arg1 = t11;
  arg2 = 0;
  goto performmemoryaction;

/* end Setup1DLongArray */
/* start DoFastAset1 */

  /* Halfword operand from stack instruction - DoFastAset1 */
  /* arg2 has the preloaded 8 bit operand. */

dofastaset1:
  if (_trace) printf("dofastaset1:\n");
#ifdef TRACING
#endif

DoFastAset1SP:
  if (_trace) printf("DoFastAset1SP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindofastaset1;
#endif

DoFastAset1LP:
  if (_trace) printf("DoFastAset1LP:\n");
#ifdef TRACING
  goto begindofastaset1;
#endif

DoFastAset1FP:
  if (_trace) printf("DoFastAset1FP:\n");

begindofastaset1:
  if (_trace) printf("begindofastaset1:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Index */
  arg4 = *(s32 *)iSP;
  /* Index */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  /* value */
  t11 = *(s32 *)iSP;
  /* value */
  t10 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t11 = (u32)t11;
  t1 = arg3 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto fastaset1iop;

fastaset1retry:
  if (_trace) printf("fastaset1retry:\n");
  arg6 = *(s32 *)arg1;
  t9 = *(s32 *)(arg1 + 8);
  t3 = *(s32 *)(arg1 + 16);
  arg6 = (u32)arg6;
  t9 = (u32)t9;
  t5 = arg6 << 42;
  t3 = (u32)t3;
  t4 = *(u64 *)&(processor->areventcount);
  t5 = t5 >> 42;
  t2 = ((u64)arg4 < (u64)t3) ? 1 : 0;
  if (t2 == 0)
    goto fastaset1bounds;
  t6 = t4 - t5;
  if (t6 != 0)
    goto aset1recomputearrayregister;
  t6 = arg6 >> (Array_RegisterBytePackingPos & 63);
  t7 = arg6 >> (Array_RegisterByteOffsetPos & 63);
  t8 = arg6 >> (Array_RegisterElementTypePos & 63);
  t6 = t6 & Array_RegisterBytePackingMask;
  t7 = t7 & Array_RegisterByteOffsetMask;
  t8 = t8 & Array_RegisterElementTypeMask;
  /* Element checking and foreplay. */
  /* TagType. */
  t1 = t10 & 63;
  t12 = (t8 == Array_ElementTypeCharacter) ? 1 : 0;

g5332:
  if (_trace) printf("g5332:\n");
  if (t12 == 0)
    goto g5328;
  /* Here if argument ArrayElementTypeCharacter */
  t2 = t1 - Type_Character;
  if (t2 == 0)
    goto g5323;
  arg5 = 0;
  arg2 = 29;
  goto illegaloperand;

g5323:
  if (_trace) printf("g5323:\n");
  /* Certainly will fit if not packed! */
  if (t6 == 0)
    goto g5322;
  t2 = 32;
  /* Compute size of byte */
  t2 = t2 >> (t6 & 63);
  t1 = ~zero;
  t1 = t1 << (t2 & 63);
  /* Compute mask for byte */
  t1 = ~t1;
  t1 = t11 & t1;
  t1 = t11 - t1;
  /* J. if character fits. */
  if (t1 == 0)
    goto g5322;
  arg5 = 0;
  arg2 = 62;
  goto illegaloperand;

g5328:
  if (_trace) printf("g5328:\n");
  t12 = (t8 == Array_ElementTypeFixnum) ? 1 : 0;

g5333:
  if (_trace) printf("g5333:\n");
  if (t12 == 0)
    goto g5329;
  /* Here if argument ArrayElementTypeFixnum */
  t2 = t1 - Type_Fixnum;
  if (t2 == 0)
    goto g5322;
  arg5 = 0;
  arg2 = 33;
  goto illegaloperand;

g5329:
  if (_trace) printf("g5329:\n");
  t12 = (t8 == Array_ElementTypeBoolean) ? 1 : 0;

g5334:
  if (_trace) printf("g5334:\n");
  if (t12 == 0)
    goto g5327;
  /* Here if argument ArrayElementTypeBoolean */
  t11 = 1;
  t1 = t1 - Type_NIL;
  /* J. if True */
  if (t1 != 0)
    goto g5322;
  t11 = zero;
  goto g5322;

g5327:
  if (_trace) printf("g5327:\n");
  /* Shove it in. */

g5322:
  if (_trace) printf("g5322:\n");
  /* J. if packed */
  if (t6 != 0)
    goto g5324;
  t1 = t8 - Array_ElementTypeObject;
  if (t1 != 0)
    goto g5324;
  /* Here for the simple non packed case */
  t1 = t9 + arg4;
  /* Memory Read Internal */

g5335:
  /* Base of stack cache */
  t4 = *(u64 *)&(processor->stackcachebasevma);
  t12 = t1 + ivory;
  t5 = *(s32 *)&processor->scovlimit;
  t3 = (t12 * 4);
  t2 = LDQ_U(t12);
  /* Stack cache offset */
  t4 = t1 - t4;
  arg3 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t5 = ((u64)t4 < (u64)t5) ? 1 : 0;
  t3 = *(s32 *)t3;
  t2 = (u8)(t2 >> ((t12&7)*8));
  if (t5 != 0)
    goto g5337;

g5336:
  t12 = zero + 240;
  arg3 = arg3 >> (t2 & 63);
  t12 = t12 >> (t2 & 63);
  if (arg3 & 1)
    goto g5339;

g5345:
  /* Merge cdr-code */
  t3 = t10 & 63;
  t2 = t2 & 192;
  t2 = t2 | t3;
  t5 = *(u64 *)&(processor->stackcachebasevma);
  t4 = t1 + ivory;
  arg3 = *(s32 *)&processor->scovlimit;
  t3 = (t4 * 4);
  t12 = LDQ_U(t4);
  /* Stack cache offset */
  t5 = t1 - t5;
  /* In range? */
  arg3 = ((u64)t5 < (u64)arg3) ? 1 : 0;
  t5 = (t2 & 0xff) << ((t4&7)*8);
  t12 = t12 & ~(0xffL << (t4&7)*8);

g5347:
  if (_trace) printf("g5347:\n");
  t12 = t12 | t5;
  STQ_U(t4, t12);
  *(u32 *)t3 = t11;
  /* J. if in cache */
  if (arg3 != 0)
    goto g5346;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;
  /* Here for the slow packed version */

g5324:
  if (_trace) printf("g5324:\n");
  arg4 = t7 + arg4;
  /* Convert byte index to word index */
  t1 = arg4 >> (t6 & 63);
  /* Address of word containing byte */
  t1 = t1 + t9;
  /* Memory Read Internal */

g5348:
  /* Base of stack cache */
  t2 = *(u64 *)&(processor->stackcachebasevma);
  t4 = t1 + ivory;
  t3 = *(s32 *)&processor->scovlimit;
  t9 = (t4 * 4);
  arg5 = LDQ_U(t4);
  /* Stack cache offset */
  t2 = t1 - t2;
  t5 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t3 = ((u64)t2 < (u64)t3) ? 1 : 0;
  t9 = *(s32 *)t9;
  arg5 = (u8)(arg5 >> ((t4&7)*8));
  if (t3 != 0)
    goto g5350;

g5349:
  t4 = zero + 240;
  t5 = t5 >> (arg5 & 63);
  t4 = t4 >> (arg5 & 63);
  t9 = (u32)t9;
  if (t5 & 1)
    goto g5352;

g5359:
  /* Check fixnum element type */
  /* TagType. */
  t2 = arg5 & 63;
  t2 = t2 - Type_Fixnum;
  /* J. if element type not fixnum. */
  if (t2 != 0)
    goto g5325;
  /* J. if unpacked fixnum element type. */
  if (t6 == 0)
    goto g5326;
  t12 = ~zero;
  t12 = t12 << (t6 & 63);
  t2 = zero - t6;
  /* Compute subword index */
  t12 = arg4 & ~t12;
  t2 = t2 + 5;
  /* Compute shift to get byte */
  t2 = t12 << (t2 & 63);
  t12 = 32;
  /* Compute size of byte */
  t12 = t12 >> (t6 & 63);
  t3 = ~zero;
  t3 = t3 << (t12 & 63);
  /* Compute mask for byte */
  t4 = ~t3;
  /* inserting into the low byte is easy */
  if (t2 == 0)
    goto g5360;
  /* Inserting the byte into any byte other than the low byte */
  t5 = 64;
  /* = the left shift rotate amount */
  t12 = t5 - t2;
  /* shift selected byte into low end of word. */
  t5 = t9 >> (t2 & 63);
  /* rotate low bits into high end of word. */
  t9 = t9 << (t12 & 63);
  /* Remove unwanted bits */
  t5 = t3 & t5;
  /* rotate low bits back into place. */
  t9 = t9 >> (t12 & 63);
  /* Strip any extra bits from element */
  t12 = t11 & t4;
  /* Insert new bits. */
  t5 = t12 | t5;
  /* reposition bits */
  t5 = t5 << (t2 & 63);
  /* Replace low order bits */
  t9 = t9 | t5;
  goto g5361;

g5360:
  if (_trace) printf("g5360:\n");
  /* Inserting the byte into the low byte */
  /* Remove the old low byte */
  t9 = t9 & t3;
  /* Remove unwanted bits from the new byte */
  t12 = t11 & t4;
  /* Insert the new byte in place of the old byte */
  t9 = t9 | t12;

g5361:
  if (_trace) printf("g5361:\n");
  t11 = t9;

g5326:
  if (_trace) printf("g5326:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);
  t2 = t1 + ivory;
  t12 = *(s32 *)&processor->scovlimit;
  t5 = (t2 * 4);
  t4 = LDQ_U(t2);
  /* Stack cache offset */
  t3 = t1 - t3;
  /* In range? */
  t12 = ((u64)t3 < (u64)t12) ? 1 : 0;
  t3 = (arg5 & 0xff) << ((t2&7)*8);
  t4 = t4 & ~(0xffL << (t2&7)*8);

g5363:
  if (_trace) printf("g5363:\n");
  t4 = t4 | t3;
  STQ_U(t2, t4);
  *(u32 *)t5 = t11;
  /* J. if in cache */
  if (t12 != 0)
    goto g5362;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

g5325:
  if (_trace) printf("g5325:\n");
  arg5 = t1;
  arg2 = 25;
  goto illegaloperand;

fastaset1iop:
  if (_trace) printf("fastaset1iop:\n");
  arg5 = 0;
  arg2 = 32;
  goto illegaloperand;

fastaset1bounds:
  if (_trace) printf("fastaset1bounds:\n");
  arg5 = 0;
  arg2 = 13;
  goto illegaloperand;

g5362:
  if (_trace) printf("g5362:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);

g5364:
  if (_trace) printf("g5364:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t3 = t1 - t3;
  /* reconstruct SCA */
  t2 = (t3 * 8) + t2;
  /* Store in stack */
  *(u32 *)t2 = t11;
  /* write the stack cache */
  *(u32 *)(t2 + 4) = arg5;
  goto NEXTINSTRUCTION;

g5350:
  if (_trace) printf("g5350:\n");
  t3 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t2 = (t2 * 8) + t3;
  t9 = *(s32 *)t2;
  /* Read from stack cache */
  arg5 = *(s32 *)(t2 + 4);
  goto g5349;

g5352:
  if (_trace) printf("g5352:\n");
  if ((t4 & 1) == 0)
    goto g5351;
  /* Do the indirect thing */
  t1 = (u32)t9;
  goto g5348;

g5351:
  if (_trace) printf("g5351:\n");
  /* Load the memory action table for cycle */
  t5 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t4 = arg5 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t4 = (t4 * 4) + t5;
  /* Get the memory action */
  t5 = *(s32 *)t4;

g5356:
  if (_trace) printf("g5356:\n");
  t4 = t5 & MemoryActionTransform;
  if (t4 == 0)
    goto g5355;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto g5359;
#ifndef MINIMA

g5355:
#endif
#ifdef MINIMA

g5355:
  if (_trace) printf("g5355:\n");
  t4 = t5 & MemoryActionBinding;
  t3 = *(u64 *)&(processor->dbcmask);
  if (t4 == 0)
    goto g5354;
  t2 = t1 << 1;
  t4 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t2 = t2 & t3;
  t3 = 1;
  t3 = t3 << (ivorymemorydata & 63);
  t2 = (s32)t2 + (s32)t4;
  /* Clear sign-extension */
  t2 = (u32)t2;
  t3 = (t2 * 4) + t3;
  /* Fetch the key */
  t2 = *(s32 *)t3;
  /* Fetch value */
  t9 = *(s32 *)(t3 + 4);
  /* Compare */
  t4 = (s32)t1 - (s32)t2;
  /* Trap on miss */
  if (t4 != 0)
    goto g5358;
  /* Extract the pointer, and indirect */
  t1 = (u32)t9;
  goto g5348;

g5358:
  if (_trace) printf("g5358:\n");
  goto dbcachemisstrap;
#endif

g5354:
  /* Perform memory action */
  arg1 = t5;
  arg2 = 0;
  goto performmemoryaction;

g5346:
  if (_trace) printf("g5346:\n");
  t5 = *(u64 *)&(processor->stackcachebasevma);

g5365:
  if (_trace) printf("g5365:\n");
  t4 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t5 = t1 - t5;
  /* reconstruct SCA */
  t4 = (t5 * 8) + t4;
  /* Store in stack */
  *(u32 *)t4 = t11;
  /* write the stack cache */
  *(u32 *)(t4 + 4) = t2;
  goto NEXTINSTRUCTION;

g5337:
  if (_trace) printf("g5337:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t4 = (t4 * 8) + t5;
  t3 = *(s32 *)t4;
  /* Read from stack cache */
  t2 = *(s32 *)(t4 + 4);
  goto g5336;

g5339:
  if (_trace) printf("g5339:\n");
  if ((t12 & 1) == 0)
    goto g5338;
  /* Do the indirect thing */
  t1 = (u32)t3;
  goto g5335;

g5338:
  if (_trace) printf("g5338:\n");
  /* Load the memory action table for cycle */
  arg3 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t12 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t12 = (t12 * 4) + arg3;
  /* Get the memory action */
  arg3 = *(s32 *)t12;
#ifndef MINIMA

g5342:
#endif
#ifdef MINIMA

g5342:
  if (_trace) printf("g5342:\n");
  t12 = arg3 & MemoryActionBinding;
  t5 = *(u64 *)&(processor->dbcmask);
  if (t12 == 0)
    goto g5341;
  t4 = t1 << 1;
  t12 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t4 = t4 & t5;
  t5 = 1;
  t5 = t5 << (ivorymemorydata & 63);
  t4 = (s32)t4 + (s32)t12;
  /* Clear sign-extension */
  t4 = (u32)t4;
  t5 = (t4 * 4) + t5;
  /* Fetch the key */
  t4 = *(s32 *)t5;
  /* Fetch value */
  t3 = *(s32 *)(t5 + 4);
  /* Compare */
  t12 = (s32)t1 - (s32)t4;
  /* Trap on miss */
  if (t12 != 0)
    goto g5344;
  /* Extract the pointer, and indirect */
  t1 = (u32)t3;
  goto g5335;

g5344:
  if (_trace) printf("g5344:\n");
  goto dbcachemisstrap;
#endif

g5341:
  /* Perform memory action */
  arg1 = arg3;
  arg2 = 1;
  goto performmemoryaction;
#ifdef TRACING
#endif

DoFastAset1IM:
  goto doistageerror;

/* end DoFastAset1 */
  /* End of Halfword operand from stack instruction - DoFastAset1 */
  /* Array leaders. */
/* start DoArrayLeader */

  /* Halfword operand from stack instruction - DoArrayLeader */
  /* arg2 has the preloaded 8 bit operand. */

doarrayleader:
  if (_trace) printf("doarrayleader:\n");
#ifdef TRACING
#endif

DoArrayLeaderSP:
  if (_trace) printf("DoArrayLeaderSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoarrayleader;
#endif

DoArrayLeaderLP:
  if (_trace) printf("DoArrayLeaderLP:\n");
#ifdef TRACING
  goto headdoarrayleader;
#endif

DoArrayLeaderFP:
  if (_trace) printf("DoArrayLeaderFP:\n");

headdoarrayleader:
  if (_trace) printf("headdoarrayleader:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoarrayleader:
  if (_trace) printf("begindoarrayleader:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  /* arg3=arraytag, arg4=arraydata */
  arg4 = *(s32 *)iSP;
  /* arg3=arraytag, arg4=arraydata */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  /* index data */
  arg2 = (u32)arg1;
  /* index tag */
  arg1 = arg1 >> 32;
  t1 = arg1 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto arrayleaderiop;

arrayleadermerge:
  if (_trace) printf("arrayleadermerge:\n");
  t1 = arg3 - Type_Array;
  /* Strip CDR code, low bits */
  t1 = t1 & 62;
  if (t1 != 0)
    goto arrayleaderexception;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g5366:
  t3 = arg4 + ivory;
  arg5 = (t3 * 4);
  arg6 = LDQ_U(t3);
  /* Stack cache offset */
  t1 = arg4 - t11;
  t4 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t2 = ((u64)t1 < (u64)t12) ? 1 : 0;
  arg5 = *(s32 *)arg5;
  arg6 = (u8)(arg6 >> ((t3&7)*8));
  if (t2 != 0)
    goto g5368;

g5367:
  t3 = zero + 64;
  t4 = t4 >> (arg6 & 63);
  t3 = t3 >> (arg6 & 63);
  if (t4 & 1)
    goto g5370;

g5375:
  /* TagType. */
  t1 = arg6 & 63;
  t1 = t1 - Type_HeaderI;
  if (t1 != 0)
    goto arrayleaderiop;
  t8 = arg5 >> (Array_LeaderLengthFieldPos & 63);
  t8 = t8 & Array_LeaderLengthFieldMask;
  t1 = ((u64)arg2 < (u64)t8) ? 1 : 0;
  if (t1 == 0)
    goto arrayleaderbounds;
  arg2 = arg4 - arg2;
  arg2 = arg2 - 1;
  /* Memory Read Internal */

g5376:
  t3 = arg2 + ivory;
  arg5 = (t3 * 4);
  arg6 = LDQ_U(t3);
  /* Stack cache offset */
  t1 = arg2 - t11;
  t4 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t2 = ((u64)t1 < (u64)t12) ? 1 : 0;
  arg5 = *(s32 *)arg5;
  arg6 = (u8)(arg6 >> ((t3&7)*8));
  if (t2 != 0)
    goto g5378;

g5377:
  t3 = zero + 240;
  t4 = t4 >> (arg6 & 63);
  t3 = t3 >> (arg6 & 63);
  if (t4 & 1)
    goto g5380;

g5387:
  /* set CDR-NEXT */
  t1 = arg6 & 63;
  *(u32 *)(iSP + 8) = arg5;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

arrayleaderexception:
  if (_trace) printf("arrayleaderexception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = arg3;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  arg5 = 0;
  arg2 = 10;
  goto arrayexception;

arrayleaderiop:
  if (_trace) printf("arrayleaderiop:\n");
  arg5 = 0;
  arg2 = 10;
  goto illegaloperand;

arrayleaderbounds:
  if (_trace) printf("arrayleaderbounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;
#ifdef TRACING
  goto DoArrayLeaderIM;
#endif

DoArrayLeaderIM:
  if (_trace) printf("DoArrayLeaderIM:\n");
  /* arg3=arraytag, arg4=arraydata */
  arg4 = *(s32 *)iSP;
  /* arg3=arraytag, arg4=arraydata */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  goto arrayleadermerge;

g5378:
  if (_trace) printf("g5378:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t1 = (t1 * 8) + t2;
  arg5 = *(s32 *)t1;
  /* Read from stack cache */
  arg6 = *(s32 *)(t1 + 4);
  goto g5377;

g5380:
  if (_trace) printf("g5380:\n");
  if ((t3 & 1) == 0)
    goto g5379;
  /* Do the indirect thing */
  arg2 = (u32)arg5;
  goto g5376;

g5379:
  if (_trace) printf("g5379:\n");
  /* Load the memory action table for cycle */
  t4 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t3 = arg6 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg2;
  /* Adjust for a longword load */
  t3 = (t3 * 4) + t4;
  /* Get the memory action */
  t4 = *(s32 *)t3;

g5384:
  if (_trace) printf("g5384:\n");
  t3 = t4 & MemoryActionTransform;
  if (t3 == 0)
    goto g5383;
  arg6 = arg6 & ~63L;
  arg6 = arg6 | Type_ExternalValueCellPointer;
  goto g5387;
#ifndef MINIMA

g5383:
#endif
#ifdef MINIMA

g5383:
  if (_trace) printf("g5383:\n");
  t3 = t4 & MemoryActionBinding;
  t2 = *(u64 *)&(processor->dbcmask);
  if (t3 == 0)
    goto g5382;
  t1 = arg2 << 1;
  t3 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t1 = t1 & t2;
  t2 = 1;
  t2 = t2 << (ivorymemorydata & 63);
  t1 = (s32)t1 + (s32)t3;
  /* Clear sign-extension */
  t1 = (u32)t1;
  t2 = (t1 * 4) + t2;
  /* Fetch the key */
  t1 = *(s32 *)t2;
  /* Fetch value */
  arg5 = *(s32 *)(t2 + 4);
  /* Compare */
  t3 = (s32)arg2 - (s32)t1;
  /* Trap on miss */
  if (t3 != 0)
    goto g5386;
  /* Extract the pointer, and indirect */
  arg2 = (u32)arg5;
  goto g5376;

g5386:
  if (_trace) printf("g5386:\n");
  goto dbcachemisstrap;
#endif

g5382:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 0;
  goto performmemoryaction;

g5368:
  if (_trace) printf("g5368:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t1 = (t1 * 8) + t2;
  arg5 = *(s32 *)t1;
  /* Read from stack cache */
  arg6 = *(s32 *)(t1 + 4);
  goto g5367;

g5370:
  if (_trace) printf("g5370:\n");
  if ((t3 & 1) == 0)
    goto g5369;
  /* Do the indirect thing */
  arg4 = (u32)arg5;
  goto g5366;

g5369:
  if (_trace) printf("g5369:\n");
  /* Load the memory action table for cycle */
  t4 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t3 = arg6 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t3 = (t3 * 4) + t4;
  /* Get the memory action */
  t4 = *(s32 *)t3;

g5372:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoArrayLeader */
  /* End of Halfword operand from stack instruction - DoArrayLeader */
/* start DoStoreArrayLeader */

  /* Halfword operand from stack instruction - DoStoreArrayLeader */
  /* arg2 has the preloaded 8 bit operand. */

dostorearrayleader:
  if (_trace) printf("dostorearrayleader:\n");
#ifdef TRACING
#endif

DoStoreArrayLeaderSP:
  if (_trace) printf("DoStoreArrayLeaderSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdostorearrayleader;
#endif

DoStoreArrayLeaderLP:
  if (_trace) printf("DoStoreArrayLeaderLP:\n");
#ifdef TRACING
  goto headdostorearrayleader;
#endif

DoStoreArrayLeaderFP:
  if (_trace) printf("DoStoreArrayLeaderFP:\n");

headdostorearrayleader:
  if (_trace) printf("headdostorearrayleader:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindostorearrayleader:
  if (_trace) printf("begindostorearrayleader:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  /* arg3=arraytag, arg4=arraydata */
  arg4 = *(s32 *)iSP;
  /* arg3=arraytag, arg4=arraydata */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  /* t6=valuetag, t7=valuedata */
  t7 = *(s32 *)iSP;
  /* t6=valuetag, t7=valuedata */
  t6 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t7 = (u32)t7;
  /* index data */
  arg2 = (u32)arg1;
  /* index tag */
  arg1 = arg1 >> 32;
  t1 = arg1 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto storearrayleaderiop;

storearrayleadermerge:
  if (_trace) printf("storearrayleadermerge:\n");
  t1 = arg3 - Type_Array;
  /* Strip CDR code, low bits */
  t1 = t1 & 62;
  if (t1 != 0)
    goto storearrayleaderexception;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g5388:
  t3 = arg4 + ivory;
  arg5 = (t3 * 4);
  arg6 = LDQ_U(t3);
  /* Stack cache offset */
  t1 = arg4 - t11;
  t4 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t2 = ((u64)t1 < (u64)t12) ? 1 : 0;
  arg5 = *(s32 *)arg5;
  arg6 = (u8)(arg6 >> ((t3&7)*8));
  if (t2 != 0)
    goto g5390;

g5389:
  t3 = zero + 64;
  t4 = t4 >> (arg6 & 63);
  t3 = t3 >> (arg6 & 63);
  if (t4 & 1)
    goto g5392;

g5397:
  /* TagType. */
  t1 = arg6 & 63;
  t1 = t1 - Type_HeaderI;
  if (t1 != 0)
    goto storearrayleaderiop;
  t2 = arg5 >> (Array_LeaderLengthFieldPos & 63);
  t2 = t2 & Array_LeaderLengthFieldMask;
  t1 = ((u64)arg2 < (u64)t2) ? 1 : 0;
  if (t1 == 0)
    goto storearrayleaderbounds;
  arg2 = arg4 - arg2;
  arg2 = arg2 - 1;
  /* Memory Read Internal */

g5398:
  t5 = arg2 + ivory;
  t2 = (t5 * 4);
  t1 = LDQ_U(t5);
  /* Stack cache offset */
  t3 = arg2 - t11;
  t8 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t4 = ((u64)t3 < (u64)t12) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t5&7)*8));
  if (t4 != 0)
    goto g5400;

g5399:
  t5 = zero + 240;
  t8 = t8 >> (t1 & 63);
  t5 = t5 >> (t1 & 63);
  if (t8 & 1)
    goto g5402;

g5408:
  /* Merge cdr-code */
  t2 = t6 & 63;
  t1 = t1 & 192;
  t1 = t1 | t2;
  t3 = arg2 + ivory;
  t2 = (t3 * 4);
  t5 = LDQ_U(t3);
  /* Stack cache offset */
  t4 = arg2 - t11;
  /* In range? */
  t8 = ((u64)t4 < (u64)t12) ? 1 : 0;
  t4 = (t1 & 0xff) << ((t3&7)*8);
  t5 = t5 & ~(0xffL << (t3&7)*8);

g5410:
  if (_trace) printf("g5410:\n");
  t5 = t5 | t4;
  STQ_U(t3, t5);
  *(u32 *)t2 = t7;
  /* J. if in cache */
  if (t8 != 0)
    goto g5409;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

storearrayleaderexception:
  if (_trace) printf("storearrayleaderexception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = arg3;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 3;
  /* arg4 = arithmeticp */
  arg4 = 0;
  arg5 = 0;
  arg2 = 11;
  goto arrayexception;

storearrayleaderiop:
  if (_trace) printf("storearrayleaderiop:\n");
  arg5 = 0;
  arg2 = 11;
  goto illegaloperand;

storearrayleaderbounds:
  if (_trace) printf("storearrayleaderbounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;
#ifdef TRACING
  goto DoStoreArrayLeaderIM;
#endif

DoStoreArrayLeaderIM:
  if (_trace) printf("DoStoreArrayLeaderIM:\n");
  /* arg3=arraytag, arg4=arraydata */
  arg4 = *(s32 *)iSP;
  /* arg3=arraytag, arg4=arraydata */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  /* t6=valuetag, t7=valuedata */
  t7 = *(s32 *)iSP;
  /* t6=valuetag, t7=valuedata */
  t6 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t7 = (u32)t7;
  goto storearrayleadermerge;

g5409:
  if (_trace) printf("g5409:\n");
  t3 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t4 = arg2 - t11;
  /* reconstruct SCA */
  t3 = (t4 * 8) + t3;
  /* Store in stack */
  *(u32 *)t3 = t7;
  /* write the stack cache */
  *(u32 *)(t3 + 4) = t1;
  goto NEXTINSTRUCTION;

g5400:
  if (_trace) printf("g5400:\n");
  t4 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t3 = (t3 * 8) + t4;
  t2 = *(s32 *)t3;
  /* Read from stack cache */
  t1 = *(s32 *)(t3 + 4);
  goto g5399;

g5402:
  if (_trace) printf("g5402:\n");
  if ((t5 & 1) == 0)
    goto g5401;
  /* Do the indirect thing */
  arg2 = (u32)t2;
  goto g5398;

g5401:
  if (_trace) printf("g5401:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t5 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg2;
  /* Adjust for a longword load */
  t5 = (t5 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t5;
#ifndef MINIMA

g5405:
#endif
#ifdef MINIMA

g5405:
  if (_trace) printf("g5405:\n");
  t5 = t8 & MemoryActionBinding;
  t4 = *(u64 *)&(processor->dbcmask);
  if (t5 == 0)
    goto g5404;
  t3 = arg2 << 1;
  t5 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t3 = t3 & t4;
  t4 = 1;
  t4 = t4 << (ivorymemorydata & 63);
  t3 = (s32)t3 + (s32)t5;
  /* Clear sign-extension */
  t3 = (u32)t3;
  t4 = (t3 * 4) + t4;
  /* Fetch the key */
  t3 = *(s32 *)t4;
  /* Fetch value */
  t2 = *(s32 *)(t4 + 4);
  /* Compare */
  t5 = (s32)arg2 - (s32)t3;
  /* Trap on miss */
  if (t5 != 0)
    goto g5407;
  /* Extract the pointer, and indirect */
  arg2 = (u32)t2;
  goto g5398;

g5407:
  if (_trace) printf("g5407:\n");
  goto dbcachemisstrap;
#endif

g5404:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 1;
  goto performmemoryaction;

g5390:
  if (_trace) printf("g5390:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t1 = (t1 * 8) + t2;
  arg5 = *(s32 *)t1;
  /* Read from stack cache */
  arg6 = *(s32 *)(t1 + 4);
  goto g5389;

g5392:
  if (_trace) printf("g5392:\n");
  if ((t3 & 1) == 0)
    goto g5391;
  /* Do the indirect thing */
  arg4 = (u32)arg5;
  goto g5388;

g5391:
  if (_trace) printf("g5391:\n");
  /* Load the memory action table for cycle */
  t4 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t3 = arg6 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t3 = (t3 * 4) + t4;
  /* Get the memory action */
  t4 = *(s32 *)t3;

g5394:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoStoreArrayLeader */
  /* End of Halfword operand from stack instruction - DoStoreArrayLeader */
/* start DoAlocLeader */

  /* Halfword operand from stack instruction - DoAlocLeader */
  /* arg2 has the preloaded 8 bit operand. */

doalocleader:
  if (_trace) printf("doalocleader:\n");
#ifdef TRACING
#endif

DoAlocLeaderSP:
  if (_trace) printf("DoAlocLeaderSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoalocleader;
#endif

DoAlocLeaderLP:
  if (_trace) printf("DoAlocLeaderLP:\n");
#ifdef TRACING
  goto headdoalocleader;
#endif

DoAlocLeaderFP:
  if (_trace) printf("DoAlocLeaderFP:\n");

headdoalocleader:
  if (_trace) printf("headdoalocleader:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoalocleader:
  if (_trace) printf("begindoalocleader:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  /* arg3=arraytag, arg4=arraydata */
  arg4 = *(s32 *)iSP;
  /* arg3=arraytag, arg4=arraydata */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  /* index data */
  arg2 = (u32)arg1;
  /* index tag */
  arg1 = arg1 >> 32;
  t1 = arg1 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto alocleaderiop;

alocleadermerge:
  if (_trace) printf("alocleadermerge:\n");
  t1 = arg3 - Type_Array;
  /* Strip CDR code, low bits */
  t1 = t1 & 62;
  if (t1 != 0)
    goto alocleaderexception;
  /* Memory Read Internal */

g5411:
  /* Base of stack cache */
  t1 = *(u64 *)&(processor->stackcachebasevma);
  t3 = arg4 + ivory;
  t2 = *(s32 *)&processor->scovlimit;
  arg5 = (t3 * 4);
  arg6 = LDQ_U(t3);
  /* Stack cache offset */
  t1 = arg4 - t1;
  t4 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t2 = ((u64)t1 < (u64)t2) ? 1 : 0;
  arg5 = *(s32 *)arg5;
  arg6 = (u8)(arg6 >> ((t3&7)*8));
  if (t2 != 0)
    goto g5413;

g5412:
  t3 = zero + 64;
  t4 = t4 >> (arg6 & 63);
  t3 = t3 >> (arg6 & 63);
  if (t4 & 1)
    goto g5415;

g5420:
  /* TagType. */
  t1 = arg6 & 63;
  t1 = t1 - Type_HeaderI;
  if (t1 != 0)
    goto alocleaderiop;
  t9 = arg5 >> (Array_LeaderLengthFieldPos & 63);
  t9 = t9 & Array_LeaderLengthFieldMask;
  t1 = ((u64)arg2 < (u64)t9) ? 1 : 0;
  if (t1 == 0)
    goto alocleaderbounds;
  arg2 = arg4 - arg2;
  arg2 = arg2 - 1;
  t1 = Type_Locative;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

alocleaderexception:
  if (_trace) printf("alocleaderexception:\n");
  arg1 = Type_Fixnum;
  /* SetTag. */
  t1 = arg1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = arg3;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  arg5 = 0;
  arg2 = 10;
  goto arrayexception;

alocleaderiop:
  if (_trace) printf("alocleaderiop:\n");
  arg5 = 0;
  arg2 = 10;
  goto illegaloperand;

alocleaderbounds:
  if (_trace) printf("alocleaderbounds:\n");
  arg5 = 0;
  arg2 = 74;
  goto illegaloperand;
#ifdef TRACING
  goto DoAlocLeaderIM;
#endif

DoAlocLeaderIM:
  if (_trace) printf("DoAlocLeaderIM:\n");
  /* arg3=arraytag, arg4=arraydata */
  arg4 = *(s32 *)iSP;
  /* arg3=arraytag, arg4=arraydata */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  goto alocleadermerge;

g5413:
  if (_trace) printf("g5413:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t1 = (t1 * 8) + t2;
  arg5 = *(s32 *)t1;
  /* Read from stack cache */
  arg6 = *(s32 *)(t1 + 4);
  goto g5412;

g5415:
  if (_trace) printf("g5415:\n");
  if ((t3 & 1) == 0)
    goto g5414;
  /* Do the indirect thing */
  arg4 = (u32)arg5;
  goto g5411;

g5414:
  if (_trace) printf("g5414:\n");
  /* Load the memory action table for cycle */
  t4 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t3 = arg6 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t3 = (t3 * 4) + t4;
  /* Get the memory action */
  t4 = *(s32 *)t3;

g5417:
  /* Perform memory action */
  arg1 = t4;
  arg2 = 6;
  goto performmemoryaction;

/* end DoAlocLeader */
  /* End of Halfword operand from stack instruction - DoAlocLeader */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunarra.as */
